local log = require("klua.log"):new("game_scripts")

require("klua.table")

local km = require("klua.macros")
local signal = require("hump.signal")
local AC = require("achievements")
local E = require("entity_db")
local GR = require("grid_db")
local GS = require("game_settings")
local P = require("path_db")
local S = require("sound_db")
local SU = require("script_utils")
local U = require("utils")
local LU = require("level_utils")
local UP = require("upgrades")
local V = require("klua.vector")
local W = require("wave_db")
local F = require("klove.font_db")
local I = require("klove.image_db")
local features = require("features")
local G = love.graphics
local bit = require("bit")
local band = bit.band
local bor = bit.bor
local bnot = bit.bnot

require("i18n")

local scripts = require("scripts")

local function queue_insert(store, e)
	simulation:queue_insert_entity(e)
end

local function queue_remove(store, e)
	simulation:queue_remove_entity(e)
end

local function queue_damage(store, damage)
	table.insert(store.damage_queue, damage)
end

local function fts(v)
	return v / FPS
end

local function v(v1, v2)
	return {
		x = v1,
		y = v2
	}
end

local function r(x, y, w, h)
	return {
		pos = v(x, y),
		size = v(w, h)
	}
end

local function tpos(e)
	return e.tower and e.tower.range_offset and V.v(e.pos.x + e.tower.range_offset.x, e.pos.y + e.tower.range_offset.y) or e.pos
end

local function y_show_taunt_set(store, taunts, set_name, index, wait)
	local set = taunts.sets[set_name]

	index = index or set.idxs and table.random(set.idxs) or math.random(set.start_idx, set.end_idx)

	local duration = taunts.duration
	local taunt_id = _(string.format(set.format, index))

	log.info("show taunt " .. taunt_id)
	signal.emit("show-balloon_tutorial", taunt_id, false)

	if wait then
		U.y_wait(store, duration)
	end
end

local SU5 = {}

function SU5.hero_get_relic(store, hero)
	if hero.relic_slot and hero.relic_slot.relic_id then
		local relic = store.entities[hero.relic_slot.relic_id]

		if relic then
			return relic
		end
	end

	return nil
end

function SU5.relic_hero_leveled(store, hero)
	local relic = SU5.hero_get_relic(store, hero)

	if relic and relic.relic.fn_level_up then
		relic.relic.fn_level_up(relic, store, hero)
	end
end

function SU5.find_towers_in_range_vis(entities, origin, attack, filter_func)
	local bans = attack.vis_bans or 0
	local flags = attack.vis_flags or 0
	local towers = table.filter(entities, function(k, v)
		return not v.pending_removal and v.tower and (not v.vis or band(v.vis.flags, bans) == 0 and band(v.vis.bans, flags) == 0) and (not attack.excluded_templates or not table.contains(attack.excluded_templates, v.template_name)) and U.is_inside_ellipse(v.pos, origin, attack.max_range) and (attack.min_range == 0 or not U.is_inside_ellipse(v.pos, origin, attack.min_range)) and (not filter_func or filter_func(v, origin, attack))
	end)

	if not towers or #towers == 0 then
		return nil
	else
		return towers
	end
end

function SU5.valid_node_interval(x, y, offset_back, offset_forward, path_width_factor, flags)
	offset_back = offset_back or 0
	offset_forward = offset_forward or 0
	path_width_factor = path_width_factor or 1

	local nodes = P:nearest_nodes(x, y, nil, nil, true, flags)

	for _, n in pairs(nodes) do
		do
			local pi, spi, ni, dist = unpack(n)

			if dist < path_width_factor * P:path_width(pi, spi, ni) then
				for off = -1, offset_back, -1 do
					if not P:is_node_valid(pi, ni + off, flags) then
						goto label_13_0
					end
				end

				for off = 1, offset_forward do
					if not P:is_node_valid(pi, ni + off, flags) then
						goto label_13_0
					end
				end

				return true
			end
		end

		::label_13_0::
	end

	return false
end

function SU5.go_to_forced_waypoint(this, store)
	if this.motion.forced_waypoint then
		local w = this.motion.forced_waypoint

		if V.dist(w.x, w.y, this.pos.x, this.pos.y) < 2 * this.motion.max_speed * store.tick_length then
			this.pos.x, this.pos.y = w.x, w.y
			this.motion.forced_waypoint = nil

			return false
		end

		U.set_destination(this, this.motion.forced_waypoint)

		local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

		U.animation_start(this, an, af, store.tick_ts, true)
		U.walk(this, store.tick_length)

		return true
	end

	return false
end

function SU5.get_difficulty_field_value(store, field)
	if type(field) == "table" then
		return field[store.level_difficulty]
	elseif type(field) == "number" then
		return field
	else
		log.todo("ERROR FIELD TYPE NOT RECOGNIZED")

		return 0
	end
end

scripts.mod_test_unit_pos_kr5 = {}

function scripts.mod_test_unit_pos_kr5.update(this, store, script)
	local m = this.modifier

	m.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local targetZ = Z_EFFECTS
	local targetOffset = V.vv(0)

	if target.render then
		targetZ = target.render.sprites[1].z
	end

	if target.unit then
		if this.position_test == "HEAD" and target.unit.head_offset then
			targetOffset = V.vclone(target.unit.head_offset)
		elseif this.position_test == "MOD" and target.unit.mod_offset then
			targetOffset = V.vclone(target.unit.mod_offset)
		elseif this.position_test == "HIT" and target.unit.hit_offset then
			targetOffset = V.vclone(target.unit.hit_offset)
		end
	end

	for _, s in pairs(this.render.sprites) do
		s.offset = targetOffset
		s.z = targetZ
	end

	while true do
		target = store.entities[m.target_id]

		if not target or target.health and target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration then
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

scripts.mod_lifesteal_kr5 = {}

function scripts.mod_lifesteal_kr5.insert(this, store)
	local source = store.entities[this.modifier.source_id]
	local target = store.entities[this.modifier.target_id]
	local damage = 0

	if target and target.health then
		local dmg_value = this.damage

		if this.damage_min then
			local damage_min = SU5.get_difficulty_field_value(store, this.damage_min)
			local damage_max = SU5.get_difficulty_field_value(store, this.damage_max)

			dmg_value = math.random(damage_min, damage_max)
		end

		local d = E:create_entity("damage")

		d.value = dmg_value
		d.source_id = this.id
		d.target_id = target.id
		d.damage_type = this.damage_type

		if not this.only_predict_damage then
			queue_damage(store, d)
		end

		damage = U.predict_damage(target, d)
	end

	if source and source.health then
		local heal_hp = this.heal_hp_fixed and this.heal_hp_fixed or 0

		if this.heal_hp_damage_factor then
			local heal_hp_damage_factor = SU5.get_difficulty_field_value(store, this.heal_hp_damage_factor)

			heal_hp = heal_hp + damage * heal_hp_damage_factor
		end

		source.health.hp = km.clamp(0, source.health.hp_max, source.health.hp + heal_hp)

		if this.heal_fx then
			local fx = E:create_entity(this.heal_fx)

			fx.pos = V.v(source.pos.x + source.unit.hit_offset.x + this.heal_fx_offset.x, source.pos.y + source.unit.hit_offset.y + this.heal_fx_offset.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		end
	end

	return false
end

scripts.delayed_play_kr5 = {}

function scripts.delayed_play_kr5.update(this, store, script)
	local s = this.render.sprites[1]
	local d = this.delayed_play
	local clicks = 0

	if math.random() < d.flip_chance then
		s.flip_x = not s.flip_x
	end

	if d.idle_animation then
		U.animation_start(this, d.idle_animation, nil, store.tick_ts, d.loop_idle)
	else
		s.hidden = true
	end

	d.delay = U.frandom(d.start_min_delay and d.start_min_delay or d.min_delay, d.start_max_delay and d.start_max_delay or d.max_delay)

	if d.start_fixed_delay then
		d.delay = d.start_fixed_delay
	end

	while true do
		if not d.disabled and this.ui and d.required_clicks then
			if this.ui.clicked then
				this.ui.clicked = nil
				clicks = clicks + 1

				if clicks < d.required_clicks then
					S:queue(d.click_sound)
				end

				if d.click_tweens and this.tween then
					this.tween.props[1].ts = store.tick_ts
					this.tween.disabled = false
				end
			end

			if clicks == d.required_clicks then
				if not d.idle_animation then
					s.hidden = false
				end

				S:queue(d.clicked_sound)

				if d.required_clicks_fx then
					SU.insert_sprite(store, d.required_clicks_fx, this.pos)
				end

				if d.required_clicks_hides then
					s.hidden = true
				elseif d.clicked_animation then
					U.y_animation_play(this, d.clicked_animation, nil, store.tick_ts, 1)
				end

				if d.achievement then
					AC:got(d.achievement)
				end

				if d.achievement_flag then
					AC:flag_check(unpack(d.achievement_flag))
				end

				if d.achievement_inc then
					AC:inc_check(d.achievement_inc)
				end

				if d.play_once then
					queue_remove(store, this)

					return
				end

				if not d.idle_animation then
					s.hidden = true
				else
					U.animation_start(this, d.idle_animation, nil, store.tick_ts, d.loop_play)
				end

				clicks = 0
				this.ui.clicked = nil
			end
		end

		if store.tick_ts - s.ts > d.delay then
			s.ts = store.tick_ts

			if d.disabled then
				-- block empty
			else
				if not d.idle_animation then
					s.hidden = false
				end

				if math.random() < d.flip_chance then
					s.flip_x = not s.flip_x
				end

				if d.play_animation then
					if d.play_sound then
						S:queue(d.play_sound)
					end

					if d.play_duration then
						U.animation_start(this, d.play_animation, nil, store.tick_ts, true)

						if U.y_wait(store, d.play_duration, function()
							return d.click_interrupts and this.ui.clicked
						end) then
							goto label_15_0
						end
					else
						U.animation_start(this, d.play_animation, nil, store.tick_ts, false)

						while not U.animation_finished(this) do
							if d.click_interrupts and this.ui.clicked then
								goto label_15_0
							end

							coroutine.yield()
						end
					end
				end

				if not d.idle_animation then
					s.hidden = true
				else
					U.animation_start(this, d.idle_animation, nil, store.tick_ts, d.loop_idle)
				end

				if this.ui and not d.click_interrupts then
					this.ui.clicked = nil
				end
			end
		end

		::label_15_0::

		coroutine.yield()
	end
end

scripts.bolt_force_motion_kr5 = {}

function scripts.bolt_force_motion_kr5.insert(this, store, script)
	local b = this.bullet

	if this.impulse_per_distance then
		local dx, dy = V.sub(b.to.x, b.to.y, b.from.x, b.from.y)
		local dist = V.len(dx, dy)

		this.initial_impulse = this.impulse_per_distance * dist
	end

	if b.target_id then
		local target = store.entities[b.target_id]

		if not target or band(target.vis.bans, F_RANGED) ~= 0 then
			return false
		end
	end

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	local s = this.render.sprites[1]

	if not b.ignore_rotation then
		s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
	end

	return true
end

function scripts.bolt_force_motion_kr5.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local pred_pos

	if target then
		pred_pos = P:predict_enemy_pos(target, fts(5))
	else
		pred_pos = b.to
	end

	local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			local d = math.max(math.abs(target.pos.x + hit_offset.x - b.to.x), math.abs(target.pos.y + hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.level = b.level

				queue_insert(store, m)
			end
		end
	elseif b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	this.render.sprites[1].hidden = true

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.boss_pig = {}

function scripts.boss_pig.update(this, store, script)
	local sid_body, sid_fly = 1, 4
	local d_flying = E:create_entity("decal_boss_pig_flying")
	local s_flying = d_flying.render.sprites[1]

	queue_insert(store, d_flying)

	local s_body = this.render.sprites[sid_body]
	local node_id = P:nearest_nodes(698, 467, {
		2
	})[1][3]
	local jump_id = 1
	local jump_positions = {
		V.v(698, 467),
		V.v(150, 278)
	}
	local reach_positions = {
		V.v(418, 435),
		V.v(868, 242)
	}
	local reach_path_id = {
		1,
		2
	}

	this.fly_time_up = 0.5
	this.fly_time_down = 0.4
	this.fly_time_out = 1.5
	this.fly_offset_y = 60

	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_boss

	for _, value in pairs(spawners) do
		if value.load_file == "level06_spawner" then
			megaspawner_boss = value
		end
	end

	local round_idx = 0

	local function y_arrive(to, dest_pi)
		local start_ts = store.tick_ts
		local phase
		local flags = this.vis.flags
		local bans = this.vis.bans

		this.vis.flags = this.vis.flags_jumping
		this.vis.bans = this.vis.bans_jumping
		s_flying.hidden = false

		local shadow = E:create_entity(this.shadow)

		shadow.pos.x, shadow.pos.y = to.x, to.y
		shadow.render.sprites[1].ts = store.tick_ts
		shadow.render.sprites[1].runs = 0
		shadow.tween.props[1].keys[2][1] = this.fly_time_down
		shadow.tween.reverse = true

		queue_insert(store, shadow)
		S:queue(this.sound_falling)

		repeat
			phase = (store.tick_ts - start_ts) / this.fly_time_down
			d_flying.pos.x = U.ease_value(to.x, to.x, phase, "sine-out")
			d_flying.pos.y = U.ease_value(868, to.y + 150, phase, "sine-out") + this.fly_offset_y

			coroutine.yield()
		until phase >= 1

		S:queue(this.sound_land)

		this.phase = "loop"

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.5
		shake.aura.duration = 1
		shake.aura.freq_factor = 2

		queue_insert(store, shake)

		round_idx = round_idx + 1
		megaspawner_boss.manual_wave = string.format("BOSS%i", round_idx)

		local damage_on_fall = E:create_entity(this.aura_damage_on_fall)

		damage_on_fall.pos.x, damage_on_fall.pos.y = this.pos.x, this.pos.y
		damage_on_fall.owner = this
		damage_on_fall.aura.source_id = this.id

		queue_insert(store, damage_on_fall)

		this.pos.x, this.pos.y = to.x, to.y
		s_flying.hidden = true
		this.vis.flags = this.vis.flags_normal
		this.vis.bans = this.vis.bans_normal

		for _, value in pairs(this.render.sprites) do
			value.hidden = false
		end

		local ground_decal = E:create_entity("decal_boss_pig_ground_fall")

		ground_decal.render.sprites[1].ts = store.tick_ts
		ground_decal.pos.x = this.pos.x
		ground_decal.pos.y = this.pos.y

		queue_insert(store, ground_decal)
		U.y_animation_play(this, "fall", true, store.tick_ts, 1)

		this.nav_path.pi = dest_pi
		this.nav_path.ni = P:nearest_nodes(this.pos.x, this.pos.y, {
			dest_pi
		})[1][3]

		U.y_wait(store, 1)
	end

	local function ready_to_jump()
		return this.health.dead or jump_id <= 2 and this.nav_path.ni > node_id
	end

	local function y_fly(to, speed, dest_pi)
		this.vis.flags = this.vis.flags_jumping
		this.vis.bans = this.vis.bans_jumping

		local from = this.pos

		SU.remove_modifiers(store, this)

		local af = to.x < from.x

		s_flying.r = V.angleTo(to.x - from.x, to.y - from.y)
		s_flying.flip_y = math.abs(s_flying.r) > math.pi / 2

		S:queue(this.sound_jump)

		local an, af = U.animation_name_facing_point(this, "idle", this.motion.dest)

		U.animation_start(this, an, af, store.tick_ts, false)
		U.y_wait(store, 1)
		U.y_animation_play(this, "jump", af, store.tick_ts, 1)

		local ground_decal = E:create_entity("decal_boss_pig_ground_fall")

		ground_decal.render.sprites[1].ts = store.tick_ts
		ground_decal.pos.x = this.pos.x
		ground_decal.pos.y = this.pos.y
		ground_decal.tween.ts = store.tick_ts

		queue_insert(store, ground_decal)

		local shadow = E:create_entity(this.shadow)

		shadow.pos.x, shadow.pos.y = this.pos.x, this.pos.y
		shadow.render.sprites[1].ts = store.tick_ts
		shadow.render.sprites[1].runs = 0
		shadow.tween.props[1].keys[2][1] = 1.5

		queue_insert(store, shadow)

		s_flying.hidden = false

		for _, value in pairs(this.render.sprites) do
			value.hidden = true
		end

		local start_ts = store.tick_ts
		local phase

		repeat
			phase = (store.tick_ts - start_ts) / this.fly_time_up
			d_flying.pos.x = U.ease_value(from.x, from.x, phase, "sine-in")
			d_flying.pos.y = U.ease_value(from.y, 868, phase, "sine-in") + this.fly_offset_y

			coroutine.yield()
		until phase >= 1

		U.y_wait(store, this.fly_time_out)

		start_ts = store.tick_ts

		local shadow = E:create_entity(this.shadow)

		shadow.pos.x, shadow.pos.y = to.x, to.y
		shadow.render.sprites[1].ts = store.tick_ts
		shadow.render.sprites[1].runs = 0
		shadow.tween.reverse = true
		shadow.tween.props[1].keys[2][1] = this.fly_time_down

		queue_insert(store, shadow)
		S:queue(this.sound_falling)

		repeat
			phase = (store.tick_ts - start_ts) / this.fly_time_down
			d_flying.pos.x = U.ease_value(to.x, to.x, phase, "sine-out")
			d_flying.pos.y = U.ease_value(868, to.y + 150, phase, "sine-out") + this.fly_offset_y

			coroutine.yield()
		until phase >= 1

		S:queue(this.sound_land)

		this.pos.x, this.pos.y = to.x, to.y
		s_flying.hidden = true
		this.vis.flags = this.vis.flags_normal
		this.vis.bans = this.vis.bans_normal

		for _, value in pairs(this.render.sprites) do
			value.hidden = false
		end

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.5
		shake.aura.duration = 1
		shake.aura.freq_factor = 2

		queue_insert(store, shake)

		round_idx = round_idx + 1
		megaspawner_boss.manual_wave = string.format("BOSS%i", round_idx)

		local damage_on_fall = E:create_entity(this.aura_damage_on_fall)

		damage_on_fall.pos.x, damage_on_fall.pos.y = this.pos.x, this.pos.y
		damage_on_fall.owner = this
		damage_on_fall.aura.source_id = this.id

		queue_insert(store, damage_on_fall)

		local ground_decal = E:create_entity("decal_boss_pig_ground_fall")

		ground_decal.render.sprites[1].ts = store.tick_ts
		ground_decal.pos.x = this.pos.x
		ground_decal.pos.y = this.pos.y
		ground_decal.tween.ts = store.tick_ts

		queue_insert(store, ground_decal)
		U.y_animation_play(this, "fall", af, store.tick_ts, 1)

		this.nav_path.pi = dest_pi
		this.nav_path.ni = P:nearest_nodes(this.pos.x, this.pos.y, {
			dest_pi
		})[1][3]

		U.y_wait(store, 1)
	end

	this.vis.flags = this.vis.flags_jumping
	this.vis.bans = this.vis.bans_jumping
	this.phase = "intro"
	this.health_bar.hidden = true
	this.health_bar.hidden = nil

	for _, value in pairs(this.render.sprites) do
		value.hidden = true
	end

	U.y_wait(store, this.fly_time_out)
	y_arrive(this.pos, 2)
	signal.emit("boss_fight_start", this)

	::label_11_0::

	while true do
		if this.health.dead then
			this.phase = "dead"

			LU.kill_all_enemies(store, true)

			megaspawner_boss.interrupt = true

			S:stop_all()
			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts)

			if store.level_difficulty == DIFFICULTY_IMPOSSIBLE then
				signal.emit("no_jump_boss-stage06", jump_id)
			end

			signal.emit("boss-killed", this)
			LU.kill_all_enemies(store, true)

			this.phase = "death-complete"

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			if ready_to_jump() then
				this.ui.can_select = false
				this.health_bar.hidden = true

				y_fly(reach_positions[jump_id], 300, reach_path_id[jump_id])

				jump_id = jump_id + 1

				if jump_id <= 2 then
					local next_jump = jump_positions[jump_id]

					node_id = P:nearest_nodes(next_jump.x, next_jump.y, {
						this.nav_path.pi
					})[1][3]
				end

				this.health_bar.hidden = false
				this.ui.can_select = true
			end

			local ok, blocker = SU.y_enemy_walk_until_blocked(store, this, false, ready_to_jump)

			if not ok then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_11_0
					end

					while SU.can_melee_blocker(store, this, blocker) and not ready_to_jump() do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_11_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.decal_boss_pig_pool = {}

function scripts.decal_boss_pig_pool.update(this, store, script)
	while store.wave_group_number < 10 do
		coroutine.yield()
	end

	while not store.waves_finished or LU.has_alive_enemies(store) do
		local delay = math.random(this.taunts.delay_min, this.taunts.delay_max)

		U.y_wait(store, delay)

		if store.waves_finished or not LU.has_alive_enemies(store) then
			break
		end

		y_show_taunt_set(store, this.taunts, "from_pool", false)
		coroutine.yield()
	end
end

scripts.enemy_turtle_shaman = {}

function scripts.enemy_turtle_shaman.update(this, store, script)
	local a
	local ah = this.timed_attacks.list[1]

	local function ready_to_heal()
		return store.tick_ts - ah.ts > ah.cooldown and this.enemy.can_do_magic
	end

	local function break_fn()
		return ready_to_heal()
	end

	::label_16_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_heal() then
				a = ah

				local targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans, function(e)
					return e ~= this and e.health.hp < e.health.hp_max * a.hp_trigger_factor and not U.has_modifiers(store, e, a.mod) and (a.excluded_templates and not table.contains(a.excluded_templates, e.template_name) or not a.excluded_templates)
				end)

				if not targets then
					SU.delay_attack(store, a, 1)
				else
					table.sort(targets, function(e1, e2)
						return e1.health.hp < e2.health.hp
					end)
					S:queue(a.sound)

					a.ts = store.tick_ts

					for i = 1, math.min(a.max_count, #targets) do
						local target = targets[i]
						local markMod = E:create_entity(a.markMod)

						markMod.modifier.target_id = target.id
						markMod.modifier.source_id = this.id
						markMod.modifier.duration = a.cast_time + a.markDurationOffset

						queue_insert(store, markMod)
					end

					local target = targets[1]
					local an, af = U.animation_name_facing_point(this, a.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					if SU.y_enemy_wait(store, this, a.cast_time) or #this.enemy.blockers > 0 then
						goto label_16_0
					end

					for i = 1, math.min(a.max_count, #targets) do
						local target = targets[i]
						local m = E:create_entity(a.mod)

						m.modifier.source_id = this.id
						m.modifier.target_id = target.id

						queue_insert(store, m)
					end

					SU.insert_sprite(store, a.cast_fx, this.pos)
					U.y_animation_wait(this)
				end
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, false) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_cutthroat_rat = {}

function scripts.enemy_cutthroat_rat.update(this, store, script)
	local ah = this.timed_attacks.list[1]

	ah.ts = store.tick_ts - ah.cooldown

	local function ready_to_hide()
		if not ah.disabled and store.tick_ts - ah.ts >= ah.cooldown then
			if not this.node_limit then
				this.node_limit = math.floor(ah.min_distance_from_end / P.average_node_dist)
			end

			local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

			if nodes_to_end < this.node_limit then
				ah.disabled = true

				return false
			end

			if not this.enemy.can_do_magic or #this.enemy.blockers == 0 then
				return false
			end

			return true
		end

		return false
	end

	local function break_fn()
		return ready_to_hide()
	end

	::label_21_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_hide() then
				local blocker = store.entities[this.enemy.blockers[1]]
				local an, af = U.animation_name_facing_point(this, ah.animation, V.vclone(blocker.pos))

				U.animation_start(this, an, af, store.tick_ts)

				ah.ts = store.tick_ts

				if SU.y_enemy_wait(store, this, ah.cast_time) then
					goto label_21_0
				end

				S:queue(ah.sound)

				local target = store.entities[this.enemy.blockers[1]]

				if target and not target.health.dead then
					local target_id = target.id
					local d = E:create_entity("damage")

					d.source_id = this.id
					d.target_id = target_id
					d.value = math.random(ah.damage_min, ah.damage_max) * this.unit.damage_factor
					d.damage_type = ah.damage_type

					queue_damage(store, d)

					local m = E:create_entity(ah.mod)

					m.modifier.target_id = target_id
					m.modifier.source_id = this.id

					queue_insert(store, m)

					if ah.hit_fx then
						local fx = E:create_entity(ah.hit_fx)

						fx.pos = V.vclone(target.pos)
						fx.render.sprites[1].ts = store.tick_ts

						queue_insert(store, fx)
					end
				end

				if SU.y_enemy_wait(store, this, ah.hide_time - ah.cast_time) then
					goto label_21_0
				end

				do
					local fx = E:create_entity(ah.smoke_fx)

					fx.pos = V.vclone(this.pos)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end

				U.unblock_all(store, this)

				this.vis.bans = bor(F_BLOCK, F_RANGED)
				this.render.sprites[1].alpha = 40

				local invis_ts = store.tick_ts

				while store.tick_ts - invis_ts < ah.duration and not this.health.dead and this.enemy.can_do_magic and not this.unit.is_stunned do
					SU.y_enemy_walk_step(store, this)
				end

				this.render.sprites[1].alpha = 255
				this.vis.bans = 0
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_basic_with_random_range = {}

function scripts.enemy_basic_with_random_range.insert(this, store, script)
	if scripts.enemy_basic.insert(this, store, script) then
		for _, a in ipairs(this.ranged.attacks) do
			if a.max_range_variance then
				a.max_range = a.max_range + math.random(0, a.max_range_variance)
			end
		end

		return true
	else
		return false
	end
end

scripts.debug_path_renderer = {}

function scripts.debug_path_renderer.insert(this, store, script)
	local visible_coords = store.visible_coords

	G.push()

	local path_canvas = G.newCanvas(visible_coords.right - visible_coords.left, visible_coords.top - visible_coords.bottom)
	local cWidth = path_canvas:getWidth()
	local cHeight = path_canvas:getHeight()

	G.setCanvas(path_canvas)

	local backgroundColor = this.path_debug and this.path_debug.background_color or nil
	local pathColor = this.path_debug and this.path_debug.path_color or {
		255,
		255,
		255,
		255
	}

	if backgroundColor then
		G.setColor(backgroundColor[1], backgroundColor[2], backgroundColor[3], backgroundColor[4])
		G.rectangle("fill", 0, 0, cWidth, cHeight)
	end

	G.translate(-visible_coords.left, -visible_coords.bottom)
	log.info("PATH_DEBUG: canvas:%f, %f", path_canvas:getWidth(), path_canvas:getHeight())

	local function fill_paths(width_scale)
		for pi, p in ipairs(P.paths) do
			local pw = P:path_width(pi) * width_scale

			for ni, o in pairs(p[1]) do
				if P:is_node_valid(pi, ni) then
					G.circle("fill", o.x, REF_H - o.y, pw, 16)
				end
			end
		end
	end

	G.setColor(pathColor[1] * 0.6, pathColor[2] * 0.6, pathColor[3] * 0.6, pathColor[4])
	fill_paths(1.1)
	G.setColor(pathColor[1], pathColor[2], pathColor[3], pathColor[4])
	fill_paths(1)
	G.setLineWidth(1)
	G.setColor(255, 255, 255, 255)
	G.setCanvas()
	G.pop()

	local image_data = path_canvas:newImageData()
	local image = G.newImage(image_data)
	local image_name = "generated_path_image"

	this.generated_image_name = image_name

	I:remove_image(this.generated_image_name)
	I:add_image(image_name, image, "temp_game_texts", nil)

	this.render.sprites[1].name = image_name
	this.render.sprites[1].animated = false
	this.render.sprites[1].anchor = v(0, 0)
	this.pos = v(visible_coords.left, visible_coords.bottom)
end

scripts.enemy_rhino = {}

function scripts.enemy_rhino.update(this, store, script)
	local a = this.timed_attacks.list[1]
	local ps_a, ps_b

	a.ts = store.tick_ts - a.cooldown
	a.hit_targets = {}

	local function ready_to_charge()
		return store.tick_ts - a.ts > a.cooldown and not U.get_blocker(store, this) and P:nodes_to_defend_point(this.nav_path) > a.min_distance_from_end
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if this._placed_from_tunnel then
				this._placed_from_tunnel = nil

				if ps_a ~= nil then
					ps_a.particle_system.emit = false
				end

				if ps_b ~= nil then
					ps_b.particle_system.emit = false
				end

				this.motion.max_speed = this.base_speed
				this.vis.bans = U.flag_clear(this.vis.bans, F_BLOCK)
			end

			if ready_to_charge() then
				local ni = this.nav_path.ni + 10

				if not P:is_node_valid(this.nav_path.pi, ni) then
					log.debug("razorboar path node invalid: %s,%s", this.nav_path.pi, ni)
					SU.delay_attack(store, a, 2)
				else
					local npos = P:node_pos(this.nav_path.pi, this.nav_path.spi, ni)
					local soldiers = U.find_soldiers_in_range(store.entities, npos, a.min_range, a.trigger_range, a.vis_flags, a.vis_bans)

					if not soldiers then
						SU.delay_attack(store, a, 1)
					else
						a.ts = store.tick_ts
						this.motion.max_speed = a.speed
						this.vis.bans = U.flag_set(this.vis.bans, F_BLOCK)
						ps_a = E:create_entity(a.particles_name_a)
						ps_a.particle_system.track_id = this.id

						queue_insert(store, ps_a)

						ps_b = E:create_entity(a.particles_name_b)
						ps_b.particle_system.track_id = this.id

						queue_insert(store, ps_b)
						S:queue(a.sound)

						while store.tick_ts - a.ts < a.duration and not this.health.dead do
							local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.range, a.vis_flags_enemies, a.vis_bans_enemies, function(e)
								return e.id ~= this.id and not table.contains(a.hit_targets, e.id)
							end)

							if enemies then
								for _, e in pairs(enemies) do
									table.insert(a.hit_targets, e.id)

									local m = E:create_entity(a.mod_enemy)

									m.modifier.target_id = e.id
									m.modifier.source_id = this.id
									m.modifier.ts = store.tick_ts

									queue_insert(store, m)
								end
							end

							local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, a.range, a.vis_flags_soldiers, a.vis_bans_soldiers, function(e)
								return not table.contains(a.hit_targets, e.id)
							end)

							if soldiers then
								for _, e in pairs(soldiers) do
									table.insert(a.hit_targets, e.id)

									local m = E:create_entity(a.mod_soldier)

									m.modifier.target_id = e.id
									m.modifier.source_id = this.id
									m.modifier.ts = store.tick_ts

									queue_insert(store, m)
								end
							end

							SU.y_enemy_walk_step(store, this, a.animation)

							while this.unit.is_stunned do
								SU.y_enemy_stun(store, this)

								a.ts = a.ts - a.duration
							end
						end

						ps_a.particle_system.emit = false
						ps_b.particle_system.emit = false
						this.motion.max_speed = this.base_speed
						this.vis.bans = U.flag_clear(this.vis.bans, F_BLOCK)
					end
				end
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, function(store, this)
				return ready_to_charge()
			end) then
				-- block empty
			end
		end

		coroutine.yield()
	end
end

scripts.screen_focus_circle = {}

function scripts.screen_focus_circle.insert(this, store, script)
	local visible_coords = store.visible_coords

	G.push()

	local canvas = G.newCanvas(visible_coords.right - visible_coords.left, visible_coords.top - visible_coords.bottom)
	local cWidth = canvas:getWidth()
	local cHeight = canvas:getHeight()

	G.setCanvas(canvas)
	G.setColor(0, 0, 0, this.black_opacity)
	G.rectangle("fill", 0, 0, cWidth, cHeight)
	G.translate(-visible_coords.left, -visible_coords.bottom)
	G.setColor(0, 0, 0, 0)
	G.setBlendMode("replace")

	for i = 1, this.circle_gradient_size do
		G.setColor(0, 0, 0, (this.circle_gradient_size - i) * this.black_opacity / this.circle_gradient_size)
		G.circle("fill", this.circle_pos.x, REF_H - this.circle_pos.y, this.circle_radius - i, 100)
	end

	G.setBlendMode("alpha")
	G.setCanvas()
	G.pop()

	local image_data = canvas:newImageData()
	local image = G.newImage(image_data)
	local image_name = "generated_circle_image"

	this.generated_image_name = image_name

	I:remove_image(this.generated_image_name)
	I:add_image(image_name, image, "temp_game_circle", nil)

	this.render.sprites[1].name = image_name
	this.render.sprites[1].animated = false
	this.render.sprites[1].anchor = v(0, 0)
	this.pos = v(visible_coords.left, visible_coords.bottom)
	this.render.sprites[1].pos = this.pos

	return true
end

function scripts.screen_focus_circle.update(this, store, script)
	this.tween.ts = store.tick_ts
	this.tween.disabled = false

	while true do
		coroutine.yield()
	end
end

scripts.enemy_hyena5 = {}

function scripts.enemy_hyena5.update(this, store, script)
	this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.health_bar.hidden = true

		U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	this.feast.ts = store.tick_ts - this.feast.cooldown

	local function can_feast()
		return this.health.hp <= this.feast.hp_min_trigger and store.tick_ts - this.feast.ts > this.feast.cooldown
	end

	::label_34_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false)

			if not ok then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_34_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_34_0
						end

						coroutine.yield()
					end
				end

				if blocker and blocker.health.dead and band(blocker.health.last_damage_types, bor(DAMAGE_DISINTEGRATE_BOSS, DAMAGE_DISINTEGRATE, DAMAGE_HOST, DAMAGE_EAT)) == 0 and can_feast() then
					local target = blocker

					if band(target.vis.bans, F_CANNIBALIZE) ~= 0 then
						coroutine.yield()

						goto label_34_0
					end

					U.unblock_all(store, this)

					this.vis.bans = bor(this.vis.bans, F_BLOCK)
					this.motion.forced_waypoint = V.v(target.pos.x, target.pos.y)

					while SU.y_enemy_walk_step(store, this) do
						if this.health.dead then
							goto label_34_0
						end

						if not store.entities[target.id] then
							goto label_34_1
						end
					end

					this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))

					do
						local start_ts = store.tick_ts

						U.animation_start(this, this.feast.animation .. "_start", nil, store.tick_ts)

						if SU.y_enemy_animation_wait(this) then
							-- block empty
						else
							U.animation_start(this, this.feast.animation .. "_loop", nil, store.tick_ts, true)
							S:queue(this.sound_events.feast)

							for _, mod_id in ipairs(this.feast.mods) do
								local m = E:create_entity(mod_id)

								m.modifier.source_id = this.id
								m.modifier.target_id = this.id

								queue_insert(store, m)
							end

							if SU.y_enemy_wait(store, this, this.feast.duration) then
								-- block empty
							else
								U.animation_start(this, this.feast.animation .. "_end", nil, store.tick_ts)

								if SU.y_enemy_animation_wait(this) then
									-- block empty
								else
									this.feast.ts = start_ts
								end
							end
						end
					end

					::label_34_1::

					this.vis.bans = band(this.vis.bans, bnot(F_BLOCK))
					this.motion.forced_waypoint = nil

					for _, mod_id in ipairs(this.feast.mods) do
						SU.remove_modifiers(store, this, mod_id)
					end

					local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
						this.nav_path.pi
					}, {
						this.nav_path.spi
					})

					if nearest and nearest[1] and nearest[1][3] > this.nav_path.ni then
						this.nav_path.ni = nearest[1][3]
					end

					this.motion.forced_waypoint = P:node_pos(this.nav_path)

					U.set_destination(this, this.motion.forced_waypoint)
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_bear_vanguard = {}

function scripts.enemy_bear_vanguard.update(this, store, script)
	local trigger_wrath_of_the_fallen = false

	local function can_wrath()
		if this.wrath_of_the_fallen.ts and store.tick_ts - this.wrath_of_the_fallen.ts <= this.wrath_of_the_fallen.ts_max and this.enemy.can_do_magic then
			trigger_wrath_of_the_fallen = true

			return true
		end

		return false
	end

	::label_36_0::

	while true do
		if this.health.dead then
			local bears = table.filter(store.entities, function(k, v)
				return v.health and not v.health.dead and U.is_inside_ellipse(v.pos, this.pos, this.wrath_of_the_fallen.radius) and 
				(v.template_name == "enemy_bear_vanguard" or v.template_name == "enemy_bear_woodcutter")
			end)

			for _, bear in ipairs(bears) do
				if U.has_modifiers(store, bear, this.wrath_of_the_fallen.mod) then
					local mod = E:create_entity(this.wrath_of_the_fallen.mod)

					mod.modifier.target_id = bear.id
					mod.modifier.source_id = this.id

					queue_insert(store, mod)

					bear.wrath_of_the_fallen.ts = nil
				else
					bear.wrath_of_the_fallen.ts = store.tick_ts
				end
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if trigger_wrath_of_the_fallen then
				S:queue(this.wrath_of_the_fallen.sound)
				U.animation_start(this, this.wrath_of_the_fallen.animation, nil, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, this.wrath_of_the_fallen.cast_time) then
					goto label_36_0
				end

				local mod = E:create_entity(this.wrath_of_the_fallen.mod)

				mod.modifier.target_id = this.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)
				U.y_animation_wait(this)

				this.wrath_of_the_fallen.ts = nil
				trigger_wrath_of_the_fallen = false
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, can_wrath, can_wrath) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_acolyte = {}

function scripts.enemy_acolyte.update(this, store, script)
	while true do
		if this.health.dead then
			if this.death_spawns and this.death_spawns.name == "enemy_acolyte_tentacle" then
				if #this.enemy.blockers == 0 or band(this.health.last_damage_types, DAMAGE_INSTAKILL) ~= 0 then
					this.death_spawns = nil
					this.unit.hide_after_death = false
					this.sound_events.death = this.sound_death_no_spawn
				else
					this.vis.bans = bor(this.vis.bans, F_SKELETON)
					this.unit.death_animation = this.death_spawns.death_animation
					this.health.delete_after = store.tick_ts + this.death_spawns.dead_lifetime
					this.sound_events.death = this.sound_death_with_spawn
				end
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this) then
			-- block empty
		else
			coroutine.yield()
		end
	end
end

scripts.enemy_acolyte_tentacle = {}

function scripts.enemy_acolyte_tentacle.update(this, store, script)
	local a
	local ah = this.timed_attacks.list[1]
	local start_ts = store.tick_ts

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	ah.ts = store.tick_ts - ah.cooldown + math.random(ah.first_cooldown_min, ah.first_cooldown_max)

	local function ready_to_hit()
		if not ah.disabled then
			return store.tick_ts - ah.ts > ah.cooldown
		end

		return false
	end

	local function lifespan_done()
		if store.tick_ts - start_ts > ah.duration then
			return true
		end

		return false
	end

	::label_40_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if lifespan_done() then
			break
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_hit() then
				a = ah
				a.ts = store.tick_ts

				S:queue(a.sound)
				U.animation_start(this, a.animation, nil, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, a.cast_time) then
					goto label_40_0
				end

				local e = E:create_entity(a.aura_name)

				e.pos.x, e.pos.y = this.pos.x, this.pos.y
				e.owner = this
				e.aura.source_id = this.id
				e.damage_min = math.ceil(e.aura.damage_min * this.unit.damage_factor)
				e.damage_max = math.ceil(e.aura.damage_max * this.unit.damage_factor)

				queue_insert(store, e)
				U.y_animation_wait(this)
			else
				SU.delay_attack(store, ah, fts(10))
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, lifespan_done, nil, nil) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end

	this.health_bar.hidden = true
	this.vis.bans = F_ALL
	this.vis.flags = F_NONE

	U.unblock_all(store, this)
	SU.remove_modifiers(store, this)
	U.y_animation_play(this, "death", nil, store.tick_ts, 1)

	this.trigger_deselect = true

	queue_remove(store, this)
end

function scripts.enemy_acolyte_tentacle.get_info(this)
	local t = E:get_template(this.timed_attacks.list[1].aura_name)
	local o = scripts.enemy_basic.get_info(this)

	o.damage_min = math.ceil(t.aura.damage_min * this.unit.damage_factor)
	o.damage_max = math.ceil(t.aura.damage_max * this.unit.damage_factor)
	o.damage_type = t.aura.damage_type
	o.lives = 0

	return o
end

scripts.enemy_lesser_sister = {}

function scripts.enemy_lesser_sister.update(this, store, script)
	local a = this.timed_attacks.list[1]
	local cg = store.count_groups[a.count_group_type]

	this.spawned_nightmares = 0
	a.ts = store.tick_ts

	local function ready_to_crooked_souls()
		if not a.disabled and store.tick_ts - a.ts > a.cooldown then
			local nodes_to_goal = P:nodes_to_goal(this.nav_path)

			if nodes_to_goal < this.nodes_limit then
				a.disabled = true

				return false
			end

			if not this.enemy.can_do_magic then
				SU.delay_attack(store, a, fts(10))

				return false
			end

			if #this.enemy.blockers > 0 then
				SU.delay_attack(store, a, fts(10))

				return false
			end

			if cg[a.count_group_name] and cg[a.count_group_name] > a.count_group_max then
				SU.delay_attack(store, a, fts(10))

				return false
			end

			return true
		end

		return false
	end

	local function break_fn()
		return ready_to_crooked_souls()
	end

	::label_44_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_crooked_souls() then
				local start_ts = store.tick_ts

				S:queue(a.sound)

				local actual_ni = this.nav_path.ni
				local pi, spi_available = this.nav_path.pi, {
					1,
					2,
					3
				}
				local ni = actual_ni + math.random(this.node_random_min, this.node_random_max)
				local spi = spi_available[math.random(1, 3)]
				local npos = P:node_pos(pi, spi, ni)
				local an, af = U.animation_name_facing_point(this, a.animation, npos)

				U.animation_start(this, an, af, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, a.cast_time) then
					goto label_44_0
				end

				a.ts = start_ts

				local e = E:create_entity(a.entity)

				e.nav_path.pi = pi
				e.nav_path.spi = spi
				e.nav_path.ni = ni
				e.can_be_converted = true
				e.pos = V.vclone(npos)

				queue_insert(store, e)

				this.spawned_nightmares = this.spawned_nightmares + 1

				signal.emit("wave-notification", "icon", a.entity)
				U.y_animation_wait(this)
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, nil, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_lesser_sister_nightmare = {}

function scripts.enemy_lesser_sister_nightmare.update(this, store, script)
	local cont, blocker, ranged

	local function break_fn()
		if this.enemy.can_do_magic then
			local nodes_to_goal = P:nodes_to_goal(this.nav_path)

			if nodes_to_goal <= this.nodes_to_reveal then
				this.enemy.can_do_magic = false
			end
		end

		if not this.enemy.can_do_magic and not this.tween.reverse then
			this.vis.flags = this.vis.flags_blocked
			this.tween.ts = store.tick_ts
			this.tween.reverse = true
		end

		return false
	end

	this.vis.flags = this.vis.flags_unblocked

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if not this.unit.is_stunned and this.enemy.can_do_magic and (this.vis.flags ~= this.vis.flags_unblocked or this.tween.reverse) then
			this.vis.flags = this.vis.flags_unblocked
			this.tween.ts = store.tick_ts
			this.tween.reverse = false
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if not this.enemy.can_do_magic and not this.tween.reverse then
			this.vis.flags = this.vis.flags_blocked
			this.tween.ts = store.tick_ts
			this.tween.reverse = true
		end

		if this.unit.is_stunned then
			if this.vis.flags ~= this.vis.flags_blocked then
				this.vis.flags = this.vis.flags_blocked
				this.tween.ts = store.tick_ts
				this.tween.reverse = true
			end

			SU.y_enemy_stun(store, this)
		else
			cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, break_fn)

			if not cont then
				-- block empty
			elseif blocker then
				if not SU.y_wait_for_blocker(store, this, blocker) then
					-- block empty
				else
					if not this.tween.reverse then
						this.vis.flags = this.vis.flags_blocked
						this.tween.ts = store.tick_ts
						this.tween.reverse = true
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							break
						end

						coroutine.yield()
					end
				end
			elseif ranged then
				while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
					if not SU.y_enemy_range_attacks(store, this, ranged) then
						break
					end

					coroutine.yield()
				end
			end
		end

		coroutine.yield()
	end
end

scripts.enemy_surveyor_harpy = {}

function scripts.enemy_surveyor_harpy.update(this, store, script)
	local shadow_sprite = this.render.sprites[2]
	local terrain_type

	if this.render.sprites[1].name == "raise" then
		local next_pos

		if this.motion.forced_waypoint then
			next_pos = this.motion.forced_waypoint
		else
			next_pos = P:next_entity_node(this, store.tick_length)
		end

		local an, af = U.animation_name_facing_point(this, "raise", next_pos)

		U.y_animation_play(this, an, af, store.tick_ts, 1)
	end

	while true do
		if this.cliff then
			terrain_type = SU.enemy_cliff_change(store, this)
		end

		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			SU.y_enemy_walk_until_blocked(store, this)
		end
	end
end

scripts.enemy_small_stalker = {}

function scripts.enemy_small_stalker.update(this, store)
	local shadow_sprite = this.render.sprites[2]

	if this.render.sprites[1].name == "raise" then
		local next_pos

		if this.motion.forced_waypoint then
			next_pos = this.motion.forced_waypoint
		else
			next_pos = P:next_entity_node(this, store.tick_length)
		end

		local an, af = U.animation_name_facing_point(this, "raise", next_pos)

		U.y_animation_play(this, an, af, store.tick_ts, 1)
	end

	this.skill_teleport.ts = store.tick_ts - this.skill_teleport.cooldown

	local last_run = 0
	local animation = "walk"

	while true do
		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if this.skill_teleport.active then
				this.health_bar.hidden = true
				this.vis.bans = U.flag_set(this.vis.bans, F_RANGED)

				S:queue(this.skill_teleport.sound)
				U.animation_start(this, "teleport_in", nil, store.tick_ts, 1)
				SU.remove_modifiers(store, this)

				while not U.animation_finished(this) do
					if this.health.dead then
						shadow_sprite.hidden = true

						SU.y_enemy_death(store, this)

						return
					end

					coroutine.yield()
				end

				U.y_wait(store, fts(this.skill_teleport.wait_between_teleport))

				local ni = this.nav_path.ni + this.nodes_advance

				this.pos = P:node_pos(this.nav_path.pi, this.nav_path.spi, ni)
				this.nav_path.ni = ni
				this.health_bar.hidden = false

				U.animation_start(this, "teleport_out", nil, store.tick_ts, false)

				animation = "teleport_out"
				this.vis.bans = U.flag_clear(this.vis.bans, F_RANGED)
				this.skill_teleport.ts = store.tick_ts
				this.skill_teleport.active = nil
			end

			SU.y_enemy_walk_step(store, this, animation, 1)

			if shadow_sprite.alpha == 0 and P:is_node_valid(this.nav_path.pi, this.nav_path.ni, NF_NO_SHADOW) and this.tween.reverse then
				this.tween.disabled = false
				this.tween.reverse = false
				this.tween.ts = store.tick_ts
			elseif shadow_sprite.alpha == 255 and not P:is_node_valid(this.nav_path.pi, this.nav_path.ni, NF_NO_SHADOW) and not this.tween.reverse then
				this.tween.disabled = false
				this.tween.reverse = true
				this.tween.ts = store.tick_ts
			end

			if animation == "teleport_out" and this.render.sprites[1].runs > 0 then
				animation = "walk"
				this.health_bar.hidden = false
				this.vis.bans = U.flag_clear(this.vis.bans, F_RANGED)
			end
		end
	end
end

function scripts.enemy_small_stalker.on_damage(this, store, damage)
	if not this.skill_teleport.active and store.tick_ts - this.skill_teleport.ts > this.skill_teleport.cooldown then
		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal > this.nodes_before_exit and this.enemy.can_do_magic then
			this.skill_teleport.active = true
		else
			this.skill_teleport.active = nil
		end
	end

	return true
end

scripts.enemy_unblinded_priest = {}

function scripts.enemy_unblinded_priest.on_start_glare(this, store, script)
	this.do_glare_transform = true
	this.transformation_time = 0
end

function scripts.enemy_unblinded_priest.update(this, store, script)
	local last_near_priest_check_cd = 1
	local last_near_priest_check_ts = store.tick_ts - last_near_priest_check_cd

	local function check_transform()
		if this.do_glare_transform then
			return true
		end

		local health_trigger = not this.health.dead and this.health.hp < this.health.hp_max * this.health_trigger_factor and this.enemy.can_do_magic

		if not health_trigger then
			return false
		end

		if store.tick_ts - last_near_priest_check_ts < last_near_priest_check_cd then
			return false
		end

		local near_priest = false
		local dist2 = 1600

		for _, e in pairs(store.entities) do
			if (e.template_name == this.template_name or e.template_name == "enemy_unblinded_abomination") and e.id ~= this.id and not e.health.dead and e.health.hp > 0 and dist2 >= V.dist2(e.pos.x, e.pos.y, this.pos.x, this.pos.y) then
				near_priest = true

				break
			end
		end

		if near_priest then
			last_near_priest_check_ts = store.tick_ts
		end

		return not near_priest
	end

	::label_53_0::

	while true do
		if this.health.dead then
			if not this.old_death_spawns then
				this.death_spawns = nil
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if check_transform() then
				S:queue(this.transformation_sound)
				U.y_animation_play(this, "transformation_start", nil, store.tick_ts, 1)
				U.animation_start(this, "transformation_loop", nil, store.tick_ts, true)

				if U.y_wait(store, this.transformation_time, function()
					return this.health.dead or this.unit.is_stunned
				end) then
					S:stop(this.transformation_sound)
					S:queue(this.transformation_end_sound)

					goto label_53_0
				end

				S:queue(this.transformation_end_sound)
				U.y_animation_play(this, "transformation_end", nil, store.tick_ts, 1)

				if this.old_death_spawns then
					this.death_spawns = this.old_death_spawns
				end

				SU.do_death_spawns(store, this)
				signal.emit("wave-notification", "icon", "enemy_unblinded_abomination")
				queue_remove(store, this)

				return
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, check_transform, check_transform, check_transform) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.mod_enemy_unblinded_abomination_eat = {}

function scripts.mod_enemy_unblinded_abomination_eat.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		target.vis.bans = F_ALL

		SU.stun_inc(target)
	end
end

function scripts.mod_enemy_unblinded_abomination_eat.update(this, store)
	local target = store.entities[this.modifier.target_id]
	local source = store.entities[this.modifier.source_id]

	if not target or not source then
		queue_remove(store, this)

		return
	end

	local af = source.pos.x > target.pos.x

	this.pos.x, this.pos.y = target.pos.x, target.pos.y

	local d = E:create_entity("damage")

	d.damage_type = DAMAGE_EAT
	d.source_id = this.id
	d.target_id = target.id

	queue_damage(store, d)

	local es = E:create_entity(this.explode_fx)

	es.pos.x, es.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	es.render.sprites[1].ts = store.tick_ts

	queue_insert(store, es)
	queue_remove(store, this)
end

scripts.enemy_spiderling = {}

function scripts.enemy_spiderling.update(this, store, script)
	local terrain_type

	::label_58_0::

	while true do
		if this.cliff then
			terrain_type = SU.enemy_cliff_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			if terrain_type == TERRAIN_CLIFF then
				SU.remove_modifiers(store, this)

				this.render.sprites[1].hidden = false
				this.health.hp = 0

				SU.y_enemy_death(store, this)

				return
			else
				U.animation_start(this, "idle", nil, store.tick_ts, -1)
				coroutine.yield()

				goto label_58_0
			end
		end

		local ignore_soldiers = terrain_type == TERRAIN_CLIFF
		local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers)

		if not ok then
			-- block empty
		else
			if blocker then
				if not SU.y_wait_for_blocker(store, this, blocker) then
					goto label_58_0
				end

				while SU.can_melee_blocker(store, this, blocker) do
					if not SU.y_enemy_melee_attacks(store, this, blocker) then
						goto label_58_0
					end

					coroutine.yield()
				end
			elseif ranged then
				while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
					if not SU.y_enemy_range_attacks(store, this, ranged) then
						goto label_58_0
					end

					coroutine.yield()
				end
			end

			coroutine.yield()
		end
	end
end

scripts.enemy_unblinded_shackler = {}

function scripts.enemy_unblinded_shackler.update(this, store, script)
	local a = this.timed_attacks.list[1]

	a.ts = store.tick_ts

	local function ready_to_shackle()
		return store.tick_ts - a.ts > a.cooldown and this.enemy.can_do_magic and not this.health.dead and this.health.hp < this.health.hp_max * a.health_trigger_factor
	end

	local function break_fn()
		return ready_to_shackle()
	end

	local is_shackling = false
	local target_marker_mods = {}
	local target_mods = {}

	::label_59_0::

	while true do
		if this.health.dead then
			if is_shackling then
				for _, m in ipairs(target_marker_mods) do
					queue_remove(store, m)
				end

				for _, m in ipairs(target_mods) do
					m.remove = true
				end

				S:queue(a.sound_out)
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned and not is_shackling then
			SU.y_enemy_stun(store, this)
		else
			if not is_shackling and ready_to_shackle() then
				local towers = U.find_towers_in_range(store.entities, this.pos, a, function(t)
					return t.tower.can_be_mod and not SU.has_modifiers(store, t, a.mark_mod)
				end)

				if not towers or #towers < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)

					for i = 1, km.clamp(a.min_targets, a.max_targets, #towers) do
						local tower = towers[i]
						local mod = E:create_entity(a.mark_mod)

						mod.modifier.target_id = tower.id
						mod.modifier.source_id = this.id

						queue_insert(store, mod)
						table.insert(target_marker_mods, mod)
					end

					local an, af = U.animation_name_facing_point(this, a.animation .. "_in", towers[1].pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					if SU.y_enemy_wait(store, this, a.cast_time) then
						goto label_59_0
					end

					a.ts = start_ts

					for i = 1, km.clamp(a.min_targets, a.max_targets, #towers) do
						local tower = towers[i]
						local mod = E:create_entity(a.mod)

						mod.modifier.target_id = tower.id
						mod.modifier.source_id = this.id

						queue_insert(store, mod)
						table.insert(target_mods, mod)
					end

					local an, af = U.animation_name_facing_point(this, a.animation .. "_loop", towers[1].pos)

					U.animation_start(this, an, af, store.tick_ts, true)

					is_shackling = true
					this.vis.bans = this.vis.bans_on_shackles
				end
			end

			if not is_shackling and not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, break_fn, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.mod_enemy_unblinded_shackler_shackles = {}

function scripts.mod_enemy_unblinded_shackler_shackles.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	SU.tower_block_inc(target)

	this.pos = target.pos

	if this.tween and not this.tween.disabled then
		this.tween.ts = store.tick_ts
	end

	U.animation_start(this, "in", nil, store.tick_ts)
	U.y_wait(store, fts(10))
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	local start_ts = store.tick_ts

	while true do
		if source.health.dead or this.remove then
			break
		end

		if not store.entities[m.source_id] then
			break
		end

		coroutine.yield()
	end

	U.animation_start(this, "out", nil, store.tick_ts)
	U.y_wait(store, fts(11))
	SU.tower_block_dec(target)
	queue_remove(store, this)
end

scripts.enemy_armored_nightmare = {}

function scripts.enemy_armored_nightmare.update(this, store, script)
	while true do
		if this.health.dead then
			local function show_blood_pool(e, terrain_type)
				if e.unit.show_blood_pool and e.unit.blood_color ~= BLOOD_NONE and band(terrain_type, TERRAIN_WATER) == 0 then
					local decal = E:create_entity("decal_blood_pool")

					decal.pos = V.vclone(e.pos)
					decal.render.sprites[1].ts = store.tick_ts
					decal.render.sprites[1].name = e.unit.blood_color
					decal.render.sprites[1].z = e.render.sprites[1].z
					decal.render.sprites[1].sort_y_offset = 1

					queue_insert(store, decal)
				end
			end

			local can_spawn = this.death_spawns and band(this.health.last_damage_types, bor(DAMAGE_EAT, DAMAGE_NO_SPAWNS, this.death_spawns.no_spawn_damage_types or 0)) == 0
			local terrain_type = band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_TYPES_MASK)

			if band(this.health.last_damage_types, bor(DAMAGE_EXPLOSION, DAMAGE_INSTAKILL, DAMAGE_FX_EXPLODE)) ~= 0 and band(this.health.last_damage_types, bor(DAMAGE_FX_NOT_EXPLODE, DAMAGE_DISINTEGRATE)) == 0 and this.unit.can_explode and this.unit.explode_fx and band(terrain_type, TERRAIN_WATER) == 0 then
				S:queue(this.sound_events.death_by_explosion)

				local fx = E:create_entity(this.unit.explode_fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts
				fx.render.sprites[1].name = fx.render.sprites[1].size_names[this.unit.size]

				queue_insert(store, fx)
				show_blood_pool(this, terrain_type)

				this.unit.hide_during_death = true
			elseif band(this.health.last_damage_types, bor(DAMAGE_DISINTEGRATE)) ~= 0 and this.unit.can_disintegrate and this.unit.disintegrate_fx then
				local fx = E:create_entity(this.unit.disintegrate_fx)

				fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
				fx.render.sprites[1].ts = store.tick_ts

				if fx.render.sprites[1].size_names then
					fx.render.sprites[1].name = fx.render.sprites[1].size_names[this.unit.size]
				end

				if band(this.vis.flags, F_FLYING) ~= 0 and this.unit.hit_offset then
					fx.render.sprites[1].offset.y = this.unit.hit_offset.y
				end

				queue_insert(store, fx)

				this.unit.hide_during_death = true
				this.unit.show_blood_pool = false
			elseif band(this.health.last_damage_types, bor(DAMAGE_EAT)) ~= 0 then
				this.unit.hide_during_death = true
				this.unit.show_blood_pool = false
			elseif band(terrain_type, TERRAIN_CLIFF) ~= 0 and band(this.vis.flags, F_FLYING) == 0 then
				S:queue(this.sound_events.death, this.sound_events.death_args)
				U.animation_start(this, "fall", nil, store.tick_ts, true)
				U.set_destination(this, this.cliff.fall_to_pos)

				while not U.walk(this, store.tick_length, this.cliff.fall_accel) do
					coroutine.yield()
				end

				show_blood_pool(this, terrain_type)
				U.y_animation_play(this, "death", nil, store.tick_ts, 1)
			elseif band(terrain_type, TERRAIN_WATER) ~= 0 and band(this.vis.flags, F_FLYING) == 0 then
				S:queue(this.sound_events.death_water, this.sound_events.death_water_args)
				U.y_animation_play(this, this.unit.death_animation, nil, store.tick_ts, 1)
			elseif this.unit.death_animation then
				S:queue(this.sound_events.death, this.sound_events.death_args)
				show_blood_pool(this, terrain_type)

				local an, af = this.unit.death_animation

				if this.heading and this.heading.angle then
					an, af = U.animation_name_for_angle(this, this.unit.death_animation, this.heading.angle)
				end

				U.animation_start(this, an, af, store.tick_ts, false)

				while not U.animation_finished(this) do
					if can_spawn and this.death_spawns.delay then
						U.y_wait(store, this.death_spawns.delay)
						SU.do_death_spawns(store, this)

						can_spawn = false
					end

					coroutine.yield()
				end
			end

			this.health.death_finished_ts = store.tick_ts

			if can_spawn then
				SU.do_death_spawns(store, this)
				coroutine.yield()

				can_spawn = false
			end

			if this.unit.hide_during_death or this.unit.hide_after_death then
				for _, s in pairs(this.render.sprites) do
					s.hidden = true
				end
			end

			if this.ui then
				this.ui.can_click = not this.unit.hide_after_death and not this.unit.hide_during_death
				this.ui.z = -1
			end

			if this.unit.fade_time_after_death then
				SU.fade_out_entity(store, this, this.unit.fade_time_after_death, this.unit.fade_duration_after_death, true)
			end

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false) then
			-- block empty
		else
			coroutine.yield()
		end
	end
end

scripts.enemy_corrupted_stalker = {}

function scripts.enemy_corrupted_stalker.update(this, store, script)
	local shadow_sprite = this.render.sprites[2]
	local terrain_type

	while true do
		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			SU.y_enemy_walk_until_blocked(store, this)
		end
	end
end

scripts.enemy_crystal_golem = {}

function scripts.enemy_crystal_golem.update(this, store, script)
	if this.start_as_rock then
		this.vis._bans = this.vis.bans
		this.vis.bans = F_ALL
		this.motion._max_speed = this.motion.max_speed
		this.motion.max_speed = 0
		this.ui.can_click = false
		this.health._hp_max = this.health.hp_max
		this.health_bar.hidden = true

		U.animation_start(this, "holder", nil, store.tick_ts)

		while true do
			if this.wake_up then
				signal.emit("wave-notification", "icon", "enemy_crystal_golem")

				this.health.hp_max = this.health._hp_max

				local nearest_nodes = P:nearest_nodes(this.walk_pos.x, this.walk_pos.y, {
					this.selected_path
				})
				local pi, spi, ni = unpack(nearest_nodes[1])

				this.nav_path.pi = pi
				this.nav_path.spi = spi
				this.nav_path.ni = ni

				S:queue(this.wake_up_sound)
				U.y_animation_play(this, "holder_spawn", nil, store.tick_ts, 1)

				this.motion.max_speed = this.motion._max_speed

				local holder = table.filter(store.entities, function(_, v)
					return v.tower and v.tower.holder_id == this.activate_holder
				end)[1]

				holder.ui.can_click = true
				this.health.dead = false
				this.vis.bans = this.vis._bans
				this.ui.can_click = true
				this.health_bar.hidden = false

				break
			end

			coroutine.yield()
		end
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false) then
			-- block empty
		else
			coroutine.yield()
		end
	end
end

scripts.enemy_blinker = {}

function scripts.enemy_blinker.update(this, store)
	local shadow_sprite = this.render.sprites[2]
	local ar = this.ranged.attacks[1]

	ar.ts = store.tick_ts - ar.cooldown

	if this.render.sprites[1].name == "raise" then
		local next_pos

		if this.motion.forced_waypoint then
			next_pos = this.motion.forced_waypoint
		else
			next_pos = P:next_entity_node(this, store.tick_length)
		end

		local an, af = U.animation_name_facing_point(this, "raise", next_pos)

		U.y_animation_play(this, an, af, store.tick_ts, 1)
	end

	local last_blink = store.tick_ts
	local blink_cd = math.random(this.blink_min_cd, this.blink_max_cd)
	local last_run = 0
	local animation = "walk"

	while true do
		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local target

			while target == nil and not this.unit.is_stunned and not this.health.dead do
				if not ar.disabled and (not ar.requires_magic or this.enemy.can_do_magic) and store.tick_ts - ar.ts > ar.cooldown then
					target = U.find_nearest_soldier(store.entities, this.pos, ar.min_range, ar.max_range, ar.vis_flags, ar.vis_bans, function(v, origin)
						return not v.unit.is_stunned and SU.can_range_soldier(store, this, v)
					end)
				end

				if target == nil then
					SU.y_enemy_walk_step(store, this, animation, 1)

					if this.render.sprites[1].runs ~= last_run and (animation == "walk" or animation == "blink") then
						last_run = this.render.sprites[1].runs

						if blink_cd < store.tick_ts - last_blink then
							blink_cd = math.random(this.blink_min_cd, this.blink_max_cd)
							last_blink = store.tick_ts
							animation = "blink"
						else
							animation = "walk"
						end
					end
				end
			end

			if target then
				local flip = target.pos.x < this.pos.x

				U.animation_start(this, ar.animation, flip, store.tick_ts, true)

				local nearest_nodes = P:nearest_nodes(target.pos.x, target.pos.y)
				local pi, spi, ni = unpack(nearest_nodes[1])
				local target_pos = P:node_pos(pi, spi, ni)
				local aura

				if this.is_glare_active then
					aura = E:create_entity(ar.aura_glare)
				else
					aura = E:create_entity(ar.aura)
				end

				aura.pos = V.vclone(target_pos)
				aura.aura.source_id = this.id
				aura.aura.ts = store.tick_ts

				queue_insert(store, aura)

				local fx

				if this.is_glare_active then
					fx = E:create_entity(ar.fx_glare)
				else
					fx = E:create_entity(ar.fx_normal)
				end

				fx.pos = V.vclone(this.pos)
				fx.pos.x, fx.pos.y = fx.pos.x + this.unit.hit_offset.x, fx.pos.y + this.unit.hit_offset.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)

				local ray

				if this.is_glare_active then
					ray = E:create_entity(ar.bullet_glare)
				else
					ray = E:create_entity(ar.bullet)
				end

				ray.pos = V.vclone(this.pos)
				ray.pos.x, ray.pos.y = ray.pos.x + this.unit.hit_offset.x, ray.pos.y + this.unit.hit_offset.y
				ray.bullet.from = V.vclone(ray.pos)
				ray.bullet.to = V.vclone(target_pos)
				ray.bullet.target_id = target.id
				ray.bullet.source_id = this.id

				queue_insert(store, ray)

				ar.ts = store.tick_ts

				local check_aura_ts = store.tick_ts

				U.y_wait(store, ar.duration, function()
					if this.unit.is_stunned or this.health.dead then
						return true
					end

					if store.tick_ts - check_aura_ts > 0.2 then
						check_aura_ts = store.tick_ts

						local targets = table.filter(store.entities, function(k, v)
							return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, aura.aura.vis_bans) == 0 and band(v.vis.bans, aura.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, aura.pos, aura.aura.radius)
						end)

						return #targets == 0
					end

					return false
				end)
				queue_remove(store, aura)
				queue_remove(store, fx)
				queue_remove(store, ray)
			end

			coroutine.yield()
		end
	end
end

function scripts.enemy_blinker.on_start_glare(this, store, script)
	this.is_glare_active = true
end

function scripts.enemy_blinker.on_end_glare(this, store, script)
	this.is_glare_active = false
end

scripts.bullet_enemy_blinker = {}

function scripts.bullet_enemy_blinker.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)

	local function update_sprite()
		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()
	U.y_wait(store, this.ray_duration)

	while store.tick_ts - s.ts < this.ray_duration do
		coroutine.yield()
	end

	queue_remove(store, this)

	return true
end

scripts.enemy_mindless_husk = {}

function scripts.enemy_mindless_husk.update(this, store, script)
	if not this.death_spawns then
		this.death_spawns = {}
		this.death_spawns.name = "noname"
		this.death_spawns.quantity = 0
	end

	while true do
		if this.health.dead then
			local can_spawn = band(this.health.last_damage_types, bor(DAMAGE_EAT, DAMAGE_NO_SPAWNS, DAMAGE_INSTAKILL)) == 0
			local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni
			local enemies_left = table.filter(store.entities, function(_, e)
				return e.main_script and (e.main_script.co or e.main_script.runs > 0) and (e.enemy and e.health and not e.health.dead or e.enemy and e.death_spawns or e.spawner and not e.spawner.eternal or e.picked_enemies and #e.picked_enemies > 0 or e.tunnel and #e.tunnel.picked_enemies > 0) and e.id ~= this.id
			end)

			if can_spawn and store.level.run_complete and store.waves_finished and #enemies_left == 0 then
				can_spawn = false
			end

			if can_spawn and nodes_to_end > this.glareling_spawn_max_nodes_to_exit then
				local c = E:create_entity(this.glareling_spawn_controller)

				c.husk = this

				queue_insert(store, c)

				this.sound_events.death = this.sound_death_and_spawn
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false) then
			-- block empty
		else
			coroutine.yield()
		end
	end
end

scripts.controller_enemy_mindless_husk_glareling_spawn = {}

function scripts.controller_enemy_mindless_husk_glareling_spawn.update(this, store, script)
	U.y_wait(store, this.glareling_spawn_delay)

	local np = this.husk.nav_path
	local nodes_ahead = math.random(this.min_nodes_ahead, this.max_nodes_ahead)
	local dest = P:node_pos(np.pi, np.spi, np.ni + nodes_ahead)
	local b = E:create_entity(this.glareling_bullet)

	b.pos.x, b.pos.y = this.husk.pos.x + this.start_offset.x, this.husk.pos.y + this.start_offset.y
	b.bullet.from = V.vclone(b.pos)
	b.bullet.to = dest
	b.bullet.source_id = this.husk.id
	b.path_to_spawn = np.pi

	queue_insert(store, b)
	queue_remove(store, this)
end

scripts.enemy_mindless_husk_egg = {}

function scripts.enemy_mindless_husk_egg.update(this, store, script)
	local start_ts = store.tick_ts

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if store.tick_ts - start_ts > this.time_to_spawn then
			local g = E:create_entity(this.spawn_entity)

			g.pos = V.vclone(this.pos)
			g.render.sprites[1].name = this.spawn_entity_anim
			g.render.sprites[1].flip_x = this.render.sprites[1].flip_x
			g.nav_path.pi = this.nav_path.pi
			g.nav_path.spi = this.nav_path.spi
			g.nav_path.ni = this.nav_path.ni + 2

			queue_insert(store, g)
			U.y_wait(store, fts(1))

			this.ui.can_click = not this.unit.hide_after_death and not this.unit.hide_during_death
			this.ui.z = -1
			this.render.sprites[1].hidden = true
			this.health.dead = true

			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

scripts.enemy_vile_spawner = {}

function scripts.enemy_vile_spawner.on_start_glare(this, store, script)
	this.timed_attacks.list[1].cooldown = this.glare_kr5.lesser_spawn_cooldown
end

function scripts.enemy_vile_spawner.on_end_glare(this, store, script)
	this.timed_attacks.list[1].cooldown = this.timed_attacks.list[1].normal_cooldown
end

function scripts.enemy_vile_spawner.update(this, store, script)
	local a
	local ab = this.melee.attacks[1]
	local as = this.timed_attacks.list[1]

	as.ts = store.tick_ts

	local cg = store.count_groups[as.count_group_type]

	local function ready_to_spawn()
		local node_limit = math.floor(as.min_distance_from_end / P.average_node_dist)
		local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

		return store.tick_ts - as.ts > as.cooldown and store.tick_ts - ab.ts > 3 and this.enemy.can_do_magic and node_limit < nodes_to_end and (not cg[as.count_group_name] or cg[as.count_group_name] < as.count_group_max)
	end

	local function break_fn()
		return ready_to_spawn()
	end

	while true do
		if this.health.dead then
			this.tween.disabled = true
			this.tween = nil
			this.render.sprites[2].hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_spawn() then
				a = as

				local start_ts = store.tick_ts

				this.available_nodes = {}

				local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, a.min_range, a.max_range, nil, function(x, y)
					local nearest_node = P:nearest_nodes(x, y, {
						this.nav_path.pi
					}, {
						1,
						2,
						3
					}, true)

					if #nearest_node > 0 then
						return true
					end

					return false
				end, nil, {
					1,
					2,
					3
				})

				nodes = table.random_order(nodes)

				for j = 1, #nodes do
					local is_far = true

					for k = 1, #this.available_nodes do
						local distance = V.dist(nodes[j].x, nodes[j].y, this.available_nodes[k].pos.x, this.available_nodes[k].pos.y)

						if distance < a.distance_between_entities then
							is_far = false

							break
						end
					end

					if is_far then
						local nearest_node = P:nearest_nodes(nodes[j].x, nodes[j].y, {
							this.nav_path.pi
						}, {
							1,
							2,
							3
						}, true)
						local min_distance = 5

						if #nearest_node > 0 and min_distance > nearest_node[1][4] then
							table.insert(this.available_nodes, {
								pos = nodes[j],
								node = nearest_node[1]
							})

							if #this.available_nodes >= a.entities_amount then
								break
							end
						end
					end
				end

				U.animation_start(this, a.animation, nil, store.tick_ts)
				U.y_wait(store, a.cast_time)
				S:queue(this.sound_events.spawn_cast)

				for i = 1, #this.available_nodes do
					local b = E:create_entity(a.bullet)
					local bullet_start_offset = a.bullet_start_offset

					b.pos.x, b.pos.y = this.pos.x + bullet_start_offset.x, this.pos.y + bullet_start_offset.y
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = V.vclone(this.available_nodes[i].pos)
					b.bullet.to.y = b.bullet.to.y + a.bullet_aim_height
					b.bullet.source_id = this.id
					b.bullet_aim_height = a.bullet_aim_height
					b.nav_path_data = this.available_nodes[i].node

					queue_insert(store, b)
					U.y_wait(store, a.delay_between)
					signal.emit("wave-notification", "icon", "enemy_lesser_eye")
				end

				U.y_animation_wait(this)

				a.ts = start_ts
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.bullet_vile_spawner_spawn = {}

function scripts.bullet_vile_spawner_spawn.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius
	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if this.bullet_particle then
		bullet_particle = E:create_entity(this.bullet_particle)
		bullet_particle.bullet.to = b.to
		bullet_particle.bullet.from = b.from

		queue_insert(store, bullet_particle)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
			hp.nav_path_data = this.nav_path_data
		else
			hp = b.hit_payload
		end

		hp.pos.x, hp.pos.y = b.to.x, b.to.y - this.bullet_aim_height
		hp.spawn_from_bullet = true

		if hp.aura then
			hp.aura.level = this.bullet.level
		end

		queue_insert(store, hp)
	end

	queue_remove(store, this)
end

scripts.bullet_vile_spawner_spawn_particle = {}

function scripts.bullet_vile_spawner_spawn_particle.update(this, store)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	queue_remove(store, this)
end

scripts.enemy_lesser_eye = {}

function scripts.enemy_lesser_eye.update(this, store)
	local shadow_sprite = this.render.sprites[2]

	if not this.initialized_nav_path then
		this.nav_path.pi = this.nav_path_data[1]
		this.nav_path.spi = this.nav_path_data[2]
		this.nav_path.ni = this.nav_path_data[3]
	end

	this.initialized_nav_path = true

	local next, new = P:next_entity_node(this, store.tick_length)
	local an, af = U.animation_name_facing_point(this, "spawn", next)

	U.y_animation_play(this, an, af, store.tick_ts, 1)

	while true do
		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			SU.y_enemy_walk_step(store, this, "walk", 1)
		end
	end
end

scripts.enemy_noxious_horror = {}

function scripts.enemy_noxious_horror.update(this, store, script)
	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false) then
			-- block empty
		else
			coroutine.yield()
		end
	end
end

function scripts.enemy_noxious_horror.on_start_glare(this, store, script)
	this.health.magic_armor = this.health.magic_armor + this.glare_kr5.magic_armor
	this.aura_glare = E:create_entity(this.glare_kr5.aura_poison)
	this.aura_glare.aura.source_id = this.id
	this.aura_glare.aura.ts = store.tick_ts
	this.aura_glare.tween.ts = store.tick_ts

	queue_insert(store, this.aura_glare)
end

function scripts.enemy_noxious_horror.on_end_glare(this, store, script)
	this.health.magic_armor = this.health.magic_armor - this.glare_kr5.magic_armor
	this.aura_glare.tween.ts = store.tick_ts
	this.aura_glare.tween.reverse = true
	this.aura_glare.tween.remove = true
end

scripts.mod_enemy_noxious_horror_poison = {}

function scripts.mod_enemy_noxious_horror_poison.insert(this, store, script)
	if not scripts.mod_dps.insert(this, store, script) then
		return false
	end

	local target = store.entities[this.modifier.target_id]
	local fx = E:create_entity(this.start_fx)

	fx.pos = V.vclone(target.pos)
	fx.pos.x, fx.pos.y = target.unit.hit_offset.x, target.unit.hit_offset.y
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)
	U.animation_start(this, "idle", false, store.tick_ts, true)

	return true
end

scripts.bullet_enemy_noxious_horror = {}

function scripts.bullet_enemy_noxious_horror.insert(this, store)
	local b = this.bullet
	local target = store.entities[this.bullet.target_id]

	if not target then
		return false
	end

	local is_flying = U.flag_has(target.vis.flags, F_FLYING)

	if is_flying and target.unit and target.unit.hit_offset then
		this.bullet.to.x, this.bullet.to.y = this.bullet.to.x + target.unit.hit_offset.x, this.bullet.to.y + target.unit.hit_offset.y
		this.bullet.hit_decal = this.bullet.hit_decal_flying
	else
		this.bullet.hit_decal = this.bullet.hit_decal_ground
	end

	if b.flight_time_base and b.flight_time_factor then
		local dist = V.dist(b.to.x, b.to.y, b.from.x, b.from.y)

		b.flight_time = b.flight_time_base + dist * b.flight_time_factor
	end

	b.speed = SU.initial_parabola_speed(b.from, b.to, b.flight_time, b.g)
	b.ts = store.tick_ts
	b.last_pos = V.vclone(b.from)
	this.render.sprites[1].r = (math.random() - 0.5) * math.pi

	if b.hide_radius then
		this.render.sprites[1].hidden = true
	end

	return true
end

scripts.enemy_hardened_horror = {}

function scripts.enemy_hardened_horror.update(this, store, script)
	::label_95_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local function walk_melee_break_fn()
				return this.do_roll_in
			end

			local function roll_break_fn()
				return this.do_roll_out
			end

			if this.is_rolling then
				local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, true, roll_break_fn)

				if this.do_roll_out then
					this.do_roll_out = false
					this.is_rolling = false

					U.y_animation_play(this, "roll_out", nil, store.tick_ts)

					this.render.sprites[1].angles.walk = this._old_angles_walk
					this.motion.max_speed = this.base_speed
					this.vis.bans = 0
				end

				if not cont then
					goto label_95_0
				end
			elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, walk_melee_break_fn, walk_melee_break_fn) then
				if this.do_roll_in then
					this.do_roll_in = false
					this.is_rolling = true

					U.y_animation_play(this, "roll_in", nil, store.tick_ts)

					this._old_angles_walk = this.render.sprites[1].angles.walk
					this.render.sprites[1].angles.walk = this.glare_kr5.roll_angles
					this.motion.max_speed = this.glare_kr5.roll_speed

					U.unblock_all(store, this)

					this.vis.bans = bor(F_BLOCK)
				end

				goto label_95_0
			end

			coroutine.yield()
		end
	end
end

function scripts.enemy_hardened_horror.on_start_glare(this, store, script)
	SU.armor_inc(this, this.glare_kr5.armor)

	this.do_roll_in = true
end

function scripts.enemy_hardened_horror.on_end_glare(this, store, script)
	SU.armor_dec(this, this.glare_kr5.armor)

	this.do_roll_out = true
end

scripts.enemy_evolving_scourge = {}

function scripts.enemy_evolving_scourge.update(this, store, script)
	this.current_phase = 1
	this.next_phase = 1

	local min_lt_to_transform = 2

	this.spawn_ts = store.tick_ts

	local shadow_sprite = this.render.sprites[2]

	this.melee.attacks[2].ts = store.tick_ts - this.melee.attacks[2].cooldown

	while true do
		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local function walk_melee_break_fn()
				return this.next_phase ~= this.current_phase and (not this.glare_ts or store.tick_ts - this.spawn_ts > min_lt_to_transform)
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, walk_melee_break_fn, walk_melee_break_fn) then
				if this.next_phase ~= this.current_phase then
					local old_max_hp = this.health.hp_max
					local hp_factor_enemy = GS.difficulty_enemy_hp_max_factor[store.level_difficulty]
					local current_hp_ptg = this.health.hp / this.health.hp_max

					this.health.hp_max = this.hp_config[this.next_phase] * hp_factor_enemy
					this.health.hp = this.health.hp_max * current_hp_ptg
					this.health_bar.alpha = 0

					local old_bans = this.vis.bans

					this.vis.bans = bor(F_ALL)

					S:queue(this.sound_events.evolve)

					if this.next_phase - this.current_phase > 1 then
						U.y_animation_play(this, "mutation2", nil, store.tick_ts)
					else
						U.y_animation_play(this, "mutation", nil, store.tick_ts)
					end

					this.health_bar.offset = this.health_bar_offset_config[this.next_phase]
					this.health_bar.type = this.health_bar_type_config[this.next_phase]
					this.current_phase = this.next_phase

					local speed_factor_enemy = GS.difficulty_enemy_speed_factor[store.level_difficulty]

					this.motion.max_speed = this.speed_config[this.current_phase] * speed_factor_enemy
					this.render.sprites[1].prefix = "evolving_scourge_fase" .. this.current_phase
					this.ui.click_rect = this.click_rect_config[this.current_phase]
					this.unit.hit_offset = v(-2, 10 + this.unit_y_offset_config[this.current_phase])
					this.unit.mod_offset = v(0, 10 + this.unit_y_offset_config[this.current_phase])
					this.enemy.gold = this.gold_config[this.current_phase]
					this.info.portrait = "gui_bottom_info_image_enemies_00" .. 34 + this.current_phase
					this.trigger_deselect = true

					U.unblock_all(store, this)

					this.vis.bans = old_bans

					if this.current_phase == 2 then
						this.melee.attacks[1].disabled = true
						this.melee.attacks[2].disabled = true
						this.melee.attacks[3].disabled = false
						this.melee.attacks[4].disabled = false
						this.melee.attacks[3].ts = store.tick_ts
						this.melee.attacks[4].ts = store.tick_ts
					else
						this.render.sprites[2].hidden = false
						this.vis.flags = bor(F_ENEMY, F_FLYING)
						this.vis.bans = bor(F_BLOCK)

						for k, v in pairs(this.melee.attacks) do
							v.disabled = true
						end

						this.tween.disabled = false
						this.tween.ts = store.tick_ts
						this.unit.can_explode = false
						this.unit.show_blood_pool = false
						this.unit.hide_after_death = true
						this.unit.disintegrate_fx = "fx_enemy_desintegrate_air"
					end
				end
			else
				coroutine.yield()
			end
		end
	end
end

function scripts.enemy_evolving_scourge.on_start_glare(this, store, script)
	this.next_phase = 3
	this.glare_ts = store.tick_ts
end

scripts.mod_enemy_evolving_scourge_eat = {}

function scripts.mod_enemy_evolving_scourge_eat.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		target.vis.bans = F_ALL

		SU.stun_inc(target)
	end
end

function scripts.mod_enemy_evolving_scourge_eat.update(this, store)
	local target = store.entities[this.modifier.target_id]
	local source = store.entities[this.modifier.source_id]

	if not target or not source then
		queue_remove(store, this)

		return
	end

	local af = source.pos.x > target.pos.x

	this.pos.x, this.pos.y = target.pos.x, target.pos.y

	local d = E:create_entity("damage")

	d.damage_type = DAMAGE_EAT
	d.source_id = this.id
	d.target_id = target.id

	queue_damage(store, d)

	local es = E:create_entity(this.explode_fx)

	es.pos.x, es.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	es.render.sprites[1].ts = store.tick_ts

	queue_insert(store, es)

	source.next_phase = source.next_phase + 1

	queue_remove(store, this)
end

scripts.decal_enemy_amalgam_hit = {}

function scripts.decal_enemy_amalgam_hit.update(this, store)
	local spikes = {}
	local spikes_pos = {}

	spikes_pos[1] = V.vclone(this.pos)
	spikes_pos[2] = V.vclone(this.pos)
	spikes_pos[2].x, spikes_pos[2].y = spikes_pos[2].x, spikes_pos[2].y + this.distance_between
	spikes_pos[3] = V.vclone(this.pos)
	spikes_pos[3].x, spikes_pos[3].y = spikes_pos[3].x, spikes_pos[3].y - this.distance_between
	spikes_pos[4] = V.vclone(this.pos)
	spikes_pos[4].x, spikes_pos[4].y = spikes_pos[4].x + this.distance_between, spikes_pos[4].y
	spikes_pos[5] = V.vclone(this.pos)
	spikes_pos[5].x, spikes_pos[5].y = spikes_pos[5].x - this.distance_between, spikes_pos[5].y

	for i = #spikes_pos, 2, -1 do
		local j = math.random(i)

		spikes_pos[i], spikes_pos[j] = spikes_pos[j], spikes_pos[i]
	end

	for k, v in pairs(spikes_pos) do
		U.y_wait(store, fts(math.random(0, 2)))

		v.x, v.y = v.x + math.random(-8, 8), v.y + math.random(-8, 8)

		local spike = E:create_entity(this.spike_decals[math.random(1, #this.spike_decals)])

		spike.pos = V.vclone(v)
		spike.render.sprites[1].ts = store.tick_ts

		queue_insert(store, spike)
	end

	queue_remove(store, this)
end

scripts.enemy_corrupted_elf = {}

function scripts.enemy_corrupted_elf.update(this, store, script)
	local has_knife = false

	local function y_stun(store, this)
		local flip_x = this.motion and this.motion.dest.x < this.pos.x or nil

		if has_knife then
			U.animation_start(this, "idle", flip_x, store.tick_ts, true)
		else
			U.animation_start(this, "idle2", flip_x, store.tick_ts, true)
		end

		coroutine.yield()
	end

	::label_106_0::

	while true do
		if this.health.dead then
			local nodes_to_goal = P:nodes_to_goal(this.nav_path)

			if nodes_to_goal < this.spawn_nodes_limit then
				this.death_spawns = nil
			else
				S:queue(this.sound_specter_spawn, {
					delay = 1
				})
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			y_stun(store, this)
		else
			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

			if not cont then
				-- block empty
			else
				if blocker then
					if not has_knife then
						U.y_animation_play(this, this.melee.attacks[1].animation_in, nil, store.tick_ts)

						has_knife = true
					end

					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_106_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							if #this.enemy.blockers == 0 then
								U.y_animation_play(this, this.melee.attacks[1].animation_out, nil, store.tick_ts)

								has_knife = false
							end

							goto label_106_0
						end

						coroutine.yield()
					end

					if #this.enemy.blockers == 0 then
						U.y_animation_play(this, this.melee.attacks[1].animation_out, nil, store.tick_ts)

						has_knife = false
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_106_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_specter = {}

function scripts.enemy_specter.insert(this, store, script)
	if not U.is_seen(store, "enemy_specter") then
		signal.emit("wave-notification", "icon", "enemy_specter")
	end

	return scripts.enemy_basic.insert(this, store, script)
end

function scripts.enemy_specter.update(this, store, script)
	local search_cd = 0.5
	local search_ts = store.tick_ts

	this.corruption_target = nil

	local non_corruptable = {}
	local base_speed = this.motion.max_speed

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	local function search_corruptable()
		if store.tick_ts - search_ts < search_cd or #this.enemy.blockers > 0 then
			return false
		end

		search_ts = store.tick_ts

		local c
		local search_dist2 = this.chase_dist * this.chase_dist

		for k, v in pairs(store.entities) do
			if v.corruption_kr5 and v.corruption_kr5.enabled and not v.corruption_kr5._marked and not table.contains(non_corruptable, v) and search_dist2 >= V.dist2(v.pos.x, v.pos.y, this.pos.x, this.pos.y) then
				local nearest_nodes = P:nearest_nodes(v.pos.x, v.pos.y, {
					this.nav_path.pi
				}, {
					this.nav_path.spi
				})
				local _, _, ni = unpack(nearest_nodes[1])

				if ni < this.nav_path.ni then
					table.insert(non_corruptable, v)
				else
					c = v
					v.corruption_kr5._marked = true

					break
				end
			end
		end

		if c then
			this.corruption_target = c

			return true
		end

		return false
	end

	local function corruption_break_fn()
		return this.health.dead or this.unit.is_stunned or this.start_tel_count < this.enemy.counts.mod_teleport or
		#this.enemy.blockers > 0
	end

	local function cancel_corruption()
		if this.corruption_target then
			this.corruption_target.corruption_kr5._marked = false
		end

		this.corruption_target = nil
		this.motion.max_speed = base_speed

		if this.trail then
			this.trail.particle_system.emit = false
		end

		this.render.sprites[1].angles.walk = {
			"walk",
			"walk_back",
			"walk_front"
		}
	end

	::label_109_0::

	while true do
		if this.health.dead then
			cancel_corruption()
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			cancel_corruption()
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, search_corruptable) then
			if this.corruption_target then
				S:queue(this.sound_rush_anticipation)

				this.motion.max_speed = this.speed_chase
				this.render.sprites[1].angles.walk = this.angles_chase

				if not this.enemy.counts.mod_teleport then
					this.enemy.counts.mod_teleport = 0
				end

				this.start_tel_count = this.enemy.counts.mod_teleport

				U.y_animation_play(this, "approach_in", nil, store.tick_ts)
				U.animation_start(this, "approach_idle", nil, store.tick_ts, true)

				if U.y_wait(store, this.chase_delay, corruption_break_fn) then
					-- block empty
				else
					S:queue(this.sound_rush)

					this.trail = E:create_entity(this.chase_trail)
					this.trail.particle_system.track_id = this.id

					queue_insert(store, this.trail)

					local c = this.corruption_target

					this.motion.forced_waypoint = c.pos
					this.vis.bans = bor(this.vis.bans, F_BLOCK)

					while SU.y_enemy_walk_step(store, this) do
						if corruption_break_fn() then
							goto label_109_0
						end
					end

					c.corruption_kr5.on_corrupt(c, store)

					c.corruption_kr5._marked = false
					this.corruption_target = nil

					S:queue(this.sound_corruption)

					this.sound_events.death = nil
					this.health_bar.hidden = true
					this.render.sprites[1].z = Z_EFFECTS

					U.y_animation_play(this, this.animation_corrupt, false, store.tick_ts)

					this.trail.particle_system.emit = false
					this.render.sprites[1].hidden = true

					U.y_wait(store, fts(90))

					break
				end
			end
		else
			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

function scripts.enemy_specter.remove(this, store, script)
	if this.trail then
		queue_remove(store, this.trail)
	end

	if this.corruption_target then
		this.corruption_target.corruption_kr5._marked = false
	end

	return true
end

scripts.enemy_dust_cryptid = {}

function scripts.enemy_dust_cryptid.update(this, store, script)
	local shadow_sprite = this.render.sprites[2]

	while true do
		if this.health.dead then
			shadow_sprite.hidden = true

			local nodes_to_goal = P:nodes_to_goal(this.nav_path)

			if nodes_to_goal <= this.nodes_to_prevent_dust then
				this.enemy.can_do_magic = false
			end

			if not this.enemy.can_do_magic then
				this.death_spawns = nil
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			SU.y_enemy_walk_until_blocked(store, this)
		end
	end
end

scripts.aura_enemy_dust_cryptid = {}

function scripts.aura_enemy_dust_cryptid.insert(this, store, script)
	this.aura.ts = store.tick_ts

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts
		end
	end

	this.actual_duration = this.aura.duration

	if this.aura.duration_inc then
		this.actual_duration = this.actual_duration + this.aura.level * this.aura.duration_inc
	end

	local nearest_nodes = P:nearest_nodes(this.pos.x, this.pos.y)
	local pi, spi, ni = unpack(nearest_nodes[1])

	this.pos = P:node_pos(pi, 1, ni)
	this.decals = {}
	this.decals_pos = {
		P:node_pos(pi, 1, ni - 4),
		P:node_pos(pi, 1, ni),
		P:node_pos(pi, 1, ni + 4),
		P:node_pos(pi, 2, ni - 2),
		P:node_pos(pi, 2, ni + 2),
		P:node_pos(pi, 3, ni - 2),
		P:node_pos(pi, 3, ni + 2)
	}

	for k, v in pairs(this.decals_pos) do
		local decal = E:create_entity(this.decal_t)

		decal.pos = v
		decal.render.sprites[1].ts = store.tick_ts - fts(math.random(0, 15))
		decal.tween.ts = store.tick_ts

		queue_insert(store, decal)
		table.insert(this.decals, decal)
	end

	return true
end

function scripts.aura_enemy_dust_cryptid.remove(this, store, script)
	for k, v in pairs(this.decals) do
		v.tween.ts = store.tick_ts
		v.tween.reverse = true
		v.tween.remove = true
	end

	return true
end

scripts.mod_enemy_dust_cryptid = {}

function scripts.mod_enemy_dust_cryptid.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		return false
	end

	if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id,
			target.template_name)

		return false
	end

	if target and target.unit and this.render then
		for i = 1, #this.render.sprites do
			local s = this.render.sprites[i]

			s.flip_x = target.render.sprites[1].flip_x
			s.ts = store.tick_ts

			if s.size_names then
				s.name = s.size_names[target.unit.size]
			end
		end

		this.old_on_damage = target.health.on_damage

		function target.health.on_damage(hero, store, damage)
			if U.flag_has(damage.damage_type, bit.bor(DAMAGE_INSTAKILL, DAMAGE_DISINTEGRATE, DAMAGE_EAT, DAMAGE_IGNORE_SHIELD, DAMAGE_NO_DODGE, DAMAGE_POISON, DAMAGE_MODIFIER, DAMAGE_EXPLOSION)) then
				return true
			end

			local e = E:create_entity("pop_miss")

			e.pos = V.v(hero.pos.x, hero.pos.y)

			if hero.unit and hero.unit.pop_offset then
				e.pos.y = e.pos.y + hero.unit.pop_offset.y
			end

			e.pos.y = e.pos.y + e.pop_y_offset
			e.render.sprites[1].r = math.random(-21, 21) * math.pi / 180
			e.render.sprites[1].ts = store.tick_ts

			simulation:queue_insert_entity(e)

			return false
		end
	end

	return true
end

function scripts.mod_enemy_dust_cryptid.remove(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target.health.on_damage = this.old_on_damage
	end

	return true
end

scripts.aura_damage_sprint = {}

function scripts.aura_damage_sprint.insert(this, store, script)
	local target = store.entities[this.aura.source_id]

	if not target or target.health.dead or not target.motion then
		return false
	end

	if not target.damage_sprint_factor then
		log.error("Target %s has no damage_sprint_factor property. Aura discarded.", this.aura.source_id)

		return false
	end

	this.last_sprint_factor = 1
	this.aura.ts = store.tick_ts

	return true
end

function scripts.aura_damage_sprint.remove(this, store, script)
	local target = store.entities[this.aura.source_id]

	if target and target.health and target.motion then
		log.paranoid("aura_damage_sprint.remove: current max_speed: %s / prev: %s", target.motion.max_speed,
			this.last_sprint_factor)

		target.motion.max_speed = target.motion.max_speed / this.last_sprint_factor
	end

	return true
end

function scripts.aura_damage_sprint.update(this, store, script)
	while true do
		local target = store.entities[this.aura.source_id]

		if not target or target.health.dead or not target.motion then
			queue_remove(store, this)

			return
		end

		if this.last_sprint_hp ~= target.health.hp then
			local hp, hp_max = target.health.hp, target.health.hp_max
			local sprint_factor = 1 + (hp_max - hp) / hp_max * target.damage_sprint_factor

			log.paranoid("aura_damage_sprint.update: current max_speed: %s / %s * %s", target.motion.max_speed,
				this.last_sprint_factor, sprint_factor)

			target.motion.max_speed = target.motion.max_speed / this.last_sprint_factor * sprint_factor
			this.last_sprint_hp = target.health.hp
			this.last_sprint_factor = sprint_factor
		end

		coroutine.yield()
	end
end

scripts.enemy_deathwood = {}

function scripts.enemy_deathwood.update(this, store, script)
	if this.started_in_holder then
		if store.wave_group_number < 9 and this.selected_path == 4 then
			this.selected_path = 1
		end

		local nearest_nodes = P:nearest_nodes(this.walk_pos.x, this.walk_pos.y, {
			this.selected_path
		})
		local pi, spi, ni = unpack(nearest_nodes[1])

		this.nav_path.pi = pi
		this.nav_path.spi = spi
		this.nav_path.ni = ni
		this.motion.forced_waypoint = P:node_pos(pi, spi, ni)

		S:queue(this.wake_up_sound)

		while SU.y_enemy_walk_step(store, this) do
			if this.unit.is_stunned then
				SU.y_enemy_stun(store, this)
			end

			if this.health.dead then
				SU.y_enemy_death(store, this)

				return
			end

			if this.enemy.counts.mod_teleport and this.enemy.counts.mod_teleport > 0 then
				break
			end
		end

		this.motion.forced_waypoint = nil
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false) then
			-- block empty
		else
			coroutine.yield()
		end
	end
end

scripts.enemy_animated_armor = {}

function scripts.enemy_animated_armor.insert(this, store, script)
	local next, new = P:next_entity_node(this, store.tick_length)

	if not next then
		log.debug("(%s) %s has no valid next node", this.id, this.template_name)

		return false
	end

	U.set_destination(this, next)
	U.set_heading(this, next)

	if not this.pos or this.pos.x == 0 and this.pos.y == 0 then
		this.pos = P:node_pos(this.nav_path.pi, this.nav_path.spi, this.nav_path.ni)
	end

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts
		end
	end

	if this.melee then
		this.melee.order = U.attack_order(this.melee.attacks)

		for _, a in pairs(this.melee.attacks) do
			a.ts = store.tick_ts
		end
	end

	if this.ranged then
		this.ranged.order = U.attack_order(this.ranged.attacks)

		for _, a in pairs(this.ranged.attacks) do
			a.ts = store.tick_ts
		end
	end

	if this.auras then
		for _, a in pairs(this.auras.list) do
			a.ts = store.tick_ts

			if a.cooldown == 0 then
				local e = E:create_entity(a.name)

				e.pos = V.vclone(this.pos)
				e.aura.level = this.unit.level
				e.aura.source_id = this.id
				e.aura.ts = store.tick_ts

				queue_insert(store, e)
			end
		end
	end

	this.enemy.gold_bag = math.ceil(this.enemy.gold * 0.3)

	if this.water and this.spawn_data and this.spawn_data.water_ignore_pi then
		this.water.ignore_pi = this.spawn_data.water_ignore_pi
	end

	this.anim_armor_achievement_controller_id = nil

	for _, e in pairs(store.entities) do
		if e.template_name == "controller_terrain_4_animated_armor_achievement" then
			this.anim_armor_achievement_controller_id = e.id

			break
		end
	end

	if not this.anim_armor_achievement_controller_id then
		local e = E:create_entity("controller_terrain_4_animated_armor_achievement")

		queue_insert(store, e)

		this.anim_armor_achievement_controller_id = e.id
	end

	return true
end

function scripts.enemy_animated_armor.update(this, store, script)
	if this.spawned_from_tower then
		this.motion.max_speed = this.motion.max_speed * 2

		while SU.y_enemy_walk_step(store, this, "spawn") and this.render.sprites[1].runs <= 0 and (not this.enemy.counts.mod_teleport or this.enemy.counts.mod_teleport == 0) and not this.unit.is_stunned do
			-- block empty
		end

		this.motion.max_speed = this.motion.max_speed / 2

		if this.enemy.counts.mod_teleport == 0 and not this.unit.is_stunned then
			while SU.y_enemy_walk_step(store, this) do
				if this.unit.is_stunned then
					SU.y_enemy_stun(store, this)
				end

				if this.health.dead then
					break
				end
			end
		end
	end

	while true do
		if this.health.dead then
			local enemy_gold = this.enemy.gold

			this.enemy.gold = 0

			if band(this.health.last_damage_types, bor(DAMAGE_EXPLOSION, DAMAGE_INSTAKILL, DAMAGE_FX_EXPLODE)) ~= 0 and band(this.health.last_damage_types, bor(DAMAGE_FX_NOT_EXPLODE, DAMAGE_DISINTEGRATE)) == 0 and this.unit.can_explode and this.unit.explode_fx or band(this.health.last_damage_types, bor(DAMAGE_DISINTEGRATE)) ~= 0 and this.unit.can_disintegrate and this.unit.disintegrate_fx or band(this.health.last_damage_types, bor(DAMAGE_EAT)) ~= 0 then
				SU.y_enemy_death(store, this)

				return
			end

			S:queue(this.sound_events.death)
			U.y_animation_play(this, "death", nil, store.tick_ts, 1)
			U.animation_start(this, "deadidle", nil, store.tick_ts, true)

			this.enemy.gold = 0
			this.corruption_kr5.enabled = true

			local death_ts = store.tick_ts

			while store.tick_ts - death_ts < this.death_duration and this.corruption_kr5.count < this.corruption_kr5.limit do
				coroutine.yield()
			end

			if store.tick_ts - death_ts >= this.death_duration then
				this.corruption_kr5.enabled = false

				U.y_animation_play(this, "fadeout", nil, store.tick_ts, 1)
				U.animation_start(this, "fadeoutidle", nil, store.tick_ts, true)
				SU.fade_out_entity(store, this, 2, 1, true)

				return
			else
				this.corruption_kr5.enabled = false

				S:queue(this.respawn_sound)
				U.y_animation_play(this, "revive", nil, store.tick_ts, 1)

				this.health.hp = this.health.hp_max * this.respawn_health_factor
				this.health.dead = false
				this.health_bar.hidden = false
				this.corruption_kr5.count = 0

				local achievement_controller = store.entities[this.anim_armor_achievement_controller_id]

				achievement_controller.revived = achievement_controller.revived + 1
			end
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif not SU.y_enemy_mixed_walk_melee_ranged(store, this, false) then
			-- block empty
		else
			coroutine.yield()
		end
	end
end

function scripts.enemy_animated_armor.on_corrupt(this, store, script)
	if not this.corruption_kr5.enabled then
		return
	end

	this.corruption_kr5.count = this.corruption_kr5.count + 1
end

scripts.enemy_revenant_soulcaller = {}

function scripts.enemy_revenant_soulcaller.update(this, store, script)
	local as = this.timed_attacks.list[1]
	local at = this.timed_attacks.list[2]
	local cg = store.count_groups[as.count_group_type]

	this.spawned_specters = 0
	as.ts = store.tick_ts
	at.ts = store.tick_ts

	local function ready_to_summon()
		if as.disabled or store.tick_ts - as.ts < as.cooldown then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal < this.nodes_limit then
			as.disabled = true

			return false
		end

		if not this.enemy.can_do_magic or #this.enemy.blockers > 0 or cg[as.count_group_name] and cg[as.count_group_name] > as.count_group_max then
			SU.delay_attack(store, as, fts(10))

			return false
		end

		return true
	end

	local function ready_to_stun()
		if at.disabled or store.tick_ts - at.ts < at.cooldown then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal < this.nodes_limit then
			at.disabled = true

			return false
		end

		if not this.enemy.can_do_magic or #this.enemy.blockers > 0 then
			SU.delay_attack(store, at, fts(10))

			return false
		end

		return true
	end

	local function break_fn()
		return ready_to_summon() or ready_to_stun()
	end

	::label_127_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_summon() then
				local start_ts = store.tick_ts
				local actual_ni = this.nav_path.ni
				local pi, spi_available = this.nav_path.pi, {
					1,
					2,
					3
				}
				local ni = actual_ni + math.random(this.node_random_min, this.node_random_max)
				local spi = 3
				local npos = P:node_pos(pi, spi, ni + 3)
				local an, af = U.animation_name_facing_point(this, as.animation, npos)

				U.animation_start(this, an, af, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, as.cast_time - fts(10)) then
					goto label_127_0
				end

				as.ts = start_ts

				S:queue(as.sound)

				local e = E:create_entity(as.entity)

				e.nav_path.pi = pi
				e.nav_path.spi = spi
				e.nav_path.ni = ni + 3
				e.pos = V.vclone(npos)

				queue_insert(store, e)

				this.spawned_specters = this.spawned_specters + 1

				if SU.y_enemy_wait(store, this, fts(10)) then
					goto label_127_0
				end

				spi = 2

				local npos = P:node_pos(pi, spi, ni - 2)
				local e = E:create_entity(as.entity)

				e.nav_path.pi = pi
				e.nav_path.spi = spi
				e.nav_path.ni = ni - 2
				e.pos = V.vclone(npos)

				queue_insert(store, e)

				this.spawned_specters = this.spawned_specters + 1

				U.y_animation_wait(this)
			end

			if ready_to_stun() then
				local towers = U.find_towers_in_range(store.entities, this.pos, at, function(t)
					return t.tower.can_be_mod and not SU.has_modifiers(store, t, at.mark_mod) and not t.tower.blocked
				end)

				if not towers or #towers < 1 then
					SU.delay_attack(store, at, fts(10))
				else
					local target = towers[1]
					local start_ts = store.tick_ts
					local an, af, ai = U.animation_name_facing_point(this, at.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					local mod = E:create_entity(at.mark_mod)

					mod.modifier.target_id = target.id
					mod.modifier.source_id = this.id

					queue_insert(store, mod)

					if SU.y_enemy_wait(store, this, at.cast_time) then
						goto label_127_0
					end

					if not towers or #towers < 1 then
						SU.delay_attack(store, at, fts(10))
					else
						local bullet = E:create_entity(at.bullet)

						bullet.pos = V.vclone(this.pos)

						local offset = at.bullet_start_offset[1]

						bullet.pos.x, bullet.pos.y = bullet.pos.x + (af and -1 or 1) * offset.x, bullet.pos.y + offset.y
						bullet.bullet.from = V.vclone(bullet.pos)
						bullet.bullet.to = V.vclone(target.pos)
						bullet.bullet.target_id = target.id
						bullet.bullet.source_id = this.id

						queue_insert(store, bullet)

						at.ts = start_ts

						U.y_animation_wait(this)
					end
				end
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, nil, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.bullet_enemy_revenant_soulcaller_tower_stun = {}

function scripts.bullet_enemy_revenant_soulcaller_tower_stun.update(this, store, script)
	local b = this.bullet
	local mspeed = b.min_speed
	local target, ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if b.target_id then
		S:queue(this.sound_events.travel)
	else
		S:queue(this.sound_events.summon)
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		if b.target_id then
			target = store.entities[b.target_id]
		end

		if target then
			if b.max_track_distance then
				local d = math.max(math.abs(target.pos.x - b.to.x), math.abs(target.pos.y - b.to.y))

				if d > b.max_track_distance then
					b.target_id = nil
					target = nil
				end
			else
				b.to.x, b.to.y = target.pos.x, target.pos.y
			end
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		else
			this.render.sprites[1].flip_x = b.to.x < this.pos.x
		end

		if ps then
			ps.particle_system.emit_direction = this.render.sprites[1].r
		end

		coroutine.yield()
	end

	if target then
		local mod = E:create_entity(b.hit_mod)

		mod.modifier.target_id = target.id
		mod.modifier.source_id = b.source

		queue_insert(store, mod)
	end

	local sfx = E:create_entity(b.hit_fx)

	sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
	sfx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, sfx)
	queue_remove(store, this)
end

scripts.mod_enemy_revenant_soulcaller_branches = {}

function scripts.mod_enemy_revenant_soulcaller_branches.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	SU.tower_block_inc(target)

	this.pos = target.pos

	if this.tween and not this.tween.disabled then
		this.tween.ts = store.tick_ts
	end

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	local start_ts = store.tick_ts

	while store.tick_ts - start_ts < m.duration do
		if this.remove then
			break
		end

		coroutine.yield()
	end

	U.y_animation_play(this, "out", nil, store.tick_ts)
	SU.tower_block_dec(target)
	queue_remove(store, this)
end

scripts.enemy_revenant_harvester = {}

function scripts.enemy_revenant_harvester.update(this, store, script)
	local ac = this.timed_attacks.list[1]
	local cg = store.count_groups[ac.count_group_type]

	ac.ts = store.tick_ts

	if this.cloned then
		SU.y_enemy_animation_wait(this)
	end

	local function ready_to_clone()
		if ac.disabled or store.tick_ts - ac.ts < ac.cooldown then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal < this.nodes_limit then
			ac.disabled = true

			return false
		end

		if not this.enemy.can_do_magic or #this.enemy.blockers > 0 or cg[ac.count_group_name] and cg[ac.count_group_name] >= ac.count_group_max then
			SU.delay_attack(store, ac, fts(10))

			return false
		end

		local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, ac.range, 0, 0, function(e, o)
			return e.template_name == ac.entity and e.nav_path.ni > 8 and not SU.has_modifiers(store, e, ac.mark_mod)
		end)

		if enemies and #enemies > 0 then
			this.specter_target = enemies[1]

			local mod = E:create_entity(ac.mark_mod)

			mod.modifier.target_id = this.specter_target.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)

			return true
		else
			return false
		end
	end

	::label_134_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_clone() then
				local start_ts = store.tick_ts

				S:queue(ac.sound)

				local sp = this.specter_target
				local an, af = U.animation_name_facing_point(this, ac.animation, sp.pos)

				U.animation_start(this, an, af, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, ac.cast_time) then
					goto label_134_0
				end

				ac.ts = start_ts

				U.unblock_all(store, sp)

				sp.motion.max_speed = 0
				sp.render.sprites[1].sort_y_offset = 1

				local e = E:create_entity(this.template_name)

				e.nav_path.pi = sp.nav_path.pi
				e.nav_path.spi = sp.nav_path.spi
				e.nav_path.ni = sp.nav_path.ni
				e.pos = V.vclone(sp.pos)
				e.cloned = true
				e.enemy.gold = 0

				queue_insert(store, e)
				U.animation_start(e, "spawn", sp.render.sprites[1].flip_x, store.tick_ts, false)
				U.y_wait(store, fts(13))
				queue_remove(store, sp)

				this.specter_target = nil

				SU.y_enemy_animation_wait(this)
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, ready_to_clone, nil, ready_to_clone) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_crocs_basic_egg = {}

function scripts.enemy_crocs_basic_egg.update(this, store, script)
	local terrain_type

	if not this.evolve_ts then
		this.evolve_ts = store.tick_ts
	end

	if not this.evolve_cooldown then
		this.evolve_cooldown = math.random(this.evolve_cooldown_min, this.evolve_cooldown_max)
	end

	if this._placed_from_tunnel then
		this._placed_from_tunnel = nil
		this.evolve_cooldown = this.evolve_cooldown + 1.6
	end

	local function ready_to_evolve()
		return terrain_type ~= TERRAIN_WATER and store.tick_ts - this.evolve_ts > this.evolve_cooldown
	end

	local function break_fn()
		return ready_to_evolve()
	end

	if not this.initialized_nav_path and this.nav_path_data then
		this.nav_path.pi = this.nav_path_data[1]
		this.nav_path.spi = this.nav_path_data[2]
		this.nav_path.ni = this.nav_path_data[3]
		this.initialized_nav_path = true
	end

	terrain_type = band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_TYPES_MASK)

	if this.render.sprites[1].name == "raise" and terrain_type ~= TERRAIN_WATER then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if this.water then
			terrain_type = SU.enemy_water_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_evolve() then
				S:queue(this.sound_events.evolve)

				local an, af = U.animation_name_facing_point(this, this.transform_anim, this.motion.dest)

				U.y_animation_play(this, an, af, store.tick_ts, 1)

				local mod = E:create_entity(this.evolve_mod)

				mod.modifier.target_id = this.id

				queue_insert(store, mod)

				goto label_146_0
			end

			SU.y_enemy_walk_until_blocked(store, this, true, break_fn)
		end

		::label_146_0::

		coroutine.yield()
	end
end

scripts.ps_enemy_crocs_water_trail = {}

function scripts.ps_enemy_crocs_water_trail.update(this, store)
	local tid = this.particle_system.track_id
	local owner = store.entities[tid]

	if this.adjust_scale and owner and owner.water_particles_scale_var then
		this.particle_system.scale_var = owner.water_particles_scale_var
	end

	while true do
		owner = store.entities[tid]

		if not owner or owner.health and owner.health.dead then
			break
		end

		local terrain_type = band(GR:cell_type(owner.pos.x, owner.pos.y), TERRAIN_TYPES_MASK)

		this.particle_system.emit = terrain_type == TERRAIN_WATER

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.enemy_crocs_basic = {}

function scripts.enemy_crocs_basic.insert(this, store, script)
	if not scripts.enemy_basic.insert(this, store, scripts) then
		return false
	end

	if this.water_fixed_speed then
		local level_water_speed = this.water_fixed_speed[game.store.level_idx]

		level_water_speed = level_water_speed or 1
		this.water.speed_factor = level_water_speed / this.motion.max_speed
	end

	local e = E:create_entity("ps_enemy_crocs_water_trail")

	e.particle_system.track_id = this.id
	e.particle_system.emit = false

	if this.water_trail_ts_offset then
		e.particle_system.ts_offset = this.water_trail_ts_offset
	end

	queue_insert(store, e)

	local size_names = {
		"small",
		"small",
		"big"
	}
	local e2 = E:create_entity("ps_enemy_crocs_water_bubbles_" .. size_names[this.unit.size])

	e2.particle_system.track_id = this.id
	e2.particle_system.emit = false

	queue_insert(store, e2)

	if this.water_trail_with_bubbles_projectile then
		local e3 = E:create_entity("ps_enemy_crocs_water_bubbles_projectile")

		e3.particle_system.track_id = this.id
		e3.particle_system.emit = false

		if this.water_trail_ts_offset then
			e3.particle_system.ts_offset = this.water_trail_ts_offset
		end

		queue_insert(store, e3)
	end

	return true
end

function scripts.enemy_crocs_basic.update(this, store, script)
	local terrain_type

	local function ready_to_evolve()
		return this.can_evolve_chicken_leg
	end

	local function break_fn()
		return ready_to_evolve()
	end

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if this.water then
			terrain_type = SU.enemy_water_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_evolve() then
				S:queue(this.evolve_sound)

				local an, af = U.animation_name_facing_point(this, this.transform_anim, this.motion.dest)

				U.y_animation_play(this, an, af, store.tick_ts, 1)

				local mod = E:create_entity(this.evolve_mod)

				mod.modifier.target_id = this.id

				queue_insert(store, mod)

				goto label_151_0
			end

			local ignore_soldiers = terrain_type == TERRAIN_WATER
			local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers, break_fn)

			if not ok then
				-- block empty
			elseif not blocker or not SU.y_wait_for_blocker(store, this, blocker) then
				-- block empty
			else
				while SU.can_melee_blocker(store, this, blocker) and (not break_fn or not break_fn(store, this)) do
					if not SU.y_enemy_melee_attacks(store, this, blocker) then
						break
					end

					coroutine.yield()
				end
			end
		end

		::label_151_0::

		coroutine.yield()
	end
end

scripts.enemy_quickfeet_gator = {}

function scripts.enemy_quickfeet_gator.update(this, store, script)
	local a
	local attack_chicken = this.timed_attacks.list[1]

	attack_chicken.ts = store.tick_ts

	local terrain_type

	local function ready_to_chicken()
		local nodes_from_start = P:nodes_from_start(this.nav_path)

		if nodes_from_start < attack_chicken.self_nodes_from_start then
			return false
		end

		return terrain_type ~= TERRAIN_WATER and store.tick_ts - attack_chicken.ts > attack_chicken.cooldown and this.enemy.can_do_magic and not attack_chicken.disabled
	end

	local function break_fn()
		return ready_to_chicken()
	end

	while true do
		if this.water then
			terrain_type = SU.enemy_water_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			a = attack_chicken

			if ready_to_chicken() then
				local enemy, enemies, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.cast_time, a.vis_flags, a.vis_bans, function(e)
					return e ~= this and (a.allowed_templates and table.contains(a.allowed_templates, e.template_name) or not a.allowed_templates) and not SU.has_modifiers(store, e, a.mark_mod)
				end)

				if not enemy then
					SU.delay_attack(store, a, fts(10))
				elseif enemy then
					local e_nodes_from_start = P:nodes_from_start(enemy.nav_path)

					if e_nodes_from_start < attack_chicken.target_nodes_from_start then
						SU.delay_attack(store, a, fts(10))
					else
						local start_ts = store.tick_ts
						local enemy_id = enemy.id
						local distance_percentage = U.dist_factor_inside_ellipse(this.pos, enemy.pos, a.max_range, a.min_range)
						local bullet_flight_time = a.min_flight_time + (a.max_flight_time - a.min_flight_time) * distance_percentage
						local node_prediction_time = a.cast_time + bullet_flight_time + a.node_prediction_base
						local b_template = E:get_template(a.bullet)

						if b_template.bullet.hit_ts_offset then
							node_prediction_time = node_prediction_time - b_template.bullet.hit_ts_offset
						end

						local node_offset = P:predict_enemy_node_advance(enemy, node_prediction_time)
						local e_ni = enemy.nav_path.ni + node_offset

						pred_pos = P:node_pos(enemy.nav_path.pi, enemy.nav_path.spi, e_ni)

						local terrain_pred_pos = band(GR:cell_type(pred_pos.x, pred_pos.y), TERRAIN_TYPES_MASK)

						if terrain_pred_pos == TERRAIN_WATER then
							SU.delay_attack(store, a, fts(10))
						else
							local m_mod = E:create_entity(a.mark_mod)

							m_mod.modifier.target_id = enemy.id
							m_mod.modifier.source_id = this.id

							queue_insert(store, m_mod)

							local an, af = U.animation_name_facing_point(this, a.animation, pred_pos)

							U.animation_start(this, an, af, store.tick_ts, false)

							if SU.y_enemy_wait(store, this, a.cast_time) then
								-- block empty
							else
								S:queue(a.sound)

								local bullet = E:create_entity(a.bullet)

								bullet.bullet.damage_factor = this.unit.damage_factor
								bullet.bullet.source_id = this.id
								bullet.bullet.flight_time = bullet_flight_time
								bullet.bullet.to = V.v(pred_pos.x + enemy.unit.head_offset.x, pred_pos.y + enemy.unit.head_offset.y)
								bullet.bullet.target_id = store.entities[enemy_id] and enemy_id or nil

								local start_offset = a.bullet_start_offset[af and 2 or 1]

								bullet.bullet.from = V.v(this.pos.x + start_offset.x, this.pos.y + start_offset.y)
								bullet.bullet.xp_dest_id = this.id
								bullet.bullet.xp_gain_factor = a.xp_gain_factor
								bullet.pos = V.vclone(bullet.bullet.from)

								queue_insert(store, bullet)

								a.disabled = true
								this.health_bar.offset = a.new_health_bar_offset

								SU.y_enemy_animation_wait(this)

								this.render.sprites[1].prefix = a.new_anim_prefix
								this.ranged.attacks[1].disabled = false
							end
						end
					end
				end
			end

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, break_fn)

			if not cont then
				-- block empty
			elseif blocker then
				if not SU.y_wait_for_blocker(store, this, blocker) then
					-- block empty
				else
					while SU.can_melee_blocker(store, this, blocker) and (not break_fn or not break_fn(store, this)) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							break
						end

						coroutine.yield()
					end
				end
			elseif ranged then
				log.info(terrain_type)

				while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 and (not break_fn or not break_fn(store, this)) do
					if not SU.y_enemy_range_attacks(store, this, ranged) then
						break
					end

					coroutine.yield()
				end
			end
		end

		coroutine.yield()
	end
end

scripts.quickfeet_gator_chicken_leg_bullet = {}

function scripts.quickfeet_gator_chicken_leg_bullet.insert(this, store, script)
	local b = this.bullet

	b.speed = SU.initial_parabola_speed(b.from, b.to, b.flight_time, b.g)
	b.ts = store.tick_ts
	b.last_pos = V.vclone(b.from)

	if b.rotation_speed then
		this.render.sprites[1].r = (math.random() - 0.5) * math.pi
		b.rotation_speed = b.rotation_speed * (b.to.x > b.from.x and -1 or 1)
	end

	return true
end

function scripts.quickfeet_gator_chicken_leg_bullet.update(this, store, script)
	local b = this.bullet
	local has_hit = false

	local function hit()
		if has_hit then
			return
		end

		has_hit = true

		local target = store.entities[this.bullet.target_id]

		if target and not target.health.dead then
			if b.mod or b.mods then
				local mods = b.mods or {
					b.mod
				}

				for _, mod_name in pairs(mods) do
					local m = E:create_entity(mod_name)

					m.modifier.target_id = b.target_id
					m.modifier.level = b.level

					queue_insert(store, m)
				end
			end

			if b.hit_payload then
				local hp = b.hit_payload

				hp.pos.x, hp.pos.y = this.pos.x, this.pos.y

				queue_insert(store, hp)
			end
		end
	end

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y

		local elapsed_ts = store.tick_ts - b.ts

		this.pos.x, this.pos.y = SU.position_in_parabola(elapsed_ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hit_ts_offset and b.flight_time - elapsed_ts < b.hit_ts_offset then
			hit()
		end

		if b.hide_radius_end then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius_end
		end
	end

	hit()

	if b.hit_fx then
		S:queue(this.sound_events.hit)

		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.mod_chicken_leg_polymorph = {}

function scripts.mod_chicken_leg_polymorph.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		if not target.can_evolve_chicken_leg then
			target.can_evolve_chicken_leg = true

			return false
		end

		this.target_ref = target

		for _, s in ipairs(target.render.sprites) do
			s.hidden = true
		end

		SU.remove_modifiers(store, target)
		SU.remove_auras(store, target)
		queue_remove(store, target)
		U.unblock_all(store, target)

		if target.ui then
			target.ui.can_click = false
		end

		target.main_script.co = nil
		target.main_script.runs = 0

		if target.count_group then
			target.count_group.in_limbo = true
		end

		local polymorph_template

		for k, v in pairs(this.entity_t) do
			log.info()

			if target.template_name == v[1] then
				polymorph_template = v[2]

				break
			end
		end

		local entity_poly = E:create_entity(polymorph_template)

		entity_poly.pos = target.pos
		entity_poly.nav_path = target.nav_path

		queue_insert(store, entity_poly)

		entity_poly.enemy.gems = target.enemy.gems
		target.enemy.gems = 0

		return true
	end

	return false
end

scripts.enemy_killertile = {}

function scripts.enemy_killertile.update(this, store, script)
	local terrain_type

	::label_162_0::

	while true do
		if this.water then
			terrain_type = SU.enemy_water_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			local ignore_soldiers = terrain_type == TERRAIN_WATER
			local ok, blocker, _ = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers, break_fn)

			if not ok then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_162_0
					end

					while SU.can_melee_blocker(store, this, blocker) and (not break_fn or not break_fn(store, this)) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_162_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_crocs_flier = {}

function scripts.enemy_crocs_flier.update(this, store, script)
	local shadow_sprite = this.render.sprites[2]
	local terrain_type

	if this.render.sprites[1].name == "raise" then
		local next_pos

		if this.motion.forced_waypoint then
			next_pos = this.motion.forced_waypoint
		else
			next_pos = P:next_entity_node(this, store.tick_length)
		end

		local an, af = U.animation_name_facing_point(this, "raise", next_pos)

		U.y_animation_play(this, an, af, store.tick_ts, 1)
	end

	while true do
		if this.cliff then
			terrain_type = SU.enemy_cliff_change(store, this)
		end

		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			SU.y_enemy_walk_until_blocked(store, this)
		end
	end
end

scripts.enemy_crocs_ranged = {}

function scripts.enemy_crocs_ranged.insert(this, store, script)
	if not scripts.enemy_basic_with_random_range.insert(this, store, scripts) then
		return false
	end

	if this.water_fixed_speed then
		local level_water_speed = this.water_fixed_speed[game.store.level_idx]

		level_water_speed = level_water_speed or 1
		this.water.speed_factor = level_water_speed / this.motion.max_speed
	end

	local e = E:create_entity("ps_enemy_crocs_water_trail")

	e.particle_system.track_id = this.id
	e.particle_system.emit = false

	queue_insert(store, e)

	local size_names = {
		"small",
		"small",
		"big"
	}
	local e2 = E:create_entity("ps_enemy_crocs_water_bubbles_" .. size_names[this.unit.size])

	e2.particle_system.track_id = this.id
	e2.particle_system.emit = false

	queue_insert(store, e2)

	return true
end

function scripts.enemy_crocs_ranged.update(this, store, script)
	local terrain_type

	::label_165_0::

	while true do
		if this.water then
			terrain_type = SU.enemy_water_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			local ignore_soldiers = terrain_type == TERRAIN_WATER
			local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers, break_fn)

			if not ok then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_165_0
					end

					while SU.can_melee_blocker(store, this, blocker) and (not break_fn or not break_fn(store, this)) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_165_0
						end

						coroutine.yield()
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 and (not break_fn or not break_fn(store, this)) do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_165_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_crocs_shaman = {}

function scripts.enemy_crocs_shaman.update(this, store, script)
	local terrain_type, a
	local attack_healing = this.timed_attacks.list[1]
	local attack_debuff = this.timed_attacks.list[2]

	attack_healing.ts = store.tick_ts

	local function ready_to_heal()
		return terrain_type ~= TERRAIN_WATER and store.tick_ts - attack_healing.ts > attack_healing.cooldown and this.enemy.can_do_magic
	end

	local function ready_to_tower_debuff()
		if terrain_type == TERRAIN_WATER then
			return false
		end

		if store.tick_ts - attack_debuff.ts < attack_debuff.cooldown then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal < attack_debuff.nodes_limit then
			return false
		end

		if not this.enemy.can_do_magic or #this.enemy.blockers > 0 then
			SU.delay_attack(store, attack_debuff, fts(10))

			return false
		end

		return true
	end

	local function break_fn()
		return ready_to_heal() or ready_to_tower_debuff()
	end

	::label_166_0::

	while true do
		if this.water then
			terrain_type = SU.enemy_water_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			a = attack_healing

			if ready_to_heal() then
				local enemy, enemies = U.find_nearest_enemy(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans, function(e)
					if e == this then
						return false
					end

					if (not a.allowed_templates or not table.contains(a.allowed_templates, e.template_name)) and not not a.allowed_templates then
						return false
					end

					if not (e.health.hp < e.health.hp_max) then
						return false
					end

					return true
				end)

				if enemies and #enemies >= a.min_targets then
					local start_ts = store.tick_ts

					S:queue(a.sound)
					U.animation_start(this, a.animation, nil, store.tick_ts, false)

					if SU.y_enemy_wait(store, this, a.cast_time) then
						goto label_166_0
					end

					local healed_units = 0

					for _, enemy in pairs(enemies) do
						if not (enemy.health.hp < enemy.health.hp_max) then
							-- block empty
						else
							local mod = E:create_entity(a.mod)

							mod.modifier.target_id = enemy.id
							mod.modifier.source_id = this.id

							queue_insert(store, mod)

							healed_units = healed_units + 1

							if healed_units >= a.max_targets then
								break
							end
						end
					end

					a.ts = start_ts

					SU.y_enemy_animation_wait(this)
				else
					SU.delay_attack(store, a, fts(10))
				end
			end

			a = attack_debuff

			if ready_to_tower_debuff() then
				local towers = SU5.find_towers_in_range_vis(store.entities, this.pos, a, function(t)
					return t.tower.can_be_mod and not t.tower.blocked and not SU.has_modifiers(store, t, a.mod) and not SU.has_modifiers(store, t, a.mark_mod)
				end)

				if not towers or #towers < 1 then
					SU.delay_attack(store, a, fts(10))
				else
					table.sort(towers, function(el, e2)
						return V.dist(el.pos.x, el.pos.y, this.pos.x, this.pos.y) < V.dist(e2.pos.x, e2.pos.y, this.pos.x, this.pos.y)
					end)

					local start_ts = store.tick_ts
					local target = towers[1]
					local mod = E:create_entity(a.mark_mod)

					mod.modifier.target_id = target.id
					mod.modifier.source_id = this.id

					queue_insert(store, mod)

					local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					if SU.y_enemy_wait(store, this, a.cast_time) then
						goto label_166_0
					end

					local mod = E:create_entity(a.mod)

					mod.modifier.target_id = target.id
					mod.modifier.source_id = this.id

					for k, v in pairs(mod.offset_y_per_tower) do
						if string.find(target.template_name, k, 1, true) then
							mod.render.sprites[1].offset.y = mod.render.sprites[1].offset.y + v
						end
					end

					queue_insert(store, mod)

					a.ts = start_ts

					U.y_animation_wait(this)
				end
			end

			local ignore_soldiers = terrain_type == TERRAIN_WATER
			local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers, break_fn)

			if not ok then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_166_0
					end

					while SU.can_melee_blocker(store, this, blocker) and (not break_fn or not break_fn(store, this)) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_166_0
						end

						coroutine.yield()
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 and (not break_fn or not break_fn(store, this)) do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_166_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.mod_crocs_shaman_tower_debuff = {}

function scripts.mod_crocs_shaman_tower_debuff.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or band(this.modifier.vis_flags, target.vis.bans) ~= 0 then
		return false
	end

	local mods_list = U.get_modifiers(store, target, this.remove_mods)

	for _, v in pairs(mods_list) do
		v.remove = true
	end

	return true
end

function scripts.mod_crocs_shaman_tower_debuff.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	SU.tower_block_inc(target)

	this.pos = target.pos

	if this.tween and not this.tween.disabled then
		this.tween.ts = store.tick_ts
		this.tween.props[1].ts = store.tick_ts
	end

	U.y_animation_play(this, "block_tower_in", nil, store.tick_ts)
	U.animation_start(this, "block_tower_loop", nil, store.tick_ts, true)

	local start_ts = store.tick_ts

	while store.tick_ts - start_ts < m.duration do
		if this.remove then
			break
		end

		coroutine.yield()
	end

	U.y_animation_play(this, "block_tower_out", nil, store.tick_ts)
	queue_remove(store, this)
end

function scripts.mod_crocs_shaman_tower_debuff.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		SU.tower_block_dec(target)
	end

	return true
end

scripts.enemy_crocs_tank = {}

function scripts.enemy_crocs_tank.update(this, store, script)
	local a = this.timed_attacks.list[1]

	this.ps_charge_id = nil
	if not this.vis._original_bans then
		this.vis._original_bans = this.vis.bans
	end

	if this._placed_from_tunnel then
		this._placed_from_tunnel = nil
		this.vis.bans = this.vis._original_bans
		this.render.sprites[1].angles.walk = this.original_angles_walk

		if this.ps_charge_id ~= nil then
			store.entities[this.ps_charge_id].particle_system.emit = false
		end

		if this.on_charge then
			this.on_charge = nil
		end
		this.motion.max_speed = this.base_speed
	end

	a.ts = store.tick_ts
	a.hit_targets = {}

	local charge_blocker_delay_ts = store.tick_ts + a.blocker_charge_delay

	local function ready_to_charge()
		return store.tick_ts - a.ts > a.cooldown and store.tick_ts > charge_blocker_delay_ts and P:nodes_to_defend_point(this.nav_path) > a.min_distance_from_end
	end

	local walk_break_fn

	local function melee_break_fn()
		return ready_to_charge()
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_charge() then
				local ni = this.nav_path.ni + 10

				if not this.on_charge and not P:is_node_valid(this.nav_path.pi, ni) then
					log.debug("tank path node invalid: %s,%s", this.nav_path.pi, ni)
					SU.delay_attack(store, a, 2)
				else
					local npos = P:node_pos(this.nav_path.pi, this.nav_path.spi, ni)

					if not this.on_charge then
						S:queue(a.sound)
						U.y_animation_play(this, a.animation_start, nil, store.tick_ts, 1)

						this.render.sprites[1].angles.walk = this.render.sprites[1].angles.charge
						this.elapsed_time = 0
						a.ts = store.tick_ts
						this.motion.max_speed = math.min(this.motion.max_speed * a.speed / this.base_speed, a.speed)
					end

					this.on_charge = true
					this.vis.bans = U.flag_set(this.vis.bans, F_BLOCK)

					local ps

					if not this.ps_charge_id then
						ps = E:create_entity(a.particles_name)
						this.ps_charge_id = ps.id
						ps.particle_system.track_id = this.id

						queue_insert(store, ps)
					else
						ps = store.entities[this.ps_charge_id]
						ps.particle_system.emit = true
					end

					while store.tick_ts - a.ts < a.duration and not this.health.dead do
						local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, a.range, a.vis_flags_soldiers, a.vis_bans_soldiers, function(e)
							return not table.contains(a.hit_targets, e.id)
						end)

						if soldiers then
							for _, e in pairs(soldiers) do
								table.insert(a.hit_targets, e.id)

								local m = E:create_entity(a.mod_soldier)

								m.modifier.target_id = e.id
								m.modifier.source_id = this.id
								m.modifier.ts = store.tick_ts

								queue_insert(store, m)
							end
						end

						SU.y_enemy_walk_step(store, this)

						this.elapsed_time = store.tick_ts - a.ts
					end

					ps.particle_system.emit = false
					this.motion.max_speed = this.motion.max_speed / (a.speed / this.base_speed)
					this.render.sprites[1].angles.walk = this.original_angles_walk

					U.y_animation_play(this, a.animation_end, nil, store.tick_ts, 1)

					this.vis.bans = this.vis._original_bans
					this.on_charge = nil

					goto label_175_0
				end
			end

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, walk_break_fn)

			if not cont then
				-- block empty
			elseif not blocker or not SU.y_wait_for_blocker(store, this, blocker) then
				-- block empty
			else
				charge_blocker_delay_ts = store.tick_ts + a.blocker_charge_delay

				while SU.can_melee_blocker(store, this, blocker) and (not melee_break_fn or not melee_break_fn(store, this)) do
					if not SU.y_enemy_melee_attacks(store, this, blocker) then
						break
					end

					coroutine.yield()
				end
			end
		end

		::label_175_0::

		coroutine.yield()
	end
end

scripts.mod_enemy_crocs_tank_charge_soldier = {}

function scripts.mod_enemy_crocs_tank_charge_soldier.update(this, store, script)
	local cycles, total_damage = 0, 0
	local m = this.modifier
	local dps = this.dps
	local dmin = dps.damage_min + m.level * dps.damage_inc
	local dmax = dps.damage_max + m.level * dps.damage_inc
	local fx_ts = 0

	local function do_damage(target, value)
		total_damage = total_damage + value

		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = dps.damage_type
		d.pop = dps.pop
		d.pop_chance = dps.pop_chance
		d.pop_conds = dps.pop_conds

		queue_damage(store, d)
	end

	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

		if store.tick_ts - m.ts >= m.duration - 1e-09 then
			if dps.damage_last then
				do_damage(target, dps.damage_last)
			end

			break
		end

		if this.render and m.use_mod_offset and target.unit.mod_offset then
			local so = this.render.sprites[1].offset

			so.x, so.y = target.unit.mod_offset.x, target.unit.mod_offset.y
		end

		if dps.damage_every and store.tick_ts - dps.ts >= dps.damage_every then
			cycles = cycles + 1
			dps.ts = dps.ts + dps.damage_every

			local damage_value = math.random(dmin, dmax)

			if cycles == 1 and dps.damage_first then
				damage_value = dps.damage_first
			end

			if not dps.kill then
				damage_value = km.clamp(0, target.health.hp - 1, damage_value)
			end

			do_damage(target, damage_value)

			if dps.fx and (not dps.fx_every or store.tick_ts - fx_ts >= dps.fx_every) then
				fx_ts = store.tick_ts

				local fx = E:create_entity(dps.fx)

				if dps.fx_tracks_target then
					fx.pos = target.pos

					if m.use_mod_offset and target.unit.mod_offset then
						for _, s in pairs(fx.render.sprites) do
							s.offset.x = target.unit.mod_offset.x
							s.offset.y = target.unit.mod_offset.y
						end
					end
				else
					fx.pos = V.vclone(this.pos)

					if m.use_mod_offset and target.unit.mod_offset then
						fx.pos.x, fx.pos.y = fx.pos.x + target.unit.mod_offset.x, fx.pos.y + target.unit.mod_offset.y
					end
				end

				for _, s in pairs(fx.render.sprites) do
					s.ts = store.tick_ts
					s.runs = 0

					if s.size_names then
						s.name = s.size_names[target.unit.size]
					end

					if s.use_blood_color and target.unit.blood_color then
						s.name = s.name .. "_" .. target.unit.blood_color
					end

					if dps.fx_target_flip and target and target.render then
						s.flip_x = target.render.sprites[1].flip_x
					end
				end

				queue_insert(store, fx)
			end
		end

		coroutine.yield()
	end

	log.paranoid(">>>>> id:%s - mod_dps cycles:%s total_damage:%s", this.id, cycles, total_damage)
	queue_remove(store, this)
end

scripts.enemy_crocs_egg_spawner = {}

function scripts.enemy_crocs_egg_spawner.update(this, store, script)
	local a
	local ab = this.melee.attacks[1]
	local as = this.timed_attacks.list[1]

	as.ts = store.tick_ts

	local cg = store.count_groups[as.count_group_type]

	local function ready_to_spawn()
		if terrain_type == TERRAIN_WATER then
			return false
		end

		local node_limit = math.floor(as.min_distance_from_end / P.average_node_dist)
		local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

		return store.tick_ts - as.ts > as.cooldown and store.tick_ts - ab.ts > 3 and node_limit < nodes_to_end and (not cg[as.count_group_name] or cg[as.count_group_name] < as.count_group_max)
	end

	local function break_fn()
		return ready_to_spawn()
	end

	while true do
		if this.water then
			terrain_type = SU.enemy_water_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_spawn() then
				a = as

				local start_ts = store.tick_ts

				this.available_nodes = {}

				local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, a.min_range, a.max_range, TERRAIN_LAND, function(x, y)
					local nearest_node = P:nearest_nodes(x, y, {
						this.nav_path.pi
					}, {
						1,
						2,
						3
					}, true)

					if #nearest_node > 0 then
						return true
					end

					return false
				end, nil, {
					1,
					2,
					3
				})

				nodes = table.random_order(nodes)

				if not nodes then
					SU.delay_attack(store, a, fts(10))
				else
					S:queue(a.sound)

					for j = 1, #nodes do
						local is_far = true

						for k = 1, #this.available_nodes do
							local distance = V.dist(nodes[j].x, nodes[j].y, this.available_nodes[k].pos.x, this.available_nodes[k].pos.y)

							if distance < a.distance_between_entities then
								is_far = false

								break
							end
						end

						if is_far then
							local nearest_node = P:nearest_nodes(nodes[j].x, nodes[j].y, {
								this.nav_path.pi
							}, {
								1,
								2,
								3
							}, true)
							local min_distance = 5

							if #nearest_node > 0 and min_distance > nearest_node[1][4] then
								table.insert(this.available_nodes, {
									pos = nodes[j],
									node = nearest_node[1]
								})

								if #this.available_nodes >= a.entities_amount then
									break
								end
							end
						end
					end

					U.animation_start(this, a.animation, nil, store.tick_ts)
					U.y_wait(store, a.cast_time)
					S:queue(this.sound_events.spawn_cast)

					for i = 1, #this.available_nodes do
						local b = E:create_entity(a.bullet)
						local bullet_start_offset = a.bullet_start_offset

						b.pos.x, b.pos.y = this.pos.x + bullet_start_offset.x, this.pos.y + bullet_start_offset.y
						b.bullet.from = V.vclone(b.pos)
						b.bullet.to = V.vclone(this.available_nodes[i].pos)
						b.bullet.source_id = this.id
						b.nav_path_data = this.available_nodes[i].node

						queue_insert(store, b)
						U.y_wait(store, a.delay_between)
					end

					U.y_animation_wait(this)

					a.ts = start_ts
				end
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.bullet_crocs_egg_spawner_spawn = {}

function scripts.bullet_crocs_egg_spawner_spawn.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius
	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
			hp.nav_path_data = this.nav_path_data
		else
			hp = b.hit_payload
		end

		hp.pos.x, hp.pos.y = b.to.x, b.to.y
		hp.spawn_from_bullet = true

		if hp.aura then
			hp.aura.level = this.bullet.level
		end

		queue_insert(store, hp)
	end

	queue_remove(store, this)
end

scripts.enemy_crocs_hydra = {}

function scripts.enemy_crocs_hydra.on_damage(this, store, damage)
	if not this.transformed_hydra then
		log.debug("  HYDRA ON_DAMAGE: %s", damage.value)

		local pd = U.predict_damage(this, damage)

		if this.health.hp - pd <= 0 then
			this.transform_hydra = true
			this.health.hp = 1
			this.vis.bans = F_ALL
			return false
		end

		return true
	end

	return true
end

function scripts.enemy_crocs_hydra.update(this, store, script)
	local attack_debuff = this.timed_attacks.list[1]
	local attack_transform = this.timed_attacks.list[2]
	local _gold = this.enemy.gold
	this.enemy.gold = 0
	this.vis._bans = this.vis.bans
	local terrain_type = SU.enemy_water_change(store, this)
	
	local function table_get_random_excluding(tbl, exclude)
		local temp_tbl = table.filter(tbl, function(k, v)
			return v ~= exclude
		end)

		return table.random(temp_tbl)
	end

	local function y_enemy_melee_attacks_hydra(store, this, target)
		for _, i in ipairs(this.melee.order) do
			local ma = this.melee.attacks[i]
			local cooldown = ma.cooldown

			if ma.shared_cooldown then
				cooldown = this.melee.cooldown
			end

			if not ma.disabled and cooldown <= store.tick_ts - ma.ts and band(ma.vis_flags, target.vis.bans) == 0 and band(ma.vis_bans, target.vis.flags) == 0 and (not ma.fn_can or ma.fn_can(this, store, ma, target)) then
				ma.ts = store.tick_ts

				if math.random() >= ma.chance then
					-- block empty
				else
					log.paranoid("attack %i selected for entity %s", i, this.template_name)

					for _, aa in pairs(this.melee.attacks) do
						if aa ~= ma and aa.shared_cooldown then
							aa.ts = ma.ts
						end
					end

					ma.ts = store.tick_ts

					S:queue(ma.sound, ma.sound_args)

					local an, af = U.animation_name_facing_point(this, ma.animation, target.pos)

					for i = 1, #this.render.sprites do
						if this.render.sprites[i].animated then
							U.animation_start(this, an, af, store.tick_ts, 1, i)
						end
					end

					local hit_pos = V.vclone(this.pos)

					if ma.hit_offset then
						hit_pos.x = hit_pos.x + (af and -1 or 1) * ma.hit_offset.x
						hit_pos.y = hit_pos.y + ma.hit_offset.y
					end

					local hit_times = ma.hit_times and ma.hit_times or {
						ma.hit_time
					}

					for i = 1, #hit_times do
						local hit_time = hit_times[i]
						local dodged = false

						if ma.dodge_time and target.dodge then
							local dodge_time = ma.dodge_time

							if target.dodge and target.dodge.time_before_hit then
								dodge_time = hit_time - target.dodge.time_before_hit
							end

							while dodge_time > store.tick_ts - ma.ts do
								if this.health.dead or this.unit.is_stunned and not ma.ignore_stun or this.dodge and this.dodge.active and not this.dodge.silent then
									return false
								end

								coroutine.yield()
							end

							dodged = SU.unit_dodges(store, target, false, ma, this)
						end

						while hit_time > store.tick_ts - ma.ts do
							if this.health.dead or this.unit.is_stunned and not ma.ignore_stun or this.dodge and this.dodge.active and not this.dodge.silent then
								return false
							end

							coroutine.yield()
						end

						S:queue(ma.sound_hit, ma.sound_hit_args)

						if ma.retarget_blockers then
							local retarget_id = table_get_random_excluding(this.enemy.blockers, target.id)

							if retarget_id and store.entities[retarget_id] then
								target = store.entities[retarget_id]
							end
						end

						if ma.type == "melee" and not dodged and table.contains(this.enemy.blockers, target.id) then
							local d = E:create_entity("damage")

							d.source_id = this.id
							d.target_id = target.id
							d.track_kills = this.track_kills ~= nil
							d.track_damage = ma.track_damage
							d.pop = ma.pop
							d.pop_chance = ma.pop_chance
							d.pop_conds = ma.pop_conds

							if ma.instakill then
								d.damage_type = DAMAGE_INSTAKILL

								queue_damage(store, d)
							elseif ma.damage_min then
								d.damage_type = ma.damage_type
								d.value = math.ceil(this.unit.damage_factor * math.random(ma.damage_min, ma.damage_max))

								queue_damage(store, d)
							end

							if ma.mod then
								local mod = E:create_entity(ma.mod)

								mod.modifier.target_id = target.id
								mod.modifier.source_id = this.id

								queue_insert(store, mod)
							end
						end

						if ma.hit_fx and (not ma.hit_fx_once or i == 1) then
							local fx = E:create_entity(ma.hit_fx)

							fx.pos = V.vclone(hit_pos)

							if ma.hit_fx_offset then
								fx.pos.x = fx.pos.x + (af and -1 or 1) * ma.hit_fx_offset.x
								fx.pos.y = fx.pos.y + ma.hit_fx_offset.y
							end

							if ma.hit_fx_flip then
								fx.render.sprites[1].flip_x = af
							end

							fx.render.sprites[1].ts = store.tick_ts

							queue_insert(store, fx)
						end

						if ma.hit_decal then
							local fx = E:create_entity(ma.hit_decal)

							fx.pos = V.vclone(hit_pos)
							fx.render.sprites[1].ts = store.tick_ts

							queue_insert(store, fx)
						end
					end

					while not U.animation_finished(this) do
						if this.health.dead or ma.ignore_stun and this.unit.is_stunned or this.dodge and this.dodge.active and not this.dodge.silent then
							return false
						end

						coroutine.yield()
					end

					U.animation_start(this, "idle", nil, store.tick_ts, true)

					return true
				end
			end
		end

		return true
	end

	local function y_enemy_mixed_walk_melee_hydra(store, this, ignore_soldiers, walk_break_fn, melee_break_fn, ranged_break_fn)
		ranged_break_fn = ranged_break_fn or melee_break_fn

		local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers, walk_break_fn)

		if not cont then
			return false
		end

		if blocker then
			if not SU.y_wait_for_blocker(store, this, blocker) then
				return false
			end

			while SU.can_melee_blocker(store, this, blocker) and (not melee_break_fn or not melee_break_fn(store, this)) do
				if not y_enemy_melee_attacks_hydra(store, this, blocker) then
					return false
				end

				coroutine.yield()
			end
		end

		return true
	end

	local function ready_to_special_ability()
		if store.tick_ts - attack_debuff.ts < attack_debuff.cooldown then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if attack_debuff.disabled or terrain_type == TERRAIN_WATER or nodes_to_goal < attack_debuff.nodes_limit then
			SU.delay_attack(store, attack_debuff, fts(10))

			return false
		end

		return true
	end

	local function find_furthest_soldier(entities, origin, min_range, max_range, flags, bans, filter_func)
		local soldiers = U.find_soldiers_in_range(entities, origin, min_range, max_range, flags, bans, filter_func)

		if not soldiers or #soldiers == 0 then
			return nil
		else
			table.sort(soldiers, function(e1, e2)
				return V.dist(e1.pos.x, e1.pos.y, origin.x, origin.y) > V.dist(e2.pos.x, e2.pos.y, origin.x, origin.y)
			end)

			return soldiers[1]
		end
	end

	local function break_fn()
		return ready_to_special_ability() or this.transform_hydra
	end

	::label_187_0::

	while true do
		if this.water then
			local new_terrain_type = band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_TYPES_MASK)

			if new_terrain_type ~= terrain_type then
				local jump_into_water_multiplier = 4
				local jump_out_of_water_multiplier = 5

				if new_terrain_type == TERRAIN_WATER then
					U.animation_start(this, "spawnOut", nil, store.tick_ts, false)
					U.y_wait(store, fts(4))

					while not U.animation_finished(this) do
						local next, new = P:next_entity_node(this, store.tick_length)

						if not next then
							log.debug("enemy %s ran out of nodes to walk", this.id)
							coroutine.yield()

							return false
						end

						U.set_destination(this, next)

						local orig_max_speed = this.motion.max_speed

						this.motion.max_speed = this.motion.max_speed * jump_into_water_multiplier

						U.walk(this, store.tick_length)

						this.motion.max_speed = orig_max_speed

						coroutine.yield()

						this.motion.speed.x, this.motion.speed.y = 0, 0
					end

					terrain_type = SU.enemy_water_change(store, this)
				else
					terrain_type = SU.enemy_water_change(store, this)

					U.animation_start(this, "spawnIn", nil, store.tick_ts, false)

					local start_ts = store.tick_ts

					while store.tick_ts - start_ts < fts(14) do
						local next, new = P:next_entity_node(this, store.tick_length)

						if not next then
							log.debug("enemy %s ran out of nodes to walk", this.id)
							coroutine.yield()

							return false
						end

						U.set_destination(this, next)

						local orig_max_speed = this.motion.max_speed

						this.motion.max_speed = this.motion.max_speed * jump_out_of_water_multiplier

						U.walk(this, store.tick_length)

						this.motion.max_speed = orig_max_speed

						coroutine.yield()

						this.motion.speed.x, this.motion.speed.y = 0, 0
					end

					SU.y_enemy_animation_wait(this)
				end
			end
		end

		if this.transform_hydra then
			S:queue("DeathEplosion")

			local fx = E:create_entity(this.transform_fx)

			fx.pos = V.vclone(this.pos)
			fx.render.sprites[1].ts = store.tick_ts
			fx.tween.ts = store.tick_ts

			queue_insert(store, fx)
			U.y_animation_play(this, attack_transform.animation, nil, store.tick_ts, 1)

			this.render.sprites[1].prefix = attack_transform.new_anim_prefix
			attack_debuff.disabled = false
			attack_debuff.ts = store.tick_ts
			this.melee.attacks[1].hit_times = attack_transform.new_hit_times
			this.health_bar.offset = V.vclone(attack_transform.new_health_bar_offset)
			this.ui.click_rect = attack_transform.new_click_rect
			this.unit.size = attack_transform.new_size
			this.enemy.gold = _gold

			local hp_factor_enemy = GS.difficulty_enemy_hp_max_factor[store.level_difficulty]

			this.health.hp_max = 10 * math.ceil(this.health.hp_max_evolved * hp_factor_enemy / 10)
			this.health.hp = this.health.hp_max
			this.health.dead = false
			this.health_bar.hidden = false
			this.ui.can_click = true
			this.vis.bans = this.vis._bans
			this.transform_hydra = false
			this.transformed_hydra = true
		end

		if this.health.dead then
			local fx = E:create_entity(this.death_fx)

			fx.pos = V.vclone(this.pos)
			fx.render.sprites[1].ts = store.tick_ts
			fx.tween.ts = store.tick_ts

			queue_insert(store, fx)
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_special_ability() then
				local target = find_furthest_soldier(store.entities, this.pos, attack_debuff.min_range, attack_debuff.max_range, attack_debuff.vis_flags, attack_debuff.vis_bans)

				if not target then
					SU.delay_attack(store, attack_debuff, fts(10))
				else
					local start_ts = store.tick_ts
					local target_pos = V.vclone(target.pos)
					local an, af, ai = U.animation_name_facing_point(this, attack_debuff.animation, target_pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					if SU.y_enemy_wait(store, this, attack_debuff.cast_time) then
						goto label_187_0
					end

					local bullet = E:create_entity(attack_debuff.bullet)

					bullet.pos = V.vclone(this.pos)

					local offset = attack_debuff.bullet_start_offset[1]

					bullet.pos.x, bullet.pos.y = bullet.pos.x + (af and -1 or 1) * offset.x, bullet.pos.y + offset.y
					bullet.bullet.from = V.vclone(bullet.pos)
					bullet.bullet.to = V.vclone(target_pos)
					bullet.bullet.target_id = nil
					bullet.bullet.source_id = this.id

					queue_insert(store, bullet)

					for _, v in pairs(attack_debuff.extra_bullets_start_offset) do
						local bullet = E:create_entity(attack_debuff.bullet)

						bullet.pos = V.vclone(this.pos)
						bullet.pos.x, bullet.pos.y = bullet.pos.x + (af and -1 or 1) * v.x, bullet.pos.y + v.y
						bullet.bullet.from = V.vclone(bullet.pos)
						bullet.bullet.to = V.vclone(target_pos)
						bullet.bullet.target_id = nil
						bullet.bullet.source_id = this.id
						bullet.bullet.hit_payload = nil

						queue_insert(store, bullet)
					end

					attack_debuff.ts = start_ts

					U.y_animation_wait(this)
				end
			end

			if not y_enemy_mixed_walk_melee_hydra(store, this, false, break_fn, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_spider_priest = {}

function scripts.enemy_spider_priest.update(this, store, script)
	local last_near_priest_check_cd = 1
	local last_near_priest_check_ts = store.tick_ts - last_near_priest_check_cd

	local function check_transform()
		local health_trigger = not this.health.dead and this.health.hp < this.health.hp_max * this.health_trigger_factor and this.enemy.can_do_magic

		if not health_trigger then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal <= this.transformation_nodes_limit then
			return false
		end

		if store.tick_ts - last_near_priest_check_ts < last_near_priest_check_cd then
			return false
		end

		local near_priest = false
		local dist2 = 1600

		for _, e in pairs(store.entities) do
			if (e.template_name == this.template_name or e.template_name == "enemy_unblinded_abomination") and e.id ~= this.id and not e.health.dead and e.health.hp > 0 and dist2 >= V.dist2(e.pos.x, e.pos.y, this.pos.x, this.pos.y) then
				near_priest = true

				break
			end
		end

		if near_priest then
			last_near_priest_check_ts = store.tick_ts
		end

		return not near_priest
	end

	::label_200_0::

	while true do
		if this.health.dead then
			if not this.old_death_spawns then
				this.death_spawns = nil
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if check_transform() then
				S:queue(this.transformation_sound)
				U.y_animation_play(this, "transform_start", nil, store.tick_ts, 1)
				U.animation_start(this, "transform_loop", nil, store.tick_ts, true)

				if U.y_wait(store, this.transformation_time, function()
					return this.health.dead or this.unit.is_stunned
				end) then
					S:stop(this.transformation_sound)

					goto label_200_0
				end

				S:queue(this.transformation_end_sound)
				U.y_animation_play(this, "transformation", nil, store.tick_ts, 1)

				if this.old_death_spawns then
					this.death_spawns = this.old_death_spawns
				end

				SU.do_death_spawns(store, this)
				signal.emit("wave-notification", "icon", this.death_spawns.name)
				queue_remove(store, this)

				return
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, check_transform, check_transform, check_transform) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_glarenwarden = {}

function scripts.enemy_glarenwarden.update(this, store, script)
	local terrain_type

	::label_203_0::

	while true do
		if this.cliff then
			terrain_type = SU.enemy_cliff_change(store, this)
		end

		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			if terrain_type == TERRAIN_CLIFF then
				SU.remove_modifiers(store, this)

				this.health.hp = 0

				SU.y_enemy_death(store, this)

				return
			else
				U.animation_start(this, "idle", nil, store.tick_ts, -1)
				coroutine.yield()

				goto label_203_0
			end
		end

		local ignore_soldiers = terrain_type == TERRAIN_CLIFF
		local ok, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers)

		if not ok then
			-- block empty
		else
			if blocker then
				if not SU.y_wait_for_blocker(store, this, blocker) then
					goto label_203_0
				end

				while SU.can_melee_blocker(store, this, blocker) do
					if not SU.y_enemy_melee_attacks(store, this, blocker) then
						goto label_203_0
					end

					coroutine.yield()
				end
			elseif ranged then
				while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
					if not SU.y_enemy_range_attacks(store, this, ranged) then
						goto label_203_0
					end

					coroutine.yield()
				end
			end

			coroutine.yield()
		end
	end
end

scripts.glarenwarden_thread_spawner = {}

function scripts.glarenwarden_thread_spawner.insert(this, store, script)
	for i = 1, this.threads_amount do
		this.render.sprites[i + 1].name = table.random(this.threads_idles)
	end

	return true
end

function scripts.glarenwarden_thread_spawner.update(this, store)
	local dest = V.vclone(this.pos)

	this.pos.x, this.pos.y = dest.x, REF_H

	U.animation_start(this, "descending_loop", nil, store.tick_ts, true, 1)
	U.y_ease_key(store, this.pos, "y", REF_H, dest.y, 2, "quad-in")

	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1,
		2,
		3
	}, true)
	local pi, spi, ni = unpack(nodes[1])
	local next_pos, _ = P:next_entity_node(this, store.tick_length)
	local an = "descending_out"
	local af

	if next_pos then
		an, af = U.animation_name_facing_point(this, an, next_pos, 1, nil, true)
	end

	U.y_animation_play(this, an, af, store.tick_ts, 1, 1)

	local e = E:create_entity(this.spawn)

	e.pos = V.vclone(this.pos)
	e.nav_path.pi = pi
	e.nav_path.spi = spi
	e.nav_path.ni = ni

	queue_insert(store, e)
	coroutine.yield()

	if this.spawner.interrupt then
		e.health.hp = 0
	end

	this.render.sprites[1].hidden = true

	for i = 2, #this.render.sprites do
		local s = this.render.sprites[i]

		s.name = "dissolve"
		s.ts = store.tick_ts

		U.y_wait(store, 2 * store.tick_length)
	end

	U.y_wait(store, fts(10))
	queue_remove(store, this)
end

scripts.enemy_ballooning_spider = {}

function scripts.enemy_ballooning_spider.update(this, store)
	local shadow_sprite = this.render.sprites[2]

	if this.render.sprites[1].name == "raise" then
		local next_pos

		if this.motion.forced_waypoint then
			next_pos = this.motion.forced_waypoint
		else
			next_pos = P:next_entity_node(this, store.tick_length)
		end

		local an, af = U.animation_name_facing_point(this, "raise", next_pos)

		U.y_animation_play(this, an, af, store.tick_ts, 1)
	end

	local function easeInOutSine(x)
		return -(math.cos(math.pi * x) - 1) / 2
	end

	local function update_shadow()
		local target_alpha = P:is_node_valid(this.nav_path.pi, this.nav_path.ni, NF_NO_SHADOW) and 255 or 0

		shadow_sprite.alpha = shadow_sprite.alpha + (target_alpha - shadow_sprite.alpha) * 0.05
	end

	local function can_takeoff()
		update_shadow()

		if U.flag_has(this.vis.flags, F_FLYING) then
			return false
		end

		local target = U.find_nearest_soldier(store.entities, this.pos, 0, this.detection_range, this.detection_flags, this.detection_bans)

		if target == nil then
			return false
		end

		return true
	end

	local function set_flying_vars()
		this.health_bar.offset = V.vclone(this.takeoff.health_bar_offset)
		this.render.sprites[1].offset = V.vclone(this.takeoff.sprite_offset)
		this.ui.click_rect = this.takeoff.ui_click_rect
		this.unit.disintegrate_fx = this.takeoff.disintegrate_fx
		this.unit.hit_offset = this.takeoff.hit_offset
		this.unit.mod_offset = this.takeoff.mod_offset
		this.tween.disabled = false
		this.tween.ts = store.tick_ts
		this.render.sprites[1].prefix = this.takeoff.anims_prefix
		this.render.sprites[2].hidden = false
	end

	local function change_motion_speed(speed)
		local current_speed_mult = this.motion.max_speed / this.base_speed

		this.motion.max_speed = speed * current_speed_mult
		this.base_speed = speed
	end

	if U.flag_has(this.vis.flags, F_FLYING) then
		set_flying_vars()
		change_motion_speed(this.takeoff.max_speed)

		if game.store.level_idx == 28 and this.nav_path.pi == 7 then
			this.pos.x = this.pos.x + 80
			this.pos.y = this.pos.y - 80
		end
	end

	::label_206_0::

	while true do
		if this.health.dead then
			shadow_sprite.hidden = true

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if can_takeoff() then
				this.vis.bans = bor(F_BLOCK, F_MOD)

				change_motion_speed(this.takeoff.max_speed)

				local an, af = U.animation_name_facing_point(this, "takeoff", this.motion.dest, 1, nil, true)

				U.animation_start(this, an, af, store.tick_ts, false)

				local anim_finished = false

				this.render.sprites[2].hidden = false

				local oSprOffset = V.vclone(this.render.sprites[1].offset)
				local oHPOffset = V.vclone(this.takeoff.health_bar_offset_mid)
				local oHitOffset = V.vclone(this.unit.hit_offset)
				local oModOffset = V.vclone(this.unit.mod_offset)
				local diffSprOffset = V.v(this.takeoff.sprite_offset.x - oSprOffset.x, this.takeoff.sprite_offset.y - oSprOffset.y)
				local diffHPOffset = V.v(this.takeoff.health_bar_offset.x - oHPOffset.x, this.takeoff.health_bar_offset.y - oHPOffset.y)
				local diffHitOffset = V.v(this.takeoff.hit_offset.x - oHitOffset.x, this.takeoff.hit_offset.y - oHitOffset.y)
				local diffModOffset = V.v(this.takeoff.mod_offset.x - oModOffset.x, this.takeoff.mod_offset.y - oModOffset.y)
				local start_ts = store.tick_ts
				local transition_duration = fts(45)

				while store.tick_ts < start_ts + transition_duration do
					if this.health.dead then
						goto label_206_0
					end

					local next, new = P:next_entity_node(this, store.tick_length)

					if not next then
						log.debug("enemy %s ran out of nodes to walk", this.id)
						coroutine.yield()

						return false
					end

					U.set_destination(this, next)
					U.walk(this, store.tick_length)
					coroutine.yield()

					this.motion.speed.x, this.motion.speed.y = 0, 0

					if not anim_finished and U.animation_finished(this, 1) then
						anim_finished = true
						this.render.sprites[1].prefix = this.render.sprites[1].prefix .. "_air"

						local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest, 1, nil, true)

						U.animation_start(this, an, af, store.tick_ts, true)

						this.vis.flags = U.flag_set(this.vis.flags, F_FLYING)
					end

					local elapsed_time = store.tick_ts - start_ts
					local elapsed_percentage = easeInOutSine(elapsed_time / transition_duration)

					this.render.sprites[1].offset = V.v(oSprOffset.x + diffSprOffset.x * elapsed_percentage, oSprOffset.y + diffSprOffset.y * elapsed_percentage)
					this.unit.hit_offset = V.v(oHitOffset.x + diffHitOffset.x * elapsed_percentage, oHitOffset.y + diffHitOffset.y * elapsed_percentage)
					this.unit.mod_offset = V.v(oModOffset.x + diffModOffset.x * elapsed_percentage, oModOffset.y + diffModOffset.y * elapsed_percentage)

					local hp_transition_start = fts(6)
					local hp_transition_duration = transition_duration - hp_transition_start

					if hp_transition_start < elapsed_time then
						local hp_elapsed_percentage = easeInOutSine((elapsed_time - hp_transition_start) / hp_transition_duration)

						this.health_bar.offset = V.v(oHPOffset.x + diffHPOffset.x * hp_elapsed_percentage, oHPOffset.y + diffHPOffset.y * hp_elapsed_percentage)
					end
				end

				this.vis.bans = bor(F_BLOCK)

				set_flying_vars()
			end

			update_shadow()
			SU.y_enemy_walk_until_blocked(store, this, true, can_takeoff)
			coroutine.yield()
		end
	end
end

scripts.enemy_spider_sister = {}

function scripts.enemy_spider_sister.update(this, store, script)
	local a = this.timed_attacks.list[1]
	local cg = store.count_groups[a.count_group_type]

	this.spawned_nightmares = 0
	a.ts = store.tick_ts

	local function ready_to_crooked_souls()
		if not a.disabled and store.tick_ts - a.ts > a.cooldown then
			local nodes_to_goal = P:nodes_to_goal(this.nav_path)

			if nodes_to_goal < this.nodes_limit then
				a.disabled = true

				return false
			end

			if not this.enemy.can_do_magic then
				SU.delay_attack(store, a, fts(10))

				return false
			end

			if #this.enemy.blockers > 0 then
				SU.delay_attack(store, a, fts(10))

				return false
			end

			if cg[a.count_group_name] and cg[a.count_group_name] > a.count_group_max then
				SU.delay_attack(store, a, fts(10))

				return false
			end

			return true
		end

		return false
	end

	local function break_fn()
		return ready_to_crooked_souls()
	end

	a.ts = store.tick_ts - a.cooldown + a.cooldown_init

	::label_212_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_crooked_souls() then
				if a.cooldown < a.cooldown_max then
					a.cooldown = a.cooldown + a.cooldown_increment
				end

				local start_ts = store.tick_ts

				S:queue(a.sound)

				local actual_ni = this.nav_path.ni
				local pi, spi_available = this.nav_path.pi, {
					1,
					2,
					3
				}
				local ni = actual_ni + math.random(this.node_random_min, this.node_random_max)
				local spi = spi_available[math.random(1, 3)]
				local npos = P:node_pos(pi, spi, ni)
				local an, af = U.animation_name_facing_point(this, a.animation, npos)

				U.animation_start(this, an, af, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, a.cast_time) then
					goto label_212_0
				end

				a.ts = start_ts

				local e = E:create_entity(a.entity)

				e.nav_path.pi = pi
				e.nav_path.spi = spi
				e.nav_path.ni = ni
				e.can_be_converted = true
				e.pos = V.vclone(npos)

				queue_insert(store, e)

				this.spawned_nightmares = this.spawned_nightmares + 1

				signal.emit("wave-notification", "icon", a.entity)
				U.y_animation_wait(this)
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, nil, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_glarebrood_crystal = {}

function scripts.enemy_glarebrood_crystal.update(this, store, script)
	local current_threshold = 0
	local start_ts = store.tick_ts
	local next_pos, _ = P:next_entity_node(this, store.tick_length)
	local an = "in"
	local af

	if next_pos then
		an, af = U.animation_name_facing_point(this, an, next_pos, 1, nil, true)
	end

	U.y_animation_play(this, an, af, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	local function update_sprites()
		local hp_percent = this.health.hp / this.health.hp_max

		if current_threshold < 2 and hp_percent < this.hp_threshold_2[1] then
			U.animation_start(this, this.hp_threshold_2[2], nil, store.tick_ts, true)
		elseif current_threshold < 1 and hp_percent < this.hp_threshold_1[1] then
			U.animation_start(this, this.hp_threshold_1[2], nil, store.tick_ts, true)
		end
	end

	local stun_start_time

	::label_215_0::

	while true do
		if this.health.dead then
			if not this.old_death_spawns then
				this.death_spawns = nil
			end

			SU.y_enemy_death(store, this)

			return
		end

		update_sprites()

		if this.unit.is_stunned then
			stun_start_time = stun_start_time or store.tick_ts

			coroutine.yield()

			goto label_215_0
		elseif stun_start_time then
			this.transform_time = this.transform_time + (store.tick_ts - stun_start_time)
			stun_start_time = nil
		end

		if store.tick_ts - start_ts > this.transform_time then
			this.vis.bans = bor(F_AREA, F_MOD)

			U.y_animation_play(this, this.transform_anim, nil, store.tick_ts)

			if this.old_death_spawns then
				this.death_spawns = this.old_death_spawns
			end

			SU.do_death_spawns(store, this)
			signal.emit("wave-notification", "icon", this.death_spawns.name)
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

scripts.mod_cultbrood_poison = {}

function scripts.mod_cultbrood_poison.update(this, store)
	local m = this.modifier
	local dps = this.dps
	local target
	local source = store.entities[m.source_id]
	local generation = source and source.generation + 1 or 1

	while store.tick_ts - m.ts < m.duration do
		target = store.entities[m.target_id]

		if not target then
			break
		end

		this.pos = target.pos

		if target.health.dead then
			coroutine.yield()
			coroutine.yield()

			if target.hero or not target.health.dead or target.reinforcement and target.reinforcement.hp_before_timeout then
				break
			end

			local nodes = P:nearest_nodes(target.pos.x, target.pos.y, nil, nil, true)

			if not nodes or #nodes == 0 then
				break
			end

			local pi, spi, ni = unpack(nodes[1])
			local nodes_to_goal = P:nodes_to_goal(pi, spi, ni)

			if nodes_to_goal <= this.transformation_nodes_limit then
				break
			end

			U.sprites_hide(target)

			local new_cultbrood = E:create_entity("enemy_cultbrood")

			new_cultbrood.pos = V.vclone(target.pos)
			new_cultbrood.nav_path.pi = pi
			new_cultbrood.nav_path.spi = spi
			new_cultbrood.nav_path.ni = ni
			new_cultbrood.render.sprites[1].name = "raise"
			new_cultbrood.enemy.gold = 0
			new_cultbrood.melee.attacks[2].cooldown_init = new_cultbrood.melee.attacks[2].cooldown

			queue_insert(store, new_cultbrood)

			break
		end

		if store.tick_ts - dps.ts >= dps.damage_every then
			dps.ts = store.tick_ts

			local d = E:create_entity("damage")

			d.source_id = this.id
			d.target_id = target.id
			d.value = dps.damage_max
			d.damage_type = dps.damage_type

			queue_damage(store, d)
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.enemy_cultbrood = {}

function scripts.enemy_cultbrood.update(this, store, script)
	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, "raise_in", af, store.tick_ts, 1)
		U.animation_start(this, "raise", af, store.tick_ts, true, 1, true)
		U.y_wait(store, this.spawn_time)
		U.y_animation_play(this, "raise_out", af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	this.melee.attacks[2].ts = store.tick_ts - this.melee.attacks[2].cooldown + this.melee.attacks[2].cooldown_init

	::label_218_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_218_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_218_0
						end

						coroutine.yield()
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_218_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_drainbrood = {}

function scripts.enemy_drainbrood.update(this, store, script)
	local a = this.timed_attacks.list[1]

	a.ts = store.tick_ts

	local function ready_to_cast()
		if store.tick_ts - a.ts <= a.cooldown then
			return false
		end

		for _, id in pairs(this.enemy.blockers) do
			local target = store.entities[id]

			if target and U.flags_pass(target.vis, a) and not target.unit.is_stunned then
				return true
			end
		end

		return false
	end

	::label_219_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_219_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_219_0
						end

						if ready_to_cast() then
							a.ts = store.tick_ts

							U.animation_start(this, a.animation, nil, store.tick_ts, false)

							if SU.y_enemy_wait(store, this, a.cast_time) then
								goto label_219_0
							end

							local targets_hit = {}

							for _, id in pairs(this.enemy.blockers) do
								local target = store.entities[id]

								if target and U.flags_pass(target.vis, a) and not target.unit.is_stunned and (not target.dodge or not SU.unit_dodges(store, target, false, a, this)) then
									local m = E:create_entity(a.mod)

									m.modifier.source_id = this.id
									m.modifier.target_id = target.id

									queue_insert(store, m)
									table.insert(targets_hit, target)

									if SU.y_enemy_wait(store, this, a.drain_time) then
										goto label_219_0
									end

									local d = E:create_entity("damage")

									d.source_id = this.id
									d.target_id = target.id
									d.damage_type = a.damage_type
									d.value = math.ceil(math.random(a.damage_min, a.damage_max))

									queue_damage(store, d)

									local damage = U.predict_damage(target, d)
									local heal_hp = a.heal_hp_fixed and a.heal_hp_fixed or 0

									if a.heal_hp_damage_factor then
										local heal_hp_damage_factor = a.heal_hp_damage_factor[store.level_difficulty]

										heal_hp = heal_hp + damage * heal_hp_damage_factor
									end

									this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + heal_hp)
								end

								break
							end

							U.y_animation_wait(this)

							a.ts = store.tick_ts

							for _, e in pairs(targets_hit) do
								U.unblock_target(store, e)
							end

							goto label_219_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.mod_drainbrood_web = {}

function scripts.mod_drainbrood_web.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local source = store.entities[this.modifier.source_id]
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos
	start_ts = store.tick_ts

	if m.animation_phases then
		U.animation_start(this, "in", nil, store.tick_ts)

		while not U.animation_finished(this) do
			if not target_hidden and m.hide_target_delay and store.tick_ts - start_ts > m.hide_target_delay then
				target_hidden = true

				if target.ui then
					target.ui.can_click = false
				end

				if target.health_bar then
					target.health_bar.hidden = true
				end

				U.sprites_hide(target, nil, nil, true)
				SU.hide_modifiers(store, target, true, this)
				SU.hide_auras(store, target, true)
			end

			coroutine.yield()
		end
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
		if this.render and m.use_mod_offset and target.unit.mod_offset and not m.custom_offsets then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	if m.animation_phases then
		U.animation_start(this, "death", nil, store.tick_ts)

		if target_hidden then
			if target.ui then
				target.ui.can_click = true
			end

			if target.health_bar and not target.health.dead then
				target.health_bar.hidden = nil
			end

			U.sprites_show(target, nil, nil, true)
			SU.show_modifiers(store, target, true, this)
			SU.show_auras(store, target, true)
		end

		while not U.animation_finished(this) do
			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.enemy_spidead = {}

function scripts.enemy_spidead.update(this, store, script)
	::label_222_0::

	while true do
		if this.health.dead then
			local nodes_to_goal = P:nodes_to_goal(this.nav_path)

			if nodes_to_goal <= this.nodes_to_prevent_web then
				this.enemy.can_do_magic = false
			end

			if not this.enemy.can_do_magic then
				this.death_spawns = nil
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local cont, blocker = SU.y_enemy_walk_until_blocked(store, this, false)

			if not cont then
				-- block empty
			elseif not SU.y_wait_for_blocker(store, this, blocker) then
				-- block empty
			else
				while SU.can_melee_blocker(store, this, blocker) do
					if not SU.y_enemy_melee_attacks(store, this, blocker) then
						goto label_222_0
					end

					coroutine.yield()
				end

				coroutine.yield()
			end
		end
	end
end

scripts.decal_spidead_spiderweb = {}

function scripts.decal_spidead_spiderweb.insert(this, store, script)
	this.tween.ts = store.tick_ts
	this.render.sprites[1].name = this.render.sprites[1].name .. "_000" .. table.random({
		"1",
		"2"
	})
	this.render.sprites[1].scale = V.vv(0.85 + math.random() * 0.15)
	this.render.sprites[1].flip_x = table.random({
		true,
		false
	})

	for _, a in pairs(this.auras.list) do
		a.ts = store.tick_ts

		if a.cooldown == 0 then
			local e = E:create_entity(a.name)

			e.pos = V.vclone(this.pos)
			e.aura.source_id = this.id
			e.aura.ts = store.tick_ts
			e.aura.track_source = true

			queue_insert(store, e)
		end
	end

	return true
end

scripts.boss_spider_queen = {}

function scripts.boss_spider_queen.update(this, store, script)
	local a_stun_towers = this.timed_attacks.list[1]
	local a_webspit = this.timed_attacks.list[2]
	local a_drain_life = this.timed_attacks.list[3]
	local a_call_wardens = this.timed_attacks.list[4]
	local a

	this.fly_time_up = 0.5
	this.fly_time_down = 0.4
	this.fly_time_out = 0.5
	this.fly_offset_y = 60

	local drain_decal_fade_start_ts = store.tick_ts
	local jump_id = 1
	local d_flying = E:create_entity("decal_boss_spider_queen_flying")
	local s_flying = d_flying.render.sprites[1]

	queue_insert(store, d_flying)

	a_webspit.ts = store.tick_ts - (a_webspit.cooldown - a_webspit.first_cooldown)
	a_call_wardens.ts = store.tick_ts - (a_call_wardens.cooldown - a_call_wardens.first_cooldown)

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	local function filter_tower_fn(v, origin, attack)
		return v.vis and band(v.vis.flags, a.vis_bans) == 0 and band(v.vis.bans, a.vis_flags) == 0 and (not a.exclude_tower_kind or not table.contains(a.exclude_tower_kind, v.tower.kind)) and v.tower.can_be_mod
	end

	local function is_after_nodes_limit(attack)
		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		return nodes_to_goal < attack.nodes_limit
	end

	local function can_stun_towers()
		local aa = a_stun_towers

		if is_after_nodes_limit(aa) then
			return false
		end

		return store.tick_ts - aa.ts > aa.cooldown
	end

	local function can_webspitting()
		local aa = a_webspit

		if is_after_nodes_limit(aa) then
			return false
		end

		return store.tick_ts - aa.ts > aa.cooldown
	end

	local function can_call_wardens()
		local aa = a_call_wardens

		if jump_id <= 1 or is_after_nodes_limit(aa) then
			return false
		end

		return store.tick_ts - aa.ts > aa.cooldown
	end

	local function can_drain_life()
		local aa = a_drain_life

		if is_after_nodes_limit(aa) then
			return false
		end

		return store.tick_ts - aa.ts > aa.cooldown
	end

	local function ready_to_jump()
		return jump_id <= #this.reach_nodes and this.nav_path.ni > this.reach_nodes[jump_id]
	end

	local function break_fn()
		return can_stun_towers() or can_webspitting() or can_call_wardens() or can_drain_life() or ready_to_jump()
	end

	local function melee_break_fn()
		return break_fn()
	end

	local function range_break_fn()
		return break_fn()
	end

	local function filter_same_side(towers)
		return table.filter(towers, function(k, v)
			return v.pos.x >= this.pos.x and not this.render.sprites[1].flip_x or v.pos.x < this.pos.x and this.render.sprites[1].flip_x
		end)
	end

	local function y_on_death()
		W:stop_manual_wave("BOSS1")
		LU.kill_all_enemies(store, true)
		S:stop_all()
		S:queue(this.sound_death)
		U.animation_start(this, "death", nil, store.tick_ts, false, 1)
		LU.kill_all_enemies(store, true)
		signal.emit("boss-killed", this)

		store.level.bossfight_ended = true
	end

	local function y_fly(to, speed, dest_pi)
		this.vis.flags = this.vis.flags_jumping
		this.vis.bans = this.vis.bans_jumping

		local from = this.pos

		SU.remove_modifiers(store, this)

		local af = to.x < from.x

		s_flying.r = V.angleTo(to.x - from.x, to.y - from.y)
		s_flying.flip_y = math.abs(s_flying.r) > math.pi / 2

		S:queue(this.sound_jump)

		local an, af = U.animation_name_facing_point(this, "idle", this.motion.dest)

		U.animation_start(this, an, af, store.tick_ts, false, 1)
		U.y_wait(store, 1)
		U.y_animation_play(this, "jump_in", nil, store.tick_ts, 1, 1)
		S:queue("Stage30BossfightJump")

		s_flying.hidden = false

		for _, value in pairs(this.render.sprites) do
			value.hidden = true
		end

		local start_ts = store.tick_ts
		local phase

		repeat
			phase = (store.tick_ts - start_ts) / this.fly_time_up
			d_flying.pos.x = U.ease_value(from.x, from.x, phase, "sine-in")
			d_flying.pos.y = U.ease_value(from.y, 868, phase, "sine-in") + this.fly_offset_y

			coroutine.yield()
		until phase >= 1

		U.y_wait(store, this.fly_time_out)

		start_ts = store.tick_ts

		repeat
			phase = (store.tick_ts - start_ts) / this.fly_time_down
			d_flying.pos.x = U.ease_value(to.x, to.x, phase, "sine-out")
			d_flying.pos.y = U.ease_value(868, to.y + 20, phase, "sine-out") + this.fly_offset_y

			coroutine.yield()
		until phase >= 1

		S:queue(this.sound_land)

		this.pos.x, this.pos.y = to.x, to.y
		s_flying.hidden = true
		this.vis.flags = this.vis.flags_normal
		this.vis.bans = this.vis.bans_normal

		for _, value in pairs(this.render.sprites) do
			value.hidden = false
		end

		S:queue("Stage30BossfightFall")
		U.y_animation_play(this, "jump_out", af, store.tick_ts, 1, 1)

		this.nav_path.pi = dest_pi
		this.nav_path.ni = P:nearest_nodes(this.pos.x, this.pos.y, {
			dest_pi
		})[1][3]

		U.y_wait(store, 1)
	end

	a_drain_life.ts = store.tick_ts - a_drain_life.cooldown + a_drain_life.cooldown_init

	::label_224_0::

	while true do
		if this.health.dead then
			y_on_death()

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_jump() then
				this.ui.can_select = false
				this.health_bar.hidden = true

				local dest = P:node_pos(this.jump_paths[jump_id], 1, this.jump_nodes[jump_id])

				y_fly(dest, 300, this.jump_paths[jump_id])

				if jump_id == 1 then
					a_call_wardens.ts = store.tick_ts - (a_call_wardens.cooldown - a_call_wardens.first_cooldown)
				end

				jump_id = jump_id + 1
				this.health_bar.hidden = false
				this.ui.can_select = true
			end

			a = a_stun_towers

			if can_stun_towers() then
				local towers = U.find_towers_in_range(store.entities, this.pos, a, filter_tower_fn)

				if not towers or #towers < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local towers_to_same_side = filter_same_side(towers)
					local af

					if towers_to_same_side and #towers_to_same_side > 0 then
						towers = towers_to_same_side
					else
						af = not this.render.sprites[1].flip_x
					end

					U.animation_start(this, a.animation_start, af, store.tick_ts, false, 1)

					if SU.y_enemy_wait(store, this, a.shoot_time) then
						SU.delay_attack(store, a, fts(10))
					else
						towers = U.find_towers_in_range(store.entities, this.pos, a, filter_tower_fn)

						if towers then
							if #towers > a.max_targets then
								towers = table.random_order(towers)
								towers = table.slice(towers, 1, a.max_targets)
							end

							for _, t in pairs(towers) do
								local proy_amount = math.random(2, 4)

								for i = 1, proy_amount do
									local bullet = E:create_entity(a.bullet)

									bullet.pos = V.vclone(this.pos)

									local offset = a.bullet_start_offset[1]

									bullet.pos.x, bullet.pos.y = bullet.pos.x + (af and -1 or 1) * offset.x, bullet.pos.y + offset.y
									bullet.pos.x = bullet.pos.x - 8 + 16

									math.random()

									bullet.pos.y = bullet.pos.y - 8 + 16

									math.random()

									bullet.bullet.from = V.vclone(bullet.pos)
									bullet.bullet.to = V.v(t.pos.x - 30 + 15 * i, t.pos.y + 30 - 10 + 20 * math.random())
									bullet.bullet.target_id = t.id
									bullet.bullet.source_id = this.id
									bullet.render.sprites[1].scale = V.vv(bullet.render.sprites[1].scale.x - 0.3 + 0.3 * math.random())
									bullet.bullet.flight_time = bullet.bullet.flight_time + table.random({
										fts(-1),
										fts(0),
										fts(1)
									})

									queue_insert(store, bullet)
								end

								U.y_wait(store, fts(4))
							end
						end

						a.ts = store.tick_ts

						U.y_animation_wait(this, 1)
						U.animation_start(this, "idle", nil, store.tick_ts, true, 1, true)
						U.y_wait(store, 1)
						U.animation_start(this, a.animation_end, nil, store.tick_ts, false, 1, true)
						U.y_wait(store, fts(23))

						local shake = E:create_entity("aura_screen_shake")

						shake.aura.amplitude = 0.4
						shake.aura.duration = fts(30)
						shake.aura.freq_factor = 3

						LU.queue_insert(store, shake)
						U.y_animation_wait(this, 1)

						goto label_224_0
					end
				end
			end

			a = a_webspit

			if can_webspitting() then
				S:queue("Stage30BossfightSpit")
				U.animation_start(this, a.animation, nil, store.tick_ts, false, 1)

				if SU.y_enemy_wait(store, this, a.cast_time) then
					SU.delay_attack(store, a, fts(10))
				else
					local all_decals_pos = {}

					for i = 1, 5 do
						local decal = E:create_entity(a.decal)

						decal.render.sprites[1].name = decal.render.sprites[1].name .. "_000" .. table.random({
							"1",
							"2"
						})
						decal.render.sprites[1].flip_x = table.random({
							true,
							false
						})

						local centerX, centerY = 512, 384
						local offsetX, offsetY = centerX * 1, centerY * 1

						for i = 1, 8 do
							decal.pos = V.v(centerX - offsetX + offsetX * 2 * math.random(), centerY - offsetY + offsetY * 2 * math.random())

							local viable_pos = true

							for _, p in pairs(all_decals_pos) do
								if V.dist(decal.pos.x, decal.pos.y, p.x, p.y) < 170 then
									viable_pos = false

									break
								end
							end

							if viable_pos then
								break
							end
						end

						table.insert(all_decals_pos, V.vclone(decal.pos))

						decal.render.sprites[1].ts = store.tick_ts

						local duration = decal.duration * 0.85 + math.random() * 0.3 * decal.duration
						local alpha_transition = 0.1
						local opacity = 255

						decal.tween.props[1].keys = {
							{
								0,
								0
							},
							{
								alpha_transition,
								opacity
							},
							{
								duration - alpha_transition,
								opacity
							},
							{
								duration,
								0
							}
						}

						local scale_transition = 0.2
						local scaleTotal = U.frandom(2.5, 3.5)

						decal.tween.props[2].keys = {
							{
								0,
								V.vv(scaleTotal * 0.5)
							},
							{
								scale_transition,
								V.vv(scaleTotal * 1.05)
							},
							{
								scale_transition + 0.05,
								V.vv(scaleTotal * 1)
							},
							{
								duration - scale_transition,
								V.vv(scaleTotal * 1)
							},
							{
								duration,
								V.vv(scaleTotal * 0.9)
							}
						}

						queue_insert(store, decal)
					end

					a.ts = store.tick_ts

					if SU.y_enemy_animation_wait(this) then
						-- block empty
					end

					goto label_224_0
				end
			end

			a = a_call_wardens

			if can_call_wardens() then
				U.animation_start(this, a.animation, nil, store.tick_ts, false, 1)

				if SU.y_enemy_wait(store, this, a.cast_time) then
					SU.delay_attack(store, a, fts(10))
				else
					S:queue("Stage30BossfightBuffCharge")

					if a.use_custom_formation then
						local random_formation = table.random(a.custom_formation)

						for _, v in pairs(random_formation) do
							local ni = this.nav_path.ni + v.n

							if P:is_node_valid(this.nav_path.pi, ni) then
								local obj = E:create_entity(a.object)

								obj.pos = P:node_pos(this.nav_path.pi, v.spi, ni)
								obj.render.sprites[1].flip_x = this.render.sprites[1].flip_x
								obj.pi = this.nav_path.pi
								obj.spi = spi
								obj.ni = ni

								queue_insert(store, obj)
							end
						end
					else
						local sign = 1
						local sign_offset = 1
						local nodes_to_goal = P:nodes_to_goal(this.nav_path)

						if nodes_to_goal < a.nodes_limit_reverse then
							sign_offset = -1
						end

						local current_offset = a.nodes_spread_start

						log.todo("CALL WARDENS SIGN %s", tostring(sign_offset))

						for i = 1, a.amount do
							local ni = this.nav_path.ni + a.nodes_offset * sign_offset + current_offset * sign

							if P:is_node_valid(this.nav_path.pi, ni) then
								local spi = math.random(1, 3)
								local obj = E:create_entity(a.object)

								obj.pos = P:node_pos(this.nav_path.pi, spi, ni)
								obj.render.sprites[1].flip_x = this.render.sprites[1].flip_x
								obj.pi = this.nav_path.pi
								obj.spi = spi
								obj.ni = ni

								queue_insert(store, obj)
							end

							if sign == -1 then
								current_offset = current_offset + a.nodes_spread
							end

							sign = -sign
						end
					end

					a.ts = store.tick_ts

					if SU.y_enemy_animation_wait(this) then
						-- block empty
					end

					goto label_224_0
				end
			end

			a = a_drain_life

			if can_drain_life() then
				local soldiers = U.find_soldiers_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

				if not soldiers or #soldiers < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					this.render.sprites[2].hidden = false

					U.animation_start(this, "loop", nil, store.tick_ts, true, 2, true)
					U.animation_start(this, a.animation_start, nil, store.tick_ts, 1, 1)
					U.y_wait(store, fts(25))
					S:queue("Stage30BossfightDrainLoopStart")
					SU.y_enemy_animation_wait(this)
					S:queue("Stage30BossfightDrainLoop")
					U.animation_start(this, a.animation_loop, nil, store.tick_ts, true, 1, true)

					local loop_start_ts = store.tick_ts
					local last_loop_lifesteal_ts = store.tick_ts - a.mod_loop_every

					while store.tick_ts - loop_start_ts < a.loop_duration do
						if SU.enemy_interrupted(this) then
							goto label_224_1
						end

						if store.tick_ts - last_loop_lifesteal_ts > a.mod_loop_every then
							last_loop_lifesteal_ts = store.tick_ts
							soldiers = U.find_soldiers_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

							if soldiers then
								if #soldiers > a.max_targets then
									soldiers = table.random_order(soldiers)
									soldiers = table.slice(soldiers, 1, a.max_targets)
								end

								for _, s in pairs(soldiers) do
									local mod = E:create_entity(a.mod_loop)

									mod.modifier.target_id = s.id
									mod.modifier.source_id = this.id

									queue_insert(store, mod)
								end

								local rs = table.random(soldiers)
								local bullet = E:create_entity(a.bullet)

								bullet.pos = V.vclone(rs.pos)

								if rs.unit and rs.unit.mod_offset then
									bullet.pos.x, bullet.pos.y = bullet.pos.x + rs.unit.mod_offset.x, bullet.pos.y + rs.unit.mod_offset.y
								end

								bullet.bullet.from = V.vclone(bullet.pos)
								bullet.bullet.to = V.v(this.pos.x + (this.render.sprites[1].flip_x and -a.drain_center_offset.x or a.drain_center_offset.x), this.pos.y + a.drain_center_offset.y)
								bullet.bullet.target_id = rs.id
								bullet.bullet.source_id = this.id

								queue_insert(store, bullet)
							end
						end

						coroutine.yield()
					end

					U.animation_start(this, a.animation_end_success, nil, store.tick_ts, false, 1, true)
					U.y_wait(store, fts(14))

					this.drained_health = 0
					soldiers = U.find_soldiers_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

					if soldiers then
						if #soldiers > a.max_targets then
							soldiers = table.random_order(soldiers)
							soldiers = table.slice(soldiers, 1, a.max_targets)
						end

						for _, s in pairs(soldiers) do
							local bullet = E:create_entity(a.bullet)

							bullet.pos = V.vclone(s.pos)

							if s.unit and s.unit.mod_offset then
								bullet.pos.x, bullet.pos.y = bullet.pos.x + s.unit.mod_offset.x, bullet.pos.y + s.unit.mod_offset.y
							end

							bullet.bullet.from = V.vclone(bullet.pos)
							bullet.bullet.to = V.v(this.pos.x + (this.render.sprites[1].flip_x and -a.drain_center_offset.x or a.drain_center_offset.x), this.pos.y + a.drain_center_offset.y)
							bullet.bullet.target_id = s.id
							bullet.bullet.source_id = this.id
							bullet.bullet.hit_fx = nil

							queue_insert(store, bullet)

							local fx_units = E:create_entity(a.fx_end_units)

							fx_units.pos = V.vclone(s.pos)
							fx_units.render.sprites[1].ts = store.tick_ts

							queue_insert(store, fx_units)

							local mod = E:create_entity(a.mod_end)

							mod.modifier.target_id = s.id
							mod.modifier.source_id = this.id

							queue_insert(store, mod)
						end

						this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + this.drained_health)

						S:stop("Stage30BossfightDrainLoop")
						S:queue("Stage30BossfightDrainExecute")
						U.y_animation_play(this, "out", nil, store.tick_ts, 1, 2)

						this.render.sprites[2].hidden = true

						U.y_animation_wait(this, 1)

						goto label_224_2
					end

					::label_224_1::

					S:stop("Stage30BossfightDrainLoop")
					U.animation_start(this, a.animation_end_fail, nil, store.tick_ts, false, 1, true)

					drain_decal_fade_start_ts = store.tick_ts

					while store.tick_ts - drain_decal_fade_start_ts < fts(16) do
						this.render.sprites[2].alpha = this.render.sprites[2].alpha * 0.9

						coroutine.yield()
					end

					this.render.sprites[2].alpha = 255
					this.render.sprites[2].hidden = true

					U.y_animation_wait(this, 1, 1)

					::label_224_2::

					a.ts = store.tick_ts

					goto label_224_0
				end
			end

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, break_fn)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_224_0
					end

					while SU.can_melee_blocker(store, this, blocker) and (not melee_break_fn or not melee_break_fn(store, this)) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_224_0
						end

						coroutine.yield()
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 and (not range_break_fn or not range_break_fn(store, this)) do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_224_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.decal_boss_spider_queen_spawns = {}

function scripts.decal_boss_spider_queen_spawns.update(this, store)
	U.y_animation_play(this, "in", nil, store.tick_ts, 1, 1)
	U.animation_start(this, "idle", nil, store.tick_ts, true, 1)
	U.y_wait(store, fts(14))

	local obj = E:create_entity(this.object)

	obj.pos = V.vclone(this.pos)
	obj.render.sprites[1].flip_x = this.render.sprites[1].flip_x
	obj.nav_path.pi = this.pi
	obj.nav_path.spi = this.spi
	obj.nav_path.ni = this.ni

	queue_insert(store, obj)

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	U.y_animation_play(this, "out", nil, store.tick_ts, 1, 1)
	queue_remove(store, this)
end

scripts.mod_boss_spider_queen_area_lifesteal = {}

function scripts.mod_boss_spider_queen_area_lifesteal.insert(this, store)
	local source = store.entities[this.modifier.source_id]
	local target = store.entities[this.modifier.target_id]
	local damage = 0

	if target and target.health then
		local dmg_value = this.damage

		if this.damage_min then
			local damage_min = SU5.get_difficulty_field_value(store, this.damage_min)
			local damage_max = SU5.get_difficulty_field_value(store, this.damage_max)

			dmg_value = math.random(damage_min, damage_max)
		end

		local d = E:create_entity("damage")

		d.value = dmg_value
		d.source_id = this.id
		d.target_id = target.id
		d.damage_type = this.damage_type

		queue_damage(store, d)

		damage = U.predict_damage(target, d)
	end

	if source then
		local heal_hp = SU5.get_difficulty_field_value(store, this.heal_hp_fixed)

		if this.heal_hp_damage_factor then
			heal_hp = heal_hp + damage * this.heal_hp_damage_factor
		end

		source.drained_health = source.drained_health + heal_hp
	end

	return false
end

scripts.aura_boss_spider_queen_spiderweb = {}

function scripts.aura_boss_spider_queen_spiderweb.update(this, store, script)
	this.aura.ts = store.tick_ts

	local last_pos_created = V.vclone(this.pos)
	local last_ts = store.tick_ts

	while true do
		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead then
				queue_remove(store, this)

				return
			end

			if te and te.pos then
				this.pos.x, this.pos.y = te.pos.x, te.pos.y

				local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {
					te.nav_path.pi
				}, {
					1
				}, false)
				local pi, spi, ni = unpack(nodes[1])
				local n_pos = P:node_pos(pi, spi, ni)

				if V.dist(last_pos_created.x, last_pos_created.y, n_pos.x, n_pos.y) >= this.min_decal_distance or store.tick_ts - last_ts > this.decal_duration - 0.5 then
					local decal = E:create_entity(this.decal)
					local offsetX, offsetY = 6, 6

					decal.pos = V.v(n_pos.x - offsetX + offsetX * 2 * math.random(), n_pos.y - offsetY + offsetY * 2 * math.random())
					decal.render.sprites[1].ts = store.tick_ts

					queue_insert(store, decal)

					last_pos_created = V.vclone(n_pos)
					last_ts = store.tick_ts
				end
			else
				queue_remove(store, this)
			end
		end

		U.y_wait(store, this.aura.cycle_time)
	end
end

scripts.mod_boss_spider_queen_tower_debuff = {}

function scripts.mod_boss_spider_queen_tower_debuff.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or not target.vis or band(this.modifier.vis_flags, target.vis.bans) ~= 0 then
		return false
	end

	if target.tower and target.tower.type and this.tower_type_scales[target.tower.type] then
		this.render.sprites[this.render.sid_mask].scale = V.vclone(this.tower_type_scales[target.tower.type])
	end

	if target.tower and target.tower.type and this.tower_type_offsets[target.tower.type] then
		local curr_offset = V.vclone(this.render.sprites[this.render.sid_mask].offset)
		local add_offset = V.vclone(this.tower_type_offsets[target.tower.type])

		this.render.sprites[this.render.sid_mask].offset = V.v(curr_offset.x + add_offset.x, curr_offset.y + add_offset.y)
	end

	return true
end

function scripts.mod_boss_spider_queen_tower_debuff.update(this, store)
	local clicks = 0
	local s_tap = this.render.sprites[this.render.sid_hand]
	local m = this.modifier
	local duration = SU5.get_difficulty_field_value(store, m.duration)
	local duration_long = SU5.get_difficulty_field_value(store, m.duration_long)
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts
	this.pos = V.vclone(target.pos)

	local click_rect_y = this.ui.click_rect.pos.y + this.pos.y

	if this.tween and not this.tween.disabled then
		this.tween.ts = store.tick_ts
	end

	this.render.sprites[this.render.sid_mask].pos = V.vclone(this.pos)
	s_tap.pos = V.vclone(this.pos)
	this.pos.y = target.pos.y + REF_H

	U.y_animation_play(this, "in", nil, store.tick_ts, 1, this.render.sid_mask)
	U.animation_start(this, "idle_lvl_1", nil, store.tick_ts, true, this.render.sid_mask)

	s_tap.hidden = nil

	SU.tower_block_inc(target)

	local start_ts = store.tick_ts
	local long_block_ts = store.tick_ts

	SU.ui_click_proxy_add(target, this)

	local spiders_appear_delay = fts(40)
	local spiders_arrive_duration = 2
	local dist_to_top = REF_H - target.pos.y + 50 * math.random()
	local ref_speed = REF_H / spiders_arrive_duration

	spiders_arrive_duration = dist_to_top / ref_speed

	local animation_release
	local animation_started = false
	local spiders_arrived = false
	local spiders_netting = false
	local spiders_exit = false
	local phase, mod_hide

	while clicks < this.required_clicks and duration > store.tick_ts - start_ts do
		if store.tick_ts - start_ts > duration - fts(26) and not animation_started then
			U.animation_start(this, "in_2", nil, store.tick_ts, false, this.render.sid_mask, false)

			animation_started = true
		end

		if IS_CONSOLE then
			if target.ui.hover_controller_active then
				s_tap.alpha = s_tap.alpha_focused
				s_tap.name = s_tap.name_focused
			else
				s_tap.alpha = s_tap.alpha_unfocused
				s_tap.name = s_tap.name_unfocused
			end
		end

		phase = (store.tick_ts - (start_ts + spiders_appear_delay)) / spiders_arrive_duration
		this.pos.y = U.ease_value(target.pos.y + dist_to_top, target.pos.y, phase, "sine-in")
		this.ui.click_rect.pos.y = click_rect_y - this.pos.y

		for i = this.render.sid_threads_start, this.render.sid_threads_end do
			this.render.sprites[i].sort_y_offset = target.pos.y - this.pos.y - 5
		end

		for i = this.render.sid_spiders_start, this.render.sid_spiders_end do
			this.render.sprites[i].sort_y_offset = target.pos.y - this.pos.y - 5
		end

		if this.pos.y < target.pos.y + 20 then
			if not spiders_arrived then
				spiders_arrived = true

				U.animation_start_group(this, "arrive", nil, store.tick_ts, false, "spiders")
			elseif not spiders_netting and U.animation_finished_group(this, "spiders") then
				spiders_netting = true

				U.animation_start_group(this, "netting", nil, store.tick_ts, true, "spiders")
			end
		end

		if this.ui.clicked then
			local fx = E:create_entity(this.tap_fx)

			fx.pos = V.v(target.pos.x - 20 + math.random() * 40, target.pos.y - 20 + math.random() * 40 + 30)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
			S:queue(this.sound_click)

			this.ui.clicked = nil
			clicks = clicks + 1

			log.info("clicks: " .. clicks)

			if clicks >= this.required_clicks then
				animation_release = "death_2"

				for i = this.render.sid_spiders_start, this.render.sid_spiders_end do
					this.render.sprites[i].runs = 0
					this.render.sprites[i].hide_after_runs = 1
				end

				U.animation_start_group(this, "explode", nil, store.tick_ts, false, "spiders")

				goto label_243_0
			end
		end

		if this.remove then
			animation_release = "death_2"

			for i = this.render.sid_spiders_start, this.render.sid_spiders_end do
				this.render.sprites[i].runs = 0
				this.render.sprites[i].hide_after_runs = 1
			end

			U.animation_start_group(this, "explode", nil, store.tick_ts, false, "spiders")

			goto label_243_0
		end

		coroutine.yield()
	end

	mod_hide = E:create_entity("mod_hide_tower")
	mod_hide.modifier.target_id = target.id
	mod_hide.modifier.source_id = this.id
	mod_hide.skip_modifiers = {
		this.template_name
	}
	mod_hide.handle_stun = false

	queue_insert(store, mod_hide)
	U.animation_start(this, "idle_lvl_2", nil, store.tick_ts, true, this.render.sid_mask)

	animation_release = "death_1"
	s_tap.hidden = true
	target.ui.can_click = false
	target.tower.blocked = true

	S:queue(this.sound_blocked)
	U.animation_start_group(this, "climbUpStart", nil, store.tick_ts, false, "spiders")

	long_block_ts = store.tick_ts

	while duration_long > store.tick_ts - start_ts do
		if this.remove then
			SU.remove_modifiers(store, target, "mod_hide_tower")

			goto label_243_0
		end

		phase = (store.tick_ts - long_block_ts) / 2
		this.pos.y = U.ease_value(target.pos.y, target.pos.y + REF_H, phase, "sine-out")

		for i = this.render.sid_threads_start, this.render.sid_threads_end do
			this.render.sprites[i].sort_y_offset = target.pos.y - this.pos.y - 5
		end

		for i = this.render.sid_spiders_start, this.render.sid_spiders_end do
			this.render.sprites[i].sort_y_offset = target.pos.y - this.pos.y - 5
		end

		if not spiders_exit and U.animation_finished_group(this, "spiders") then
			spiders_exit = true

			U.animation_start_group(this, "climbingUpIdle", nil, store.tick_ts, true, "spiders")
		end

		coroutine.yield()
	end

	SU.remove_modifiers(store, target, "mod_hide_tower")

	::label_243_0::

	SU.ui_click_proxy_remove(target, this)

	s_tap.hidden = true

	S:queue(this.sound_released)

	this.render.sprites[this.render.sid_mask].runs = 0
	this.render.sprites[this.render.sid_mask].hide_after_runs = 1

	U.animation_start(this, animation_release, nil, store.tick_ts, false, this.render.sid_mask, true)

	local removed_block = false

	for i2 = 1, this.threads_amount do
		for i1 = 1, 3 do
			local sid_thread = this.render.sid_threads_start + this.threads_amount * (i1 - 1) + i2 - 1

			this.render.sprites[sid_thread].runs = 0
			this.render.sprites[sid_thread].hide_after_runs = 1

			U.animation_start(this, "dissolve", nil, store.tick_ts, false, sid_thread, true)
		end

		if not removed_block and (U.animation_finished(this, this.render.sid_mask) or this.render.sprites[this.render.sid_mask].hidden) then
			removed_block = true

			SU.tower_block_dec(target)
		end

		U.y_wait(store, fts(1))
	end

	if not removed_block and (U.animation_finished(this, this.render.sid_mask) or this.render.sprites[this.render.sid_mask].hidden) then
		removed_block = true

		SU.tower_block_dec(target)
	end

	queue_remove(store, this)
end

scripts.bullet_boss_spider_queen_tower_stun = {}

function scripts.bullet_boss_spider_queen_tower_stun.update(this, store, script)
	local b = this.bullet

	if not this.render.sprites[1].scale then
		this.render.sprites[1].scale = V.vv(1)
	end

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id
		ps.particle_system.scales_x[1] = this.render.sprites[1].scale.x
		ps.particle_system.scales_y[1] = this.render.sprites[1].scale.y

		queue_insert(store, ps)
	end

	local ps2

	if b.particles_name_2 then
		ps2 = E:create_entity(b.particles_name_2)
		ps2.particle_system.track_id = this.id
		ps.particle_system.scales_x[1] = this.render.sprites[1].scale.x
		ps.particle_system.scales_y[1] = this.render.sprites[1].scale.y

		queue_insert(store, ps2)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	if b.target_id then
		local target = store.entities[b.target_id]

		if target and b.hit_mod then
			local mod = E:create_entity(b.hit_mod)

			mod.modifier.target_id = target.id
			mod.modifier.source_id = b.source

			queue_insert(store, mod)
		end
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(this.pos)
		sfx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.editor_aura_spider_web_sprint = {}

function scripts.editor_aura_spider_web_sprint.update(this, store)
	while true do
		this.render.sprites[1].scale = V.vv(this.aura.radius / 50)

		coroutine.yield()
	end
end

scripts.decal_boss_spider_queen_spiderweb = {}

function scripts.decal_boss_spider_queen_spiderweb.insert(this, store, script)
	this.render.sprites[1].name = this.render.sprites[1].name .. "_000" .. table.random({
		"1",
		"2"
	})
	this.render.sprites[1].scale = V.vv(0.85 + math.random() * 0.15)
	this.render.sprites[1].flip_x = table.random({
		true,
		false
	})

	for _, a in pairs(this.auras.list) do
		a.ts = store.tick_ts

		if a.cooldown == 0 then
			local e = E:create_entity(a.name)

			e.pos = V.vclone(this.pos)
			e.aura.source_id = this.id
			e.aura.ts = store.tick_ts
			e.aura.track_source = true

			queue_insert(store, e)
		end
	end

	return true
end

scripts.aura_spider_webs = {}

function scripts.aura_spider_webs.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_247_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_247_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_247_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_247_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id) and (not this.aura.ignore_flywalk or not v.on_flywalk)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_247_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.invisible_bullet = {}

function scripts.invisible_bullet.insert(this, store, script)
	local b = this.bullet

	if b.start_fx then
		local fx = E:create_entity(b.start_fx)

		fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
		fx.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	if b.hide_radius then
		this.render.sprites[1].hidden = true
	end

	return true
end

function scripts.invisible_bullet.update(this, store, script)
	local b = this.bullet
	local target = store.entities[b.target_id]
	local target_invalid = false

	if target and target.health and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if b.hit_fx then
			local sfx = E:create_entity(b.hit_fx)

			sfx.pos.x, sfx.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			sfx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, sfx)
		end
	elseif b.miss_fx_water and GR:cell_is(b.to.x, b.to.y, TERRAIN_WATER) then
		local fx = E:create_entity(b.miss_fx_water)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	elseif b.miss_fx then
		local fx = E:create_entity(b.miss_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	queue_remove(store, this)
end

scripts.enemy_darksteel_shielder = {}

function scripts.enemy_darksteel_shielder.update(this, store, script)
	::label_201_0::

	while true do
		if this.health.dead then
			this.health.last_damage_types = band(this.health.last_damage_types, bnot(DAMAGE_FX_EXPLODE))

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_201_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_201_0
						end

						coroutine.yield()
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_201_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_surveillance_sentry = {}

function scripts.enemy_surveillance_sentry.update(this, store, script)
	local terrain_type

	local function check_shadow()
		local terrain_ni

		if this.nav_path.pi == 5 then
			terrain_ni = 45
		elseif this.nav_path.pi == 6 then
			terrain_ni = 40
		elseif this.nav_path.pi == 8 then
			terrain_ni = 125
		elseif this.nav_path.pi == 9 then
			terrain_ni = 115
		end

		if terrain_ni > this.nav_path.ni then
			this.render.sprites[2].hidden = true
		elseif this.render.sprites[2].hidden then
			this.render.sprites[2].hidden = false
			this.tween.disabled = false
			this.tween.ts = store.tick_ts
		end
	end

	local function check_z()
		if this.nav_path.ni < 25 then
			this.render.sprites[1].z = Z_BACKGROUND_BETWEEN
		elseif this.render.sprites[1].z == Z_BACKGROUND_BETWEEN then
			this.render.sprites[1].z = Z_OBJECTS
		end
	end

	local function walk_checks_fn()
		if game.store.level_idx ~= 27 then
			return false
		end

		if this.nav_path.pi ~= 5 and this.nav_path.pi ~= 6 and this.nav_path.pi ~= 8 and this.nav_path.pi ~= 9 then
			return false
		end

		check_shadow()
		check_z()

		return false
	end

	walk_checks_fn()

	if this.render.sprites[1].name == "raise" then
		local next_pos

		if this.motion.forced_waypoint then
			next_pos = this.motion.forced_waypoint
		else
			next_pos = P:next_entity_node(this, store.tick_length)
		end

		local an, af = U.animation_name_facing_point(this, "raise", next_pos)

		U.y_animation_play(this, an, af, store.tick_ts, 1)
	end

	while true do
		if this.health.dead then
			signal.emit("wave-notification", "icon", "enemy_rolling_sentry")
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			SU.y_enemy_walk_until_blocked(store, this, true, walk_checks_fn)
		end
	end
end

scripts.enemy_rolling_sentry = {}

function scripts.enemy_rolling_sentry.update(this, store, script)
	local ra = this.ranged.attacks[1]
	local deploy_mode = false

	U.y_animation_play(this, "spawn", nil, store.tick_ts)

	this.ranged.attacks[1].ts = store.tick_ts - this.ranged.attacks[1].cooldown

	::label_206_0::

	while true do
		if this.health.dead then
			local nodes_to_goal = P:nodes_to_goal(this.nav_path)

			S:queue(this.sound_specter_spawn, {
				delay = 1
			})
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

			if not cont then
				-- block empty
			else
				if blocker then
					if not deploy_mode then
						U.y_animation_play(this, this.melee.attacks[1].animation_in, nil, store.tick_ts)

						deploy_mode = true
					end

					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_206_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						SU.y_enemy_melee_attacks(store, this, blocker)
						coroutine.yield()
					end

					if #this.enemy.blockers == 0 then
						U.y_animation_play(this, this.melee.attacks[1].animation_out, nil, store.tick_ts)

						deploy_mode = false
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
						if not deploy_mode then
							ra.hold_advance = true

							local flip_x = ranged.pos.x - this.pos.x < 0

							U.y_animation_play(this, ra.animation_in, flip_x, store.tick_ts)

							deploy_mode = true
						end

						if not ra.disabled and store.tick_ts - ra.ts >= ra.cooldown and band(ra.vis_flags, ranged.vis.bans) == 0 and band(ra.vis_bans, ranged.vis.flags) == 0 and (not ra.sync_animation or this.render.sprites[1].sync_flag) then
							S:queue(ra.sound)
						end

						SU.y_enemy_range_attacks(store, this, ranged)
						coroutine.yield()
					end

					if deploy_mode then
						U.y_animation_play(this, ra.animation_out, nil, store.tick_ts)

						deploy_mode = false
						ra.ts = store.tick_ts - 0.5
						ra.hold_advance = false
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.enemy_mad_tinkerer = {}

function scripts.enemy_mad_tinkerer.update(this, store, script)
	local ac = this.timed_attacks.list[1]
	local cg = store.count_groups[ac.count_group_type]

	ac.ts = store.tick_ts
	this.spawned_drones = 0

	if this.cloned then
		SU.y_enemy_animation_wait(this)
	end

	local function fix_scrap()
		if ac.disabled or store.tick_ts - ac.ts < ac.cooldown then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal < this.nodes_limit then
			ac.disabled = true

			return false
		end

		if not this.enemy.can_do_magic or #this.enemy.blockers > 0 or cg[ac.count_group_name] and cg[ac.count_group_name] >= ac.count_group_max then
			SU.delay_attack(store, ac, fts(10))

			return false
		end

		local enemies = table.filter(store.entities, function(k, v)
			return not v.pending_removal and v.template_name and v.template_name == ac.entity_search and not v.scrap_selected and U.is_inside_ellipse(v.pos, this.pos, ac.radius) and not U.is_inside_ellipse(v.pos, this.pos, ac.min_range)
		end)

		if enemies and #enemies > 0 then
			this.scrap_target = enemies[1]

			return true
		else
			return false
		end
	end

	::label_207_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if fix_scrap() then
				local start_ts = store.tick_ts

				S:queue(ac.sound)

				local sp = this.scrap_target

				sp.scrap_selected = true
				ac.ts = start_ts

				local an, af = U.animation_name_facing_point(this, ac.animation, sp.pos)

				U.y_animation_play(this, "skill_start", af, store.tick_ts)

				local r = E:create_entity(ac.ray)
				local side = 1

				if af then
					side = -1
				end

				r.pos = V.v(this.pos.x + 10 * side, this.pos.y + 30)
				r.render.sprites[1].r = V.angleTo(r.pos.x - sp.pos.x, r.pos.y - sp.pos.y)

				local dist = V.dist(r.pos.x, r.pos.y, sp.pos.x, sp.pos.y)
				local sx = dist / 100

				r.render.sprites[1].scale = V.v(-sx, 1)
				r.render.sprites[1].ts = store.tick_ts

				queue_insert(store, r)
				U.animation_start(sp, "out", af, store.tick_ts, false)

				local b = E:create_entity(ac.bullet)

				b.pos = V.v(sp.pos.x, sp.pos.y)
				b.render.sprites[1].r = r.render.sprites[1].r
				b.render.sprites[1].scale = V.v(-1, 1)

				local dir = V.v(r.pos.x - sp.pos.x, r.pos.y - sp.pos.y)

				U.y_wait(store, 0.5)
				queue_insert(store, b)

				local speed = 50
				local acceleration = 3
				local regregsion_total = dist / speed
				local regresion_ts = store.tick_ts - 0.5

				U.animation_start(sp, "out_exit", af, store.tick_ts, false)

				while regregsion_total > store.tick_ts - regresion_ts do
					local s = (store.tick_ts - regresion_ts) / regregsion_total

					b.pos.x = dir.x * s + sp.pos.x
					b.pos.y = dir.y * s + sp.pos.y
					regregsion_total = dist / speed
					speed = speed + acceleration
					dist = V.dist(r.pos.x, r.pos.y, b.pos.x, b.pos.y)
					sx = dist / 100
					r.render.sprites[1].scale = V.v(-sx, 1)

					coroutine.yield()
				end

				queue_remove(store, b)
				queue_remove(store, r)
				queue_remove(store, sp)
				S:queue(this.sound_summon)
				U.animation_start(this, "skill_grab_metal", af, store.tick_ts, false)

				if SU.y_enemy_wait(store, this, ac.cast_time) then
					goto label_207_0
				end

				local e = E:create_entity(ac.entity_spawn)

				e.nav_path.pi = this.nav_path.pi
				e.nav_path.spi = this.nav_path.spi
				e.nav_path.ni = this.nav_path.ni + 5
				e.pos = V.vclone(this.pos)
				e.pos.x = e.pos.x + 20 * side
				e.enemy.gold = 0

				queue_insert(store, e)

				this.spawned_drones = this.spawned_drones + 1

				signal.emit("wave-notification", "icon", "enemy_scrap_drone")
				U.y_wait(store, fts(13))

				this.specter_target = nil

				SU.y_enemy_animation_wait(this)
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, fix_scrap, nil, fix_scrap) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.enemy_brute_welder = {}

function scripts.enemy_brute_welder.get_info(this)
	local min, max
	local a = this.melee.attacks[1]
	local aura_t = E:get_template(a.aura)
	local dot_t = E:get_template(aura_t.aura.mod)

	min = dot_t.dps.damage_min * (aura_t.aura.duration + dot_t.modifier.duration) / dot_t.dps.damage_every
	max = dot_t.dps.damage_max * (aura_t.aura.duration + dot_t.modifier.duration) / dot_t.dps.damage_every

	if min and max then
		min, max = math.ceil(min), math.ceil(max)
	end

	local armor = band(this.health.immune_to, DAMAGE_PHYSICAL) ~= 0 and 1 or this.health.armor
	local magic_armor = band(this.health.immune_to, DAMAGE_MAGICAL) ~= 0 and 1 or this.health.magic_armor

	return {
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		damage_icon = this.info.damage_icon,
		armor = armor,
		magic_armor = magic_armor,
		lives = this.enemy and this.enemy.lives_cost or this._original_enemy and this._original_enemy.lives_cost,
		immune = this.health.immune_to == DAMAGE_ALL_TYPES
	}
end

function scripts.enemy_brute_welder.update(this, store, script)
	local a = this.melee.attacks[1]

	::label_211_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_211_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not a.disabled and store.tick_ts - a.ts >= a.cooldown and band(a.vis_flags, blocker.vis.bans) == 0 and band(a.vis_bans, blocker.vis.flags) == 0 then
							a.ts = store.tick_ts

							local an, af = U.animation_name_facing_point(this, a.animation, blocker.pos)

							U.animation_start(this, an, af, store.tick_ts, false)

							while store.tick_ts - a.ts < a.hit_time do
								if this.health.dead or this.unit.is_stunned then
									goto label_211_0
								end

								coroutine.yield()
							end

							S:queue(a.sound_hit)

							local aura = E:create_entity(a.aura)

							aura.pos = V.vclone(this.pos)

							local offset_flip = af and -1 or 1

							aura.pos.x = aura.pos.x + a.aura_offset.x * offset_flip
							aura.pos.y = aura.pos.y + a.aura_offset.y
							aura.aura.source_id = this.id
							aura.aura.ts = store.tick_ts

							queue_insert(store, aura)

							while not U.animation_finished(this) do
								if this.health.dead or this.unit.is_stunned then
									goto label_211_0
								end

								coroutine.yield()
							end

							U.animation_start(this, "idle", nil, store.tick_ts, true)
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.controller_enemy_brute_welder_death = {}

function scripts.controller_enemy_brute_welder_death.update(this, store)
	S:queue(this.sound_shoot)

	local targets = {}
	local target

	for k, v in pairs(store.entities) do
		if v.tower and not v.tower.blocked and v.tower.type ~= "holder" and U.is_inside_ellipse(v.pos, this.pos, this.missile_range) and (not v.vis or band(v.vis.bans, F_STUN) == 0) then
			table.insert(targets, v)
		end
	end

	if #targets == 0 then
		for k, v in pairs(store.entities) do
			if v.tower_holder and not v.tower_holder.blocked and not v.tower.blocked and U.is_inside_ellipse(v.pos, this.pos, this.missile_range) and (not v.vis or band(v.vis.bans, F_STUN) == 0) then
				table.insert(targets, v)
			end
		end
	end

	if #targets == 0 then
		target = this
	else
		target = targets[math.random(1, #targets)]

		if target.tower and target.tower.type ~= "holder" then
			local m = E:create_entity(this.mark_mod)

			m.modifier.target_id = target.id

			queue_insert(store, m)
		end
	end

	local bullet = E:create_entity(this.missile_t)

	bullet.pos = V.vclone(this.pos)
	bullet.pos.x = bullet.pos.x + this.spawn_offset.x * (this.render.sprites[1].flip_x and -1 or 1)
	bullet.pos.y = bullet.pos.y + this.spawn_offset.y
	bullet.bullet.from = V.vclone(bullet.pos)
	bullet.bullet.to = V.vclone(target.pos)
	bullet.bullet.target_id = target.id
	bullet.bullet.source_id = this.id

	queue_insert(store, bullet)

	while bullet do
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.bullet_enemy_brute_welder_death = {}

function scripts.bullet_enemy_brute_welder_death.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local ps

	if not source then
		queue_remove(store, this)

		return
	end

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 8 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	local function fly_to_pos(target_pos)
		local start_ts = store.tick_ts
		local last_pos = V.vclone(this.pos)
		local dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)

		while V.len(dx, dy) > 20 do
			last_pos.x, last_pos.y = this.pos.x, this.pos.y

			move_step(target_pos)

			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
			dist = V.len(dx, dy)

			coroutine.yield()
		end
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local source_pos = V.vclone(source.pos)

	fm.a.x, fm.a.y = 0, 80

	local target_pos = v(source_pos.x, source_pos.y + 130)

	fly_to_pos(target_pos)

	local side_flip = 1

	if target and target.pos.x < source_pos.x then
		side_flip = -1
	end

	fm.a.x, fm.a.y = 100, 0

	local target_pos = v(source_pos.x + 70 * side_flip, source_pos.y + 130)

	fly_to_pos(target_pos)

	target_pos = v(source_pos.x + 35 * side_flip, source_pos.y + 100)

	fly_to_pos(target_pos)

	target_pos = v(source_pos.x, source_pos.y + 130)

	fly_to_pos(target_pos)

	target_pos = v(source_pos.x, source_pos.y + 180)

	fly_to_pos(target_pos)

	if target then
		target_pos = v(target.pos.x, source_pos.y + 180)

		fly_to_pos(target_pos)
	end

	fm.a_step = 5
	fm.max_a = 2700
	fm.max_v = 900
	ps.particle_system.emission_rate = 90

	if not target or not target.tower or target.tower.blocked then
		local targets = {}

		for k, v in ipairs(store.entities) do
			if v.tower and not v.tower.blocked and U.is_inside_ellipse(v.pos, source.pos, this.range) and (not v.vis or band(v.vis.bans, F_STUN) == 0) then
				table.insert(targets, v)
			end
		end

		if #targets >= 1 then
			local new_target = targets[math.random(1, #targets)]

			b.target_id = new_target.id
			b.to = V.vclone(new_target.pos)

			local m = E:create_entity(this.mark_mod)

			m.modifier.target_id = new_target.id

			queue_insert(store, m)
		end
	end

	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	if target then
		local hit_fx = E:create_entity(b.hit_fx)

		hit_fx.pos = V.vclone(b.to)
		hit_fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, hit_fx)

		if (b.mod or b.mods) and target.tower then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.ts = store.tick_ts

				queue_insert(store, m)
			end
		end
	end

	S:queue(this.sound_events.hit)

	this.render.sprites[1].hidden = true

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false
	end

	queue_remove(store, this)
end

scripts.mod_bullet_enemy_brute_welder_death_mark = {}

function scripts.mod_bullet_enemy_brute_welder_death_mark.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target or not target.vis then
		return
	end

	return scripts.mod_mark_flags.queue(this, store, insertion)
end

function scripts.mod_bullet_enemy_brute_welder_death_mark.dequeue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target or not target.vis then
		return
	end

	return scripts.mod_mark_flags.dequeue(this, store, insertion)
end

scripts.mod_bullet_enemy_brute_welder_death_stun = {}

function scripts.mod_bullet_enemy_brute_welder_death_stun.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	local function block_holder()
		local t = target.tower

		t.block_count = t.block_count + 1

		if t.block_count > 0 then
			t.blocked = true

			if target.ui then
				target.ui.can_click = false
			end
		end
	end

	local function unblock_holder()
		local t = target.tower

		t.block_count = 0

		if t.block_count < 1 then
			t.blocked = nil
			t.block_count = 0

			if target.ui then
				target.ui.can_click = true
			end
		end
	end

	m.ts = store.tick_ts

	if target.tower and not target.tower_holder then
		SU.tower_block_inc(target)
	else
		block_holder()
	end

	this.pos = target.pos
	this.tween.ts = store.tick_ts

	U.animation_start(this, "loop", nil, store.tick_ts, true)

	local start_ts = store.tick_ts

	while store.tick_ts - start_ts < m.duration do
		coroutine.yield()
	end

	this.tween.ts = store.tick_ts
	this.tween.reverse = true
	this.tween.remove = true
	this.tween.props[2].disabled = false

	if target.tower and not target.tower_holder then
		SU.tower_block_dec(target)
	else
		unblock_holder()
	end
end

scripts.enemy_scrap_speedster = {}

function scripts.enemy_scrap_speedster.update(this, store, script)
	this.trail = E:create_entity(this.trail_t)
	this.trail.particle_system.track_id = this.id

	queue_insert(store, this.trail)

	local function adjust_trail_offset()
		if this.render.sprites[1].name == "walk" then
			if this.render.sprites[1].flip_x then
				this.trail.particle_system.emit_offset = v(10, 5)
			else
				this.trail.particle_system.emit_offset = v(-10, 5)
			end
		else
			this.trail.particle_system.emit_offset = v(0, 5)
		end
	end

	::label_221_0::

	while true do
		if this.health.dead then
			this.trail.particle_system.emit = false

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			this.trail.particle_system.emit = true

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, nil, adjust_trail_offset)

			if not cont then
				-- block empty
			else
				if blocker then
					this.trail.particle_system.emit = false

					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_221_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_221_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

function scripts.enemy_scrap_speedster.remove(this, store, script)
	if this.trail then
		queue_remove(store, this.trail)
	end

	return true
end

scripts.decal_scrap = {}

function scripts.decal_scrap.update(this, store)
	local start_ts = store.tick_ts

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "idle_loop", nil, store.tick_ts, true)

	while store.tick_ts - start_ts < this.duration or this.scrap_selected do
		coroutine.yield()
	end

	this.scrap_selected = true

	U.y_animation_play(this, "death", nil, store.tick_ts)
	U.animation_start(this, "grave", nil, store.tick_ts, true)
	U.y_wait(store, 3)

	this.tween.ts = store.tick_ts
	this.tween.disabled = false
	this.tween.remove = true
end

scripts.enemy_darksteel_fist = {}

function scripts.enemy_darksteel_fist.update(this, store, script)
	::label_225_0::

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_225_0
					end

					U.y_animation_play(this, "attack_in", nil, store.tick_ts)

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							U.y_animation_play(this, "attck_out", nil, store.tick_ts)

							goto label_225_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.fx_enemy_darksteel_fist_area = {}

function scripts.fx_enemy_darksteel_fist_area.insert(this, store, script)
	this.render.sprites[1].ts = store.tick_ts
	this.render.sprites[2].ts = store.tick_ts

	return true
end

scripts.controller_basic_clone_darksteel_guardian = {}

function scripts.controller_basic_clone_darksteel_guardian.update(this, store, script)
	local function reached_guardian()
		local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

		return nodes_to_end < 2
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if reached_guardian() then
				local guardian

				for k, v in pairs(store.entities) do
					if v.template_name == this.guardian_t and V.dist2(this.pos.x, this.pos.y, v.pos.x, v.pos.y) < 900 then
						guardian = v

						break
					end
				end

				guardian.wake_up = true

				queue_remove(store, this)

				return
			end

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, true, reached_guardian)

			if not cont then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.controller_darksteel_guardian = {}

function scripts.controller_darksteel_guardian.insert(this, store, script)
	local guardian = E:create_entity(this.guardian_t)

	guardian.pos = V.vclone(this.pos)
	guardian.nav_path.pi = this.editor.path
	guardian.nav_path.spi = 1
	guardian.nav_path.ni = 1
	guardian.source_id = this.id
	guardian.render.sprites[1].flip_x = this.editor.flip_x > 0
	guardian.start_asleep = true
	guardian.ignore_seen_tracker = true

	queue_insert(store, guardian)
end

scripts.enemy_darksteel_guardian = {}

function scripts.enemy_darksteel_guardian.update(this, store, script)
	local is_enraged = false
	local rock

	for k, v in pairs(store.entities) do
		if v.template_name == "decal_stage_23_rock" then
			rock = v

			break
		end
	end

	if this.start_asleep then
		this.vis._bans = this.vis.bans
		this.vis.bans = F_ALL
		this.motion._max_speed = this.motion.max_speed
		this.motion.max_speed = 0
		this.ui.can_click = false
		this.health._hp_max = this.health.hp_max
		this.health._immune_to = this.health.immune_to
		this.health.immune_to = DAMAGE_ALL
		this.health_bar.hidden = true

		U.animation_start(this, "idle_1", nil, store.tick_ts)

		while not this.wake_up do
			if store.waves_finished then
				queue_remove(store, this)

				return
			end

			coroutine.yield()
		end

		signal.emit("wave-notification", "icon", "enemy_darksteel_guardian")

		this.health.hp_max = this.health._hp_max

		S:queue(this.sound_activation)
		U.y_animation_play(this, "wake_up", nil, store.tick_ts)

		this.motion.max_speed = this.motion._max_speed
		this.health.dead = false
		this.vis.bans = this.vis._bans
		this.ui.can_click = true
		this.health_bar.hidden = false
		this.health.immune_to = this.health._immune_to
	end

	this.render.sprites[1].angles.idle = {
		"idle_2"
	}

	local function check_rock()
		return rock and V.dist2(this.pos.x, this.pos.y, rock.pos.x, rock.pos.y) < 4900
	end

	local function check_rage()
		return not is_enraged and this.health.hp < this.health.hp_max * this.rage_hp_trigger
	end

	local function break_fn()
		return check_rage() or check_rock()
	end

	local function y_darksteel_guardian_mixed_walk_melee(store, this, ignore_soldiers, walk_break_fn, melee_break_fn)
		local cont, blocker, _ = SU.y_enemy_walk_until_blocked(store, this, ignore_soldiers, walk_break_fn)

		if not cont then
			return false
		end

		if blocker then
			if not SU.y_wait_for_blocker(store, this, blocker) then
				return false
			end

			while SU.can_melee_blocker(store, this, blocker) and (not melee_break_fn or not melee_break_fn(store, this)) do
				if not SU.y_enemy_melee_attacks(store, this, blocker) then
					return false
				end

				local idle = is_enraged and "idle_3" or "idle_2"

				U.animation_start(this, idle, nil, store.tick_ts, true)
				coroutine.yield()
			end
		end

		return true
	end

	local function y_darksteel_guardian_stun(store, this)
		local flip_x = this.motion and this.motion.dest.x < this.pos.x or nil
		local idle = is_enraged and "idle_3" or "idle_2"

		U.animation_start(this, idle, flip_x, store.tick_ts, true)
		coroutine.yield()
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			y_darksteel_guardian_stun(store, this)
		else
			if check_rock() then
				S:queue(this.sound_rock)
				U.animation_start(this, "attack", nil, store.tick_ts)
				U.y_wait(store, this.melee.attacks[1].hit_time)
				U.animation_start(rock, "hit_1", nil, store.tick_ts)
				U.y_animation_wait(this)
				S:queue(this.sound_rock)
				U.animation_start(this, "attack", nil, store.tick_ts)
				U.y_wait(store, this.melee.attacks[1].hit_time)
				U.animation_start(rock, "hit_2", nil, store.tick_ts)
				U.y_animation_wait(this)
				queue_remove(store, rock)

				rock = nil
			end

			if check_rage() then
				S:queue(this.sound_enrage)
				U.y_animation_play(this, "hammer_out", nil, store.tick_ts)

				this.melee.attacks[1].disabled = true
				this.melee.attacks[2].disabled = false
				this.render.sprites[1].angles.idle = {
					"idle_3"
				}
				this.render.sprites[1].angles.walk = {
					"walk_2",
					"walk_front_2",
					"walk_front_2"
				}
				is_enraged = true
			end

			if not y_darksteel_guardian_mixed_walk_melee(store, this, false, break_fn, break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.controller_darksteel_guardian_death = {}

function scripts.controller_darksteel_guardian_death.update(this, store)
	S:queue(this.sound_shoot)

	local dmin = this.explotion_damage_min
	local dmax = this.explotion_damage_max
	local dradius = this.explotion_damage_radius
	local targets = table.filter(store.entities, function(k, v)
		return v.soldier and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.explotion_vis_bans) == 0 and band(v.vis.bans, this.explotion_vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, dradius)
	end)

	for _, enemy in pairs(targets) do
		local d = E:create_entity("damage")

		d.damage_type = this.explotion_damage_type

		local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, this.pos, dradius)

		d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
		d.source_id = this.id
		d.target_id = enemy.id

		queue_damage(store, d)
	end

	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)
	local pi, spi, ni = unpack(nodes[1])
	local nodes_to_end = P:get_end_node(pi) - ni

	if nodes_to_end < this.nodes_range + 5 then
		ni = ni - this.nodes_range
	else
		ni = ni + this.nodes_range
	end

	local target_pos = P:node_pos(pi, 1, ni)
	local bullet = E:create_entity(this.clone_t)

	bullet.pos = V.vclone(this.pos)
	bullet.pos.x = bullet.pos.x + this.spawn_offset.x * (this.render.sprites[1].flip_x and -1 or 1)
	bullet.pos.y = bullet.pos.y + this.spawn_offset.y
	bullet.bullet.from = V.vclone(bullet.pos)
	bullet.bullet.to = V.vclone(target_pos)
	bullet.bullet.source_id = this.id

	queue_insert(store, bullet)
	U.y_wait(store, fts(17))

	local legs = E:create_entity(this.legs_t)

	legs.pos = V.vclone(this.pos)
	legs.render.sprites[1].ts = store.tick_ts
	legs.render.sprites[1].flip_x = this.render.sprites[1].flip_x

	queue_insert(store, legs)
	queue_remove(store, this)
end

scripts.enemy_darksteel_anvil = {}

function scripts.enemy_darksteel_anvil.update(this, store, script)
	local cont, blocker, ranged, a
	local ab = this.timed_attacks.list[1]

	local function ready_to_buff()
		if store.tick_ts - ab.ts < ab.cooldown then
			return false
		end

		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal < ab.nodes_limit_end then
			return false
		end

		local nodes_from_start = P:nodes_from_start(this.nav_path)

		if nodes_from_start < ab.nodes_limit_start then
			return false
		end

		local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, ab.max_range, ab.vis_flags, ab.vis_bans, function(e, o)
			return e.id ~= this.id
		end)

		return enemies and #enemies >= ab.min_targets
	end

	local function break_fn()
		return ready_to_buff()
	end

	if this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise, this.sound_events.raise_args)
		end

		this.health_bar.hidden = true

		local an, af = U.animation_name_facing_point(this, "raise", this.motion.dest)

		U.y_animation_play(this, an, af, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_buff() then
				a = ab

				S:queue(a.sound)
				U.animation_start(this, a.animation_in, nil, store.tick_ts)

				if SU.y_enemy_animation_wait(this) then
					goto label_238_0
				end

				a.ts = store.tick_ts

				U.animation_start(this, a.animation_loop, nil, store.tick_ts, true)

				local aura = E:create_entity(a.aura)

				aura.aura.source_id = this.id
				aura.aura.ts = store.tick_ts
				aura.pos = this.pos

				queue_insert(store, aura)

				if SU.y_enemy_wait(store, this, a.duration) then
					queue_remove(store, aura)

					goto label_238_0
				end

				queue_remove(store, aura)
				U.animation_start(this, a.animation_end, nil, store.tick_ts)

				if SU.y_enemy_animation_wait(this) then
					goto label_238_0
				end
			end

			cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, false, break_fn)

			if not cont then
				-- block empty
			elseif blocker then
				if not SU.y_wait_for_blocker(store, this, blocker) then
					-- block empty
				else
					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							break
						end

						coroutine.yield()
					end
				end
			elseif ranged then
				while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 and not break_fn() do
					if not SU.y_enemy_range_attacks(store, this, ranged) then
						break
					end

					coroutine.yield()
				end
			end
		end

		::label_238_0::

		coroutine.yield()
	end
end

scripts.mod_enemy_darksteel_anvil_buff = {}

function scripts.mod_enemy_darksteel_anvil_buff.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or not target.unit then
		return false
	end

	if not this.target_self and target.template_name == "enemy_darksteel_anvil" then
		return false
	end

	if this.extra_armor then
		SU.armor_inc(target, this.extra_armor)
	end

	target.motion.max_speed = target.motion.max_speed * this.fast.factor

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_enemy_darksteel_anvil_buff.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if target and target.health and target.unit then
		if this.extra_armor then
			SU.armor_dec(target, this.extra_armor)
		end

		target.motion.max_speed = target.motion.max_speed / this.fast.factor
	end

	return true
end

function scripts.mod_enemy_darksteel_anvil_buff.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local start_countdown = false

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end
end

scripts.enemy_darksteel_hulk = {}

function scripts.enemy_darksteel_hulk.update(this, store, script)
	local a = this.timed_attacks.list[1]
	local ps_a, ps_b

	a.ts = store.tick_ts - a.cooldown
	a.hit_targets = {}

	local function ready_to_charge()
		return store.tick_ts - a.ts > a.cooldown and this.health.hp / this.health.hp_max <= a.health_threshold and P:nodes_to_defend_point(this.nav_path) > a.min_distance_from_end
	end

	local function break_fn()
		return a.charge_while_blocked and ready_to_charge()
	end

	while true do
		if this.health.dead then
			if ps_a ~= nil then
				ps_a.particle_system.emit = false
			end

			if ps_b ~= nil then
				ps_b.particle_system.emit = false
			end

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if this._placed_from_tunnel then
				this._placed_from_tunnel = nil

				if ps_a ~= nil then
					ps_a.particle_system.emit = false
				end

				if ps_b ~= nil then
					ps_b.particle_system.emit = false
				end

				this.motion.max_speed = this.base_speed
				this.vis.bans = U.flag_clear(this.vis.bans, F_BLOCK)
			end

			if ready_to_charge() then
				a.ts = store.tick_ts
				this.motion.max_speed = this.motion.max_speed * a.speed_mult
				this.vis.bans = U.flag_set(this.vis.bans, F_BLOCK)
				ps_a = E:create_entity(a.particles_name_a)
				ps_a.particle_system.track_id = this.id

				queue_insert(store, ps_a)

				ps_b = E:create_entity(a.particles_name_b)
				ps_b.particle_system.track_id = this.id

				queue_insert(store, ps_b)
				S:queue(a.sound)
				this.render.sprites[1].angles.walk = this.render.sprites[1].angles.charge

				while not this.health.dead and store.tick_ts - a.ts <= a.unstoppable_duration do
					if a.damage_enemies then
						local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.range, a.vis_flags_enemies, a.vis_bans_enemies, function(e)
							return e.id ~= this.id and not table.contains(a.hit_targets, e.id)
						end)

						if enemies then
							for _, e in pairs(enemies) do
								table.insert(a.hit_targets, e.id)

								local m = E:create_entity(a.mod_enemy)

								m.modifier.target_id = e.id
								m.modifier.source_id = this.id
								m.modifier.ts = store.tick_ts

								queue_insert(store, m)
							end
						end
					end

					if a.damage_soldiers then
						local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, a.range, a.vis_flags_soldiers, a.vis_bans_soldiers, function(e)
							return not table.contains(a.hit_targets, e.id)
						end)

						if soldiers then
							for _, e in pairs(soldiers) do
								table.insert(a.hit_targets, e.id)

								local m = E:create_entity(a.mod_soldier)

								m.modifier.target_id = e.id
								m.modifier.source_id = this.id
								m.modifier.ts = store.tick_ts

								queue_insert(store, m)
							end
						end
					end

					SU.y_enemy_walk_step(store, this, a.animation)

					while this.unit.is_stunned do
						ps_a.particle_system.emit = false
						ps_b.particle_system.emit = false

						SU.y_enemy_stun(store, this)
					end

					ps_a.particle_system.emit = true
					ps_b.particle_system.emit = true
				end

				ps_a.particle_system.emit = false
				ps_b.particle_system.emit = false
				-- this.motion.max_speed = this.motion.max_speed / a.speed_mult
				this.vis.bans = U.flag_clear(this.vis.bans, F_BLOCK)
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, break_fn) then
				if ps_a ~= nil then
					ps_a.particle_system.emit = false
				end
				if ps_b ~= nil then
					ps_b.particle_system.emit = false
				end
			end
		end

		coroutine.yield()
	end
end

function scripts.debug_path_renderer.editor_update(this, store, script)
	log.info("%s - update", this.template_name)

	local visible_coords = {
		top = 868,
		left = -300,
		bottom = -100,
		right = 1324
	}
	local lastPathVersion = 0

	while true do
		while lastPathVersion >= editor.paths_version do
			coroutine.yield()
		end

		lastPathVersion = editor.paths_version

		G.push()

		local path_canvas = G.newCanvas(visible_coords.right - visible_coords.left, visible_coords.top - visible_coords.bottom)
		local cWidth = path_canvas:getWidth()
		local cHeight = path_canvas:getHeight()

		G.setCanvas(path_canvas)

		local backgroundColor = this.path_debug and this.path_debug.background_color or nil
		local pathColor = this.path_debug and this.path_debug.path_color or {
			255,
			255,
			255,
			255
		}

		if backgroundColor then
			G.setColor(backgroundColor[1], backgroundColor[2], backgroundColor[3], backgroundColor[4])
			G.rectangle("fill", 0, 0, cWidth, cHeight)
		end

		G.translate(-visible_coords.left, -visible_coords.bottom)
		G.setColor(pathColor[1], pathColor[2], pathColor[3], pathColor[4])

		for pi, path in ipairs(editor.path_curves) do
			local w1 = path.widths[1] * 2

			for i, bezier in ipairs(path.beziers) do
				G.setLineWidth(w1)
				G.line(bezier:render())
			end
		end

		G.setLineWidth(1)
		G.setColor(255, 255, 255, 255)
		G.setCanvas()
		G.pop()

		local image_data = path_canvas:newImageData()
		local image = G.newImage(image_data)

		if this.generated_image_name then
			I:remove_image(this.generated_image_name)
		end

		local image_name = "generated_path_image" .. store.tick_ts

		this.generated_image_name = image_name

		I:add_image(image_name, image, "temp_game_texts", nil)

		this.render.sprites[1].name = image_name
		this.render.sprites[1].animated = false
		this.render.sprites[1].anchor = v(0, 0)
		this.render.sprites[1].flip_y = true
		this.pos = v(visible_coords.left, visible_coords.top)

		coroutine.yield()
	end
end

scripts.aura_bullet_enemy_crocs_hydra_dot = {}

function scripts.aura_bullet_enemy_crocs_hydra_dot.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "run", nil, store.tick_ts, true)

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_198_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_198_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_198_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_198_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_198_0::

		coroutine.yield()
	end

	U.y_animation_play(this, "out", nil, store.tick_ts)
	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.aura_bullet_boss_crocs_poison_rain_lvl1 = {}

function scripts.aura_bullet_boss_crocs_poison_rain_lvl1.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_200_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_200_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_200_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_200_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_200_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.boss_crocs = {}

function scripts.boss_crocs.update(this, store, script)
	if this.boss_crocs_level == 1 and not this._placed_from_tunnel then
		this.vis.bans = U.flag_set(this.vis.bans, F_RANGED)
		this.vis.bans = U.flag_set(this.vis.bans, F_BLOCK)

		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.render.sprites[1].flip_x = true
		this.health_bar.hidden = true

		U.animation_start(this, "fall", nil, store.tick_ts, 1)
		U.y_wait(store, fts(20))

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.7
		shake.aura.duration = 0.5
		shake.aura.freq_factor = 3

		LU.queue_insert(store, shake)
		U.y_wait(store, fts(46))

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.5
		shake.aura.duration = 1
		shake.aura.freq_factor = 2

		LU.queue_insert(store, shake)

		for _, e in pairs(store.entities) do
			if e.template_name == "tower_stage_22_arborean_mages" then
				e.escape = true
			end
		end

		local rocks_fall_ts = store.tick_ts

		for _, v in pairs(this.rocks_fall_fx) do
			local fx = E:create_entity(v)

			fx.pos = V.vclone(this.rocks_fall_fx_pos)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		end

		local rocks_index = 0

		for _, mask_settings in pairs(this.masks_to_spawn) do
			while store.tick_ts < rocks_fall_ts + mask_settings[2] do
				coroutine.yield()
			end

			rocks_index = rocks_index + 1

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 1.4
			shake.aura.duration = 0.5
			shake.aura.freq_factor = 3

			LU.queue_insert(store, shake)

			for _, e in pairs(store.entities) do
				if e.template_name == mask_settings[1] then
					e.render.sprites[1].hidden = false
				end

				if e.template_name == "tower_stage_22_arborean_mages" then
					queue_remove(store, e)
				end

				if e.template_name == "controller_stage_22_boss_crocs" then
					e.rocks_fall = true
				end

				if rocks_index == 3 and e.template_name == "decal_stage_22_rune_rock" and e.pos.x > 400 and e.pos.x < 600 then
					queue_remove(store, e)
				end
			end

			for _, kill_position in pairs(mask_settings[3]) do
				local soldiers = U.find_soldiers_in_range(store.entities, kill_position[1], 0, kill_position[2], 0, 0)

				if soldiers and #soldiers > 0 then
					for _, sold in pairs(soldiers) do
						local d = E:create_entity("damage")

						d.source_id = this.id
						d.target_id = sold.id
						d.value = 99
						d.damage_type = DAMAGE_INSTAKILL
						d.pop = nil

						queue_damage(store, d)
					end
				end
			end
		end

		for _, e in pairs(store.entities) do
			if e.pos and e.pos.y < 100 and (e.template_name == "decal_defense_flag5" or e.template_name == "decal_defend_point5" or e.template_name == "decal_upgrade_alliance_flux_altering_coils" or e.template_name == "decal_upgrade_alliance_seal_of_punishment") then
				queue_remove(store, e)
			end
		end

		SU.y_enemy_animation_wait(this)
		signal.emit("end-cinematic")

		if not this.health.dead then
			this.vis.bans = U.flag_clear(this.vis.bans, F_RANGED)
			this.vis.bans = U.flag_clear(this.vis.bans, F_BLOCK)
			this.health_bar.hidden = nil
		end
	end

	local a
	local ab = this.melee.attacks[1]
	local as = this.timed_attacks.list[1]

	as.ts = store.tick_ts

	local cg = store.count_groups[as.count_group_type]
	local attack_execute = this.timed_attacks.list[2]
	local attack_towers = this.timed_attacks.list[3]
	local attack_rain = this.timed_attacks.list[4]

	attack_towers.ts = store.tick_ts

	if attack_rain then
		attack_rain.ts = store.tick_ts
	end

	if this.evolution_amount == nil then
		this.evolution_amount = 0
	end

	local orig_scale = V.vclone(this.render.sprites[1].scale)
	local orig_speed = this.motion.max_speed
	local orig_armor = this.health.armor
	local orig_magic_armor = this.health.magic_armor
	local orig_hp_offset = V.vclone(this.health_bar.offset)
	local orig_melee_dmg_min = this.melee.attacks[1].damage_min
	local orig_melee_dmg_max = this.melee.attacks[1].damage_max
	local orig_melee_hp_threshold = attack_execute.hp_threshold
	local orig_melee_slot = this.enemy.melee_slot
	local orig_td_cooldown = attack_towers.cooldown
	local orig_td_max_range = attack_towers.max_range
	local orig_max_crokinders = this.timed_attacks.list[1].entities_amount
	local orig_crokinders_loop_duration = this.timed_attacks.list[1].loop_duration
	local orig_crokinders_cooldown = this.timed_attacks.list[1].cooldown
	local orig_crokinders_min_range = this.timed_attacks.list[1].min_range
	local orig_crokinders_max_range = this.timed_attacks.list[1].max_range
	local orig_rain_cooldown, orig_rain_min_range, orig_rain_max_range, orig_rain_shots

	if attack_rain then
		orig_rain_cooldown = attack_rain.cooldown
		orig_rain_min_range = attack_rain.min_range
		orig_rain_max_range = attack_rain.max_range
		orig_rain_shots = attack_rain.shots_amount
	end

	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_boss

	for _, value in pairs(spawners) do
		if value.load_file == "level22_spawner" then
			megaspawner_boss = value
		end
	end

	local function is_on_valid_node()
		return P:is_node_valid(this.nav_path.pi, this.nav_path.ni)
	end

	local function ready_to_spawn()
		if not is_on_valid_node() then
			return false
		end

		local node_limit = math.floor(as.min_distance_from_end[this.nav_path.pi] / P.average_node_dist)
		local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

		return store.tick_ts - as.ts > as.cooldown and node_limit < nodes_to_end and (not cg[as.count_group_name] or cg[as.count_group_name] < as.count_group_max)
	end

	local function attack_is_tower_valid(v, a)
		-- local is_tower = v.tower and not v.pending_removal and (not a.excluded_templates or not table.contains(a.excluded_templates, v.template_name)) and v.vis and band(v.vis.flags, a.vis_bans) == 0 and band(v.vis.bans, a.vis_flags) == 0 and (not a.exclude_tower_kind or not table.contains(a.exclude_tower_kind, v.tower.kind)) and v.tower.can_be_mod and not U.has_modifiers(store, v, "mod_stage_22_tower_destroyed") and U.is_inside_ellipse(v.pos, this.pos, a.max_range)
		local is_tower = v.tower and not v.pending_removal and (not a.excluded_templates or not table.contains(a.excluded_templates, v.template_name)) and v.vis and band(v.vis.flags, a.vis_bans) == 0 and band(v.vis.bans, a.vis_flags) == 0 and (not a.exclude_tower_kind or not table.contains(a.exclude_tower_kind, v.tower.kind)) and v.tower.can_be_mod and U.is_inside_ellipse(v.pos, this.pos, a.max_range)

		return is_tower
	end

	local function get_towers_to_eat()
		local targets = table.filter(store.entities, function(k, v)
			return attack_is_tower_valid(v, attack_towers)
		end)
		-- local priority_towers

		-- if targets and #targets > 0 then
		-- 	priority_towers = table.filter(targets, function(k, v)
		-- 		return not table.contains(attack_towers.low_priority_holders, v.tower.holder_id)
		-- 	end)
		-- end

		-- if priority_towers and #priority_towers > 0 then
		-- 	return priority_towers
		-- end

		if targets and #targets > 0 then
			return targets
		end

		return nil
	end

	local function get_executable_blocker()
		local executable_blocker = {}

		for _, blocker_id in pairs(this.enemy.blockers) do
			local blocker = store.entities[blocker_id]

			if not blocker then
				-- block empty
			elseif not blocker.health or blocker.health.dead then
				-- block empty
			elseif blocker.health.hp / blocker.health.hp_max > attack_execute.hp_threshold then
				-- block empty
			elseif not blocker.motion.arrived then
				-- block empty
			else
				table.insert(executable_blocker, blocker)
			end
		end

		return executable_blocker
	end

	local function ready_to_execute()
		if ab.disabled then
			return false
		end

		if store.tick_ts - ab.ts < ab.cooldown then
			return false
		end

		if #get_executable_blocker() < 1 then
			return false
		end

		if not is_on_valid_node() then
			return false
		end

		return true
	end

	local function ready_to_eat_tower()
		if store.tick_ts - attack_towers.ts <= attack_towers.cooldown then
			return false
		end

		if not is_on_valid_node() then
			return false
		end

		local towers_to_eat = get_towers_to_eat()

		if not towers_to_eat or #towers_to_eat < 1 then
			return false
		end

		return true
	end

	local function ready_to_evolve()
		local current_percentage = this.health.hp / this.health.hp_max

		if this.evolution_amount < this.eat_tower_evolution and current_percentage > this.life_percentage_evolution then
			return false
		end

		if not this.can_evolve then
			return false
		end

		return true
	end

	local function ready_to_rain()
		if not attack_rain then
			return false
		end

		if store.tick_ts - attack_rain.ts <= attack_rain.cooldown then
			return false
		end

		if not is_on_valid_node() then
			return false
		end

		return true
	end

	local function melee_break_fn()
		if ready_to_spawn() then
			return true
		end

		if ready_to_execute() then
			return true
		end

		if ready_to_evolve() then
			return true
		end

		if ready_to_eat_tower() then
			return true
		end

		if ready_to_rain() then
			return true
		end

		return false
	end

	local function break_fn()
		if this.stomp_passive then
			local a = this.render.sprites[1]

			if a.name == "walk" and (a.frame_idx == 16 or a.frame_idx == 36) then
				local step_fx = E:create_entity(this.stomp_passive.step_fx)

				step_fx.pos = V.vclone(this.pos)
				step_fx.render.sprites[1].ts = store.tick_ts

				if a.frame_idx == 36 then
					step_fx.render.sprites[1].flip_x = true
				end

				queue_insert(store, step_fx)

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 0.3
				shake.aura.duration = 0.5
				shake.aura.freq_factor = 1

				queue_insert(store, shake)

				local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, this.stomp_passive.range, this.stomp_passive.vis_flags_soldiers, this.stomp_passive.vis_bans_soldiers)

				if soldiers then
					for _, soldier in pairs(soldiers) do
						local d = E:create_entity("damage")

						d.damage_type = this.stomp_passive.damage_type
						d.value = U.frandom(this.stomp_passive.damage_min, this.stomp_passive.damage_max)
						d.source_id = this.id
						d.target_id = soldier.id

						queue_damage(store, d)
					end
				end
			end
		end

		if ready_to_spawn() then
			return true
		end

		if ready_to_evolve() then
			return true
		end

		if ready_to_eat_tower() then
			return true
		end

		if ready_to_rain() then
			return true
		end

		return false
	end

	local function shoot_acid(shot_pos)
		local b = E:create_entity(a.bullet)
		local offset_x = a.bullet_start_offset.x

		if not this.render.sprites[1].flip_x then
			offset_x = -a.bullet_start_offset.x
		end

		b.pos.x, b.pos.y = this.pos.x + offset_x, this.pos.y + a.bullet_start_offset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = shot_pos
		b.bullet.source_id = this.id

		queue_insert(store, b)
	end

	local function y_on_death()
		LU.kill_all_enemies(store, true)
		S:stop_all()

		megaspawner_boss.interrupt = true

		S:queue(this.sound_death)
		U.animation_start(this, "death", nil, store.tick_ts, false)
		U.y_animation_wait(this)
		LU.kill_all_enemies(store, true)
		signal.emit("boss-killed", this)
		U.y_wait(store, 1)

		store.level.bossfight_ended = true
	end

	if this.boss_crocs_level == 1 then
		signal.emit("show-gui")
		signal.emit("boss_fight_start_tweened", this, 0.3)

		megaspawner_boss.manual_wave = "BOSS"

		for _, e in pairs(store.entities) do
			if e.template_name == "decal_stage_22_remolino" then
				e.start_wave_boss = true

				break
			end
		end
	else
		signal.emit("boss_fight_start", this)
	end

	::label_203_0::

	while true do
		if this.health.dead then
			y_on_death()

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if ready_to_execute() then
				local start_ts = store.tick_ts
				local blockers = get_executable_blocker()
				local an, af = U.animation_name_facing_point(this, attack_execute.animation, blockers[1].pos)

				for i = 1, #this.render.sprites do
					if this.render.sprites[i].animated then
						U.animation_start(this, an, af, store.tick_ts, 1, i)
					end
				end

				while store.tick_ts - start_ts < attack_execute.hit_time do
					if this.health.dead or this.unit.is_stunned and not attack_execute.ignore_stun or this.dodge and this.dodge.active and not this.dodge.silent then
						goto label_203_0
					end

					coroutine.yield()
				end

				S:queue(this.melee.attacks[1].sound_instakill)

				blockers = get_executable_blocker()

				for _, block in pairs(blockers) do
					local d = E:create_entity("damage")

					d.source_id = this.id
					d.target_id = block.id
					d.track_kills = this.track_kills ~= nil
					d.track_damage = attack_execute.track_damage
					d.pop = attack_execute.pop
					d.pop_chance = attack_execute.pop_chance
					d.pop_conds = attack_execute.pop_conds
					d.damage_type = attack_execute.damage_type

					queue_damage(store, d)

					if not attack_execute.instakill_all_blockers then
						break
					end
				end

				SU.y_enemy_wait(store, this, attack_execute.action_time_eat - attack_execute.hit_time)

				local hit_pos = V.vclone(this.pos)

				if attack_execute.hit_offset then
					hit_pos.x = hit_pos.x + (af and -1 or 1) * attack_execute.hit_offset.x
					hit_pos.y = hit_pos.y + attack_execute.hit_offset.y
				end

				if attack_execute.hit_decal then
					local fx = E:create_entity(attack_execute.hit_decal)

					fx.pos = V.vclone(hit_pos)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end

				while not U.animation_finished(this) do
					if this.health.dead or attack_execute.ignore_stun and this.unit.is_stunned or this.dodge and this.dodge.active and not this.dodge.silent then
						return false
					end

					coroutine.yield()
				end

				U.animation_start(this, "idle", nil, store.tick_ts, true)

				ab.ts = store.tick_ts
			end

			if ready_to_spawn() then
				a = as

				local start_ts = store.tick_ts
				local target_path = this.nav_path.pi

				if target_path == 19 then
					target_path = 12
				end

				this.available_nodes = {}

				local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, a.min_range, a.max_range, TERRAIN_LAND, function(x, y)
					local nearest_node = P:nearest_nodes(x, y, {
						target_path
					}, {
						1,
						2,
						3
					}, true)

					if #nearest_node <= 0 then
						return false
					end

					local pi, spi, ni, dist = unpack(nearest_node[1])

					if ni < this.nav_path.ni then
						return false
					end

					return true
				end, nil, {
					1,
					2,
					3
				})

				nodes = table.random_order(nodes)

				if not nodes then
					SU.delay_attack(store, a, fts(10))

					goto label_203_1
				end

				for j = 1, #nodes do
					local is_far = true

					for k = 1, #this.available_nodes do
						local distance = V.dist(nodes[j].x, nodes[j].y, this.available_nodes[k].pos.x, this.available_nodes[k].pos.y)

						if distance < a.distance_between_entities then
							is_far = false

							break
						end
					end

					if is_far then
						local nearest_node = P:nearest_nodes(nodes[j].x, nodes[j].y, {
							target_path
						}, {
							1,
							2,
							3
						}, true)
						local min_distance = 5

						if #nearest_node > 0 and min_distance > nearest_node[1][4] then
							table.insert(this.available_nodes, {
								pos = nodes[j],
								node = nearest_node[1]
							})

							if #this.available_nodes >= a.entities_amount then
								break
							end
						end
					end
				end

				U.y_animation_play(this, a.animation_start, nil, store.tick_ts)

				local total_entities = a.entities_amount
				local total_loops = a.loop_times
				local entities_spawned = 0
				local bullet_start_offset = a.bullet_start_offset[1]

				if this.render.sprites[1].flip_x then
					bullet_start_offset = a.bullet_start_offset[2]
				end

				for current_loop = 1, total_loops do
					local remaining_entities = total_entities - entities_spawned
					local remaining_loops = total_loops - current_loop + 1
					local entities_this_loop = math.ceil(remaining_entities / remaining_loops)

					S:queue(a.sound)
					U.animation_start(this, a.animation_loop, nil, store.tick_ts)
					U.y_wait(store, fts(12))

					for i = 1, entities_this_loop do
						local b = E:create_entity(a.bullet)

						b.pos.x, b.pos.y = this.pos.x + bullet_start_offset.x, this.pos.y + bullet_start_offset.y
						b.bullet.from = V.vclone(b.pos)
						b.bullet.to = V.vclone(this.available_nodes[i].pos)
						b.bullet.source_id = this.id
						b.nav_path_data = this.available_nodes[i].node

						queue_insert(store, b)
						U.y_wait(store, fts(1))
					end

					SU.y_enemy_animation_wait(this)

					entities_spawned = entities_spawned + entities_this_loop
				end

				U.y_animation_play(this, a.animation_end, nil, store.tick_ts)

				a.ts = start_ts
			end

			::label_203_1::

			if ready_to_eat_tower() then
				a = attack_towers

				local target_tower = table.random(get_towers_to_eat())

				U.animation_start(this, a.animation, nil, store.tick_ts)

				for _, e in pairs(store.entities) do
					if e.template_name == "decal_stage_22_rune_rock" or e.template_name == "decal_stage_22_rune_doors" then
						e.boss_eating = true
					end
				end

				SU.y_enemy_wait(store, this, a.action_time_mod)

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 0.7
				shake.aura.duration = 2
				shake.aura.freq_factor = 2

				queue_insert(store, shake)

				local mods_in_tower = table.filter(store.entities, function(_, ee)
					return ee.modifier and ee.modifier.target_id == target_tower.id
				end)

				for _, mod_in_tower in pairs(mods_in_tower) do
					queue_remove(store, mod_in_tower)
				end

				local mod = E:create_entity(a.mod)

				mod.modifier.target_id = target_tower.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)
				SU.y_enemy_wait(store, this, a.action_time_eat - a.action_time_mod)
				SU.y_enemy_animation_wait(this)

				for _, e in pairs(store.entities) do
					if e.template_name == "decal_stage_22_rune_rock" or e.template_name == "decal_stage_22_rune_doors" then
						e.boss_eating = false
					end
				end

				a.ts = store.tick_ts
			end

			if ready_to_rain() then
				a = attack_rain

				U.animation_start(this, a.animation_start, nil, store.tick_ts)
				S:queue(a.sound)
				SU.y_enemy_wait(store, this, a.action_time_shoot)

				local qty_shoots = 0

				for _, e in pairs(store.entities) do
					if e.hero and not U.flag_has(e.vis.flags, F_FLYING) then
						local nodes = P:nearest_nodes(e.pos.x, e.pos.y, nil, nil, true)

						if #nodes < 1 then
							-- block empty
						else
							local pi, spi, ni = unpack(nodes[1])
							local shot_pos = P:node_pos(pi, spi, ni)

							shoot_acid(shot_pos)

							qty_shoots = qty_shoots + 1

							SU.y_enemy_wait(store, this, a.shots_delay)
						end
					end
				end

				for i = 1, a.shots_amount - qty_shoots do
					local shot_pos, pi, spi, ni
					local tries = 0
					local found = false

					while not found and tries < 5 do
						tries = tries + 1
						shot_pos, pi, spi, ni = P:get_random_position(10, bor(TERRAIN_LAND))

						if shot_pos ~= nil then
							found = true

							shoot_acid(shot_pos)
						end
					end

					SU.y_enemy_wait(store, this, a.shots_delay)
				end

				SU.y_enemy_animation_wait(this)

				a.ts = store.tick_ts
			end

			if ready_to_evolve() then
				U.animation_start(this, this.evolution_anim, nil, store.tick_ts, false)
				S:queue(this.evolve_sound)
				U.y_wait(store, this.evolution_health_update_tick_time)

				local next_template = E:get_template(this.next_level_template)

				this.health_bar.offset = V.vclone(next_template.health_bar.offset)

				local hp_start = this.health.hp

				if this.hp_evolution_method == 0 then
					this.health.hp = this.health.hp_max
				elseif this.hp_evolution_method == 1 then
					-- block empty
				elseif this.hp_evolution_method == 2 then
					local tick_hp = this.hp_restore_fixed_amount * 0.5 / this.hp_ticks
					local tick_time = (this.evolution_health_update_time - this.evolution_health_update_tick_time) / this.hp_ticks

					for i = 1, this.hp_ticks do
						this.health.hp = this.health.hp + tick_hp
						this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp)

						U.y_wait(store, tick_time)
					end

					this.health.hp = this.health.hp + this.hp_restore_fixed_amount * 0.5
					this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp)
				end

				local heal_amount = this.health.hp - hp_start

				this.health.hp_healed = (this.health.hp_healed or 0) + heal_amount

				if heal_amount > 0 then
					signal.emit("entity-healed", this, this, heal_amount)
				end

				U.y_animation_wait(this)

				local mod = E:create_entity(this.evolution_mod)

				mod.modifier.target_id = this.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)

				return
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, melee_break_fn) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.mod_croc_boss_melee_hit = {}

function scripts.mod_croc_boss_melee_hit.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target then
		return false
	end

	local hit_pos = V.vclone(target.pos)

	if target.unit and target.unit.hit_offset then
		hit_pos.x, hit_pos.y = hit_pos.x + target.unit.hit_offset.x, hit_pos.y + target.unit.hit_offset.y
	end

	local fx = E:create_entity(this.modifier.hit_fx)

	fx.pos = V.vclone(hit_pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	return false
end

scripts.mod_boss_crocs_tower_eat = {}

function scripts.mod_boss_crocs_tower_eat.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		SU.tower_block_inc(target)
		SU.remove_modifiers(store, target, nil, "mod_boss_crocs_tower_eat")

		this._pushed_bans = U.push_bans(target.vis, F_ALL)
	end
end

function scripts.mod_boss_crocs_tower_eat.dequeue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		SU.tower_block_dec(target)

		if this._pushed_bans then
			U.pop_bans(target.vis, this._pushed_bans)

			this._pushed_bans = nil
		end
	end
end

function scripts.mod_boss_crocs_tower_eat.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return false
	end

	target.tower._type = target.tower.type
	target.tower._prevent_timed_destroy_price = this._prevent_timed_destroy_price
	target.tower._prevent_timed_destroy = false
	target.tower.type = "tower_timed_destroy"
	target.ui.can_click = false

	return true
end

function scripts.mod_boss_crocs_tower_eat.update(this, store)
	local target = store.entities[this.modifier.target_id]
	local boss = store.entities[this.modifier.source_id]

	this.pos = target.pos

	local anim = this.use_secondary_anim and "attack2" or "attack1"

	if not this.muted then
		if this.use_secondary_anim then
			S:queue(this.sound_eat, {
				delay = 0.55
			})
		else
			S:queue(this.sound_eat, {
				delay = 0
			})
		end
	end

	U.animation_start(this, anim, nil, store.tick_ts, false, 2)

	target.ui.can_click = false
	target.tower.type = target.tower._type
	target.tower._type = nil

	local not_finished = U.y_wait(store, fts(6), function(store, time)
		return boss and boss.health and boss.health.dead
	end)

	if not_finished then
		queue_remove(store, this)

		return
	end

	-- local broken_tower_mod = E:create_entity(this.broken_tower_mod)

	-- broken_tower_mod.modifier.target_id = target.id

	-- queue_insert(store, broken_tower_mod)

	local h_id = target.tower.holder_id

	target.tower.destroy = true

	coroutine.yield()

	local holder = table.filter(store.entities, function(_, v)
		return v.tower and v.tower.holder_id == h_id
	end)

	if holder and #holder > 0 then
		holder = holder[1]
		holder.ui.can_click = false
		holder.tower.can_hover = false
	else
		holder = nil
	end

	U.y_wait(store, this.use_secondary_anim and fts(113) or fts(40))
	S:queue(this.sound_fist_remove)

	while not U.animation_finished(this, 2) do
		if boss and boss.health and boss.health.dead then
			break
		end

		coroutine.yield()
	end

	-- SU.tower_block_dec(target)

	-- if target.ui and target.tower.block_count <= 1 then
	-- 	target.ui.can_click = true
	-- 	target.tower.can_hover = true
	-- 	target.trigger_deselect = nil
	-- end

	if holder then
		holder.ui.can_click = true
		holder.tower.can_hover = true
	end

	queue_remove(store, this)
end

function scripts.mod_boss_crocs_tower_eat.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target and this._pushed_bans then
		U.pop_bans(target.vis, this._pushed_bans)

		this._pushed_bans = nil
	end

	return true
end

scripts.mod_croc_boss_evolution_polymorph = {}

function scripts.mod_croc_boss_evolution_polymorph.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		this.target_ref = target

		for _, s in ipairs(target.render.sprites) do
			s.hidden = true
		end

		SU.remove_modifiers(store, target)
		SU.remove_auras(store, target)
		queue_remove(store, target)
		U.unblock_all(store, target)

		if target.ui then
			target.ui.can_click = false
		end

		target.main_script.co = nil
		target.main_script.runs = 0

		if target.count_group then
			target.count_group.in_limbo = true
		end

		local polymorph_template

		for k, v in pairs(this.entity_t) do
			log.info()

			if target.template_name == v[1] then
				polymorph_template = v[2]

				break
			end
		end

		local entity_poly = E:create_entity(polymorph_template)

		entity_poly.pos = target.pos
		entity_poly.nav_path = target.nav_path

		queue_insert(store, entity_poly)

		entity_poly.enemy.gems = target.enemy.gems
		target.enemy.gems = 0
		entity_poly.health.hp_healed = target.health.hp_healed or 0

		local hp_start = target.health.hp

		if this.hp_evolution_method[target.boss_crocs_level] == 0 then
			-- block empty
		elseif this.hp_evolution_method[target.boss_crocs_level] == 1 then
			local current_percentage = target.health.hp / target.health.hp_max

			entity_poly.health.hp = entity_poly.health.hp_max * current_percentage
		elseif this.hp_evolution_method[target.boss_crocs_level] == 2 then
			entity_poly.health.hp = target.health.hp
		end

		local heal_amount = entity_poly.health.hp - hp_start

		entity_poly.health.hp_healed = entity_poly.health.hp_healed + heal_amount

		if heal_amount > 0 then
			signal.emit("entity-healed", this, entity_poly, heal_amount)
		end

		if entity_poly.health.hp < entity_poly.health.hp_max then
			entity_poly.health_bar.hidden = false
		end

		return true
	end

	return false
end

local function y_hero_melee_block_and_attacks(store, hero)
	local target = SU.soldier_pick_melee_target(store, hero)

	if not target then
		return false, A_NO_TARGET
	end

	if SU.soldier_move_to_slot_step(store, hero, target) then
		return true
	end

	local attack = SU.soldier_pick_melee_attack(store, hero, target)

	if not attack then
		return false, A_IN_COOLDOWN
	end

	local upg = UP:get_upgrade("heroes_lethal_focus")
	local triggered_lethal_focus = false
	local attack_pop = attack.pop
	local attack_pop_chance = attack.pop_chance

	if attack.basic_attack and upg then
		if not hero._lethal_focus_deck then
			hero._lethal_focus_deck = SU.deck_new(upg.trigger_cards, upg.total_cards)
		end

		triggered_lethal_focus = SU.deck_draw(hero._lethal_focus_deck)
	end

	if triggered_lethal_focus then
		hero.unit.damage_factor = hero.unit.damage_factor * upg.damage_factor
		attack.pop = {
			"pop_crit_heroes"
		}
		attack.pop_chance = 1
	end

	if attack.xp_from_skill then
		SU.hero_gain_xp_from_skill(hero, hero.hero.skills[attack.xp_from_skill])
	end

	local attack_done

	if attack.loops then
		attack_done = SU.y_soldier_do_loopable_melee_attack(store, hero, target, attack)
	elseif attack.type == "area" then
		attack_done = SU.y_soldier_do_single_area_attack(store, hero, target, attack)
	else
		attack_done = SU.y_soldier_do_single_melee_attack(store, hero, target, attack)
	end

	if triggered_lethal_focus then
		hero.unit.damage_factor = hero.unit.damage_factor / upg.damage_factor
		attack.pop = attack_pop
		attack.pop_chance = attack_pop_chance
	end

	if attack_done then
		return false, A_DONE
	else
		return true
	end
end

local function y_hero_ranged_attacks(store, hero)
	local target, attack, pred_pos = SU.soldier_pick_ranged_target_and_attack(store, hero)

	if not target then
		return false, A_NO_TARGET
	end

	if not attack then
		return false, A_IN_COOLDOWN
	end

	local upg = UP:get_upgrade("heroes_lethal_focus")
	local triggered_lethal_focus = false
	local bullet_t = E:get_template(attack.bullet)
	local bullet_use_unit_damage_factor = bullet_t.bullet.use_unit_damage_factor
	local bullet_pop = bullet_t.bullet.pop
	local bullet_pop_conds = bullet_t.bullet.pop_conds

	if attack.basic_attack and upg then
		if not hero._lethal_focus_deck then
			hero._lethal_focus_deck = SU.deck_new(upg.trigger_cards, upg.total_cards)
		end

		triggered_lethal_focus = SU.deck_draw(hero._lethal_focus_deck)
	end

	if triggered_lethal_focus then
		if bullet_t.bullet.damage_radius > 0 then
			hero.unit.damage_factor = hero.unit.damage_factor * upg.damage_factor_area
		else
			hero.unit.damage_factor = hero.unit.damage_factor * upg.damage_factor
		end

		bullet_t.bullet.use_unit_damage_factor = true
		bullet_t.bullet.pop = {
			"pop_crit"
		}
		bullet_t.bullet.pop_conds = DR_DAMAGE
	end

	local start_ts = store.tick_ts
	local attack_done

	U.set_destination(hero, hero.pos)

	if attack.loops then
		attack_done = SU.y_soldier_do_loopable_ranged_attack(store, hero, target, attack)
	else
		attack_done = SU.y_soldier_do_ranged_attack(store, hero, target, attack, pred_pos)
	end

	if attack_done then
		attack.ts = start_ts

		if attack.shared_cooldown then
			for _, aa in pairs(hero.ranged.attacks) do
				if aa ~= attack and aa.shared_cooldown then
					aa.ts = attack.ts
				end
			end
		end

		if hero.ranged.forced_cooldown then
			hero.ranged.forced_ts = start_ts
		end
	end

	if triggered_lethal_focus then
		if bullet_t.bullet.damage_radius > 0 then
			hero.unit.damage_factor = hero.unit.damage_factor / upg.damage_factor_area
		else
			hero.unit.damage_factor = hero.unit.damage_factor / upg.damage_factor
		end
		bullet_t.bullet.use_unit_damage_factor = bullet_use_unit_damage_factor
		bullet_t.bullet.pop = bullet_pop
		bullet_t.bullet.pop_conds = bullet_pop_conds
	end

	if attack_done then
		return false, A_DONE
	else
		return true
	end
end

scripts.power_hero_control_custom = {}

function scripts.power_hero_control_custom.can_select_point(this, x, y, store)
	local hero_entity = store.entities[this.hero_id]

	if not hero_entity then
		return false
	end

	local ut = E:get_template(hero_entity.hero.skills.ultimate.controller_name)

	if not ut.can_fire_fn or ut.can_fire_fn(ut, x, y, store, hero_entity) then
		return true
	end

	return false
end

function scripts.power_hero_control_custom.get_cooldown(this, store)
	local hero_entity = store.entities[this.hero_id]

	if not hero_entity then
		return nil
	end

	local u = hero_entity.hero.skills.ultimate
	local controller = E:get_template(u.controller_name)
	local cooldown = controller.cooldown

	return cooldown
end

function scripts.power_hero_control_custom.insert(this, store)
	local hero_entity = store.entities[this.hero_id]
	local u = hero_entity.hero.skills.ultimate

	if not u.controlled_by_hero then
		local e = E:create_entity(u.controller_name)

		e.pos.x, e.pos.y = this.pos.x, this.pos.y
		e.owner = hero_entity
		e.level = u.level

		queue_insert(store, e)
	else
		u.requested_pos = v(this.pos.x, this.pos.y)
		hero_entity.nav_rally.new = true
	end

	if hero_entity.hero.team == TEAM_DARK_ARMY then
		local upg = UP:get_upgrade("alliance_display_of_true_might_dark")

		if upg then
			for _, e in pairs(store.entities) do
				if e.enemy and band(e.vis.bans, F_MOD) == 0 then
					local mod = E:create_entity(upg.mod_dark_army)

					mod.modifier.target_id = e.id

					queue_insert(store, mod)
				end
			end

			local overlay = E:create_entity(upg.overlay_dark_army)

			overlay.tween.ts = store.tick_ts
			overlay.pos = v(512, 384)

			queue_insert(store, overlay)
			S:queue("UpgradeDisplayOfTrueMightDarkArmy")
		end
	else
		local upg = UP:get_upgrade("alliance_display_of_true_might_linirea")

		if upg then
			for _, e in pairs(store.entities) do
				if e.hero then
					if e.health.hp > 0 then
						e.health.hp = e.health.hp_max

						local mod = E:create_entity(upg.mod_linirea)

						mod.modifier.target_id = e.id

						queue_insert(store, mod)
					end
				elseif e.soldier and e.vis and e.vis.bans and band(e.vis.bans, F_MOD) == 0 then
					if e.health.hp <= 0 then
						e.health.dead = true
						if e.respawn then
							e.health.hp = e.health.hp_max
						else
							queue_remove(store, e)
						end
					else
						e.health.hp = e.health.hp_max

						local mod = E:create_entity(upg.mod_linirea)

						mod.modifier.target_id = e.id

						queue_insert(store, mod)
					end
				end
			end

			local overlay = E:create_entity(upg.overlay_linirea)

			overlay.tween.ts = store.tick_ts
			overlay.pos = v(512, 384)

			queue_insert(store, overlay)
			S:queue("UpgradeDisplayOfTrueMightLinirea")
		end
	end

	return false
end

scripts.item_control_custom = {}

function scripts.item_control_custom.can_select_point(this, x, y, store)
	local c = E:get_template("controller_item_" .. this.item)

	c.pos.x, c.pos.y = x, y

	return c.can_fire_fn(c, x, y, store)
end

function scripts.item_control_custom.insert(this, store)
	local e = E:create_entity("controller_item_" .. this.item)

	e.pos.x, e.pos.y = this.pos.x, this.pos.y

	queue_insert(store, e)

	return false
end

scripts.controller_item_cluster_bomb = {}

function scripts.controller_item_cluster_bomb.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.controller_item_cluster_bomb.insert(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	}, true)

	if #nodes < 1 then
		return false
	end

	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)
	local b = E:create_entity(this.bullet)

	b.pos.x = npos.x
	b.pos.y = npos.y + this.spawn_height
	b.bullet.from = V.vclone(b.pos)
	b.bullet.to = V.v(npos.x, npos.y)

	queue_insert(store, b)

	return false
end

scripts.bullet_cluster_bomb = {}

function scripts.bullet_cluster_bomb.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius

	if b.level and b.level > 0 then
		if b.damage_radius_inc then
			dradius = dradius + b.level * b.damage_radius_inc
		end

		if b.damage_min_inc then
			dmin = dmin + b.level * b.damage_min_inc
		end

		if b.damage_max_inc then
			dmax = dmax + b.level * b.damage_max_inc
		end
	end

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	local enemies = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, b.damage_bans) == 0 and band(v.vis.bans, b.damage_flags) == 0 and U.is_inside_ellipse(v.pos, b.to, dradius)
	end)

	for _, enemy in pairs(enemies) do
		local d = E:create_entity("damage")

		d.damage_type = b.damage_type
		d.reduce_armor = b.reduce_armor
		d.reduce_magic_armor = b.reduce_magic_armor

		if b.damage_decay_random then
			d.value = U.frandom(dmin, dmax)
		elseif this.up_alchemical_powder_chance and math.random() < this.up_alchemical_powder_chance or UP:get_upgrade("engineer_efficiency") then
			d.value = dmax
		else
			local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, b.to, dradius)

			d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
		end

		d.value = math.ceil(b.damage_factor * d.value)
		d.source_id = this.id
		d.target_id = enemy.id

		queue_damage(store, d)
		log.paranoid("bomb id:%s, radius:%s, enemy id:%s, dist:%s, damage:%s damage_type:%x", this.id, dradius, enemy.id, V.dist(enemy.pos.x, enemy.pos.y, b.to.x, b.to.y), d.value, d.damage_type)

		if this.up_shock_and_awe_chance and band(enemy.vis.bans, F_STUN) == 0 and band(enemy.vis.flags, bor(F_BOSS, F_CLIFF, F_FLYING)) == 0 and math.random() < this.up_shock_and_awe_chance then
			local mod = E:create_entity("mod_shock_and_awe")

			mod.modifier.target_id = enemy.id

			queue_insert(store, mod)
		end

		if b.mod then
			local mod = E:create_entity(b.mod)

			mod.modifier.target_id = enemy.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)
		end
	end

	local p = SU.create_bullet_pop(store, this)

	queue_insert(store, p)

	local cell_type = GR:cell_type(b.to.x, b.to.y)

	if b.hit_fx_water and band(cell_type, TERRAIN_WATER) ~= 0 then
		S:queue(this.sound_events.hit_water)

		local water_fx = E:create_entity(b.hit_fx_water)

		water_fx.pos.x, water_fx.pos.y = b.to.x, b.to.y
		water_fx.render.sprites[1].ts = store.tick_ts
		water_fx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, water_fx)
	elseif b.hit_fx then
		S:queue(this.sound_events.hit)

		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, sfx)
	end

	if b.hit_decal and band(cell_type, TERRAIN_WATER) == 0 then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
		else
			hp = b.hit_payload
		end

		hp.pos.x, hp.pos.y = b.to.x, b.to.y

		if hp.aura then
			hp.aura.level = this.bullet.level
		end

		queue_insert(store, hp)
	end

	S:queue(this.sound_small_bombs)

	for _, bomb_pos in ipairs(this.bombs_position) do
		local bomb = E:create_entity(this.bomb_small)

		bomb.bullet.to = V.v(b.to.x + bomb_pos[1], b.to.y + bomb_pos[2])
		bomb.bullet.from = V.v(b.to.x, b.to.y)

		queue_insert(store, bomb)
		U.y_wait(store, this.time_between_bombs)
	end

	queue_remove(store, this)
end

scripts.controller_item_portable_coil = {}

function scripts.controller_item_portable_coil.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.controller_item_portable_coil.insert(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	}, true)

	if #nodes < 1 then
		return false
	end

	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)
	local c = E:create_entity(this.coil)

	c.pos = V.vclone(npos)
	c.render.sprites[1].ts = store.tick_ts

	queue_insert(store, c)

	return false
end

scripts.decal_item_portable_coil = {}

function scripts.decal_item_portable_coil.update(this, store, script)
	S:queue(this.sound_cast)
	U.y_animation_play(this, "spawn", nil, store.tick_ts)
	U.animation_start(this, "idle_off", nil, store.tick_ts)

	local target, targets

	while true do
		target, targets = U.find_nearest_enemy(store.entities, this.pos, 0, this.range, this.vis_flags, this.vis_bans)

		if target then
			break
		else
			U.y_wait(store, fts(10))
		end
	end

	S:queue(this.sound_attack)
	U.y_animation_play(this, "on", nil, store.tick_ts)
	U.animation_start(this, "idle_on", nil, store.tick_ts)

	this.chain_targets = {}

	if targets and #targets >= 1 then
		local num_t = math.min(#targets, this.max_targets)

		for i = 1, num_t do
			local t = targets[i]
			local b = E:create_entity(this.ray)
			local start_offset = this.bullet_start_offset

			b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
			b.bullet.from = V.vclone(b.pos)
			b.bullet.to = V.vclone(t.pos)
			b.bullet.to.x, b.bullet.to.y = b.bullet.to.x + t.unit.hit_offset.x, b.bullet.to.y + t.unit.hit_offset.y
			b.bullet.target_id = t.id
			b.bullet.source_id = this.id
			b.chain_pos = 1

			queue_insert(store, b)
			table.insert(this.chain_targets, t.id)
		end
	end

	U.y_wait(store, fts(10))
	U.y_animation_play(this, "off", nil, store.tick_ts)
	U.y_animation_play(this, "death", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.bullet_decal_item_portable_coil = {}

function scripts.bullet_decal_item_portable_coil.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local dest = V.vclone(b.to)

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			dest.x, dest.y = tpx, tpy
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
	end

	s.scale = s.scale or V.vv(1)

	U.animation_start(this, "attack", nil, store.tick_ts, true)
	update_sprite()

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	local mods_added = {}

	if not target then
		-- block empty
	else
		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.source_id = this.id

				table.insert(mods_added, m)
				queue_insert(store, m)
			end
		end

		if b.hit_fx then
			local is_air = target and band(target.vis.flags, F_FLYING) ~= 0
			local fx = E:create_entity(b.hit_fx)

			fx.pos.x, fx.pos.y = dest.x, dest.y
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		end

		do
			local d = E:create_entity("damage")

			d.damage_type = b.damage_type

			local dmin, dmax

			if this.chain_pos == 1 then
				dmin, dmax = b.damage_min, b.damage_max
			else
				dmin, dmax = b.damage_min_chain, b.damage_max_chain
			end

			d.value = math.random(dmin, dmax)
			d.source_id = this.id
			d.target_id = target.id

			queue_damage(store, d)
		end

		U.y_wait(store, this.chain_delay)

		if this.chain_pos < this.max_chain_length then
			local chain_target, targets, _ = U.find_nearest_enemy(store.entities, target.pos, 0, this.chain_range, this.vis_flags, this.vis_bans, function(e, o)
				return not table.contains(source.chain_targets, e.id)
			end)

			if chain_target then
				local chain = E:create_entity(this.template_name)
				local start_offset = target.unit.hit_offset

				chain.pos.x, chain.pos.y = target.pos.x + start_offset.x, target.pos.y + start_offset.y
				chain.bullet.from = V.vclone(chain.pos)

				local end_offset = chain_target.unit.hit_offset

				chain.bullet.to = V.vclone(chain_target.pos)
				chain.bullet.to.x, chain.bullet.to.y = chain.bullet.to.x + end_offset.x, chain.bullet.to.y + end_offset.y
				chain.bullet.target_id = chain_target.id
				chain.bullet.source_id = b.source_id
				chain.chain_pos = this.chain_pos + 1

				queue_insert(store, chain)
				table.insert(source.chain_targets, chain_target.id, chain_target.id)
			end
		end
	end

	U.y_wait(store, fts(11) - this.chain_delay)

	this.render.sprites[1].hidden = true

	queue_remove(store, this)
end

scripts.controller_item_scroll_of_spaceshift = {}

function scripts.controller_item_scroll_of_spaceshift.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.controller_item_scroll_of_spaceshift.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	}, true)

	if #nodes < 1 then
		return false
	end

	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)

	S:queue(this.sound_cast)

	local d = E:create_entity(this.teleport_decal)

	d.pos = V.vclone(npos)
	d.render.sprites[1].ts = store.tick_ts

	queue_insert(store, d)
	U.y_wait(store, fts(20))

	local target, targets = U.find_nearest_enemy(store.entities, npos, 0, this.radius, this.vis_flags, this.vis_bans)

	if not target or not targets or #targets < 1 then
		return true
	end

	local num_targets = math.min(#targets, this.max_targets)

	for i = 1, num_targets do
		local t = targets[i]
		local mod_mark = E:create_entity(this.mod_mark)

		mod_mark.modifier.target_id = t.id
		mod_mark.modifier.source_id = this.id

		queue_insert(store, mod_mark)
		S:queue(this.sound_teleport_in)

		local mod_teleport = E:create_entity(this.mod_teleport)

		mod_teleport.modifier.target_id = t.id
		mod_teleport.modifier.source_id = this.id

		queue_insert(store, mod_teleport)
		S:queue(this.sound_teleport_out, {
			delay = mod_teleport.hold_time
		})
	end

	queue_remove(store, this)
end

scripts.controller_item_second_breath = {}

function scripts.controller_item_second_breath.can_fire_fn(this, x, y, store)
	return true
end

function scripts.controller_item_second_breath.insert(this, store)
	local tap_fx = E:create_entity(this.tap_fx)

	tap_fx.pos = V.vclone(this.pos)
	tap_fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, tap_fx)
	S:queue(this.sound_cast)

	this.heroes = {}

	for _, v in pairs(store.entities) do
		if v.template_name == store.selected_team[1] or v.template_name == store.selected_team[2] then
			table.insert(this.heroes, v)

			if #this.heroes == 2 then
				break
			end
		end
	end

	local decals = {}

	for k, v in pairs(this.heroes) do
		local d = E:create_entity(this.decal)

		d.pos = V.vclone(v.pos)
		d.render.sprites[1].ts = store.tick_ts

		queue_insert(store, d)
		table.insert(decals, d)
	end

	signal.emit("second-breath")

	return true
end

function scripts.controller_item_second_breath.update(this, store)
	U.y_wait(store, fts(17))

	for k, v in pairs(this.heroes) do
		local fx = E:create_entity(this.respawn_fx)

		fx.pos = V.vclone(v.pos)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		if v.health.hp <= 0 then
			v.force_respawn = true
		else
			v.health.hp = v.health.hp_max

			local mod_heal = E:create_entity(this.mod_heal)

			mod_heal.modifier.target_id = v.id
			mod_heal.modifier.source_id = this.id

			queue_insert(store, mod_heal)
		end
	end

	queue_remove(store, this)
end

scripts.mod_item_second_breath_heal = {}

function scripts.mod_item_second_breath_heal.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			for _, s in pairs(this.render.sprites) do
				local flip_sign = 1

				if target.render then
					flip_sign = target.render.sprites[1].flip_x and -1 or 1
				end

				s.offset.x, s.offset.y = target.render.sprites[1].offset.x * flip_sign, target.render.sprites[1].offset.y
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end
end

scripts.controller_item_deaths_touch = {}

function scripts.controller_item_deaths_touch.can_fire_fn(this, x, y, store)
	local targets = table.filter(store.entities, function(k, v)
		if not v.pos or not v.unit then
			return false
		end

		local pos = V.v(v.pos.x + v.unit.hit_offset.x, v.pos.y + v.unit.hit_offset.y)

		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.vis_bans) == 0 and band(v.vis.bans, this.vis_flags) == 0 and v.unit.hit_offset and U.is_inside_ellipse(pos, this.pos, this.radius) and (not this.allowed_templates or table.contains(this.allowed_templates, v.template_name)) and (not this.excluded_templates or not table.contains(this.excluded_templates, v.template_name))
	end)

	if targets and #targets > 0 then
		return true
	else
		return false
	end
end

function scripts.controller_item_deaths_touch.insert(this, store)
	local targets = table.filter(store.entities, function(k, v)
		if not v.pos or not v.unit then
			return false
		end

		local pos = V.v(v.pos.x + v.unit.hit_offset.x, v.pos.y + v.unit.hit_offset.y)

		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.vis_bans) == 0 and band(v.vis.bans, this.vis_flags) == 0 and v.unit.hit_offset and U.is_inside_ellipse(pos, this.pos, this.radius) and (not this.allowed_templates or table.contains(this.allowed_templates, v.template_name)) and (not this.excluded_templates or not table.contains(this.excluded_templates, v.template_name))
	end)

	table.sort(targets, function(e1, e2)
		return V.dist(e1.pos.x + e1.unit.hit_offset.x, e1.pos.y + e1.unit.hit_offset.y, this.pos.x, this.pos.y) < V.dist(e2.pos.x + e2.unit.hit_offset.x, e2.pos.y + e2.unit.hit_offset.y, this.pos.x, this.pos.y)
	end)

	if targets and #targets > 0 then
		this.target = targets[1]

		local fx = E:create_entity(this.fx)

		if this.target.unit and this.target.unit.hit_offset then
			fx.pos.x, fx.pos.y = this.target.pos.x + this.target.unit.hit_offset.x, this.target.pos.y + this.target.unit.hit_offset.y
		else
			fx.pos.x, fx.pos.y = this.target.pos.x, this.target.pos.y
		end

		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
		S:queue(this.sound)

		return true
	end

	return false
end

function scripts.controller_item_deaths_touch.update(this, store)
	local start_ts = store.tick_ts
	local is_boss = band(this.target.vis.flags, F_BOSS) ~= 0

	local function do_damage()
		local d = E:create_entity("damage")

		if is_boss then
			d.damage_type = this.damage_type_boss
		else
			this.target.health.ignore_damage = nil
			d.damage_type = this.damage_type
		end

		d.value = this.damage_boss
		d.source_id = this.id
		d.target_id = this.target.id

		queue_damage(store, d)
	end

	if not is_boss then
		SU.stun_inc(this.target)
	end

	while true do
		if store.tick_ts - start_ts >= this.damage_delay then
			do_damage()

			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.controller_item_loot_box = {}

function scripts.controller_item_loot_box.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.controller_item_loot_box.insert(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	}, true)

	if #nodes < 1 then
		return false
	end

	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)

	S:queue(this.sound)

	local b = E:create_entity(this.boxes_decals[math.random(1, 3)])

	b.bullet.from = V.v(npos.x, npos.y + REF_H)
	b.bullet.to = npos
	b.pos = V.vclone(b.bullet.from)
	b.sound = this.sound

	queue_insert(store, b)

	return false
end

scripts.decal_item_loot_box_projectile = {}

function scripts.decal_item_loot_box_projectile.update(this, store)
	local b = this.bullet
	local speed = b.max_speed

	while this.pos.y > b.to.y + 100 do
		b.speed.x, b.speed.y = V.mul(speed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		coroutine.yield()
	end

	S:queue(this.sound_hit)

	local shake = E:create_entity("aura_screen_shake")

	shake.aura.amplitude = 0.2
	shake.aura.duration = 1
	shake.aura.freq_factor = 2

	queue_insert(store, shake)

	if b.aura then
		local aura = E:create_entity(b.aura)

		aura.pos = V.vclone(b.to)

		queue_insert(store, aura)
	end

	local dust = E:create_entity(this.dust)

	dust.pos = V.vclone(b.to)
	dust.render.sprites[1].ts = store.tick_ts

	queue_insert(store, dust)

	local floor_decal = E:create_entity(this.floor_decal)

	floor_decal.pos = V.vclone(b.to)
	floor_decal.render.sprites[1].ts = store.tick_ts

	queue_insert(store, floor_decal)

	local decal = E:create_entity(b.arrive_decal)

	decal.pos = V.vclone(b.to)
	decal.render.sprites[1].ts = store.tick_ts

	queue_insert(store, decal)
	U.animation_start(decal, "in", nil, store.tick_ts, false)
	coroutine.yield()

	this.render.sprites[1].hidden = true

	U.y_wait(store, fts(10))

	local gold_pos = V.v(this.pos.x + this.gold_pos_offset.x, this.pos.y + this.gold_pos_offset.y)

	signal.emit("got-gold", gold_pos, this.gold_amount)
	U.y_animation_wait(decal)
	U.animation_start(decal, "idle", nil, store.tick_ts, true)
	queue_remove(store, this)
end

scripts.controller_item_winter_age = {}

function scripts.controller_item_winter_age.can_fire_fn(this, x, y, store)
	return true
end

function scripts.controller_item_winter_age.update(this, store)
	signal.emit("winter-age-starts")
	S:queue(this.sound_in)
	S:queue(this.sound_loop)

	local targets = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.vis_bans) == 0 and band(v.vis.bans, this.vis_flags) == 0 and (not this.allowed_templates or table.contains(this.allowed_templates, v.template_name)) and (not this.excluded_templates or not table.contains(this.excluded_templates, v.template_name)) and (v.template_name ~= "enemy_crystal_golem" or v.render.sprites[1].name ~= "holder") and (not v.nav_path or not not P:is_node_valid(v.nav_path.pi, v.nav_path.ni))
	end)

	if targets and #targets > 0 then
		table.sort(targets, function(e1, e2)
			return e1.pos.x < e2.pos.x
		end)

		local delay_between = 10 / #targets

		for _, enemy in ipairs(targets) do
			local m = E:create_entity(this.mod)

			m.modifier.source_id = this.id
			m.modifier.target_id = enemy.id

			queue_insert(store, m)
			U.y_wait(store, fts(math.random(delay_between / 2, delay_between * 2)))
		end
	end

	U.y_wait(store, this.stun_duration)
	queue_remove(store, this)
end

function scripts.controller_item_winter_age.remove(this, store)
	signal.emit("winter-age-ends")
	S:stop(this.sound_loop)
	S:queue(this.sound_out)
end

scripts.mod_item_winter_age_freeze = {}

function scripts.mod_item_winter_age_freeze.insert(this, store)
	local target = store.entities[this.modifier.target_id]
	local m = this.modifier

	if not target then
		return false
	end

	if band(target.vis.flags, this.modifier.vis_bans) ~= 0 then
		return false
	end

	if band(target.vis.bans, this.modifier.vis_flags) ~= 0 then
		return false
	end

	this._entity_frame_names = {}

	for _, es in pairs(target.render.sprites) do
		if es.animated then
			table.insert(this._entity_frame_names, es.frame_name)
		else
			table.insert(this._entity_frame_names, es.name)
		end
	end

	SU.stun_inc(target)

	local s = this.render.sprites[1]
	local is_flying = U.flag_has(target.vis.flags, F_FLYING)

	if is_flying then
		s.prefix = s.prefix .. "_air"
		m.use_mod_offset = true
		s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
	end

	if table.contains({
		UNIT_SIZE_MEDIUM,
		UNIT_SIZE_LARGE
	}, target.unit.size) then
		s.prefix = s.prefix .. "_big"
	end

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_item_winter_age_freeze.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local s = this.render.sprites[1]
	local is_flying = U.flag_has(target.vis.flags, F_FLYING)
	local is_exo = false

	for k, v in pairs(target.render.sprites) do
		if v.exo then
			is_exo = true

			break
		end
	end

	local es = E:create_entity(this.freeze_decal_name)

	if not is_exo then
		this._decal_freeze = es
		es.pos.x, es.pos.y = target.pos.x, target.pos.y
		es.render.sprites[1] = table.deepclone(target.render.sprites[1])
		local sprite1 = es.render.sprites[1]
		sprite1.shader = es.shader
		sprite1.shader_args = es.shader_args
		sprite1.animated = false
		sprite1.prefix = nil
		sprite1.name = this._entity_frame_names[1]

		queue_insert(store, es)
		coroutine.yield()
		U.sprites_hide(target, nil, nil, true)
	end

	start_ts = store.tick_ts

	if m.animation_phases and not is_flying then
		U.animation_start(this, "start", nil, store.tick_ts)

		while not U.animation_finished(this) do
			if not target_hidden and m.hide_target_delay and store.tick_ts - start_ts > m.hide_target_delay then
				target_hidden = true

				if target.ui then
					target.ui.can_click = false
				end

				if target.health_bar then
					target.health_bar.hidden = true
				end

				U.sprites_hide(target, nil, nil, true)
				SU.hide_modifiers(store, target, true, this)
				SU.hide_auras(store, target, true)
			end

			coroutine.yield()
		end
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
		if this.render and m.use_mod_offset and target.unit.mod_offset and not m.custom_offsets then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	if m.animation_phases and not is_flying then
		U.animation_start(this, "end", nil, store.tick_ts)

		if target_hidden then
			if target.ui then
				target.ui.can_click = true
			end

			if target.health_bar and not target.health.dead then
				target.health_bar.hidden = nil
			end

			U.sprites_show(target, nil, nil, true)
			SU.show_modifiers(store, target, true, this)
			SU.show_auras(store, target, true)
		end

		while not U.animation_finished(this) and not target.health.dead do
			coroutine.yield()
		end
	else
		U.y_wait(store, fts(17), function()
			return target.health.dead
		end)
	end

	if target then
		if not target.health.dead or not target.unit.hide_during_death then
			U.sprites_show(target, nil, nil, true)
		end

		SU.stun_dec(target)
	end

	if not is_exo then
		queue_remove(store, es)
	end

	this._not_interrupted = true

	queue_remove(store, this)
end

scripts.controller_item_medical_kit = {}

function scripts.controller_item_medical_kit.can_fire_fn(this, x, y, store)
	return true
end

function scripts.controller_item_medical_kit.insert(this, store)
	signal.emit("medical-kit", this.pos, this.hearts)
	S:queue(this.sound_cast)

	return false
end

scripts.controller_item_summon_blackburn = {}

function scripts.controller_item_summon_blackburn.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.controller_item_summon_blackburn.insert(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	}, true)

	if #nodes < 1 then
		return false
	end

	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)

	S:queue(this.sound_cast)

	local blackburn = E:create_entity(this.blackburn)

	blackburn.pos = V.vclone(npos)
	blackburn.nav_rally.center = V.vclone(blackburn.pos)
	blackburn.nav_rally.pos = V.vclone(blackburn.pos)
	blackburn.reinforcement.squad_id = blackburn.id

	queue_insert(store, blackburn)

	return false
end

scripts.soldier_reinforcement_item_summon_blackburn = {}

function scripts.soldier_reinforcement_item_summon_blackburn.update(this, store, script)
	local brk, sta

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].hidden = false

	local a = this.melee.attacks
	local ba = a[1]

	ba.ts = store.tick_ts - ba.cooldown

	local sa = this.timed_attacks.list[1]

	sa.ts = store.tick_ts - sa.cooldown

	U.animation_start(this, "in", nil, store.tick_ts, false)
	U.y_wait(store, fts(2))

	local shake = E:create_entity("aura_screen_shake")

	shake.aura.amplitude = 0.4
	shake.aura.duration = 1
	shake.aura.freq_factor = 2

	queue_insert(store, shake)

	local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, this.spawn_damage_radius, this.spawn_vis_flags, this.spawn_vis_bans)

	if enemies and #enemies > 0 then
		for _, enemy in pairs(enemies) do
			local d = E:create_entity("damage")

			d.damage_type = this.spawn_damage_type
			d.value = math.random(this.spawn_damage_min, this.spawn_damage_max)
			d.source_id = this.id
			d.target_id = enemy.id

			queue_damage(store, d)

			local fx = E:create_entity(ba.hit_fx)

			fx.pos = V.vclone(enemy.pos)
			fx.pos.x, fx.pos.y = fx.pos.x + enemy.unit.hit_offset.x, fx.pos.y + enemy.unit.hit_offset.y
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local mod = E:create_entity(this.spawn_mod)

			mod.modifier.target_id = enemy.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)
		end
	end

	U.y_animation_wait(this)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			this.reinforcement.hp_before_timeout = this.health.hp
			this.health.hp = 0

			SU.remove_modifiers(store, this)

			this.ui.can_click = false
			this.ui.z = -1

			U.unblock_target(store, this)
			U.y_animation_play(this, "out", nil, store.tick_ts, 1)

			this.health.death_finished_ts = store.tick_ts
			this.render.sprites[1].hidden = true

			queue_remove(store, this)
			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
			goto label_183_1
		end

		while this.nav_rally.new do
			if SU.y_hero_new_rally(store, this) then
				goto label_183_1
			end
		end

		if store.tick_ts - sa.ts > sa.cooldown then
			local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, sa.min_range, sa.max_range, sa.hit_time, sa.vis_flags, sa.vis_bans)

			if not target or not pred_pos then
				-- block empty
			else
				sa.ts = store.tick_ts
				ba.ts = store.tick_ts

				local flip_x = pred_pos.x < this.pos.x

				U.animation_start(this, sa.animation, flip_x, store.tick_ts, false)
				U.y_wait(store, sa.decal_time)

				local decal = E:create_entity(sa.decal)

				decal.pos = V.vclone(pred_pos)
				decal.render.sprites[1].ts = store.tick_ts

				queue_insert(store, decal)
				U.y_wait(store, sa.hit_time - sa.decal_time)
				S:queue(sa.sound)

				local fx = E:create_entity(sa.fx)

				fx.pos = V.vclone(pred_pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)

				local enemies = U.find_enemies_in_range(store.entities, pred_pos, 0, sa.damage_radius, sa.vis_flags, sa.vis_bans)

				if enemies and #enemies > 0 then
					for _, enemy in pairs(enemies) do
						local d = E:create_entity("damage")

						d.damage_type = sa.damage_type
						d.value = math.random(sa.damage_min, sa.damage_max)
						d.source_id = this.id
						d.target_id = enemy.id

						queue_damage(store, d)

						local fx = E:create_entity(sa.hit_fx)

						fx.pos = V.vclone(enemy.pos)
						fx.pos.x, fx.pos.y = fx.pos.x + enemy.unit.hit_offset.x, fx.pos.y + enemy.unit.hit_offset.y
						fx.render.sprites[1].ts = store.tick_ts

						queue_insert(store, fx)
					end
				end

				U.y_animation_wait(this)
			end
		end

		brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)
		if brk or sta ~= A_NO_TARGET then
			goto label_183_1
		end

		if SU.soldier_go_back_step(store, this) then
			goto label_183_1
		end

		-- if store.tick_ts - ba.ts > ba.cooldown then
		-- 	local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, ba.damage_radius, ba.hit_time, ba.vis_flags, ba.vis_bans)

		-- 	if not target or not pred_pos then
		-- 		goto label_183_0
		-- 	end

		-- 	ba.ts = store.tick_ts

		-- 	S:queue(ba.sound)

		-- 	local flip_x = pred_pos.x < this.pos.x

		-- 	U.animation_start(this, ba.animation, flip_x, store.tick_ts, false)
		-- 	U.y_wait(store, ba.hit_time)

		-- 	local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, ba.damage_radius + 10, ba.vis_flags, ba.vis_bans, function(e, o)
		-- 		if flip_x then
		-- 			return e.pos.x <= this.pos.x + 15
		-- 		else
		-- 			return e.pos.x >= this.pos.x - 15
		-- 		end
		-- 	end)

		-- 	if enemies and #enemies > 0 then
		-- 		for _, enemy in pairs(enemies) do
		-- 			local d = E:create_entity("damage")

		-- 			d.damage_type = ba.damage_type
		-- 			d.value = math.random(ba.damage_min, ba.damage_max)
		-- 			d.source_id = this.id
		-- 			d.target_id = enemy.id

		-- 			queue_damage(store, d)

		-- 			local fx = E:create_entity(ba.hit_fx)

		-- 			fx.pos = V.vclone(enemy.pos)
		-- 			fx.pos.x, fx.pos.y = fx.pos.x + enemy.unit.hit_offset.x, fx.pos.y + enemy.unit.hit_offset.y
		-- 			fx.render.sprites[1].ts = store.tick_ts

		-- 			queue_insert(store, fx)
		-- 		end
		-- 	end

		-- 	U.y_animation_wait(this)
		-- end

		::label_183_0::

		SU.soldier_idle(store, this)
		SU.soldier_regen(store, this)

		::label_183_1::

		coroutine.yield()
	end
end

scripts.controller_item_veznan_wrath = {}

function scripts.controller_item_veznan_wrath.can_fire_fn(this, x, y, store)
	return true
end

function scripts.controller_item_veznan_wrath.update(this, store)
	signal.emit("veznan-wrath-starts")

	local controller_overlay = E:create_entity(this.controller_overlay)

	queue_insert(store, controller_overlay)

	local controller_explosions = E:create_entity(this.controller_explosions)

	queue_insert(store, controller_explosions)
	U.y_wait(store, fts(10))
	signal.emit("veznan-wrath-enter-veznan")
	S:queue(this.sound_in)
	U.y_wait(store, fts(18))
	S:queue(this.sound_initial_burst)

	controller_overlay.blink = true
	controller_explosions.start = true

	local start_blink_ts = store.tick_ts
	local shake = E:create_entity("aura_screen_shake")

	shake.aura.amplitude = 0.4
	shake.aura.duration = this.blink_duration
	shake.aura.freq_factor = 2

	queue_insert(store, shake)

	local targets = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.vis_bans) == 0 and band(v.vis.bans, this.vis_flags) == 0 and (not this.allowed_templates or table.contains(this.allowed_templates, v.template_name)) and (not this.excluded_templates or not table.contains(this.excluded_templates, v.template_name)) and (v.template_name ~= "enemy_crystal_golem" or v.render.sprites[1].name ~= "holder")
	end)

	if targets and #targets > 0 then
		for i = #targets, 2, -1 do
			local j = math.random(i)

			targets[i], targets[j] = targets[j], targets[i]
		end

		local delay_between = 10 / #targets

		for _, enemy in ipairs(targets) do
			S:queue(this.sound_explosion)

			if band(enemy.vis.flags, F_FLYING) ~= 0 then
				local fx = E:create_entity(this.fx_instakill_air)

				fx.pos = V.vclone(enemy.pos)
				fx.pos.x, fx.pos.y = fx.pos.x + enemy.unit.hit_offset.x, fx.pos.y + enemy.unit.hit_offset.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			else
				local fx = E:create_entity(this.fx_instakill_ground)

				fx.pos = V.vclone(enemy.pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)

				local decal = E:create_entity(this.decal_instakill_ground)

				decal.pos = V.vclone(enemy.pos)
				decal.render.sprites[1].ts = store.tick_ts

				queue_insert(store, decal)
			end

			enemy.health.ignore_damage = nil

			local d = E:create_entity("damage")

			d.source_id = this.id
			d.target_id = enemy.id
			d.value = math.random(this.damage_min, this.damage_max)

			if d.value > enemy.health.hp then
				d.damage_type = bor(DAMAGE_INSTAKILL, DAMAGE_NO_SPAWNS)
				enemy.unit.can_explode = false
				enemy.unit.death_animation = nil
				enemy.unit.hide_during_death = true
			else
				d.damage_type = DAMAGE_PHYSICAL
			end

			queue_damage(store, d)
			U.y_wait(store, fts(math.random(delay_between / 2, delay_between * 2)))
		end
	end

	while store.tick_ts - start_blink_ts < this.blink_duration do
		coroutine.yield()
	end

	controller_overlay.blink = false
	controller_explosions.finish = true

	U.y_wait(store, fts(16))
	signal.emit("veznan-wrath-ends")
	queue_remove(store, this)
end

scripts.controller_item_veznan_wrath_overlay = {}

function scripts.controller_item_veznan_wrath_overlay.update(this, store)
	while not this.blink do
		coroutine.yield()
	end

	local last_blink_ts = store.tick_ts
	local blink_cd = math.random(fts(3), fts(5))

	while this.blink do
		if blink_cd < store.tick_ts - last_blink_ts then
			signal.emit("veznan-wrath-blink")

			last_blink_ts = store.tick_ts
			blink_cd = math.random(fts(3), fts(5))
		end

		coroutine.yield()
	end

	signal.emit("veznan-wrath-stop-blink")
	queue_remove(store, this)
end

scripts.controller_item_veznan_wrath_explosions = {}

function scripts.controller_item_veznan_wrath_explosions.update(this, store)
	while not this.start do
		coroutine.yield()
	end

	local last_explosion_ts = store.tick_ts
	local explosion_cd = math.random(fts(1), fts(2))
	local explosions = 30
	local explosions_pos = {}
	local explosions_sqrt = math.ceil(math.sqrt(explosions))

	for i = 0, explosions_sqrt - 1 do
		local x_aux = 1024 * (i / explosions_sqrt)

		for j = 1, explosions_sqrt do
			local y_aux = 768 * (j / explosions_sqrt)

			explosions_pos[i * explosions_sqrt + j] = v(x_aux, y_aux)
		end
	end

	for i = #explosions_pos, 2, -1 do
		local j = math.random(i)

		explosions_pos[i], explosions_pos[j] = explosions_pos[j], explosions_pos[i]
	end

	local exp_id = 1

	while not this.finish do
		if explosion_cd < store.tick_ts - last_explosion_ts then
			local exp_x, exp_y = explosions_pos[exp_id].x, explosions_pos[exp_id].y

			if GR:cell_is_only(exp_x, exp_y, TERRAIN_LAND) then
				local nodes = P:nearest_nodes(exp_x, exp_y, nil, {
					1
				}, true)
				local pi, spi, ni = unpack(nodes[1])
				local fx = E:create_entity(this.fx_explosion)

				fx.pos = P:node_pos(pi, spi, ni)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)

				last_explosion_ts = store.tick_ts
				explosion_cd = math.random(fts(1), fts(2))
			end

			exp_id = exp_id + 1

			if explosions < exp_id then
				exp_id = 1
			end
		end

		coroutine.yield()
	end

	signal.emit("veznan-wrath-stop-blink")
	queue_remove(store, this)
end

scripts.hero_muyrn = {}

function scripts.hero_muyrn.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local bt = E:get_template(this.ranged.attacks[1].bullet)

	bt.bullet.damage_min = ls.ranged_damage_min[hl]
	bt.bullet.damage_max = ls.ranged_damage_max[hl]

	local s, sl

	s = this.hero.skills.sentinel_wisps
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - SENTINEL WISPS - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.max_summons = s.max_summons[sl]

		local e = E:get_template(a.entity)

		e.duration = s.wisp_duration[sl]

		local b = E:get_template(e.ranged.attacks[1].bullet)

		b.bullet.damage_min = s.wisp_damage_min[sl]
		b.bullet.damage_max = s.wisp_damage_max[sl]
	end

	s = this.hero.skills.verdant_blast
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - VERDANT BLAST - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.leaf_whirlwind
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - LEAF WHIRLWIND - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local aura = E:get_template(a.aura)

		aura.aura.duration = s.duration[sl]
		aura.aura.damage_min = s.damage_min[sl]
		aura.aura.damage_max = s.damage_max[sl]

		local mod = E:get_template(a.mod)

		mod.modifier.duration = s.duration[sl]
		mod.hps.heal_min = s.heal_min[sl]
		mod.hps.heal_max = s.heal_max[sl]
	end

	s = this.hero.skills.faery_dust
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - FAERY DUST - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local aura = E:get_template(a.aura)
		local mod = E:get_template(aura.aura.mods[1])

		mod.inflicted_damage_factor = s.damage_factor[sl]
		mod.modifier.duration = s.duration[sl]

		local mod_fx = E:get_template(aura.aura.mods[2])

		mod_fx.modifier.duration = fts(26)
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local a = E:get_template(uc.aura)
		local m_slow = E:get_template(a.aura.mods[1])

		m_slow.slow.factor = s.slow_factor[sl]

		local m_damage = E:get_template(a.aura.mods[2])

		m_damage.dps.damage_min = s.damage_min[sl]
		m_damage.dps.damage_max = s.damage_max[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_muyrn.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)
	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_muyrn.update(this, store)
	local h = this.health
	local a, skill, brk, sta
	local original_speed = this.motion.max_speed

	local function distribute_summons(x, y, qty)
		local positions = {}
		local offset_options = {
			{
				{
					0,
					20
				}
			},
			{
				{
					-20,
					0
				},
				{
					20,
					0
				}
			},
			{
				{
					0,
					15
				},
				{
					-20,
					0
				},
				{
					20,
					0
				}
			}
		}
		local offsets = offset_options[qty]

		for _, offset in ipairs(offsets) do
			if qty <= #positions then
				break
			end

			local pos = V.v(x + offset[1], y + offset[2])

			table.insert(positions, pos)
		end

		return positions
	end

	local function shoot_bullet(attack, enemy, dest, flying)
		local b = E:create_entity(attack.bullet)

		b.pos.x, b.pos.y = this.pos.x + attack.bullet_start_offset.x, this.pos.y + attack.bullet_start_offset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = dest
		b.bullet.target_id = enemy and enemy.id
		b.bullet.source_id = this.id

		if flying then
			b.bullet.ignore_hit_offset = false
			b.bullet.hit_fx = b.bullet.hit_fx_flying
			b.bullet.hit_decal = nil
			b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		end

		queue_insert(store, b)

		return b
	end

	this.health_bar.hidden = false

	local treewalk_trail = E:create_entity(this.treewalk.trail)

	treewalk_trail.particle_system.track_id = this.id
	treewalk_trail.particle_system.emit = false

	queue_insert(store, treewalk_trail)

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			while this.nav_rally.new do
				local r = this.nav_rally
				local tw = this.treewalk
				local force_treewalk = false

				for _, p in pairs(this.nav_grid.waypoints) do
					if GR:cell_is(p.x, p.y, bor(TERRAIN_WATER, TERRAIN_SHALLOW, TERRAIN_NOWALK)) then
						force_treewalk = true

						break
					end
				end

				if force_treewalk or V.dist(this.pos.x, this.pos.y, r.pos.x, r.pos.y) > tw.min_distance then
					r.new = false

					U.unblock_target(store, this)

					local vis_bans = this.vis.bans

					this.vis.bans = F_ALL
					this.health.immune_to = F_ALL

					local treewalk_extra_speed_factor = (original_speed + tw.extra_speed) / original_speed

					this.motion.max_speed = this.motion.max_speed * treewalk_extra_speed_factor
					this.unit.marker_hidden = true
					this.health_bar.hidden = true

					S:queue(this.sound_events.change_rally_point)
					S:queue(this.treewalk.sound)

					treewalk_trail.particle_system.emit = true

					::label_192_0::

					local dest = r.pos
					local n = this.nav_grid

					while not V.veq(this.pos, dest) do
						local w = table.remove(n.waypoints, 1) or dest

						U.set_destination(this, w)

						local an, af = U.animation_name_facing_point(this, tw.animations[1], this.motion.dest)

						U.animation_start(this, an, af, store.tick_ts, true)

						while not this.motion.arrived do
							if r.new then
								r.new = false

								goto label_192_0
							end

							U.walk(this, store.tick_length)
							coroutine.yield()

							this.motion.speed.x, this.motion.speed.y = 0, 0
						end
					end

					treewalk_trail.particle_system.emit = false

					S:stop(this.treewalk.sound)
					SU.hide_modifiers(store, this, true)
					U.y_animation_play(this, tw.animations[2], nil, store.tick_ts)
					SU.show_modifiers(store, this, true)

					this.motion.max_speed = this.motion.max_speed / treewalk_extra_speed_factor
					this.vis.bans = vis_bans
					this.health.immune_to = 0
					this.unit.marker_hidden = nil
					this.health_bar.hidden = nil
				elseif SU.y_hero_new_rally(store, this) then
					goto label_192_1
				end
			end

			skill = this.hero.skills.sentinel_wisps
			a = this.timed_attacks.list[1]

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_trigger, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)
					U.animation_start(this, a.animation, nil, store.tick_ts, false)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_192_1
					end

					a.ts = start_ts

					SU.hero_gain_xp_from_skill(this, skill)

					local positions = distribute_summons(this.pos.x, this.pos.y, a.max_summons)

					for i, pos in ipairs(positions) do
						local e = E:create_entity(a.entity)

						e.pos = pos
						e.owner_id = this.id
						e.wisp_order = i

						queue_insert(store, e)
					end

					SU.y_hero_animation_wait(this)
				end
			end

			skill = this.hero.skills.leaf_whirlwind
			a = this.timed_attacks.list[2]

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_trigger, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)

					a.ts = start_ts

					SU.hero_gain_xp_from_skill(this, skill)

					local aura = E:create_entity(a.aura)

					aura.aura.source_id = this.id
					aura.aura.ts = store.tick_ts
					aura.pos = this.pos

					queue_insert(store, aura)

					local aura_decal = E:create_entity(a.aura_decal)

					aura_decal.duration = aura.aura.duration
					aura_decal.pos = this.pos
					aura_decal.source_id = this.id

					queue_insert(store, aura_decal)

					local mod = E:create_entity(a.mod)

					mod.modifier.source_id = this.id
					mod.modifier.target_id = this.id

					queue_insert(store, mod)
				end
			end

			skill = this.hero.skills.faery_dust
			a = this.timed_attacks.list[3]

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local _, enemies = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range_trigger, false, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local aim_target, _ = U.find_entity_most_surrounded(enemies)
					local start_ts = store.tick_ts

					S:queue(a.sound)

					local an, af, ai = U.animation_name_facing_point(this, a.animation, aim_target.pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_192_1
					end

					a.ts = start_ts

					SU.hero_gain_xp_from_skill(this, skill)

					local _, enemies = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range_effect, false, a.vis_flags, a.vis_bans)

					if enemies then
						aim_target, _ = U.find_entity_most_surrounded(enemies)
					end

					local aura = E:create_entity(a.aura)

					aura.aura.source_id = this.id
					aura.aura.ts = store.tick_ts
					aura.aura.level = skill.level

					local ni = aim_target.nav_path.ni + P:predict_enemy_node_advance(aim_target, a.node_prediction)

					aura.pos = P:node_pos(aim_target.nav_path.pi, 1, ni)
					aura.pos_pi = aim_target.nav_path.pi
					aura.pos_ni = ni

					queue_insert(store, aura)
					SU.y_hero_animation_wait(this)
				end
			end

			skill = this.hero.skills.verdant_blast
			a = this.timed_attacks.list[4]

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

				if not enemies then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts
					local enemy = enemies[1]
					local enemy_pos = V.vclone(enemy.pos)

					S:queue(a.sound)

					a.ts = start_ts

					SU.hero_gain_xp_from_skill(this, skill)

					local an, af, _ = U.animation_name_facing_point(this, a.animation, enemy_pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					if SU.y_hero_wait(store, this, a.shoot_time) then
						goto label_192_1
					end

					enemies = U.find_enemies_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

					if enemies and #enemies > 0 then
						enemy = enemies[1]
						enemy_pos = V.vclone(enemy.pos)
					end

					local flip_x = enemy_pos.x - this.pos.x < 0

					this.render.sprites[1].flip_x = flip_x

					local flying = U.flag_has(enemy.vis.flags, F_FLYING)

					shoot_bullet(a, enemy, enemy_pos, flying)

					for _, aa in pairs(this.ranged.attacks) do
						aa.ts = store.tick_ts
					end

					SU.y_hero_animation_wait(this)
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				brk, sta = y_hero_ranged_attacks(store, this)

				if brk then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_192_1::

		coroutine.yield()
	end
end

scripts.bullet_hero_muyrn_verdant_blast = {}

function scripts.bullet_hero_muyrn_verdant_blast.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	::label_195_0::

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

		if ps then
			ps.particle_system.emit = true
		end
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		if target and target.health and not target.health.dead then
			if b.ignore_hit_offset then
				b.to.x, b.to.y = target.pos.x, target.pos.y
			else
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end

			new_target = false
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end
	end

	while b.store and not b.target_id do
		coroutine.yield()

		if b.target_id then
			mspeed = b.min_speed
			new_target = true

			goto label_195_0
		end
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y

	S:queue(this.sound)

	if target and b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, target.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)
		if targets then
			for _, target in ipairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)
				queue_damage(store, d)
				if b.mod or b.mods then
					local mods = b.mods or {
						b.mod
					}
					for _, mod_name in ipairs(mods) do
						local m = E:create_entity(mod_name)
						m.modifier.target_id = target.id
						m.modifier.level = b.level
						queue_insert(store, m)
					end
				end
			end
		end
	elseif target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)
		queue_damage(store, d)
		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}
			for _, mod_name in ipairs(mods) do
				local m = E:create_entity(mod_name)
				m.modifier.target_id = b.target_id
				m.modifier.level = b.level
				queue_insert(store, m)
			end
		end

		if b.hit_payload then
			local hp = b.hit_payload
			hp.pos.x, hp.pos.y = this.pos.x, this.pos.y
			queue_insert(store, hp)
		end
	end

	if b.payload then
		local hp = b.payload

		hp.pos.x, hp.pos.y = b.to.x, b.to.y

		queue_insert(store, hp)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.mod_hero_muyrn_faery_dust_fx = {}

function scripts.mod_hero_muyrn_faery_dust_fx.insert(this, store)
	if this.render.sprites[1].size_scales then
		local target = store.entities[this.modifier.target_id]

		this.render.sprites[1].scale = this.render.sprites[1].size_scales[target.unit.size]
	end

	return true
end

scripts.hero_muyrn_ranged_attack_bullet = {}

function scripts.hero_muyrn_ranged_attack_bullet.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local pred_pos

	if target then
		pred_pos = P:predict_enemy_pos(target, fts(5))
	else
		pred_pos = b.to
	end

	local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			local d = math.max(math.abs(target.pos.x + hit_offset.x - b.to.x), math.abs(target.pos.y + hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)
	elseif b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	this.render.sprites[1].hidden = true

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.hero_muyrn_sentinel_wisps_entity = {}

function scripts.hero_muyrn_sentinel_wisps_entity.insert(this, store, script)
	this.ranged.attacks[1].cooldown = this.ranged.attacks[1].cooldown * (0.9 + math.random(1, 2) / 10)
	this.hero_max_distance = this.hero_max_distance * (0.7 + math.random(1, 3) / 10)
	this.force_motion.max_a = this.force_motion.max_a * (0.1 + math.random(1, 9) / 10)
	this.force_motion.a_step = this.force_motion.a_step * (1 + 0.9 * this.wisp_order)
	this.force_motion.max_a = this.force_motion.max_a * (1 + 10 * this.wisp_order)

	return true
end

function scripts.hero_muyrn_sentinel_wisps_entity.update(this, store, script)
	local sb_sid = 1
	local sb = this.render.sprites[sb_sid]
	local fm = this.force_motion
	local hero = store.entities[this.owner_id]
	local dest = V.v(this.pos.x, this.pos.y)
	local offset_x = this.pos.x - hero.pos.x
	local offset_y = this.pos.y - hero.pos.y
	local a = this.ranged.attacks[1]

	this.render.sprites[1].hidden = true
	this.render.sprites[2].hidden = true

	U.y_wait(store, this.wisp_order * fts(6))

	this.render.sprites[1].hidden = false
	this.render.sprites[2].hidden = false

	local spawn_ts = store.tick_ts

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	local starting_offset = V.v(offset_x, offset_y)
	local starting_pos = V.vclone(this.pos)
	local positions = {
		{
			{
				0,
				starting_offset
			},
			{
				0.2,
				V.v(offset_x, offset_y + 20)
			},
			{
				0.5,
				V.v(offset_x + 5, offset_y - 10)
			},
			{
				0.7,
				V.v(offset_x - 5, offset_y)
			},
			{
				0.8,
				V.v(offset_x, offset_y + 5)
			},
			{
				1,
				starting_offset
			}
		},
		{
			{
				0,
				starting_offset
			},
			{
				0.2,
				V.v(offset_x, offset_y - 20)
			},
			{
				0.5,
				V.v(offset_x - 5, offset_y - 10)
			},
			{
				0.7,
				V.v(offset_x + 5, offset_y)
			},
			{
				0.8,
				V.v(offset_x, offset_y + 5)
			},
			{
				1,
				starting_offset
			}
		},
		{
			{
				0,
				starting_offset
			},
			{
				0.2,
				V.v(offset_x - 10, offset_y)
			},
			{
				0.5,
				V.v(offset_x + 5, offset_y + 10)
			},
			{
				0.7,
				V.v(offset_x - 5, offset_y)
			},
			{
				0.8,
				V.v(offset_x, offset_y + 5)
			},
			{
				1,
				starting_offset
			}
		}
	}

	local function current_phase(phase)
		local last_i = 1

		for i, value in ipairs(positions[this.wisp_order]) do
			if phase < value[1] then
				if i > 1 then
					last_i = i - 1
				end

				break
			end
		end

		return last_i
	end

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local ramp_radius = fm.ramp_radius
		local df = (not ramp_radius or ramp_radius < dist) and 1 or math.max(dist / ramp_radius, 0.1)

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step * df, dx, dy)))
		fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
		fm.v.x, fm.v.y = V.trim(fm.max_v, fm.v.x, fm.v.y)
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = V.mul(-1 * fm.fr / store.tick_length, fm.v.x, fm.v.y)
	end

	if this.particles_name then
		local ps = E:create_entity(this.particles_name)

		ps.particle_system.track_id = this.id
		ps.particle_system.track_offset = V.v(0, this.flight_height)

		queue_insert(store, ps)
	end

	S:queue(this.sound)
	U.y_animation_play(this, "spawn", nil, store.tick_ts)

	local effect_x, effect_y

	local function recalculate_offset()
		local phase = (store.tick_ts - spawn_ts) / this.duration
		local current_phase_i = current_phase(phase)
		local last_phase_i = current_phase_i - 1

		if last_phase_i < 1 then
			last_phase_i = 1
		end

		local to = positions[this.wisp_order][current_phase_i][2]
		local easing = "quad-inout"
		local new_pos_x = U.ease_value(this.pos.x, this.pos.x + to.x, phase, easing)
		local new_pos_y = U.ease_value(this.pos.y, this.pos.y + to.y, phase, easing)

		effect_x = new_pos_x - this.pos.x
		effect_y = new_pos_y - this.pos.y
	end

	while true do
		if store.tick_ts - spawn_ts > this.duration then
			this.tween.reverse = true
			this.tween.ts = store.tick_ts

			U.y_animation_play(this, "death", nil, store.tick_ts)

			break
		end

		recalculate_offset()

		dest.x = hero.pos.x + offset_x + effect_x
		dest.y = hero.pos.y + offset_y + effect_y

		move_step(dest)

		if not (store.tick_ts - a.ts > a.cooldown) or not hero or hero.health.dead then
			-- block empty
		else
			local target, _ = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, false, a.vis_flags, a.vis_bans)

			if target and target.health and not target.health.dead then
				local b = E:create_entity(a.bullet)

				b.pos.x, b.pos.y = this.pos.x + sb.offset.x, this.pos.y + sb.offset.y
				b.bullet.from = V.vclone(b.pos)
				b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
				b.bullet.target_id = target.id
				b.bullet.source_id = this.id

				queue_insert(store, b)

				a.ts = store.tick_ts

				local sfx = E:create_entity(this.attack_fx)

				sfx.pos = this.pos
				sfx.render.sprites[1].ts = store.tick_ts
				sfx.render.sprites[1].runs = 0
				sfx.render.sprites[1].offset = v(0, this.flight_height)

				queue_insert(store, sfx)
			end
		end

		U.animation_start(this, "idle", nil, store.tick_ts, true, sb_sid)
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.hero_muyrn_leaf_whirlwind_decal = {}

function scripts.hero_muyrn_leaf_whirlwind_decal.update(this, store, script)
	local start_ts = store.tick_ts

	U.y_animation_play(this, "start", nil, store.tick_ts)
	U.animation_start(this, "loop", nil, store.tick_ts, true)

	while store.tick_ts - start_ts < this.duration and not this.force_end_animation do
		local te = store.entities[this.source_id]

		if not te or te.health and te.health.dead then
			break
		end

		coroutine.yield()
	end

	U.y_animation_play(this, "end", nil, store.tick_ts, 1)
	queue_remove(store, this)
end

scripts.hero_muyrn_root_defender_aura = {}

function scripts.hero_muyrn_root_defender_aura.insert(this, store)
	local function insert_root(pos, duration)
		local fx = E:create_entity(this.root_decal .. "_" .. math.random(1, 2, 3))

		fx.render.sprites[1].flip_x = math.random() < 0.5
		fx.delay = U.frandom(0, 0.3)
		fx.pos = pos
		fx.duration = duration

		queue_insert(store, fx)
	end

	this.aura.ts = store.tick_ts
	this.aura.duration = this.duration[this.aura.level]
	this.actual_duration = this.duration[this.aura.level]

	local roots_count = this.roots_count[this.aura.level]
	local root_rows = math.floor(roots_count / 3)
	local ni_inc = 2
	local pi = this.pos_pi
	local ni = this.pos_ni + math.floor((ni_inc + 2.5) * root_rows / 2)

	for i = 1, roots_count do
		local spi = km.zmod(i, 3)

		if P:is_node_valid(pi, ni) then
			local pos = P:node_pos(pi, spi, ni)

			pos.x, pos.y = pos.x + math.random(0, 8), pos.y + math.random(0, 8)

			insert_root(pos, this.actual_duration)
		end

		if i % 3 == 0 then
			ni = ni - ni_inc - math.random(2, 3)
		end
	end

	return true
end

function scripts.hero_muyrn_root_defender_aura.remove(this, store)
	S:queue(this.end_sound)

	return true
end

scripts.hero_muyrn_root_defender_aura_sides = {}

function scripts.hero_muyrn_root_defender_aura_sides.insert(this, store)
	this.aura.ts = store.tick_ts
	this.aura.duration = this.duration[this.aura.level]
	this.actual_duration = this.duration[this.aura.level]

	return true
end

scripts.hero_muyrn_root_defender_root_decal = {}

function scripts.hero_muyrn_root_defender_root_decal.update(this, store)
	if this.delay then
		U.y_wait(store, this.delay)
	end

	local start_ts = store.tick_ts

	this.render.sprites[1].hidden = nil

	U.y_animation_play(this, "start", nil, store.tick_ts)

	while store.tick_ts - start_ts < this.duration do
		if U.find_first_target(store.entities, this.pos, 0, 25, this.vis_flags, this.vis_bans) then
			U.y_animation_play(this, "loop", nil, store.tick_ts, 1)
		end

		coroutine.yield()
	end

	U.y_animation_play(this, "end", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.hero_muyrn_ultimate = {}

function scripts.hero_muyrn_ultimate.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_muyrn_ultimate.update(this, store)
	local aura = E:create_entity(this.aura)

	aura.aura.source_id = this.id
	aura.aura.ts = store.tick_ts
	aura.aura.level = this.level

	local available_paths = {}

	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end

	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, function(k, v)
			return not table.contains(store.level.ignore_walk_backwards_paths, v) and P:is_path_active(v)
		end)
	end

	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, available_paths, nil, true)

	if #nodes < 1 then
		log.debug("cannot insert muyrn ulti, no valid nodes nearby %s,%s", x, y)

		return nil
	end

	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)

	aura.pos = npos
	aura.pos_pi = pi
	aura.pos_ni = ni

	local aura_left = E:create_entity(this.aura_sides)

	aura_left.aura.source_id = this.id
	aura_left.aura.ts = store.tick_ts
	aura_left.aura.level = this.level

	local npos = P:node_pos(pi, spi, ni + 5)

	aura_left.pos = npos
	aura_left.pos_pi = pi
	aura_left.pos_ni = ni

	local aura_right = E:create_entity(this.aura_sides)

	aura_right.aura.source_id = this.id
	aura_right.aura.ts = store.tick_ts
	aura_right.aura.level = this.level

	local npos = P:node_pos(pi, spi, ni - 5)

	aura_right.pos = npos
	aura_right.pos_pi = pi
	aura_right.pos_ni = ni

	S:queue(this.sounds[this.level])
	queue_insert(store, aura)
	queue_insert(store, aura_left)
	queue_insert(store, aura_right)
	queue_remove(store, this)
end

scripts.bolt_lumenir = {}

function scripts.bolt_lumenir.insert(this, store)
	return true
end

function scripts.bolt_lumenir.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local pred_pos

	if target then
		pred_pos = P:predict_enemy_pos(target, fts(5))
	else
		pred_pos = b.to
	end

	local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local d = math.max(math.abs(target.pos.x + target.unit.hit_offset.x - b.to.x), math.abs(target.pos.y + target.unit.hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle * (b.shot_index % 2 == 0 and 1 or -1), iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)
		local u = UP:get_upgrade("mage_el_empowerment")

		if u and not this.upgrades_disabled and math.random() < u.chance then
			d.value = km.round(d.value * u.damage_factor)

			if b.pop_mage_el_empowerment then
				d.pop = b.pop_mage_el_empowerment
				d.pop_conds = DR_DAMAGE
			end
		end

		queue_damage(store, d)

		if this.alter_reality_chance and UP:has_upgrade("mage_el_alter_reality") and math.random() < this.alter_reality_chance then
			local mod = E:create_entity(this.alter_reality_mod)

			mod.modifier.target_id = target.id

			queue_insert(store, mod)
		end
	elseif b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	this.render.sprites[1].hidden = true

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.hero_lumenir = {}

function scripts.hero_lumenir.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]

	local b = E:get_template(this.ranged.attacks[1].bullet)

	b.bullet.damage_max = ls.ranged_damage_max[hl]
	b.bullet.damage_min = ls.ranged_damage_min[hl]

	local b = E:get_template("bolt_lumenir_mini_death")

	b.bullet.damage_max = ls.ranged_damage_max[hl]
	b.bullet.damage_min = ls.ranged_damage_min[hl]

	local s

	s = this.hero.skills.shield

	if initial and s.level > 0 then
		local a = this.ranged.attacks[2]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]

		local m = E:get_template(a.mod)

		m.spiked_armor = s.spiked_armor[s.level]
		m.armor = s.armor[s.level]
		m.modifier.duration = s.duration[s.level]
	end

	s = this.hero.skills.celestial_judgement

	if initial and s.level > 0 then
		local a = this.ranged.attacks[3]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]
	end

	s = this.hero.skills.mini_dragon

	if initial and s.level > 0 then
		local a = this.ranged.attacks[4]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]

		local e = E:get_template(a.entity)

		a.duration = s.duration[s.level]

		local b = E:get_template("bolt_lumenir_mini")

		b.bullet.damage_min = s.damage_min[s.level]
		b.bullet.damage_max = s.damage_max[s.level]
	end

	s = this.hero.skills.fire_balls

	if initial and s.level > 0 then
		local a = this.ranged.attacks[5]

		a.cooldown = s.cooldown[s.level]
		a.disabled = nil
		a.count = s.flames_count[s.level]
	end

	s = this.hero.skills.ultimate

	local sl = s.level

	if initial and s.level > 0 then
		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local u = E:get_template("hero_lumenir_ultimate")

		u.count = s.count[sl]

		local soldier = E:get_template("soldier_lumenir_ultimate")

		soldier.melee.attacks[1].damage_max = s.damage_max[sl]
		soldier.melee.attacks[1].damage_min = s.damage_min[sl]
		soldier.max_attack_count = s.max_attack_count
	end

	this.health.hp = this.health.hp_max
end

function scripts.hero_lumenir.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_lumenir.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill
	local upg_lf = UP:get_upgrade("heroes_lethal_focus")

	local function find_hero()
		for _, e in pairs(store.entities) do
			if e.hero and e.template_name ~= "hero_lumenir" then
				return e
			end
		end

		return nil
	end

	local function find_enemy_strongest(entities, origin, min_range, max_range, min_nodes, flags, bans, filter_func)
		local max_health = -1
		local enemy

		for _, e in pairs(entities) do
			if e.pending_removal or not e.enemy or not e.nav_path or not U.is_inside_ellipse(e.pos, origin, max_range) or e.health and e.health.dead or band(e.vis.flags, bans) ~= 0 or band(e.vis.bans, flags) ~= 0 or filter_func and not filter_func(e) then
				-- block empty
			elseif max_health < e.health.hp and min_nodes < e.nav_path.ni then
				max_health = e.health.hp
				enemy = e
			end
		end

		return enemy
	end

	local function create_mini_dragon(follow, entity_t, duration, remove_hero_death)
		local d = E:create_entity(entity_t)

		d.pos = V.vclone(follow.pos)
		d.ranged.attacks[1].xp_dest_id = this.id
		d.owner = this
		d.hero_id = follow.id
		d.duration = duration
		d.remove_hero_death = remove_hero_death

		queue_insert(store, d)

		return d
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts
	this.health_bar.hidden = false

	U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)

	while true do
		if h.dead then
			S:queue(this.ranged.attacks[4].sound)

			local time_adjustement = this.health.dead_lifetime * -1
			local d1 = create_mini_dragon(this, this.mini_dragon, this.health.dead_lifetime - time_adjustement, false)

			d1.offset.x = 40
			d1.offset.y = 10
			d1.delay_creation = 0.2

			local d2 = create_mini_dragon(this, this.mini_dragon, this.health.dead_lifetime - time_adjustement, false)

			d2.offset.x = -40
			d2.offset.y = -10
			d2.delay_creation = 0.3
			this.tween.disabled = false
			this.tween.ts = store.tick_ts
			this.tween.reverse = true

			SU.y_hero_death_and_respawn_kr5(store, this)

			this.tween.disabled = false
			this.tween.ts = store.tick_ts
			this.tween.reverse = false

			U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
		end

		while this.nav_rally.new do
			SU.y_hero_new_rally(store, this)
		end

		SU.heroes_visual_learning_upgrade(store, this)
		SU.heroes_lone_wolves_upgrade(store, this)
		SU.alliance_merciless_upgrade(store, this)
		SU.alliance_corageous_upgrade(store, this)

		if SU.hero_level_up(store, this) then
			-- block empty
		end

		for _, i in pairs(this.ranged.order) do
			do
				local a = this.ranged.attacks[i]

				if a.disabled then
					-- block empty
				elseif a.sync_animation and not this.render.sprites[1].sync_flag then
					-- block empty
				elseif store.tick_ts - a.ts < a.cooldown then
					-- block empty
				elseif i == 2 then
					if store.wave_group_number > 0 then
						local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans)

						if not soldiers or #soldiers <= a.min_count then
							SU.delay_attack(store, a, fts(10))
						else
							local middle = 0
							local damaged = false

							for _, s in pairs(soldiers) do
								middle = middle + s.pos.x

								if s.health and s.health.hp < s.health.hp_max then
									damaged = true
								end
							end

							if not damaged then
								-- block empty
							else
								middle = middle / #soldiers

								S:queue(a.sound)
								U.animation_start(this, a.animation, middle - this.pos.x < 0, store.tick_ts)
								U.y_wait(store, a.shoot_time)

								for _, s in pairs(soldiers) do
									local m = E:create_entity(a.mod)

									m.modifier.target_id = s.id
									m.modifier.source_id = this.id

									queue_insert(store, m)
								end

								U.y_animation_wait(this, 1, 1)

								a.ts = store.tick_ts

								SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
							end
						end
					end
				else
					if i == 3 then
						local target = find_enemy_strongest(store.entities, this.pos, 0, a.range, a.min_nodes, a.vis_flags, a.vis_bans)

						if target then
							local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)

							S:queue(a.sound)

							a.ts = store.tick_ts

							U.animation_start(this, an, af, store.tick_ts)
							U.y_wait(store, a.shoot_time)

							local m = E:create_entity(a.mod)

							m.modifier.target_id = target.id
							m.modifier.source_id = this.id
							m.modifier.level = this.hero.skills.celestial_judgement.level

							queue_insert(store, m)
							U.y_animation_wait(this, 1, 1)
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
						else
							SU.delay_attack(store, a, fts(10))
						end

						goto label_218_1
					end

					if i == 4 then
						if store.wave_group_number > 0 then
							local hero = find_hero()

							if hero and hero.health and not hero.health.dead then
								S:queue(a.sound)
								create_mini_dragon(hero, a.entity, a.duration, true)

								a.ts = store.tick_ts

								SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
							end
						end
					else
						if i == 5 then
							local targets_info = U.find_enemies_in_paths(store.entities, this.pos, a.range_nodes_min, a.range_nodes_max, nil, a.vis_flags, a.vis_bans)

							if not targets_info or #targets_info < a.min_targets then
								SU.delay_attack(store, a, 0.4)

								goto label_218_2
							end

							local target

							for _, ti in pairs(targets_info) do
								if GR:cell_is(ti.enemy.pos.x, ti.enemy.pos.y, TERRAIN_LAND) then
									target = ti.enemy

									break
								end
							end

							if not target then
								SU.delay_attack(store, a, 0.4)

								goto label_218_2
							end

							local pi, spi, ni = target.nav_path.pi, target.nav_path.spi, target.nav_path.ni
							local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {
								pi
							}, nil, nil, NF_RALLY)

							if #nodes < 1 then
								SU.delay_attack(store, a, 0.4)

								goto label_218_2
							end

							local s_pi, s_spi, s_ni = unpack(nodes[1])
							local dir = ni < s_ni and -1 or 1
							local offset = math.random(a.range_nodes_min, a.range_nodes_min + 5)

							s_ni = km.clamp(1, #P:path(s_pi), s_ni + (dir > 0 and offset or -offset))

							local flip = P:node_pos(s_pi, s_spi, s_ni, true).x < this.pos.x

							S:queue(a.sound)
							U.animation_start(this, a.animation, flip, store.tick_ts)
							U.y_wait(store, a.spawn_time)

							local delay = 0
							local pattern = {
								1,
								2,
								3,
								2,
								3,
								1,
								2
							}

							for i = 1, a.count do
								delay = delay + math.random(0.5, 0.66)

								local e = E:create_entity(a.entity)

								e.pos.x, e.pos.y = this.pos.x + (flip and -1 or 1) * a.spawn_offset.x, this.pos.y + a.spawn_offset.y
								e.nav_path.pi = s_pi
								e.nav_path.spi = pattern[i % #pattern + 1]
								e.nav_path.ni = s_ni
								e.nav_path.dir = dir
								e.delay = delay
								e.aura.source_id = this.id
								e.level = this.hero.skills.fire_balls.level

								queue_insert(store, e)
							end

							U.y_animation_wait(this)

							a.ts = store.tick_ts

							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])

							goto label_218_2
						end

						local bullet_t = E:get_template(a.bullet)
						local flight_time = a.estimated_flight_time or 1
						local pos_offset = v(this.pos.x + a.ignore_offset.x, this.pos.y + a.ignore_offset.y)
						local targets = U.find_enemies_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

						if targets then
							local target = targets[1]
							local start_ts = store.tick_ts
							local start_fx, b, targets
							local node_offset = P:predict_enemy_node_advance(target, flight_time)
							local t_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + node_offset)
							local an, af, ai = U.animation_name_facing_point(this, a.animation, t_pos)

							U.animation_start(this, an, af, store.tick_ts)
							S:queue(a.start_sound, a.start_sound_args)

							while store.tick_ts - start_ts < a.shoot_time do
								if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
									goto label_218_0
								end

								coroutine.yield()
							end

							S:queue(a.sound)

							targets = {
								target
							}
							b = E:create_entity(a.bullet)

							if a.type == "aura" then
								b.pos.x, b.pos.y = target.pos.x, target.pos.y
								b.aura.ts = store.tick_ts
							else
								b.bullet.target_id = target.id
								b.bullet.source_id = this.id
								b.bullet.xp_dest_id = this.id
								b.pos = V.vclone(this.pos)
								b.pos.x = b.pos.x + (af and -1 or 1) * a.bullet_start_offset[ai].x
								b.pos.y = b.pos.y + a.bullet_start_offset[ai].y
								b.bullet.from = V.vclone(b.pos)
								b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
								b.bullet.shot_index = i
								b.initial_impulse = 10

								if b.bullet.use_unit_damage_factor then
									b.bullet.damage_factor = this.unit.damage_factor
								end

								if upg_lf and a.basic_attack then
									if not this._lethal_focus_deck then
										this._lethal_focus_deck = SU.deck_new(upg_lf.trigger_cards, upg_lf.total_cards)
									end

									local triggered_lethal_focus = SU.deck_draw(this._lethal_focus_deck)

									if triggered_lethal_focus then
										b.bullet.damage_factor = b.bullet.damage_factor * upg_lf.damage_factor_area
										b.bullet.pop = {
											"pop_crit"
										}
										b.bullet.pop_chance = 1
										b.bullet.pop_conds = DR_DAMAGE
									end
								end
							end

							queue_insert(store, b)

							if a.xp_from_skill then
								SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
							end

							a.ts = start_ts

							while not U.animation_finished(this) do
								if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
									goto label_218_0
								end

								coroutine.yield()
							end

							a.ts = start_ts

							U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)

							::label_218_0::

							if start_fx then
								start_fx.render.sprites[1].hidden = true
							end

							goto label_218_2
						end
					end
				end
			end

			::label_218_1::
		end

		SU.soldier_idle(store, this)
		SU.soldier_regen(store, this)

		::label_218_2::

		coroutine.yield()
	end
end

scripts.hero_lumenir_ultimate = {}

function scripts.hero_lumenir_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_lumenir_ultimate.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true, NF_POWER_3)

	if #nodes < 1 then
		log.error("hero_lumenir_ultimate: could not find valid node")
		queue_remove(store, this)

		return
	end

	local node = {
		spi = 1,
		pi = nodes[1][1],
		ni = nodes[1][3]
	}
	local node_pos = P:node_pos(node)
	local count = this.count
	local target, targets = U.find_nearest_enemy(store.entities, this.pos, 0, this.range, this.vis_flags, this.vis_bans)
	local idx = 1

	if targets and count > #targets then
		count = #targets
	end

	while count > 0 and targets do
		local e = E:create_entity(this.entity)

		target = targets[idx]
		idx = idx + 1

		if band(target.vis.bans, F_STUN) == 0 and band(target.vis.flags, F_BOSS) == 0 then
			local m = E:create_entity("mod_lumenir_ulti_stun")

			m.modifier.target_id = target.id
			m.modifier.source_id = this.id

			queue_insert(store, m)
		end

		if band(target.vis.flags, F_BLOCK) ~= 0 then
			U.block_enemy(store, e, target)
		else
			e.unblocked_target_id = target.id
		end

		local lpos, lflip = U.melee_slot_position(e, target, 1)

		e.pos.x, e.pos.y = lpos.x, lpos.y
		e.render.sprites[1].flip_x = lflip
		e.nav_rally.center = V.vclone(e.pos)
		e.nav_rally.pos = V.vclone(e.pos)

		queue_insert(store, e)

		count = count - 1

		U.y_wait(store, this.spawn_delay)
	end

	count = this.count

	if targets then
		count = count - #targets
	end

	local available_paths = {}

	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end

	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, function(k, v)
			return not table.contains(store.level.ignore_walk_backwards_paths, v)
		end)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, available_paths)

	if nearest and #nearest > 0 then
		local path_pi, path_spi, path_ni = unpack(nearest[1])
		local spi = {
			1,
			3,
			2
		}

		while count > 0 do
			local ni_random = math.random(-5, 5)
			local spi_random = spi[count % 3 + 1]
			local pos_spawn = P:node_pos(path_pi, spi_random, path_ni + ni_random)
			local e = E:create_entity(this.entity)

			e.pos.x, e.pos.y = pos_spawn.x, pos_spawn.y
			e.render.sprites[1].flip_x = math.random() > 0.5
			e.nav_rally.center = V.vclone(e.pos)
			e.nav_rally.pos = V.vclone(e.pos)

			queue_insert(store, e)
			U.y_wait(store, this.spawn_delay)

			count = count - 1
		end
	end

	queue_remove(store, this)
end

scripts.soldier_lumenir_ultimate = {}

function scripts.soldier_lumenir_ultimate.insert(this, store, script)
	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.soldier_lumenir_ultimate.update(this, store)
	local target_id = this.soldier.target_id or this.unblocked_target_id
	local target = store.entities[target_id]
	local attack_count = 0

	this.render.sprites[1].ts = store.tick_ts
	this.render.sprites[1].runs = 0

	U.animation_start(this, "idle", nil, store.tick_ts, false, 2)
	U.y_wait(store, 0.4)

	this.render.sprites[1].hidden = false

	U.animation_start(this, "idle", nil, store.tick_ts, false, 1)

	if target then
		local enemies = U.find_enemies_in_range(store.entities, target.pos, 0, this.stun_range, this.stun_flags, this.stun_bans)

		if enemies then
			for k, e in pairs(enemies) do
				local m = E:create_entity("mod_lumenir_ulti_stun")

				m.modifier.duration = this.stun_duration
				m.modifier.target_id = e.id
				m.modifier.source_id = this.id

				queue_insert(store, m)
			end
		end
	end

	if not target then
		U.y_wait(store, U.frandom(this.min_wait, this.max_wait))
	else
		while target and not target.health.dead and not this.health.dead and (not this.max_attack_count or attack_count < this.max_attack_count) do
			local attack = SU.soldier_pick_melee_attack(store, this, target)

			if attack then
				for _, hit_time in pairs(attack.hit_times) do
					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, attack.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false, 1)
					S:queue(attack.sound)
					U.y_wait(store, hit_time)
					S:queue(attack.sound_hit)

					attack.ts = start_ts

					for _, aa in pairs(this.melee.attacks) do
						if aa ~= attack and aa.shared_cooldown then
							aa.ts = attack.ts
						end
					end

					if attack.damage_type ~= DAMAGE_NONE then
						local d = E:create_entity("damage")

						d.damage_type = attack.damage_type
						d.value = math.ceil(U.frandom(attack.damage_min, attack.damage_max))
						d.source_id = this.id
						d.target_id = target.id

						queue_damage(store, d)
					end
				end

				U.y_animation_wait(this)

				attack_count = attack_count + 1
			end

			coroutine.yield()

			target = store.entities[target_id]
		end
	end

	S:queue(this.sound_events.death, {
		delay = fts(11)
	})
	U.y_animation_play(this, "out", nil, store.tick_ts, 1, 1)
	queue_remove(store, this)
end

scripts.mod_hero_lumenir_sword_hit = {}

function scripts.mod_hero_lumenir_sword_hit.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]
	local time_hit = this.time_hit
	local decal_spawn_time = this.decal_spawn_time
	local damaged = false
	local decal_spawned = false

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	S:queue(this.sound)

	while true do
		target = store.entities[m.target_id]

		if m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if not damaged and time_hit < store.tick_ts - m.ts then
			damaged = true

			if target and not target.health.dead then
				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id
				d.value = this.damage[m.level]
				d.damage_type = this.damage_type

				queue_damage(store, d)
			end

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.stun_range, this.stun_vis_flags, this.stun_bans)

			if targets then
				for _, target in pairs(targets) do
					local s = E:create_entity(this.mod_stun)

					s.modifier.target_id = target.id
					s.modifier.source_id = m.source_id
					s.modifier.duration = this.stun_duration[m.level]

					queue_insert(store, s)
				end
			end
		end

		if not decal_spawned and decal_spawn_time < store.tick_ts - m.ts then
			decal_spawned = true

			local decal = E:create_entity(this.hit_decal)

			decal.pos = V.vclone(this.pos)
			decal.render.sprites[1].ts = store.tick_ts

			queue_insert(store, decal)
		end

		coroutine.yield()
	end
end

scripts.mod_hero_lumenir_shield = {}

function scripts.mod_hero_lumenir_shield.insert(this, store)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		return false
	end

	local s = this.render.sprites[1]
	local sd = this.render.sprites[2]

	s.ts = store.tick_ts

	if s.size_names then
		s.name = s.size_names[target.unit.size]
		sd.name = sd.name .. "_" .. sd.size_names[target.unit.size]
	end

	if this.custom_offsets then
		s.offset = V.vclone(this.custom_offsets[target.template_name] or this.custom_offsets.default)
		s.offset.x = s.offset.x * (s.flip_x and -1 or 1)

		if target.unit and target.unit.mod_offset and this.modifier.use_mod_offset then
			s.offset.x = s.offset.x + target.unit.mod_offset.x
			s.offset.y = s.offset.y + target.unit.mod_offset.y
		end
	end

	if target.health then
		SU.spiked_armor_inc(target, this.spiked_armor)
		SU.armor_inc(target, this.armor)
	end

	return true
end

function scripts.mod_hero_lumenir_shield.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			this.tween.reverse = true
			this.tween.remove = true
			this.tween.ts = store.tick_ts

			U.y_wait(store, 0.25)
			queue_remove(store, this)

			return
		end

		local s = this.render.sprites[1]

		if m.use_mod_offset and target.unit.mod_offset then
			s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
		end

		coroutine.yield()
	end
end

function scripts.mod_hero_lumenir_shield.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target and target.health then
		SU.spiked_armor_dec(target, this.spiked_armor)
		SU.armor_dec(target, this.armor)
	end

	return true
end

scripts.mini_dragon_hero_lumenir = {}

function scripts.mini_dragon_hero_lumenir.update(this, store)
	local sd = this.render.sprites[1]
	local ss = this.render.sprites[2]
	local a = this.ranged.attacks[1]
	local fm = this.force_motion
	local owner = this.owner
	local hero = store.entities[this.hero_id]
	local shoot_ts, search_ts = 0, 0
	local target, targets, dist
	local dest = V.v(this.pos.x, this.pos.y)

	if this.delay_creation then
		ss.hidden = true

		U.y_wait(store, this.delay_creation)

		ss.hidden = false
	end

	local flight_height = this.flight_height

	flight_height = this.custom_height and this.custom_height[hero.template_name] or flight_height
	this.tween.props[1].keys = {
		{
			0,
			v(0, flight_height + 2)
		},
		{
			0.4,
			v(0, flight_height - 2)
		},
		{
			0.8,
			v(0, flight_height + 2)
		}
	}
	this.render.sprites[1].offset.y = flight_height
	fm.a_step = fm.a_step + math.random(-3, 3)
	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	local oos = {
		V.v(-15, 0),
		V.v(10, 7)
	}

	U.y_animation_play(this, "spawn", true, store.tick_ts)
	U.animation_start(this, "walk", nil, store.tick_ts, true)

	this.start_ts = store.tick_ts

	local initial_pos_offset = {}

	if this.drone_id == 1 then
		initial_pos_offset = V.v(-50, 40)
	else
		initial_pos_offset = V.v(40, 30)
	end

	while store.tick_ts - this.start_ts <= this.duration do
		if this.remove_hero_death then
			if hero.health.dead then
				break
			end
		-- elseif not hero.health.dead then
		-- 	break
		end

		search_ts = store.tick_ts

		if hero then
			this._chasing_target_id = hero.id
		else
			this._chasing_target_id = nil
		end

		if hero then
			repeat
				dest.x, dest.y = hero.pos.x + this.offset.x, hero.pos.y + this.offset.y
				sd.flip_x = dest.x < this.pos.x

				U.force_motion_step(this, store.tick_length, dest)
				coroutine.yield()

				dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
			until dist < 5

			if a.sync_animation and not this.render.sprites[1].sync_flag then
				-- block empty
			else
				local targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if targets and #targets > 0 then
					local start_ts = store.tick_ts
					local start_fx, b
					local flight_time = a.estimated_flight_time or 1
					local target = targets[1]
					local node_offset = P:predict_enemy_node_advance(target, 1)
					local t_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + node_offset)
					local an, af, ai = U.animation_name_facing_point(this, a.animation, t_pos)

					U.animation_start(this, an, af, store.tick_ts)
					S:queue(a.start_sound, a.start_sound_args)

					while store.tick_ts - start_ts < a.shoot_time do
						coroutine.yield()
					end

					S:queue(a.sound)

					b = E:create_entity(a.bullet)
					b.bullet.target_id = target.id
					b.bullet.source_id = this.id
					b.bullet.xp_dest_id = this.id
					b.pos = V.vclone(this.pos)
					b.pos.x = b.pos.x + (af and -1 or 1) * a.bullet_start_offset.x
					b.pos.y = b.pos.y + a.bullet_start_offset.y + flight_height
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
					b.bullet.shot_index = 1
					b.initial_impulse = 10

					queue_insert(store, b)

					a.ts = start_ts

					while not U.animation_finished(this) do
						coroutine.yield()
					end

					a.ts = start_ts

					U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)

					if start_fx then
						start_fx.render.sprites[1].hidden = true
					end
				end

				U.animation_start(this, "walk", nil, store.tick_ts, true)
			end
		end
	end

	U.y_ease_keys(store, {
		sd,
		sd.offset,
		ss
	}, {
		"alpha",
		"y",
		"alpha"
	}, {
		255,
		this.flight_height,
		255
	}, {
		0,
		85,
		0
	}, 0.4, {
		"linear",
		"linear",
		"linear"
	})
	queue_remove(store, this)
end

scripts.aura_fire_balls_hero_lumenir = {}

function scripts.aura_fire_balls_hero_lumenir.insert(this, store)
	local next_pos = P:node_pos(this.nav_path)

	if not next_pos then
		return false
	end

	return true
end

function scripts.aura_fire_balls_hero_lumenir.update(this, store)
	local y_off = 20
	local a = this.aura
	local m = this.motion
	local nav = this.nav_path
	local dt = store.tick_length
	local start_ni = nav.ni
	local start_ts = store.tick_ts
	local hit_ts = 0

	a.duration = a.duration + U.frandom(-a.duration_var, 0)
	m.max_speed = m.max_speed + math.random(0, m.max_speed_var)

	local step = m.max_speed * dt
	local next_pos = P:node_pos(nav)

	next_pos.y = next_pos.y + y_off

	U.set_destination(this, next_pos)

	local v_heading = V.v(0, 0)

	v_heading.x, v_heading.y = V.normalize(next_pos.x - this.pos.x, next_pos.y - this.pos.y)

	local th_dist = 25
	local turn_speed = math.pi * 1.5
	local enemies_hit = {}
	local speed_offset = 0
	local ps = E:create_entity("ps_bolt_lumenir_wave")

	ps.particle_system.track_id = this.id

	queue_insert(store, ps)

	while true do
		if this.tween.disabled and store.tick_ts - start_ts > a.duration then
			this.tween.disabled = nil
			this.tween.ts = store.tick_ts
		end

		if th_dist > V.len(m.dest.x - this.pos.x, m.dest.y - this.pos.y) then
			nav.ni = nav.ni + math.random(6, 11) * nav.dir

			local p_len = #P:path(nav.pi)

			if nav.ni <= 1 or p_len <= nav.ni then
				a.duration = 0
			end

			nav.ni = km.clamp(1, p_len, nav.ni)
			nav.spi = km.zmod(nav.spi + math.random(1, 2), 3)
			next_pos = P:node_pos(nav)
			next_pos.y = next_pos.y + y_off

			U.set_destination(this, next_pos)
		end

		local dx, dy = V.sub(m.dest.x, m.dest.y, this.pos.x, this.pos.y)
		local sa = km.short_angle(V.angleTo(dx, dy), V.angleTo(v_heading.x, v_heading.y))
		local angle_step = math.min(turn_speed * dt, math.abs(sa)) * km.sign(sa) * -1

		v_heading.x, v_heading.y = V.rotate(angle_step, v_heading.x, v_heading.y)

		local sx, sy = V.mul(step, v_heading.x, v_heading.y)

		if this.delay and speed_offset < this.delay then
			sx = sx * speed_offset / this.delay
			sy = sy * speed_offset / this.delay
			speed_offset = speed_offset + dt
		end

		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, sx, sy)
		m.speed.x, m.speed.y = sx / dt, sy / dt
		this.render.sprites[1].r = V.angleTo(v_heading.x, v_heading.y)

		if store.tick_ts - hit_ts > a.damage_cycle then
			hit_ts = store.tick_ts

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.damage_radius, a.damage_flags, a.damage_bans, function(v)
				return not table.contains(enemies_hit, v)
			end)

			if not targets then
				-- block empty
			else
				for _, e in pairs(targets) do
					local d = E:create_entity("damage")

					d.source_id = this.id
					d.target_id = e.id
					d.value = math.random(this.flame_damage_min[this.level], this.flame_damage_max[this.level])
					d.damage_type = a.damage_type

					queue_damage(store, d)
					table.insert(enemies_hit, e)
				end
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.hero_vesper = {}

function scripts.hero_vesper.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]
	this.melee.attacks[2].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[2].damage_max = ls.melee_damage_max[hl]

	local bt = E:get_template(this.ranged.attacks[1].bullet)

	bt.bullet.damage_min = ls.ranged_short_damage_min[hl]
	bt.bullet.damage_max = ls.ranged_short_damage_max[hl]

	local bt = E:get_template(this.ranged.attacks[2].bullet)

	bt.bullet.damage_min = ls.ranged_long_damage_min[hl]
	bt.bullet.damage_max = ls.ranged_long_damage_max[hl]

	local s, sl

	s = this.hero.skills.arrow_to_the_knee
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - ARROW TO THE KNEE - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]
		b.bullet.damage_type = DAMAGE_TRUE

		local m = E:get_template(b.bullet.mod)

		m.modifier.duration = s.stun_duration[sl]
	end

	s = this.hero.skills.ricochet
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - RICOCHET - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]
		b.bounces = s.bounces[sl]
	end

	s = this.hero.skills.martial_flourish
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - MARTIAL FLOURISH - %i", this.template_name, hl, sl)

		local a = this.melee.attacks[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.damage_min = s.damage_min[sl]
		a.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.disengage
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - DISENGAGE - %i", this.template_name, hl, sl)

		local d = this.dodge

		d.disabled = nil
		d.cooldown = s.cooldown[sl]

		local b = E:get_template(d.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_vesper.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)
	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_vesper.can_dodge(store, this, ranged_attack, attack, enemy)
	local skill = this.hero.skills.disengage

	if enemy and enemy.health and not enemy.health.dead and not this.dodge.disabled and this.health.hp / this.health.hp_max < this.dodge.hp_to_trigger then
		local enp = enemy.nav_path
		local new_ni = enp.ni
		local node_limit = math.floor(skill.min_distance_from_end / P.average_node_dist)
		local node_jump = math.floor(skill.distance / P.average_node_dist)
		local nodes_to_goal = P:nodes_to_goal(enp)

		if node_limit < nodes_to_goal then
			new_ni = new_ni + math.min(nodes_to_goal - 1, node_jump)

			local new_pos = P:node_pos(enp.pi, enp.spi, new_ni)

			this.dodge.new_pos = new_pos

			return true
		end
	end

	return false
end

function scripts.hero_vesper.update(this, store)
	local h = this.health
	local brk, sta
	local basic_attack = this.ranged.attacks[1]
	local ricochet_attack = this.timed_attacks.list[1]

	local function shoot_arrow_after_dodge(enemy, enemy_pos, enemy_id)
		local pos, bullet_to, target_id

		if enemy then
			pos = enemy.pos
			bullet_to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
			target_id = enemy.id
		else
			pos = enemy_pos
			bullet_to = enemy_pos
			target_id = enemy_id
		end

		local an, af, ai = U.animation_name_facing_point(this, this.dodge.animation_attack_start, pos)

		U.animation_start(this, an, af, store.tick_ts, false)
		U.y_wait(store, this.dodge.shoot_time)

		local bo = this.dodge.bullet_start_offset[ai]
		local b = E:create_entity(this.dodge.bullet)

		b.pos = V.vclone(this.pos)
		b.pos.x, b.pos.y = b.pos.x + (af and -1 or 1) * bo.x, b.pos.y + bo.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = bullet_to
		b.bullet.target_id = target_id
		b.bullet.flight_time = b.bullet.flight_time + fts(math.random(0, b.bullet.flight_time_variance))

		queue_insert(store, b)
		U.y_animation_wait(this)

		local an, af, ai = U.animation_name_facing_point(this, this.dodge.animation_attack_end, pos)

		U.animation_start(this, an, af, store.tick_ts, false)
		U.y_animation_wait(this)
	end

	this.health_bar.hidden = false

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_239_0
				end
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			if not ricochet_attack.disabled and store.tick_ts - ricochet_attack.ts > ricochet_attack.cooldown then
				local enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), ricochet_attack.min_range, ricochet_attack.max_range_trigger, ricochet_attack.node_prediction, ricochet_attack.vis_flags, ricochet_attack.vis_bans)

				if not enemy then
					SU.delay_attack(store, ricochet_attack, fts(10))
				elseif enemies and #enemies < ricochet_attack.min_targets then
					SU.delay_attack(store, ricochet_attack, fts(10))
				else
					local start_ts = store.tick_ts

					if SU.y_soldier_do_ranged_attack(store, this, enemy, ricochet_attack, V.vclone(enemy.pos)) then
						ricochet_attack.ts = start_ts
					end
				end
			end

			if not this.dodge.disabled and this.dodge.active and this.vis.bans ~= F_ALL then
				local enemy = store.entities[this.soldier.target_id]

				if not enemy then
					-- block empty
				else
					local enemy_pos = enemy.pos
					local enemy_id = enemy.id

					this.dodge.active = false
					this.dodge.ts = store.tick_ts

					local new_pos = this.dodge.new_pos

					S:queue(this.dodge.sound)
					U.unblock_target(store, this)

					local bans = this.vis.bans

					this.vis.bans = F_ALL

					SU.hide_modifiers(store, this, true)
					SU.hide_auras(store, this, true)
					U.animation_start(this, this.dodge.animation_dissapear, nil, store.tick_ts, false)
					U.y_animation_wait(this)
					U.y_wait(store, fts(3))

					this.pos.x, this.pos.y = new_pos.x, new_pos.y
					this.nav_rally.center = V.vclone(this.pos)
					this.nav_rally.pos = V.vclone(this.pos)

					SU.hero_gain_xp_from_skill(this, this.hero.skills.disengage)
					U.y_animation_play(this, this.dodge.animation_appear, nil, store.tick_ts)

					this.vis.bans = bans
					this.vis._bans = nil

					SU.show_modifiers(store, this, true)
					SU.show_auras(store, this, true)

					local targets = U.find_enemies_in_range(store.entities, enemy_pos, 0, 100, this.vis.flags, bans)

					if targets then
						for i = 1, this.dodge.total_shoots do
							local target = targets[1 + i % #targets]

							shoot_arrow_after_dodge(target, target.pos, target.id)
						end
					else
						for i = 1, this.dodge.total_shoots do
							shoot_arrow_after_dodge(enemy, enemy_pos, enemy_id)
						end
					end

					U.animation_start(this, this.dodge.animation_attack_end, nil, store.tick_ts, false)

					basic_attack.ts = store.tick_ts

					U.animation_start(this, "idle", nil, store.tick_ts, true)
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				brk, sta = y_hero_ranged_attacks(store, this)

				if brk then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_239_0::

		coroutine.yield()
	end
end

scripts.hero_vesper_ricochet_bullet = {}

function scripts.hero_vesper_ricochet_bullet.update(this, store)
	local b = this.bullet
	local mspeed = b.min_speed
	local target, ps
	local bounce_count = 0
	local already_hit = {}

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	::label_241_0::

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead then
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
		this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.source_id = this.id
				m.modifier.target_id = target.id
				m.modifier.level = b.level

				queue_insert(store, m)
			end
		end

		table.insert(already_hit, target.id)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		queue_insert(store, sfx)
	end

	S:queue(this.sound)

	if bounce_count < this.bounces then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.bounce_range, b.vis_flags, b.vis_bans, function(v)
			return not table.contains(already_hit, v.id)
		end)

		if not targets then
			if target and not target.health.dead then
				already_hit = {
					target.id
				}
			else
				already_hit = {}
			end

			targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.bounce_range, b.vis_flags, b.vis_bans, function(v)
				return not table.contains(already_hit, v.id)
			end)
		end

		if targets then
			if bounce_count == 0 then
				this.render.sprites[1].name = this.bounce_arrow_name
				
				if ps then
					ps.particle_system.emit = false

					queue_remove(store, ps)
				end

				b.particles_name = this.particle_after_bounce
				ps = E:create_entity(b.particles_name)
				ps.particle_system.track_id = this.id

				queue_insert(store, ps)
			end

			table.sort(targets, function(e1, e2)
				return V.dist(this.pos.x, this.pos.y, e1.pos.x, e1.pos.y) < V.dist(this.pos.x, this.pos.y, e2.pos.x, e2.pos.y)
			end)

			local target = targets[1]

			bounce_count = bounce_count + 1
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			b.target_id = target.id

			goto label_241_0
		end
	end

	if ps then
		ps.particle_system.emit = false

		queue_remove(store, ps)
	end

	queue_remove(store, this)
end

scripts.hero_vesper_ultimate = {}

function scripts.hero_vesper_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and SU5.valid_node_interval(x, y, this.offset_back, 0, 1, NF_RALLY)
end

function scripts.hero_vesper_ultimate.update(this, store)
	local distance = 2

	local function spawn_arrow(pi, spi, ni)
		spi = spi or math.random(1, 3)

		local pos = P:node_pos(pi, spi, ni)

		pos.x = pos.x + math.random(-4, 4)
		pos.y = pos.y + math.random(-5, 5)

		local b = E:create_entity(this.bullet)

		b.bullet.damage_max = this.damage[this.level]
		b.bullet.damage_min = this.damage[this.level]
		b.bullet.damage_type = DAMAGE_TRUE
		b.bullet.from = V.v(pos.x + math.random(-170, -140), pos.y + REF_H)
		b.bullet.to = pos
		b.pos = V.vclone(b.bullet.from)

		queue_insert(store, b)
	end

	local function is_valid_path(pi)
		return (not store.level.ignore_walk_backwards_paths or not table.contains(store.level.ignore_walk_backwards_paths, pi)) and P:is_path_active(pi)
	end

	local available_paths = {}

	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end

	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, is_valid_path)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, available_paths, nil, true)

	if #nearest > 0 then
		local pi, spi, ni = unpack(nearest[1])
		local count = this.spread[this.level]
		local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, this.enemies_range, this.vis_flags, this.vis_bans)

		if enemies and #enemies > 0 and is_valid_path(enemies[1].nav_path.pi) then
			local enemy_pi = enemies[1].nav_path.pi

			nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
				enemy_pi
			})

			if #nearest > 0 then
				pi, spi, ni = unpack(nearest[1])
			end
		end

		ni = ni + this.node_prediction_offset + distance

		S:queue(this.sounds[this.level])

		for i = 1, count do
			if P:is_node_valid(pi, ni - i * distance) then
				spawn_arrow(pi, 1, ni - i * distance)
				spawn_arrow(pi, math.random(2, 3), ni - i * distance)
				U.y_wait(store, this.duration / count)
			end
		end
	end

	queue_remove(store, this)
end

scripts.hero_vesper_ultimate_arrow = {}

function scripts.hero_vesper_ultimate_arrow.update(this, store)
	local b = this.bullet
	local speed = b.max_speed

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) >= 2 * (speed * store.tick_length) do
		b.speed.x, b.speed.y = V.mul(speed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
		this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

		coroutine.yield()
	end

	local targets = U.find_targets_in_range(store.entities, b.to, 0, b.damage_radius, b.damage_flags, b.damage_bans)

	if targets then
		for _, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.damage_type = b.damage_type
			d.value = b.damage_max
			d.source_id = this.id
			d.target_id = target.id

			queue_damage(store, d)

			if b.mod then
				local mod = E:create_entity(b.mod)

				mod.modifier.target_id = target.id

				queue_insert(store, mod)
			end
		end
	end

	if b.hit_fx then
		SU.insert_sprite(store, b.hit_fx, this.pos)
	end

	if b.arrive_decal then
		local decal = E:create_entity(b.arrive_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	queue_remove(store, this)
end

scripts.hero_vesper_ultimate_decal = {}

function scripts.hero_vesper_ultimate_decal.insert(this, store)
	this.render.sprites[1].ts = store.tick_ts
	this.render.sprites[1].r = U.frandom(-10, 5) * math.pi / 180

	return true
end

scripts.hero_raelyn = {}

function scripts.hero_raelyn.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local s, sl

	s = this.hero.skills.unbreakable
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - UNBREAKABLE - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local m = E:get_template(a.mod)

		m.modifier.duration = s.duration[sl]
		m.shield_per_enemy = s.shield_per_enemy[sl]
		m.shield_base = s.shield_base[sl]
	end

	s = this.hero.skills.inspire_fear
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - INSPIRE FEAR - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local md = E:get_template(a.mods[1])

		md.modifier.duration = s.damage_duration[sl]
		md.inflicted_damage_factor = s.inflicted_damage_factor[sl]

		local ms = E:get_template(a.mods[2])

		ms.modifier.duration = s.stun_duration[sl]

		local mf = E:get_template(a.mods[3])

		mf.modifier.duration = s.stun_duration[sl]

		md = E:get_template(a.mods[4])
		md.modifier.duration = s.damage_duration[sl]
		md.speed_factor = s.inflicted_damage_factor[sl]
	end

	s = this.hero.skills.brutal_slash
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - BRUTAL SLASH - %i", this.template_name, hl, sl)

		local a = this.melee.attacks[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.damage_max = s.damage_max[sl]
		a.damage_min = s.damage_min[sl]
	end

	s = this.hero.skills.onslaught
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - ONSLAUGHT - %i", this.template_name, hl, sl)

		local a = this.melee.attacks[1]
		local o = this.timed_attacks.list[3]
		local hit_aura = E:get_template(s.hit_aura)

		hit_aura.aura.damage_max = a.damage_max * s.damage_factor[sl]
		hit_aura.aura.damage_min = a.damage_min * s.damage_factor[sl]
		o.hit_aura = hit_aura
		o.melee_cooldown = s.melee_cooldown[sl]
		o.duration = s.duration[sl]
		o.cooldown = s.cooldown[sl]
		o.disabled = nil
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]
		uc.entity = string.format("%s_%i", uc.entity_prefix, sl)
		uc.soldier = string.format("%s_lvl%i", uc.soldier_prefix, sl)
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_raelyn.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.hero_raelyn.update(this, store)
	local h = this.health
	local a, skill, brk, sta
	local ultimate = this.hero.skills.ultimate
	local basic_attack = this.melee.attacks[1]
	local unbreakable_attack = this.timed_attacks.list[1]
	local inspire_fear_attack = this.timed_attacks.list[2]
	local onslaught_attack = this.timed_attacks.list[3]
	local onslaught_on = false

	this.health_bar.hidden = false

	while true do
		while this.spawning_in_cinematic_s2 do
			coroutine.yield()
		end

		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_252_0
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			skill = this.hero.skills.inspire_fear
			a = inspire_fear_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_trigger, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)

					if a.mod_decal then
						local d = E:create_entity(a.mod_decal)

						d.modifier.source_id = this.id
						d.modifier.target_id = this.id

						queue_insert(store, d)
					end

					U.animation_start(this, a.animation, nil, store.tick_ts, 1)

					if SU.y_hero_wait(store, this, a.cast_time) then
						-- block empty
					else
						a.ts = start_ts

						SU.hero_gain_xp_from_skill(this, skill)

						enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_effect, a.vis_flags, a.vis_bans)

						if enemies then
							for _, t in ipairs(enemies) do
								for _, mod in ipairs(a.mods) do
									local m = E:create_entity(mod)

									m.modifier.source_id = this.id
									m.modifier.target_id = t.id

									queue_insert(store, m)
								end
							end
						end

						SU.y_hero_animation_wait(this)
					end

					goto label_252_0
				end
			end

			skill = this.hero.skills.unbreakable
			a = unbreakable_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and not U.has_modifiers(store, this, a.mod) then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_trigger, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)
					U.animation_start(this, a.animation, nil, store.tick_ts, 1)

					if SU.y_hero_wait(store, this, a.cast_time) then
						-- block empty
					else
						if a.mod_decal then
							local d = E:create_entity(a.mod_decal)

							d.modifier.source_id = this.id
							d.modifier.target_id = this.id

							queue_insert(store, d)
						end

						a.ts = start_ts

						SU.hero_gain_xp_from_skill(this, skill)

						enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_effect, a.vis_flags, a.vis_bans)

						if enemies and #enemies > 0 then
							enemies = table.slice(enemies, 1, a.max_targets)
							local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, a.max_range_effect, a.vis_flags, a.vis_bans)
							if soldiers then
								soldiers = table.slice(soldiers, 1, skill.max_soldiers[skill.level] + 1)
								for i, s in ipairs(soldiers) do
									local m = E:create_entity(a.mod)
									local shield_max_damage = m.shield_base * this.health.hp_max
		
									shield_max_damage = shield_max_damage + this.health.hp_max * m.shield_per_enemy * #enemies
									m.modifier.source_id = this.id
									m.modifier.target_id = s.id
									m.shield_max_damage = shield_max_damage
		
									local mod_prefix
		
									if #enemies <= #m.sprites_per_enemies then
										mod_prefix = m.sprites_per_enemies[#enemies]
									else
										mod_prefix = m.sprites_per_enemies[#m.sprites_per_enemies]
									end
		
									m.render.sprites[1].prefix = mod_prefix
		
									queue_insert(store, m)
								end
							end
						end

						SU.y_hero_animation_wait(this)
					end

					goto label_252_0
				end
			end

			skill = this.hero.skills.onslaught
			a = onslaught_attack

			if not a.disabled and not onslaught_on and store.tick_ts - a.ts > a.cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_trigger, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					onslaught_on = true
					a.duration_ts = store.tick_ts
					a._sound = basic_attack.sound
					a._cooldown = basic_attack.cooldown
					a._hit_fx = basic_attack.hit_fx
					a._hit_offset = basic_attack.hit_offset
					basic_attack.hit_aura = a.hit_aura
					basic_attack.cooldown = a.melee_cooldown
					basic_attack.hit_decal = a.hit_decal
					basic_attack.hit_fx = nil
					basic_attack.hit_offset = a.hit_offset
					basic_attack.sound = a.sound
				end
			end

			if onslaught_on and store.tick_ts - a.duration_ts > a.duration then
				onslaught_on = false
				basic_attack.hit_aura = nil
				basic_attack.cooldown = a._cooldown
				basic_attack.hit_decal = nil
				basic_attack.hit_fx = a._hit_fx
				basic_attack.hit_offset = a._hit_offset
				basic_attack.sound = a._sound
				a.ts = store.tick_ts
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_252_0::

		coroutine.yield()
	end
end

scripts.hero_raelyn_unbreakable_mod = {}

function scripts.hero_raelyn_unbreakable_mod.insert(this, store)
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	m.ts = store.tick_ts
	target.health._on_damage = target.health.on_damage
	target.health.on_damage = scripts.hero_raelyn_unbreakable_mod.on_damage
	this._hit_sources = {}
	this._blood_color = target.unit.blood_color
	target.unit.blood_color = BLOOD_NONE
	target._shield_mod = this
	this.health.hp = this.shield_max_damage
	this.health.hp_max = this.shield_max_damage

	return true
end

function scripts.hero_raelyn_unbreakable_mod.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target.health.on_damage = target.health._on_damage
		target._shield_mod = nil
		target.unit.blood_color = this._blood_color
	end

	return true
end

function scripts.hero_raelyn_unbreakable_mod.update(this, store)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	U.y_animation_play(this, this.animation_start, nil, store.tick_ts, 1)

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			U.y_animation_play(this, this.animation_end, nil, store.tick_ts, 1)
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		U.y_animation_play(this, this.animation_loop, nil, store.tick_ts, 1)
		coroutine.yield()
	end
end

function scripts.hero_raelyn_unbreakable_mod.on_damage(this, store, damage)
	local mod = this._shield_mod

	if not mod then
		log.error("hero_raelyn_unbreakable_mod.on_damage for enemy %s has no mod pointer", this.id)

		return true
	end

	if mod.shield_broken then
		return true
	end

	if U.flag_has(damage.damage_type, bor(DAMAGE_INSTAKILL, DAMAGE_DISINTEGRATE, DAMAGE_EAT, DAMAGE_IGNORE_SHIELD)) then
		mod.shield_broken = true

		queue_remove(store, mod)

		return true
	else
		mod.damage_taken = mod.damage_taken + damage.value
	end

	mod.health.hp = mod.shield_max_damage - mod.damage_taken

	if mod.damage_taken >= mod.shield_max_damage then
		mod.shield_broken = true

		queue_remove(store, mod)

		if mod.damage_taken - mod.shield_max_damage > 0 then
			damage.value = mod.damage_taken - mod.shield_max_damage

			return true
		end
	end

	return false
end

scripts.hero_raelyn_ultimate = {}

function scripts.hero_raelyn_ultimate.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_raelyn_ultimate.update(this, store)
	local x, y = this.pos.x, this.pos.y
	local special_spawn_radius = 30
	local special_angle_offset = 15

	local e = E:create_entity(this.entity)
	local spawn_pos = U.point_on_ellipse(V.v(x, y), special_spawn_radius, -math.pi / 2 + special_angle_offset)
	e.pos.x = spawn_pos.x
	e.pos.y = spawn_pos.y
	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.id
	queue_insert(store, e)

	local d = E:create_entity(e.spawn_mod_decal)
	d.modifier.source_id = e.id
	d.modifier.target_id = e.id
	queue_insert(store, d)

	e = E:create_entity(this.soldier)
	local a = 2 * math.pi / 3
	spawn_pos = U.point_on_ellipse(V.v(x, y), special_spawn_radius, a - math.pi / 2 + special_angle_offset)
	e.pos.x = spawn_pos.x
	e.pos.y = spawn_pos.y
	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.id
	queue_insert(store, e)

	e = E:create_entity(this.soldier)
	spawn_pos = U.point_on_ellipse(V.v(x, y), special_spawn_radius, 2 * a - math.pi / 2 + special_angle_offset)
	e.pos.x = spawn_pos.x
	e.pos.y = spawn_pos.y
	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.id
	queue_insert(store, e)

	queue_remove(store, this)
end

scripts.hero_raelyn_command_orders_dark_knight = {}

function scripts.hero_raelyn_command_orders_dark_knight.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts

	if this.reinforcement.fade or this.reinforcement.fade_in then
		SU.y_reinforcement_fade_in(store, this)
	elseif this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.health_bar.hidden = true

		U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			if this.health.dead then
				this.reinforcement.fade = nil
				this.tween = nil
			else
				this.reinforcement.fade = true
			end

			this.health.hp = 0

			SU.remove_modifiers(store, this)

			this.ui.can_click = false

			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_259_1
				end
			end

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_259_1
				end
			end

			if this.ranged then
				brk, star = SU.y_soldier_ranged_attacks(store, this)

				if brk or star == A_DONE then
					goto label_259_1
				elseif star == A_IN_COOLDOWN then
					goto label_259_0
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				goto label_259_1
			end

			if SU.soldier_go_back_step(store, this) then
				goto label_259_1
			end

			::label_259_0::

			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_259_1::

		coroutine.yield()
	end
end

scripts.hero_lava = {}

function scripts.hero_lava.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local s, sl

	s = this.hero.skills.temper_tantrum
	sl = s.level

	if sl > 0 and initial then
		log.debug("LEVELUP - %s - %i - temper_tantrum - %i", this.template_name, hl, sl)

		local a = this.melee.attacks[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.damage_max = s.damage_max[sl]
		a.damage_min = s.damage_min[sl]

		local mod = E:get_template(a.mod)
		mod.modifier.duration = s.duration[sl]
	end

	s = this.hero.skills.hotheaded
	sl = s.level

	if sl > 0 and initial then
		log.debug("LEVELUP - %s - %i - hotheaded - %i", this.template_name, hl, sl)

		local md = E:get_template(s.mods[1])

		md.modifier.duration = s.durations[sl]
		md.damage_factor = s.damage_factors[sl]

		local ms = E:get_template(s.mods[2])

		ms.modifier.duration = s.durations[sl]
	end

	s = this.hero.skills.double_trouble
	sl = s.level

	if sl > 0 and initial then
		log.debug("LEVELUP - %s - %i - double_trouble - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]

		local pl = E:get_template(b.bullet.hit_payload)

		pl.health.hp_max = s.soldier_hp_max[sl]
		pl.melee.attacks[1].damage_min = s.soldier_damage_min[sl]
		pl.melee.attacks[1].damage_max = s.soldier_damage_max[sl]
	end

	s = this.hero.skills.wild_eruption
	sl = s.level

	if sl > 0 and initial then
		log.debug("LEVELUP - %s - %i - wild_eruption - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local m = E:get_template(a.mod)

		m.modifier.duration = s.duration[sl]
		m.dps.damage_min = s.damage_min[sl]
		m.dps.damage_max = s.damage_min[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]
		uc.fireball_count = s.fireball_count[sl]

		local b = E:get_template(uc.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]

		local a = E:get_template(b.aura)

		a.aura.damage_min = s.scorch_damage_min[sl]
		a.aura.damage_max = s.scorch_damage_max[sl]

		local bc = E:get_template(this._combo_ultimate.bullet)

		bc.bullet.damage_min = b.bullet.damage_min
		bc.bullet.damage_max = b.bullet.damage_max
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_lava.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.hero_lava.update(this, store)
	local h = this.health
	local a, skill, brk, sta
	local ultimate = this.hero.skills.ultimate
	local basic_attack = this.melee.attacks[1]
	local hotheaded_skill = this.hero.skills.hotheaded
	local hotheaded_attack = this.timed_attacks.list[1]
	local wild_eruption = this.timed_attacks.list[2]

	local function custom_walk(store, this)
		local dest = this.nav_rally.pos

		if V.veq(this.pos, dest) then
			this.motion.arrived = true

			return false
		else
			U.set_destination(this, dest)

			if U.walk(this, store.tick_length) then
				return false
			else
				local an, af = U.animation_name_facing_point(this, "death_walk", this.motion.dest)

				U.animation_start(this, an, af, store.tick_ts, -1)

				return true
			end
		end
	end

	local function ultimate_extra_fireballs()
		local a = this._combo_ultimate
		local max_dist2 = 3600

		local function shuffle_table(nodes)
			for i = #nodes, 2, -1 do
				local j = math.random(i)

				nodes[i], nodes[j] = nodes[j], nodes[i]
			end

			return nodes
		end

		local function shoot_bullet(pos)
			local b = E:create_entity(a.bullet)

			b.pos.x, b.pos.y = this.pos.x + a.bullet_start_offset.x, this.pos.y + a.bullet_start_offset.y
			b.bullet.from = V.vclone(b.pos)
			b.bullet.to = pos
			b.bullet.source_id = this.id
			b.sound_events.insert = nil

			queue_insert(store, b)
		end

		local targets = U.find_enemies_in_range(store.entities, this.pos, a.min_radius, a.max_radius, a.vis_flags, a.vis_bans)

		if targets then
			shuffle_table(targets)
		end

		local selected_positions = {}

		for i = 1, a.max_targets do
			if not targets or #targets == 0 then
				goto label_407_0
			end

			local sel_target = targets[1]
			local node_offset = P:predict_enemy_node_advance(sel_target, a.cast_time + a.node_prediction)
			local e_ni = sel_target.nav_path.ni + node_offset
			local e_pos = P:node_pos(sel_target.nav_path.pi, sel_target.nav_path.spi, e_ni)

			table.insert(selected_positions, e_pos)
			table.remove(targets, 1)

			for i = #targets, 1, -1 do
				local e = targets[i]

				if max_dist2 > V.dist2(sel_target.pos.x, sel_target.pos.y, e.pos.x, e.pos.y) then
					table.remove(targets, i)
				end
			end
		end

		if #selected_positions == a.max_targets then
			goto label_407_1
		end

		::label_407_0::

		do
			local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, a.min_radius, a.max_radius, TERRAIN_LAND)

			shuffle_table(nodes)

			for i = #selected_positions + 1, a.max_targets do
				local sel_node = nodes[1]

				table.insert(selected_positions, sel_node)
				table.remove(nodes, 1)

				for i = #nodes, 1, -1 do
					local n = nodes[i]

					if max_dist2 > V.dist2(sel_node.x, sel_node.y, n.x, n.y) then
						table.remove(nodes, i)
					end
				end
			end
		end

		::label_407_1::

		shuffle_table(selected_positions)

		for _, p in pairs(selected_positions) do
			shoot_bullet(p)
			U.y_wait(store, a.wait_between_shots)
		end
	end

	this.health_bar.hidden = false

	while true do
		if h.dead then
			this.transfer.disabled = true
			S:queue(this.sound_events.death)
			U.unblock_target(store, this)

			local death_ts = store.tick_ts
			local bans, flags = this.vis.bans, this.vis.flags
			local prefix = this.render.sprites[1].prefix

			this.vis.bans = F_ALL
			this.vis.flags = F_NONE
			this.health.ignore_damage = true

			if this._death_by_ultimate then
				S:queue(this.sound_death_ulti)
				U.animation_start(this, "idle", nil, store.tick_ts)
				U.y_wait(store, 0.5)
				U.animation_start(this, "ultimate", nil, store.tick_ts)
				U.y_wait(store, 0.5)
				ultimate_extra_fireballs()
				U.y_animation_wait(this)

				this.health.hp = 0
				this._death_by_ultimate = false
			else
				U.y_animation_play(this, "death", nil, store.tick_ts)
			end

			this.render.sprites[1].prefix = prefix .. "_death"

			local aura = E:create_entity(this.death_aura)

			aura.pos = this.pos

			queue_insert(store, aura)
			U.animation_start(this, "idle", nil, store.tick_ts, true)

			this.health.dead = false

			while store.tick_ts - death_ts < this.health.dead_lifetime and not this.force_respawn do
				this.render.sprites[1].z = Z_OBJECTS

				SU.y_hero_new_rally(store, this)

				this.render.sprites[1].z = Z_DECALS + 1
				this.health.ignore_damage = true

				coroutine.yield()
			end

			queue_remove(store, aura)

			this.force_respawn = nil
			this.render.sprites[1].z = Z_OBJECTS
			this.vis.bans = bans
			this.vis.flags = flags
			this.render.sprites[1].prefix = prefix
			this.health.hp = this.health.hp_max
			this.health.dead = false
			this.health.ignore_damage = false

			S:queue(this.sound_events.respawn)
			U.y_animation_play(this, "respawn", nil, store.tick_ts)

			this.health_bar.hidden = false
			this.transfer.disabled = nil

			if hotheaded_skill.level > 0 then
				local towers = U.find_towers_in_range(store.entities, this.pos, hotheaded_attack, function(t)
					local has_mod, mods = U.has_modifiers(store, t, hotheaded_skill.mods[1])

					return t.tower.can_be_mod
				end)

				if not towers or #towers <= 0 then
					goto label_405_0
				end

				U.animation_start(this, hotheaded_attack.animation, nil, store.tick_ts, 1)
				S:queue(hotheaded_attack.sound)

				for _, tower in ipairs(towers) do
					local m = E:create_entity(hotheaded_skill.mods[1])

					m.modifier.source_id = this.id
					m.modifier.target_id = tower.id

					queue_insert(store, m)

					m = E:create_entity(hotheaded_skill.mods[2])
					m.modifier.source_id = this.id
					m.modifier.target_id = tower.id
					m.pos = tower.pos

					queue_insert(store, m)
				end

				SU.hero_gain_xp_from_skill(this, hotheaded_skill)
				SU.y_hero_animation_wait(this)
			end
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_405_0
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "level_up", nil, store.tick_ts, 1)
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			skill = this.hero.skills.wild_eruption
			a = wild_eruption

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_trigger, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					S:queue(a.sound)
					U.y_animation_play(this, wild_eruption.animation_in, nil, store.tick_ts, 1)

					local sts = store.tick_ts

					U.animation_start(this, wild_eruption.animation_loop, nil, store.tick_ts, true)

					local lats = store.tick_ts - a.tick

					while store.tick_ts - sts < a.loop_duration do
						if store.tick_ts - lats > a.tick then
							local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_effect, a.vis_flags, a.vis_bans)

							if enemies then
								for _, t in ipairs(enemies) do
									local mod = E:create_entity(a.mod)

									mod.modifier.target_id = t.id
									mod.modifier.source_id = this.id

									queue_insert(store, mod)
								end
							end

							lats = store.tick_ts
						end

						coroutine.yield()
					end

					SU.hero_gain_xp_from_skill(this, skill)
					U.y_animation_play(this, wild_eruption.animation_out, nil, store.tick_ts, 1)

					a.ts = store.tick_ts
				end
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				brk, sta = y_hero_ranged_attacks(store, this)

				if brk then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_405_0::

		coroutine.yield()
	end
end

scripts.hero_lava_ultimate = {}

function scripts.hero_lava_ultimate.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_lava_ultimate.update(this, store)
	local start_y = store.visible_coords and store.visible_coords.top or REF_H
	local ts
	local burst_interval = 0.33

	for i = 1, this.fireball_count do
		if i <= this.fireball_count then
			local e = E:create_entity(this.bullet)
			local p, found, tries = nil, nil, 0

			while not p and tries < 5 do
				p = V.v(this.pos.x + math.random(-this.max_spread, this.max_spread), this.pos.y + math.random(-this.max_spread, this.max_spread))

				local oy = GR.cell_size

				if band(GR:cell_type(p.x, p.y + oy), TERRAIN_CLIFF) ~= 0 or band(GR:cell_type(p.x, p.y - oy), TERRAIN_CLIFF) ~= 0 then
					p = nil
					tries = tries + 1
				end
			end

			if p then
				e.pos.x, e.pos.y = p.x, start_y
				e.bullet.from = V.vclone(e.pos)
				e.bullet.to = V.v(p.x, p.y)

				queue_insert(store, e)
			end
		end

		ts = store.tick_ts

		while burst_interval > store.tick_ts - ts do
			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.bullet_ultimate_hero_lava = {}

function scripts.bullet_ultimate_hero_lava.update(this, store, script)
	local b = this.bullet
	local mspeed = 10 * FPS
	local particle = E:create_entity(this.particles)

	particle.particle_system.track_id = this.id

	queue_insert(store, particle)

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
		this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

		coroutine.yield()
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y
	particle.particle_system.source_lifetime = 0

	local enemies = {}

	for _, v in pairs(store.entities) do
		if v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, b.damage_bans) == 0 and band(v.vis.bans, b.damage_flags) == 0 and U.is_inside_ellipse(v.pos, b.to, b.damage_radius) then
			table.insert(enemies, v)
		elseif v.template_name == "hero_lava" and v.health.hp > 0 and U.is_inside_ellipse(v.pos, b.to, b.damage_radius) then
			v._death_by_ultimate = true
			v.health.hp = 0
		end
	end

	local damage_value = math.ceil(b.damage_factor * math.random(b.damage_min, b.damage_max))

	for _, enemy in ipairs(enemies) do
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = enemy.id
		d.value = damage_value
		d.damage_type = b.damage_type

		queue_damage(store, d)
	end

	S:queue(this.sound_events.hit)

	local cell_type = GR:cell_type(b.to.x, b.to.y)

	if band(cell_type, TERRAIN_WATER) ~= 0 then
		local fx = E:create_entity("fx_explosion_water")

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		if this.scorch_earth then
			local scorched = E:create_entity("power_scorched_water")

			scorched.pos.x, scorched.pos.y = b.to.x, b.to.y

			for i = 1, #scorched.render.sprites do
				scorched.render.sprites[i].ts = store.tick_ts
			end

			queue_insert(store, scorched)
		end
	else
		if b.hit_decal then
			local decal = E:create_entity(b.hit_decal)

			decal.pos = V.vclone(b.to)
			decal.render.sprites[1].ts = store.tick_ts

			queue_insert(store, decal)
		end

		if b.hit_fx then
			local fx = E:create_entity(b.hit_fx)

			fx.pos.x, fx.pos.y = b.to.x, b.to.y
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		end

		local scorched = E:create_entity(this.aura)

		scorched.pos.x, scorched.pos.y = b.to.x, b.to.y

		queue_insert(store, scorched)
	end

	queue_remove(store, shadow)
	queue_remove(store, this)
end

scripts.hero_builder = {}

function scripts.hero_builder.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local s, sl

	s = this.hero.skills.overtime_work
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - OVERTIME WORK - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local e = E:get_template(a.entity)

		e.health.hp_max = s.hp_max[sl]
		e.melee.attacks[1].damage_max = s.damage_max[sl]
		e.melee.attacks[1].damage_min = s.damage_min[sl]
	end

	s = this.hero.skills.lunch_break
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - LUNCH BREAK - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local m = E:get_template(a.mod)

		m.heal_hp = s.heal_hp[sl]
	end

	s = this.hero.skills.demolition_man
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - DEMOLITION MAN - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local e = E:get_template(a.aura)

		e.aura.duration = s.duration[sl]
		e.aura.damage_min = s.damage_min[sl]
		e.aura.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.defensive_turret
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - DEFENSIVE TURRET - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local e = E:get_template(a.entity)

		e.bullet_attack.cooldown = s.attack_cooldown[sl]
		e.duration = s.duration[sl]

		local b = E:get_template(e.bullet_attack.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local projectile = E:get_template(uc.entity)
		local aura = E:get_template(projectile.bullet.aura)

		aura.aura.damage_min = s.damage[sl]
		aura.aura.damage_max = s.damage[sl]

		local m = E:get_template(aura.aura.mod)

		m.modifier.duration = s.stun_duration[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_builder.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.hero_builder.update(this, store)
	local h = this.health
	local a, skill, brk, sta
	local overtime_work_attack = this.timed_attacks.list[1]
	local lunch_break_attack = this.timed_attacks.list[2]
	local demolition_man_attack = this.timed_attacks.list[3]
	local defensive_turret_attack = this.timed_attacks.list[4]
	local last_ts = store.tick_ts
	local last_target
	local last_target_ts = store.tick_ts
	local base_speed = this.motion.max_speed

	if not overtime_work_attack.disabled then
		overtime_work_attack.ts = store.tick_ts - overtime_work_attack.cooldown
	end

	if not lunch_break_attack.disabled then
		lunch_break_attack.ts = store.tick_ts - lunch_break_attack.cooldown
	end

	if not demolition_man_attack.disabled then
		demolition_man_attack.ts = store.tick_ts - demolition_man_attack.cooldown
	end

	if not defensive_turret_attack.disabled then
		defensive_turret_attack.ts = store.tick_ts - defensive_turret_attack.cooldown
	end

	this.health_bar.hidden = false

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)

			this.motion.max_speed = base_speed
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_262_1
				end
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
			end

			skill = this.hero.skills.overtime_work
			a = overtime_work_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound, {
						delay = fts(10)
					})
					U.animation_start(this, a.animation, nil, store.tick_ts, 1)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_262_1
					end

					a.ts = start_ts
					last_ts = start_ts

					SU.hero_gain_xp_from_skill(this, skill)

					enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

					local e = E:create_entity(a.entity)

					e.pos.x = this.pos.x + 10
					e.pos.y = this.pos.y - 10
					e.nav_rally.center = V.v(this.pos.x, this.pos.y)
					e.nav_rally.pos = V.vclone(e.pos)

					queue_insert(store, e)

					local fx = E:create_entity(a.spawn_fx)

					fx.pos.x, fx.pos.y = e.pos.x, e.pos.y
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)

					e = E:create_entity(a.entity)
					e.pos.x = this.pos.x - 10
					e.pos.y = this.pos.y + 10
					e.nav_rally.center = V.v(this.pos.x, this.pos.y)
					e.nav_rally.pos = V.vclone(e.pos)

					queue_insert(store, e)

					fx = E:create_entity(a.spawn_fx)
					fx.pos.x, fx.pos.y = e.pos.x, e.pos.y
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
					SU.y_hero_animation_wait(this)

					goto label_262_1
				end
			end

			a = lunch_break_attack
			skill = this.hero.skills.lunch_break

			if not a.disabled and this.health.hp <= this.health.hp_max * a.lost_health and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local start_ts = store.tick_ts

				U.animation_start(this, a.animation, nil, store.tick_ts, 1)

				if SU.y_hero_wait(store, this, a.cast_time) then
					goto label_262_1
				end

				a.ts = start_ts
				last_ts = start_ts

				S:queue(a.sound, {
					delay = fts(10)
				})
				SU.hero_gain_xp_from_skill(this, skill)

				local mod = E:create_entity(a.mod)

				mod.modifier.target_id = this.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)
				U.y_animation_wait(this)
			end

			skill = this.hero.skills.demolition_man
			a = demolition_man_attack

			if this.soldier.target_id and not last_target or this.soldier.target_id ~= last_target then
				last_target = this.soldier.target_id
				last_target_ts = store.tick_ts
			end

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_target_ts > a.min_fight_cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound, {
						delay = fts(10)
					})

					local fx = E:create_entity(a.fx)

					fx.pos = this.pos
					fx.render.sprites[1].ts = store.tick_ts
					fx.render.sprites[1].flip_x = this.render.sprites[1].flip_x

					queue_insert(store, fx)
					U.animation_start(this, a.animation .. "_start", nil, store.tick_ts, 1)
					U.animation_start(fx, "start", nil, store.tick_ts, 1)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_262_1
					end

					a.ts = start_ts
					last_ts = start_ts

					SU.hero_gain_xp_from_skill(this, skill)

					local aura = E:create_entity(a.aura)

					aura.aura.source_id = this.id
					aura.aura.ts = store.tick_ts
					aura.pos = this.pos

					queue_insert(store, aura)
					U.animation_start(this, a.animation .. "_loop", nil, store.tick_ts, true)
					U.animation_start(fx, "loop", nil, store.tick_ts, true)

					if SU.y_hero_wait(store, this, aura.aura.duration - (store.tick_ts - a.ts)) then
						-- block empty
					end

					queue_remove(store, aura)
					U.animation_start(fx, "end", nil, store.tick_ts, 1)
					U.y_animation_play(this, a.animation .. "_end", nil, store.tick_ts, 1)
					SU.y_hero_animation_wait(this)
					queue_remove(store, fx)

					goto label_262_1
				end
			end

			skill = this.hero.skills.defensive_turret
			a = defensive_turret_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)
					local pi, spi, ni = unpack(nearest[1])
					local turret_pos = P:node_pos(pi, spi, ni)
					local new_pos = {}

					new_pos.x, new_pos.y = turret_pos.x - a.spawn_offset.x, turret_pos.y

					if this.pos.x > turret_pos.x then
						new_pos.x = turret_pos.x + a.spawn_offset.x
					end

					local node_limit = math.floor(a.min_distance_from_border / P.average_node_dist)
					local nodes_to_goal = P:nodes_to_goal(pi, spi, ni)
					local nodes_from_start = P:nodes_from_start(pi, spi, ni)

					if nodes_to_goal < node_limit or nodes_from_start < node_limit then
						SU.delay_attack(store, a, 0.13333333333333333)
					else
						local start_ts = store.tick_ts

						this.nav_rally.new = false
						this.nav_rally.center = new_pos
						this.nav_rally.pos = new_pos

						local speed_mult = a.build_speed / this.motion.max_speed
						this.motion.max_speed = this.motion.max_speed * speed_mult

						local r = this.nav_rally
						local vis_bans = this.vis.bans
						local prev_immune = this.health.immune_to
						this.vis.bans = F_ALL
						this.health.immune_to = r.immune_to
						local out = false
						local animation = "walk"
						local n = this.nav_grid
						local dest = r.pos
						local x_to_flip = KR_GAME == "kr5" and 2 or 0
						local last_af
						while not V.veq(this.pos, dest) and not out do
							local w = table.remove(n.waypoints, 1) or dest
							local unsnap = #n.waypoints > 0
							U.set_destination(this, w)
							local an, af = U.animation_name_facing_point(this, animation, this.motion.dest)
							local new_af = af
							if x_to_flip > math.abs(this.pos.x - this.motion.dest.x) then
								new_af = last_af
							end
							U.animation_start(this, an, new_af, store.tick_ts, true)
							last_af = new_af
							while not this.motion.arrived do
								if this.health.dead and not this.health.ignore_damage then
									out = true
									break
								end
								U.walk(this, store.tick_length, nil, unsnap)
								coroutine.yield()
								this.motion.speed.x, this.motion.speed.y = 0, 0
							end
						end
						this.vis.bans = vis_bans
						this.health.immune_to = prev_immune
						if out then
							goto label_262_1
						end
						U.animation_start(this, "idle", nil, store.tick_ts, true)

						this.motion.max_speed = this.motion.max_speed / speed_mult

						local an, af, ai = U.animation_name_facing_point(this, a.animation, turret_pos)

						U.animation_start(this, an, af, store.tick_ts, 1)

						this.health_bar.hidden = true

						local _vis = {}

						_vis.bans, _vis.flags = this.vis.bans, this.vis.flags
						this.vis.bans = F_ALL
						this.vis.flags = F_NONE
						this.ui.can_select = false
						SU.remove_modifiers(store, this)

						out = false
						if SU.y_hero_wait(store, this, a.cast_time) then
							out = true
						end
						if out then
							this.health_bar.hidden = false
							this.vis.bans = _vis.bans
							this.vis.flags = _vis.flags
							this.ui.can_select = true
							goto label_262_1
						end

						a.ts = start_ts
						last_ts = start_ts
						SU.hero_gain_xp_from_skill(this, skill)

						local e = E:create_entity(a.entity)
						local epos = turret_pos
						e.flip_x = this.render.sprites[1].flip_x
						e.pos = V.vclone(epos)
						queue_insert(store, e)
						S:queue(a.sound_cast, {
							delay = fts(10)
						})
						e.sound_destroy = a.sound_destroy

						while not U.animation_finished(this) do
							coroutine.yield()
						end

						this.health_bar.hidden = false
						this.vis.bans = _vis.bans
						this.vis.flags = _vis.flags
						this.ui.can_select = true

						goto label_262_1
					end
				end
			end

			::label_262_0::

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_262_1::

		coroutine.yield()
	end
end

scripts.mod_hero_builder_lunch_break = {}

function scripts.mod_hero_builder_lunch_break.insert(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp + this.heal_hp)

	return true
end

scripts.decal_hero_builder_defensive_turret = {}

function scripts.decal_hero_builder_defensive_turret.update(this, store)
	local a = this.bullet_attack
	local soldier_sid = 2

	for i = 1, 3 do
		this.render.sprites[i].flip_x = this.flip_x
	end

	U.y_animation_play_group(this, "spawn", nil, store.tick_ts, false, "layers")

	a.ts = store.tick_ts - a.cooldown
	this.start_ts = store.tick_ts

	while true do
		if store.tick_ts - this.start_ts > this.duration then
			S:queue(this.sound_destroy, {
				delay = fts(10)
			})
			U.y_animation_play_group(this, "death", nil, store.tick_ts, false, "layers")

			break
		end

		if store.tick_ts - a.ts > a.cooldown then
			local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, false, a.vis_flags, a.vis_bans)

			if not target then
				SU.delay_attack(store, a, 0.2)
			else
				a.ts = store.tick_ts

				if target and target.health and not target.health.dead then
					local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false, soldier_sid)
					U.animation_start(this, an, nil, store.tick_ts, false, 1)
					U.y_wait(store, a.shoot_time)

					local idx = 1

					if this.render.sprites[soldier_sid].flip_x then
						idx = 2
					end

					local b = E:create_entity(a.bullet)

					b.bullet.from = V.v(this.pos.x + a.bullet_start_offset[idx].x, this.pos.y + a.bullet_start_offset[idx].y)
					b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
					b.bullet.target_id = target.id
					b.bullet.source_id = this.id
					b.pos = V.vclone(b.bullet.from)

					queue_insert(store, b)
					U.y_animation_wait(this)
				end
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.hero_builder_ultimate = {}

function scripts.hero_builder_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_builder_ultimate.update(this, store)
	local function spawn_ball(pi, spi, ni)
		local pos = P:node_pos(pi, spi, ni)
		local b = E:create_entity(this.entity)

		b.bullet.from = V.v(pos.x, pos.y + REF_H)
		b.bullet.to = pos
		b.pos = V.vclone(b.bullet.from)
		b.sound = this.sound

		queue_insert(store, b)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

	if #nearest > 0 then
		local pi, spi, ni = unpack(nearest[1])

		if P:is_node_valid(pi, ni) then
			spawn_ball(pi, 1, ni)
		end
	end

	queue_remove(store, this)
end

scripts.decal_hero_builder_ultimate_projectile = {}

function scripts.decal_hero_builder_ultimate_projectile.update(this, store)
	local b = this.bullet
	local speed = b.max_speed

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) >= 2 * (speed * store.tick_length) do
		b.speed.x, b.speed.y = V.mul(speed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
		this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

		coroutine.yield()
	end

	local targets = U.find_targets_in_range(store.entities, b.to, 0, b.damage_radius, b.damage_flags, b.damage_bans)

	if targets then
		for _, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.damage_type = b.damage_type
			d.value = b.damage_max
			d.source_id = this.id
			d.target_id = target.id

			queue_damage(store, d)

			if b.mod then
				local mod = E:create_entity(b.mod)

				mod.modifier.target_id = target.id

				queue_insert(store, mod)
			end
		end
	end

	S:queue(this.sound)

	if b.hit_fx then
		SU.insert_sprite(store, b.hit_fx, this.pos)
	end

	if b.arrive_decal then
		local decal = E:create_entity(b.arrive_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	local shake = E:create_entity("aura_screen_shake")

	shake.aura.amplitude = 0.4
	shake.aura.duration = 1
	shake.aura.freq_factor = 2

	queue_insert(store, shake)

	if b.aura then
		local aura = E:create_entity(b.aura)

		aura.pos = V.vclone(b.to)

		queue_insert(store, aura)
	end

	queue_remove(store, this)
end

scripts.decal_hero_builder_ultimate_ball = {}

function scripts.decal_hero_builder_ultimate_ball.update(this, store)
	U.animation_start(this, "hero_obdul_ultimate_decal", nil, store.tick_ts, 1, 9)
	U.animation_start(this, "hero_obdul_ultimate_decal", nil, store.tick_ts, 1, 10)
	U.animation_start(this, "hero_obdul_ultimate_decal", nil, store.tick_ts, 1, 11)
	U.animation_start(this, "in", nil, store.tick_ts, 1, 1)

	for i = 1, 4 do
		U.animation_start(this, "rock_0" .. i .. "_in", nil, store.tick_ts, 1, i + 2)
	end

	U.animation_start(this, "dust_over_ball_run", nil, store.tick_ts, 1, 7)
	U.animation_start(this, "ball", nil, store.tick_ts, 1, 2)

	for i = 11, 16 do
		U.animation_start(this, "dust_cloud", nil, store.tick_ts, 1, i)
	end

	local start_ts = store.tick_ts

	while true do
		if store.tick_ts - start_ts > this.duration then
			this.tween.ts = store.tick_ts
			this.tween.disabled = false

			U.y_wait(store, this.tween.props[1].keys[2][1])
		end

		coroutine.yield()
	end
end

scripts.hero_space_elf = {}

function scripts.hero_space_elf.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local bt = E:get_template(this.ranged.attacks[1].bullet)

	bt.bullet.damage_min = ls.ranged_damage_min[hl]
	bt.bullet.damage_max = ls.ranged_damage_max[hl]

	local s, sl

	s = this.hero.skills.astral_reflection
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - ASTRAL REFLECTION - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.entity = string.format("%s_%i", a.entity_prefix, sl)
	end

	s = this.hero.skills.black_aegis
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - BLACK AEGIS - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local m = E:get_template(a.mod)

		m.modifier.duration = s.duration[sl]
		m.shield_base = s.shield_base[sl]
		m.explosion_damage = s.explosion_damage[sl]
	end

	s = this.hero.skills.void_rift
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - VOID RIFT - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local aura = E:get_template(a.aura)

		aura.aura.duration = s.duration[sl]
		aura.aura.damage_max = s.damage_max[sl]
		aura.aura.damage_min = s.damage_min[sl]
	end

	s = this.hero.skills.spatial_distortion
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - SPATIAL DISTORTION - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local modifier = E:get_template(a.mod)

		modifier.modifier.duration = s.duration[sl]
		modifier.range_factor = s.range_factor[sl]
		modifier.tween.props[1].keys[2][1] = modifier.fade_duration
		modifier.tween.props[1].keys[3][1] = s.duration[sl] - modifier.fade_duration
		modifier.tween.props[1].keys[4][1] = s.duration[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local aura = E:get_template(uc.entity)
		local modifier = E:get_template(aura.aura.mod)

		modifier.modifier.duration = s.duration[sl]
		modifier.damage = s.damage[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_space_elf.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)
	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_space_elf.update(this, store)
	local h = this.health
	local brk, sta, a, skill
	local astral_reflection_attack = this.timed_attacks.list[1]
	local black_aegis_attack = this.timed_attacks.list[2]
	local void_rift_attack = this.timed_attacks.list[3]
	local spatial_distortion_attack = this.timed_attacks.list[4]
	local last_ts = store.tick_ts

	if not astral_reflection_attack.disabled then
		astral_reflection_attack.ts = store.tick_ts - astral_reflection_attack.cooldown
	end

	if not black_aegis_attack.disabled then
		black_aegis_attack.ts = store.tick_ts - black_aegis_attack.cooldown
	end

	if not void_rift_attack.disabled then
		void_rift_attack.ts = store.tick_ts - void_rift_attack.cooldown
	end

	if not spatial_distortion_attack.disabled then
		spatial_distortion_attack.ts = store.tick_ts - spatial_distortion_attack.cooldown
	end

	local function astral_reflection_spawn_pos(x, y)
		local nodes = P:nearest_nodes(x, y, nil, nil, true)

		if #nodes < 1 then
			log.debug("cannot insert summons, no valid nodes nearby %s,%s", x, y)

			return nil
		end

		local opi, ospi, ni = unpack(nodes[1])
		local spi = km.zmod(ospi + 1, 3)
		local npos = P:node_pos(opi, spi, ni - 5)

		if P:is_node_valid(opi, ni - 5) and band(GR:cell_type(npos.x, npos.y), bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) == 0 then
			return npos
		end

		return nil
	end

	local function y_hero_space_elf_new_rally(store, this)
		local r = this.nav_rally

		if r.new then
			r.new = false

			U.unblock_target(store, this)

			if this.sound_events then
				S:queue(this.sound_events.change_rally_point)
			end

			if SU.hero_will_teleport(this, r.pos) then
				local tp = this.teleport
				local vis_bans = this.vis.bans

				this.vis.bans = F_ALL
				this.health.ignore_damage = true
				this.health_bar.hidden = true

				S:queue(tp.sound_in)

				if tp.fx_out then
					local fx = E:create_entity(tp.fx_out)

					fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
					fx.render.sprites[1].ts = store.tick_ts

					if fx.tween then
						fx.tween.ts = store.tick_ts
					end

					queue_insert(store, fx)
				end

				local an, af = U.animation_name_facing_point(this, tp.animations[1], r.pos)

				U.animation_start(this, an, af, store.tick_ts, 1, nil)
				SU.y_hero_animation_wait(this)

				if tp.delay > 0 then
					U.sprites_hide(this, nil, nil, true)
					U.y_wait(store, tp.delay)
					U.sprites_show(this, nil, nil, true)
				end

				this.pos.x, this.pos.y = r.pos.x, r.pos.y

				U.set_destination(this, this.pos)

				this.motion.speed.x, this.motion.speed.y = 0, 0

				if tp.fx_in then
					local fx = E:create_entity(tp.fx_in)

					fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
					fx.render.sprites[1].ts = store.tick_ts

					if fx.tween then
						fx.tween.ts = store.tick_ts
					end

					queue_insert(store, fx)
				end

				S:queue(tp.sound_out)
				U.y_animation_play(this, tp.animations[2], nil, store.tick_ts)

				this.health_bar.hidden = false
				this.vis.bans = vis_bans
				this.health.ignore_damage = false

				return false
			elseif SU.hero_will_transfer(this, r.pos) then
				local tr = this.transfer
				local interrupt = false
				local ps
				local vis_bans = this.vis.bans

				this.vis.bans = F_ALL
				this.health.ignore_damage = true
				this.health_bar.hidden = true

				S:queue(tr.sound_loop)

				local an, af = U.animation_name_facing_point(this, tr.animations[2], r.pos)

				U.animation_start(this, an, af, store.tick_ts, 1, nil)

				if tr.particles_name then
					ps = E:create_entity(tr.particles_name)
					ps.particle_system.track_id = this.id

					queue_insert(store, ps)
				end

				local first_time = true

				::label_274_0::

				if not first_time then
					local an, af = U.animation_name_facing_point(this, tr.animations[2], r.pos)

					U.animation_start(this, an, af, store.tick_ts, true, 1, true)
				end

				local dest = r.pos
				local n = this.nav_grid

				while not V.veq(this.pos, dest) do
					local w = table.remove(n.waypoints, 1) or dest

					U.set_destination(this, w)

					local runs = this.render.sprites[1].runs

					while not this.motion.arrived do
						if r.new then
							if SU.hero_will_teleport(this, r.pos) then
								return y_hero_space_elf_new_rally(store, this)
							else
								r.new = false
								first_time = false

								goto label_274_0
							end
						end

						U.walk(this, store.tick_length)
						coroutine.yield()

						this.motion.speed.x, this.motion.speed.y = 0, 0

						if this.render.sprites[1].runs ~= runs then
							local an, af = U.animation_name_facing_point(this, tr.animations[2], this.motion.dest)

							U.animation_start(this, an, af, store.tick_ts, true, 1, true)

							runs = this.render.sprites[1].runs
						end
					end
				end

				if tr.particles_name then
					ps.particle_system.emit = false
					ps.particle_system.source_lifetime = 1
				end

				S:stop(tr.sound_loop)
				U.y_animation_play(this, tr.animations[3], nil, store.tick_ts)

				this.health_bar.hidden = false
				this.vis.bans = vis_bans
				this.health.ignore_damage = false

				return interrupt
			end
		end
	end

	local function spatial_distortion_get_towers(a)
		local targets = table.filter(store.entities, function(k, v)
			local is_tower = v.tower and not v.pending_removal and not v.tower.blocked and (not a.excluded_templates or not table.contains(a.excluded_templates, v.template_name)) and v.vis and band(v.vis.flags, a.vis_bans) == 0 and band(v.vis.bans, a.vis_flags) == 0 and not table.contains(a.exclude_tower_kind, v.tower.kind) and not U.has_modifiers(store, v, a.mod) and v.tower.can_be_mod

			return is_tower
		end)

		if targets and #targets > 0 then
			return targets
		end

		return nil
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true)

	this.health_bar.hidden = false

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if y_hero_space_elf_new_rally(store, this) then
					goto label_272_0
				end
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			a = this.timed_attacks.list[1]
			skill = this.hero.skills.astral_reflection

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, false, a.vis_flags, a.vis_bans)

				if not targets or #targets == 0 then
					SU.delay_attack(store, a, fts(10))
				else
					local pos = astral_reflection_spawn_pos(this.pos.x, this.pos.y)

					if not pos then
						SU.delay_attack(store, a, fts(10))
					else
						local start_ts = store.tick_ts
						local an, af = U.animation_name_facing_point(this, a.animation, pos)

						U.animation_start(this, an, af, store.tick_ts, 1, nil)
						S:queue(a.sound)

						if SU.y_hero_wait(store, this, a.cast_time) then
							goto label_272_0
						end

						local e = E:create_entity(a.entity)

						e.pos = pos
						e.nav_rally.center = V.vclone(e.pos)
						e.nav_rally.pos = V.vclone(e.pos)
						e.melee.attacks[1].xp_dest_id = this.id
						e.render.sprites[1].flip_x = math.random() < 0.5

						queue_insert(store, e)

						e.owner = this

						SU.y_hero_animation_wait(this)

						a.ts = start_ts
						last_ts = a.ts

						SU.hero_gain_xp_from_skill(this, skill)
					end
				end
			end

			a = this.timed_attacks.list[2]
			skill = this.hero.skills.black_aegis

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local targets = U.find_soldiers_in_range(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans, function(e)
					return e.template_name ~= this.template_name and e.soldier and e.soldier.target_id
				end)

				if not targets or #targets == 0 then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, a.animation, targets[1].pos)

					U.animation_start(this, an, af, store.tick_ts, 1, nil)

					if SU.y_hero_wait(store, this, a.cast_time) then
						-- block empty
					else
						S:queue(a.sound)

						a.ts = start_ts
						last_ts = a.ts

						SU.hero_gain_xp_from_skill(this, skill)

						targets = U.find_soldiers_in_range(store.entities, this.pos, 0, a.range, a.vis_flags, a.vis_bans, function(e)
							return e.template_name ~= this.template_name and e.soldier and e.soldier.target_id
						end)

						if targets and #targets > 0 then
							local target = targets[1]
							local m = E:create_entity(a.mod)

							m.modifier.source_id = this.id
							m.modifier.target_id = target.id

							queue_insert(store, m)
						end

						SU.y_hero_animation_wait(this)
					end

					goto label_272_0
				end
			end

			a = this.timed_attacks.list[3]
			skill = this.hero.skills.void_rift

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range_trigger, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, a.animation, enemies[1].pos)

					U.animation_start(this, an, af, store.tick_ts, 1, nil)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_272_0
					end

					S:queue(a.sound)

					a.ts = start_ts
					last_ts = a.ts

					SU.hero_gain_xp_from_skill(this, skill)

					local target, enemies = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range_effect, false, a.vis_flags, a.vis_bans)

					if target and not target.health.dead then
						local ni = target.nav_path.ni + P:predict_enemy_node_advance(target, a.predict)
						local last_node_pos
						local decal = E:create_entity(a.cast_decal)

						decal.pos = this.pos
						decal.render.sprites[1].ts = store.tick_ts
						decal.tween.ts = store.tick_ts

						queue_insert(store, decal)

						local cracks_fade = 2
						local distance_index = ni
						local aura = E:create_entity(a.aura)

						aura.aura.source_id = this.id
						aura.aura.ts = store.tick_ts
						aura.ignore_damage = true

						for _, s in ipairs(aura.render.sprites) do
							s.scale = v(1, 1)

							local scale = math.random(6, 8) * 0.1

							s.scale.x, s.scale.y = scale, scale
						end

						aura.render.sprites[3].alpha = 150

						local pos = P:node_pos(target.nav_path.pi, 1, distance_index)

						distance_index = distance_index - a.border_cracks_distance
						aura.pos = V.vclone(pos)
						last_node_pos = pos

						queue_insert(store, aura)
						U.y_wait(store, fts(cracks_fade))

						local aura_2 = E:create_entity(a.aura)

						aura_2.aura.source_id = this.id
						aura_2.aura.ts = store.tick_ts
						aura_2.ignore_damage = true

						for _, s in ipairs(aura_2.render.sprites) do
							s.scale = v(1, 1)

							local scale = math.random(4, 5) * 0.1

							s.scale.x, s.scale.y = scale, scale
						end

						aura_2.render.sprites[3].alpha = 100

						local pos = P:node_pos(target.nav_path.pi, 1, distance_index)

						distance_index = distance_index - a.border_cracks_distance
						aura_2.pos = V.vclone(pos)
						last_node_pos = pos

						queue_insert(store, aura_2)
						U.y_wait(store, fts(cracks_fade))

						for i = 1, skill.cracks_amount[skill.level] do
							local aura = E:create_entity(a.aura)

							aura.aura.source_id = this.id
							aura.aura.ts = store.tick_ts

							local pos = P:node_pos(target.nav_path.pi, 1, distance_index)

							distance_index = distance_index - a.cracks_distance

							local length1 = V.dist(pos.x, pos.y, last_node_pos.x, last_node_pos.y)
							local v1 = v(last_node_pos.x - pos.x, last_node_pos.y - pos.y)

							v1.x = v1.x / length1
							v1.y = v1.y / length1

							local v1perpendicular = v(v1.y, -v1.x)

							pos.x = pos.x + v1perpendicular.x * a.crack_offset * km.rand_sign()
							pos.y = pos.y + v1perpendicular.y * a.crack_offset * km.rand_sign()
							aura.pos = pos
							last_node_pos = pos

							queue_insert(store, aura)
							U.y_wait(store, fts(cracks_fade))
						end

						aura = E:create_entity(a.aura)
						aura.aura.source_id = this.id
						aura.aura.ts = store.tick_ts
						aura.ignore_damage = true

						for _, s in ipairs(aura.render.sprites) do
							s.scale = v(1, 1)

							local scale = math.random(6, 8) * 0.1

							s.scale.x, s.scale.y = scale, scale
						end

						aura.render.sprites[3].alpha = 150
						distance_index = distance_index + a.cracks_distance - a.border_cracks_distance

						local pos = P:node_pos(target.nav_path.pi, 1, distance_index)

						distance_index = distance_index - a.border_cracks_distance

						local length1 = V.dist(pos.x, pos.y, last_node_pos.x, last_node_pos.y)
						local v1 = v(last_node_pos.x - pos.x, last_node_pos.y - pos.y)

						v1.x = v1.x / length1
						v1.y = v1.y / length1

						local v1perpendicular = v(v1.y, -v1.x)

						pos.x = pos.x + v1perpendicular.x * a.crack_offset * km.rand_sign()
						pos.y = pos.y + v1perpendicular.y * a.crack_offset * km.rand_sign()
						aura.pos = pos
						last_node_pos = pos

						queue_insert(store, aura)
						U.y_wait(store, fts(cracks_fade))

						aura = E:create_entity(a.aura)
						aura.aura.source_id = this.id
						aura.aura.ts = store.tick_ts
						aura.ignore_damage = true

						for _, s in ipairs(aura.render.sprites) do
							s.scale = v(1, 1)

							local scale = math.random(4, 5) * 0.1

							s.scale.x, s.scale.y = scale, scale
						end

						aura.render.sprites[3].alpha = 100

						local pos = P:node_pos(target.nav_path.pi, 1, distance_index)
						local length1 = V.dist(pos.x, pos.y, last_node_pos.x, last_node_pos.y)
						local v1 = v(last_node_pos.x - pos.x, last_node_pos.y - pos.y)

						v1.x = v1.x / length1
						v1.y = v1.y / length1

						local v1perpendicular = v(v1.y, -v1.x)

						pos.x = pos.x + v1perpendicular.x * a.crack_offset * km.rand_sign()
						pos.y = pos.y + v1perpendicular.y * a.crack_offset * km.rand_sign()
						aura.pos = pos
						last_node_pos = pos

						queue_insert(store, aura)
					end

					SU.y_hero_animation_wait(this)
				end
			end

			a = this.timed_attacks.list[4]
			skill = this.hero.skills.spatial_distortion

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown and store.wave_group_number > 0 then
				local towers = spatial_distortion_get_towers(a)

				if not towers then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)
					U.animation_start(this, a.animation, nil, store.tick_ts, 1, nil)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_272_0
					end

					a.ts = start_ts
					last_ts = a.ts

					SU.hero_gain_xp_from_skill(this, skill)

					local towers = spatial_distortion_get_towers(a)

					if not towers then
						-- block empty
					else
						for _, t in pairs(towers) do
							local mod = E:create_entity(a.mod)

							mod.modifier.level = skill.level
							mod.modifier.target_id = t.id
							mod.modifier.source_id = this.id

							for k, v in pairs(mod.offset_y_per_tower) do
								if string.find(t.template_name, k, 1, true) then
									mod.render.sprites[1].offset.y = v
								end
							end

							queue_insert(store, mod)
						end

						SU.y_hero_animation_wait(this)
					end
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "lvlup", nil, store.tick_ts, 1)
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			else
				brk, sta = y_hero_ranged_attacks(store, this)

				if brk then
					-- block empty
				elseif SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_272_0::

		coroutine.yield()
	end
end

scripts.soldier_hero_space_elf_astral_reflection = {}

function scripts.soldier_hero_space_elf_astral_reflection.update(this, store, script)
	local brk, stam, star, a

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts

	if this.reinforcement.fade or this.reinforcement.fade_in then
		SU.y_reinforcement_fade_in(store, this)
	elseif this.render.sprites[1].name == "in" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.health_bar.hidden = true

		U.y_animation_play(this, "in", nil, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	this.render.sprites[1].hidden = true

	local spawn_fx = E:create_entity(this.spawn_fx)

	spawn_fx.pos = V.vclone(this.pos)
	spawn_fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, spawn_fx)
	U.y_wait(store, fts(23))

	this.render.sprites[1].hidden = false

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_279_1
				end
			end

			if this.ranged then
				brk, star = SU.y_soldier_ranged_attacks(store, this)

				if brk or star == A_DONE then
					goto label_279_1
				elseif star == A_IN_COOLDOWN then
					goto label_279_0
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				goto label_279_1
			end

			if SU.soldier_go_back_step(store, this) then
				goto label_279_1
			end

			::label_279_0::

			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_279_1::

		coroutine.yield()
	end
end

scripts.mod_hero_space_elf_black_aegis = {}

function scripts.mod_hero_space_elf_black_aegis.insert(this, store)
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	m.ts = store.tick_ts
	target.health.on_damage = scripts.mod_hero_space_elf_black_aegis.on_damage
	this._hit_sources = {}
	this._blood_color = target.unit.blood_color
	target.unit.blood_color = BLOOD_NONE
	target._shield_mod = this
	this.health.hp = this.shield_base
	this.health.hp_max = this.shield_base

	return true
end

function scripts.mod_hero_space_elf_black_aegis.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		target.health.on_damage = nil
		target._shield_mod = nil
		target.unit.blood_color = this._blood_color
	end

	return true
end

function scripts.mod_hero_space_elf_black_aegis.update(this, store)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	for i, s in ipairs(this.render.sprites) do
		if s.size_names then
			s.prefix = s.prefix .. "_" .. s.size_names[target.unit.size]
		end

		if i == 2 then
			s.name = s.prefix
		end
	end

	U.y_animation_play(this, this.animation_start, nil, store.tick_ts, 1)

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node or this.shield_broken then
			this.render.sprites[2].hidden = true

			S:queue(this.sound_explosion)
			U.animation_start(this, this.animation_end, nil, store.tick_ts, false)
			U.y_wait(store, this.explosion_time)

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.explosion_range, 0, bit.bor(F_FLYING, F_CLIFF))

			if targets then
				for _, target in pairs(targets) do
					local d = E:create_entity("damage")

					d.value = this.explosion_damage
					d.damage_type = this.explosion_damage_type
					d.target_id = target.id
					d.source_id = this.id

					queue_damage(store, d)

					local fx_pos = V.vclone(target.pos)

					if target.unit and target.unit.mod_offset then
						fx_pos.x = fx_pos.x + target.unit.mod_offset.x
						fx_pos.y = fx_pos.y + target.unit.mod_offset.y
					end

					local fx = E:create_entity(m.damage_fx)

					fx.pos = fx_pos
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end
			end

			U.y_animation_wait(this)
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		U.y_animation_play(this, this.animation_loop, nil, store.tick_ts, 1)
		coroutine.yield()
	end
end

function scripts.mod_hero_space_elf_black_aegis.on_damage(this, store, damage)
	local mod = this._shield_mod

	if not mod then
		log.error("mod_hero_space_elf_black_aegis.on_damage for enemy %s has no mod pointer", this.id)

		return true
	end

	if mod.shield_broken then
		return true
	end

	if U.flag_has(damage.damage_type, bor(DAMAGE_INSTAKILL, DAMAGE_DISINTEGRATE, DAMAGE_EAT, DAMAGE_IGNORE_SHIELD)) then
		mod.shield_broken = true

		queue_remove(store, mod)

		return true
	else
		mod.damage_taken = mod.damage_taken + damage.value
	end

	mod.health.hp = mod.shield_base - mod.damage_taken

	if mod.damage_taken >= mod.shield_base then
		mod.shield_broken = true

		if mod.damage_taken - mod.shield_base > 0 then
			damage.value = mod.damage_taken - mod.shield_base

			return true
		end
	end

	return false
end

scripts.aura_hero_space_elf_void_rift = {}

function scripts.aura_hero_space_elf_void_rift.update(this, store, script)
	this.aura.ts = store.tick_ts

	local last_hit_ts = 0
	local cycles_count = 0

	U.y_animation_play(this, "in", nil, store.tick_ts, 1)

	while true do
		if this.aura.cycles then
			if cycles_count >= this.aura.cycles then
				break
			end
		elseif this.aura.duration >= 0 and store.tick_ts - this.aura.ts >= this.aura.duration then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead then
				queue_remove(store, this)

				return
			end

			if te and te.pos then
				this.pos.x, this.pos.y = te.pos.x, te.pos.y
			end
		end

		if this.ignore_damage then
			-- block empty
		elseif store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			cycles_count = cycles_count + 1
			last_hit_ts = store.tick_ts

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.excluded_entities or not table.contains(this.aura.excluded_entities, v.id))
			end)

			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id

				local dmin, dmax = this.aura.damage_min, this.aura.damage_max

				if this.aura.damage_inc then
					dmin = dmin + this.aura.damage_inc * this.aura.level
					dmax = dmax + this.aura.damage_inc * this.aura.level
				end

				d.value = math.random(dmin, dmax)
				d.damage_type = this.aura.damage_type
				d.track_damage = this.aura.track_damage
				d.xp_dest_id = this.aura.xp_dest_id
				d.xp_gain_factor = this.aura.xp_gain_factor

				queue_damage(store, d)

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local m = E:create_entity(mod_name)

					m.modifier.level = this.aura.level
					m.modifier.target_id = target.id
					m.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						m.render = nil
					end

					queue_insert(store, m)
				end
			end
		end

		U.animation_start(this, "idle", nil, store.tick_ts, true)
		coroutine.yield()
	end

	U.y_animation_play(this, "out", nil, store.tick_ts, 1)
	queue_remove(store, this)
end

scripts.hero_space_elf_ultimate = {}

function scripts.hero_space_elf_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_space_elf_ultimate.update(this, store)
	local function spawn_aura(pi, spi, ni)
		local pos = P:node_pos(pi, spi, ni)
		local a = E:create_entity(this.entity)

		a.pos = pos

		queue_insert(store, a)

		local d = E:create_entity(this.decal)

		d.pos = pos
		d.render.sprites[1].ts = store.tick_ts

		queue_insert(store, d)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

	if #nearest > 0 then
		local pi, spi, ni = unpack(nearest[1])

		if P:is_node_valid(pi, ni) then
			spawn_aura(pi, 1, ni)
		end
	end

	queue_remove(store, this)
end

scripts.mod_hero_space_elf_ultimate = {}

function scripts.mod_hero_space_elf_ultimate.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		log.debug("%s (%s) queue/insertion", this.template_name, this.id)

		if U.flags_pass(target.vis, this.modifier) then
			this._pushed_bans = U.push_bans(target.vis, F_ALL)
			target.health.ignore_damage = true
		end
	else
		log.debug("%s (%s) queue/removal", this.template_name, this.id)

		if this._pushed_bans then
			U.pop_bans(target.vis, this._pushed_bans)

			target.health.ignore_damage = false
		end

		if this._decal_timelapse then
			queue_remove(store, this._decal_timelapse)

			if target.ui then
				target.ui.can_click = true
			end

			if target.health_bar then
				target.health_bar.hidden = nil
			end

			U.sprites_show(target, nil, nil, true)
			SU.show_modifiers(store, target, true, this)
			SU.show_auras(store, target, true)
		end
	end
end

function scripts.mod_hero_space_elf_ultimate.dequeue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return
	end

	if insertion then
		log.debug("%s (%s) dequeue/insertion", this.template_name, this.id)

		if this._pushed_bans then
			U.pop_bans(target.vis, this._pushed_bans)

			target.health.ignore_damage = false
		end
	end
end

function scripts.mod_hero_space_elf_ultimate.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if target and target.health and not target.health.dead and this._pushed_bans ~= nil then
		SU.stun_inc(target)

		return true
	else
		return false
	end
end

function scripts.mod_hero_space_elf_ultimate.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		SU.stun_dec(target)
	end

	return true
end

function scripts.mod_hero_space_elf_ultimate.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts
	this.pos.x, this.pos.y = target.pos.x, target.pos.y
	this.render.sprites[1].offset.y = target.unit.hit_offset.y

	local s = this.render.sprites[1]

	if s.size_names then
		s.prefix = s.prefix .. "_" .. s.size_names[target.unit.size]
	end

	s.hidden = true

	local es = E:create_entity(this.decal)

	if not target.render.sprites[1].exo then
		this._decal_timelapse = es
		es.pos.x, es.pos.y = target.pos.x, target.pos.y
		es.render.sprites[1] = table.deepclone(target.render.sprites[1])

		-- local tween_keys = es.tween.props[1].keys

		-- for i, s in ipairs(es.render.sprites) do
		-- 	es.tween.props[i] = E:clone_c("tween_prop")
		-- 	es.tween.props[i].keys = tween_keys
		-- 	es.tween.props[i].sprite_id = i
		-- end

		queue_insert(store, es)
		U.y_wait(store, fts(1))
	end

	U.unblock_all(store, target)

	if target.ui then
		target.ui.can_click = false
	end

	if target.health_bar then
		target.health_bar.hidden = true
	end

	U.sprites_hide(target, nil, nil, true)
	SU.hide_modifiers(store, target, true, this)
	SU.hide_auras(store, target, true)

	this.tween.ts = store.tick_ts

	local tween_levitate = this.tween.props[2]

	es.tween.ts = store.tick_ts
	es.tween.disabled = false

	U.y_wait(store, fts(math.random(1, 8)))

	s.hidden = false

	U.animation_start(this, "in", nil, store.tick_ts, false, 1)
	U.y_animation_wait(this)

	tween_levitate.keys[1][2].y = this.render.sprites[1].offset.y
	tween_levitate.keys[2][2].y = this.render.sprites[1].offset.y + tween_levitate.keys[2][2].y
	tween_levitate.keys[3][2].y = this.render.sprites[1].offset.y
	tween_levitate.keys[2][1] = fts(math.random(30, 40))
	tween_levitate.keys[3][1] = tween_levitate.keys[2][1] * 2
	tween_levitate.ts = store.tick_ts
	tween_levitate.disabled = false

	U.animation_start(this, "idle", nil, store.tick_ts, true, 1)
	U.y_wait(store, m.duration - (store.tick_ts - m.ts) - fts(10), function(store, time)
		return this.interrupt
	end)

	tween_levitate.disabled = true

	U.animation_start(this, "out", nil, store.tick_ts, false, 1)

	this.tween.ts = store.tick_ts
	this.tween.reverse = true

	U.y_wait(store, fts(23))

	es.tween.reverse = true
	es.tween.ts = store.tick_ts

	S:queue(this.out_sfx)
	U.y_animation_wait(this)

	if target.ui then
		target.ui.can_click = true
	end

	if target.health_bar then
		target.health_bar.hidden = nil
	end

	U.sprites_show(target, nil, nil, true)
	SU.show_modifiers(store, target, true, this)
	SU.show_auras(store, target, true)
	queue_remove(store, es)

	this._decal_timelapse = nil

	queue_remove(store, this)

	if this.interrupt then
		target.health.hp = 0

		if target.death_spawns then
			target.health.last_damage_types = DAMAGE_NO_SPAWNS
		end
	else
		local d = E:create_entity("damage")

		d.damage_type = this.damage_type
		d.value = this.damage
		d.source_id = this.id
		d.target_id = target.id

		queue_damage(store, d)
	end

	signal.emit("mod-applied", this, target)
end

scripts.hero_mecha = {}

function scripts.hero_mecha.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.ranged.attacks[1].damage_min = ls.ranged_damage_min[hl]
	this.ranged.attacks[1].damage_max = ls.ranged_damage_max[hl]

	local bt = E:get_template(this.ranged.attacks[1].bullet)

	bt.bullet.damage_min = ls.ranged_damage_min[hl]
	bt.bullet.damage_max = ls.ranged_damage_max[hl]

	local s, sl

	s = this.hero.skills.goblidrones
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - GOBLIDRONES - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
	end

	s = this.hero.skills.tar_bomb
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - TAR BOMB - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local bullet = E:get_template(a.bullet)
		local tar = E:get_template(bullet.bullet.hit_payload)

		tar.aura.duration = s.duration[sl]
		tar.tween.props[1].keys = {
			{
				0,
				255
			},
			{
				tar.aura.duration - 0.5,
				255
			},
			{
				tar.aura.duration,
				0
			}
		}
	end

	s = this.hero.skills.power_slam
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - POWER SLAM - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
	end

	s = this.hero.skills.mine_drop
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - MINE DROP - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local bullet = E:get_template(a.bullet)
		local mine = E:get_template(bullet.bullet.hit_payload)

		mine.damage_min = s.damage_min[sl]
		mine.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local zep = E:get_template(uc.entity)
		local bullet = E:get_template(zep.ranged.attacks[1].bullet)

		bullet.bullet.level = s.level
		bullet.bullet.damage_min = s.damage_min[s.level]
		bullet.bullet.damage_max = s.damage_max[s.level]
	end

	this.health.hp = this.health.hp_max
end

function scripts.hero_mecha.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_mecha.update(this, store)
	local h = this.health
	local a, skill
	local goblidrones_attack = this.timed_attacks.list[1]
	local tar_bomb_attack = this.timed_attacks.list[2]
	local power_slam_attack = this.timed_attacks.list[3]
	local mine_drop_attack = this.timed_attacks.list[4]
	local last_ts = store.tick_ts
	local idle_ts = store.tick_ts
	local ps1, ps2

	this.max_mines_near = false

	local function calculate_mine_pos(near_mines)
		local a = mine_drop_attack
		local valid_positions = P:get_all_valid_pos(this.pos.x, this.pos.y, a.min_range, a.max_range, TERRAIN_LAND, function(x, y)
			for _, mine in ipairs(near_mines) do
				if V.dist(mine.pos.x, mine.pos.y, x, y) <= a.min_dist_between_mines then
					return false
				end
			end

			return true
		end, nil, {
			1,
			2,
			3
		})

		return valid_positions[math.random(1, #valid_positions)]
	end

	if not goblidrones_attack.disabled then
		goblidrones_attack.ts = store.tick_ts - goblidrones_attack.cooldown
	end

	if not tar_bomb_attack.disabled then
		tar_bomb_attack.ts = store.tick_ts - tar_bomb_attack.cooldown
	end

	if not power_slam_attack.disabled then
		power_slam_attack.ts = store.tick_ts - power_slam_attack.cooldown
	end

	if not mine_drop_attack.disabled then
		mine_drop_attack.ts = store.tick_ts - mine_drop_attack.cooldown
	end

	this.health_bar.hidden = false
	ps1 = E:create_entity(this.particles_name_1)
	ps1.particle_system.emit = true
	ps1.particle_system.track_id = this.id

	queue_insert(store, ps1)

	ps2 = E:create_entity(this.particles_name_2)
	ps2.particle_system.emit = true
	ps2.particle_system.track_id = this.id

	queue_insert(store, ps2)

	while true do
		if h.dead then
			ps1.particle_system.emit = false
			ps2.particle_system.emit = false

			SU.y_hero_death_and_respawn_kr5(store, this)

			ps1.particle_system.emit = true
			ps2.particle_system.emit = true
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_297_0
				end

				this.max_mines_near = false
				idle_ts = store.tick_ts
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			a = this.timed_attacks.list[1]
			skill = this.hero.skills.goblidrones

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, a.spawn_range, false, a.vis_flags, a.vis_bans)

				if not targets or #targets < a.min_targets then
					-- block empty
				else
					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, a.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, 1, nil)
					S:queue(a.sound)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_297_0
					end

					for i = 1, 2 do
						local d = E:create_entity(a.entity)

						d.pos = V.vclone(this.pos)

						if this.render.sprites[1].flip_x then
							d.pos.x, d.pos.y = this.pos.x - a.spawn_pos_offset.x, this.pos.y - a.spawn_pos_offset.y
						else
							d.pos.x, d.pos.y = this.pos.x + a.spawn_pos_offset.x, this.pos.y + a.spawn_pos_offset.y
						end

						d.ranged.attacks[1].xp_dest_id = this.id
						d.owner = this
						d.drone_id = i
						d.level = this.hero.skills.goblidrones.level

						queue_insert(store, d)
					end

					SU.y_hero_animation_wait(this)

					a.ts = start_ts
					last_ts = a.ts

					SU.hero_gain_xp_from_skill(this, skill)
				end
			end

			a = this.timed_attacks.list[2]
			skill = this.hero.skills.tar_bomb

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)

				if not targets or #targets < a.min_targets or not pred_pos then
					SU.delay_attack(store, a, fts(10))
				else
					local nearest = P:nearest_nodes(pred_pos.x, pred_pos.y)

					if #nearest > 0 then
						local path_pi, path_spi, path_ni = unpack(nearest[1])

						path_spi = 1
						pred_pos = P:node_pos(path_pi, path_spi, path_ni)
					end

					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, a.animation, pred_pos)

					U.animation_start(this, an, af, store.tick_ts, 1, nil)
					S:queue(a.sound)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_297_0
					end

					local offset_x = a.bullet_start_offset[1].x

					if af then
						offset_x = -offset_x
					end

					local b = E:create_entity(a.bullet)

					b.bullet.from = V.v(this.pos.x + offset_x, this.pos.y + a.bullet_start_offset[1].y)
					b.bullet.to = V.v(pred_pos.x, pred_pos.y)
					b.bullet.target_id = target.id
					b.bullet.source_id = this.id
					b.pos = V.vclone(b.bullet.from)

					queue_insert(store, b)
					SU.y_hero_animation_wait(this)

					a.ts = start_ts
					last_ts = a.ts

					SU.hero_gain_xp_from_skill(this, skill)
				end
			end

			a = this.timed_attacks.list[3]
			skill = this.hero.skills.power_slam

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.damage_radius, 0, a.vis_flags, a.vis_bans_trigger)

				if not targets or #targets < a.min_targets or not pred_pos then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, a.animation, pred_pos)

					U.animation_start(this, an, af, store.tick_ts, 1, nil)
					S:queue(a.sound)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_297_0
					end

					local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.damage_radius, 0, a.vis_flags, a.vis_bans_damage)

					if target and targets then
						for _, enemy in ipairs(targets) do
							if enemy and not enemy.dead then
								local d = E:create_entity("damage")

								d.damage_type = a.damage_type
								d.value = math.random(a.damage_min[skill.level], a.damage_max[skill.level])
								d.source_id = this.id
								d.target_id = enemy.id

								queue_damage(store, d)

								local mod = E:create_entity(a.mod)

								mod.modifier.target_id = enemy.id
								mod.modifier.source_id = this.id
								mod.duration = skill.stun_time[skill.level]

								queue_insert(store, mod)
							end
						end
					end

					SU.y_hero_animation_wait(this)

					a.ts = start_ts
					last_ts = a.ts

					SU.hero_gain_xp_from_skill(this, skill)
				end
			end

			a = this.timed_attacks.list[4]
			skill = this.hero.skills.mine_drop

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown and store.tick_ts - idle_ts > a.cooldown and not this.max_mines_near and store.wave_group_number > 0 then
				local target, _, _ = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, 0, a.vis_flags, a.vis_bans)

				if target then
					SU.delay_attack(store, a, fts(10))
				else
					local near_mines = table.filter(store.entities, function(k, v)
						return v.template_name == "aura_bullet_hero_mecha_mine" and V.dist2(v.pos.x, v.pos.y, this.pos.x, this.pos.y) <= a.max_range * a.max_range
					end)

					if #near_mines >= skill.max_mines[skill.level] then
						this.max_mines_near = true

						SU.delay_attack(store, a, fts(10))
					else
						local mine_pos = calculate_mine_pos(near_mines)

						if not mine_pos then
							this.max_mines_near = true

							SU.delay_attack(store, a, fts(10))
						else
							local all_mines = table.filter(store.entities, function(k, v)
								return v.template_name == "aura_bullet_hero_mecha_mine"
							end)

							if #all_mines >= skill.max_mines[skill.level] then
								local far_mines = table.filter(all_mines, function(k, v)
									return V.dist2(v.pos.x, v.pos.y, this.pos.x, this.pos.y) > a.max_range * a.max_range
								end)

								table.sort(far_mines, function(e1, e2)
									return V.dist2(e1.pos.x, e1.pos.y, this.pos.x, this.pos.y) > V.dist2(e2.pos.x, e2.pos.y, this.pos.x, this.pos.y)
								end)

								far_mines[1].trigger = true
							end

							local start_ts = store.tick_ts
							local an, af = U.animation_name_facing_point(this, a.animation, mine_pos)

							U.animation_start(this, an, af, store.tick_ts, 1, nil)
							S:queue(a.sound_cast)

							if SU.y_hero_wait(store, this, a.cast_time) then
								goto label_297_0
							end

							local b = E:create_entity(a.bullet)

							b.bullet.from = V.v(this.pos.x + a.bullet_start_offset[1].x, this.pos.y + a.bullet_start_offset[1].y)
							b.bullet.to = V.v(mine_pos.x, mine_pos.y)
							b.bullet.source_id = this.id
							b.pos = V.vclone(b.bullet.from)

							queue_insert(store, b)
							SU.y_hero_animation_wait(this)

							a.ts = start_ts
							last_ts = a.ts

							SU.hero_gain_xp_from_skill(this, skill)
						end
					end
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)
			end

			do
				local brk, sta = y_hero_ranged_attacks(store, this)

				if sta == A_DONE then
					if this.ranged.attacks[1].disabled then
						this.ranged.attacks[1].disabled = false
						this.ranged.attacks[2].disabled = true
					else
						this.ranged.attacks[1].disabled = true
						this.ranged.attacks[2].disabled = false
					end

					goto label_297_0
				end
			end

			if SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_297_0::

		coroutine.yield()
	end
end

scripts.ps_hero_mecha_smoke = {}

function scripts.ps_hero_mecha_smoke.update(this, store)
	local source_sprite = store.entities[this.particle_system.track_id].render.sprites[1]

	while true do
		if source_sprite.flip_x then
			this.particle_system.emit_offset.x = math.abs(this.particle_system.emit_offset.x)
			this.particle_system.emit_direction = this.emit_direction_sides[2]
		else
			this.particle_system.emit_offset.x = -math.abs(this.particle_system.emit_offset.x)
			this.particle_system.emit_direction = this.emit_direction_sides[1]
		end

		coroutine.yield()
	end

	return true
end

scripts.bullet_hero_mecha = {}

function scripts.bullet_hero_mecha.insert(this, store)
	local b = this.bullet
	local source = store.entities[b.source_id]
	local fx

	if source.ranged.attacks[1].disabled then
		fx = E:create_entity(b.spawn_fx_2)
	else
		fx = E:create_entity(b.spawn_fx_1)
	end

	fx.pos = V.vclone(source.pos)

	local s = fx.render.sprites[1]

	s.ts = store.tick_ts
	s.flip_x = source.render.sprites[1].flip_x

	queue_insert(store, fx)

	return true
end

function scripts.bullet_hero_mecha.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local ps
	local last_pos = V.vclone(this.pos)
	local started_curve = false
	local time_to_live = 2

	local function angle_between(x1, y1, x2, y2)
		local dot = x1 * x2 + y1 * y2
		local mags = V.len(x1, y1) * V.len(x2, y2)

		return math.acos(dot / mags)
	end

	local function move_step(dest)
		local last_dir = v(this.pos.x - last_pos.x, this.pos.y - last_pos.y)

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist2 = V.len2(dx, dy)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)
		local dist_limit = 12 * fm.max_v * store.tick_length

		if dist2 <= dist_limit * dist_limit then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		local new_dir = v(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		local angle_dif = angle_between(new_dir.x, new_dir.y, last_dir.x, last_dir.y)
		local max_angle_rot = km.deg2rad(this.max_rotation_speed)

		if started_curve and store.tick_ts - b.ts > 0.25 then
			dist_limit = 20

			local max_mult = 5

			max_angle_rot = max_angle_rot * (1 + km.clamp(0, max_mult, max_mult * (dist_limit / dist)))
		end

		if max_angle_rot < math.abs(angle_dif) then
			local dot = dx * -last_dir.y + dy * last_dir.x

			if dot < 0 then
				new_dir.x, new_dir.y = V.rotate(-max_angle_rot, last_dir.x, last_dir.y)
			else
				new_dir.x, new_dir.y = V.rotate(max_angle_rot, last_dir.x, last_dir.y)
			end

			if V.len2(new_dir.x, new_dir.y) < this.min_speed * this.min_speed then
				new_dir.x, new_dir.y = V.normalize(new_dir.x, new_dir.y)
				new_dir.x, new_dir.y = new_dir.x * this.min_speed, new_dir.y * this.min_speed
			end

			this.pos.x, this.pos.y = last_pos.x + new_dir.x, last_pos.y + new_dir.y
		end

		return dist2 <= fm.max_v * store.tick_length * 2 * (fm.max_v * store.tick_length * 2)
	end

	local function y_fly_to_pos(target_pos)
		local start_ts = store.tick_ts
		local dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
		local dist2 = V.len2(dx, dy)

		while dist2 > 400 do
			move_step(target_pos)

			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			ps.particle_system.emit_offset.x, ps.particle_system.emit_offset.y = V.rotate(this.render.sprites[1].r, ps.emit_offset_relative.x, ps.emit_offset_relative.y)
			dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
			dist2 = V.len2(dx, dy)

			coroutine.yield()
		end
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local target_pos
	local impulse_length = 35

	if source.render.sprites[1].flip_x then
		fm.a.x, fm.a.y = -80, 0
		target_pos = v(b.from.x - impulse_length, b.from.y)
	else
		fm.a.x, fm.a.y = 80, 0
		target_pos = v(b.from.x + impulse_length, b.from.y)
	end

	last_pos.x, last_pos.y = this.pos.x - fm.a.x, this.pos.y - fm.a.y

	y_fly_to_pos(target_pos)

	fm.a_step = 5
	fm.max_a = 1800
	fm.max_v = 360
	b.ts = store.tick_ts
	started_curve = true

	if target and band(target.vis.flags, F_FLYING) ~= 0 then
		b.ignore_hit_offset = false
	end

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
		end

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			ps.particle_system.emit_offset.x, ps.particle_system.emit_offset.y = V.rotate(this.render.sprites[1].r, ps.emit_offset_relative.x, ps.emit_offset_relative.y)
		end

		if time_to_live < store.tick_ts - b.ts then
			target = nil

			break
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)
		S:queue(this.sound_events.hit)
	end

	this.render.sprites[1].hidden = true

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		if target then
			fx.pos.x, fx.pos.y = b.to.x, b.to.y
		else
			fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
		end

		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.drone_hero_mecha = {}

function scripts.drone_hero_mecha.update(this, store)
	local sd = this.render.sprites[1]
	local ss = this.render.sprites[2]
	local a = this.ranged.attacks[1]
	local fm = this.force_motion
	local hero = this.owner

	local function find_target(range)
		target, targets = U.find_nearest_enemy(store.entities, hero.pos, 0, range, a.vis_flags, a.vis_bans)

		if not target then
			return nil
		end

		local drones = LU.list_entities(store.entities, this.template_name)
		local drone_target_ids = table.map(drones, function(k, v)
			return v._chasing_target_id or 0
		end)
		local untargeted = table.filter(targets, function(k, v)
			return not table.contains(drone_target_ids, v.id) and V.dist2(v.pos.x, v.pos.y, hero.pos.x, hero.pos.y) < range * range
		end)

		for _, nt in ipairs(targets) do
			if table.contains(untargeted, nt) then
				return nt
			end
		end

		return target
	end

	local shoot_ts, search_ts = 0, 0
	local target, targets, dist
	local dest = V.v(this.pos.x, this.pos.y)

	this.start_ts = store.tick_ts
	fm.a_step = fm.a_step + math.random(-3, 3)
	this.tween.ts = U.frandom(0, 1)

	local oos = {
		V.v(-15, 0),
		V.v(10, 7)
	}
	local oo = oos[this.drone_id]

	a.damage_min = a.damage_min_config[this.level]
	a.damage_max = a.damage_max_config[this.level]

	U.animation_start(this, "idle", true, store.tick_ts, true, 1)

	local initial_pos_offset = {}

	if this.drone_id == 1 then
		initial_pos_offset = V.v(-50, 40)
	else
		initial_pos_offset = V.v(40, 30)
	end

	repeat
		dest.x, dest.y = this.owner.pos.x + initial_pos_offset.x, this.owner.pos.y + initial_pos_offset.y
		sd.flip_x = dest.x < this.pos.x

		U.force_motion_step(this, store.tick_length, dest)
		coroutine.yield()

		dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
	until dist < 5

	while store.tick_ts - this.start_ts <= this.duration[this.level] do
		search_ts = store.tick_ts
		target = find_target(a.max_range)

		if target then
			this._chasing_target_id = target.id
		else
			this._chasing_target_id = nil
		end

		if target then
			repeat
				dest.x, dest.y = target.pos.x + oo.x, target.pos.y + oo.y
				sd.flip_x = dest.x < this.pos.x

				U.force_motion_step(this, store.tick_length, dest)
				coroutine.yield()

				dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
			until dist < a.shoot_range or target.health.dead or band(a.vis_flags, target.vis.bans) ~= 0

			if store.entities[target.id] and not target.health.dead and band(a.vis_flags, target.vis.bans) == 0 and store.tick_ts - shoot_ts > a.cooldown then
				if math.random() < a.sound_chance then
					S:queue(a.sound)
				end

				U.animation_start(this, a.animation, this.pos.x < target.pos.x, store.tick_ts, false, 1)

				for i = 1, a.hit_cycles do
					local hit_ts = store.tick_ts

					while store.tick_ts - hit_ts < a.hit_time do
						U.force_motion_step(this, store.tick_length, dest)

						sd.flip_x = this.pos.x < target.pos.x

						coroutine.yield()
					end

					local d = SU.create_attack_damage(a, target.id, this.id)

					queue_damage(store, d)

					local fx = E:create_entity(a.hit_fx)

					fx.pos.x, fx.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
					fx.render.sprites[1].ts = store.tick_ts
					fx.render.sprites[1].runs = 0

					queue_insert(store, fx)
				end

				while not U.animation_finished(this) do
					U.force_motion_step(this, store.tick_length, dest)

					sd.flip_x = this.pos.x < target.pos.x

					coroutine.yield()
				end

				U.animation_start(this, "idle", nil, store.tick_ts, true, 1)

				shoot_ts = store.tick_ts
			end

			U.animation_start(this, "idle", nil, store.tick_ts, true, 1)
		end

		this._chasing_target_id = nil

		while store.tick_ts - search_ts < a.search_cooldown do
			U.force_motion_step(this, store.tick_length, dest)
			coroutine.yield()
		end
	end

	U.y_ease_keys(store, {
		sd,
		sd.offset,
		ss
	}, {
		"alpha",
		"y",
		"alpha"
	}, {
		255,
		this.flight_height,
		255
	}, {
		0,
		85,
		0
	}, 0.4)
	queue_remove(store, this)
end

scripts.bullet_hero_mecha_mine = {}

function scripts.bullet_hero_mecha_mine.insert(this, store)
	local b = this.bullet

	b.speed = SU.initial_parabola_speed(b.from, b.to, b.flight_time, b.g)
	b.ts = store.tick_ts
	b.last_pos = V.vclone(b.from)

	if b.rotation_speed then
		this.render.sprites[1].r = 0
		b.rotation_speed = b.rotation_speed * (b.to.x > b.from.x and -1 or 1)
	end

	this.render.sprites[1].hidden = false

	return true
end

function scripts.bullet_hero_mecha_mine.update(this, store)
	local b = this.bullet

	this.render.sprites[1].hidden = false

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
		else
			hp = b.hit_payload
		end

		hp.pos.x, hp.pos.y = b.to.x, b.to.y
		hp.source_id = b.source_id

		if hp.aura then
			hp.aura.level = this.bullet.level
		end

		queue_insert(store, hp)
	end

	queue_remove(store, this)
end

scripts.aura_bullet_hero_mecha_mine = {}

function scripts.aura_bullet_hero_mecha_mine.insert(this, store)
	this.aura.ts = store.tick_ts

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts
		end
	end

	U.animation_start(this, "in", nil, store.tick_ts, false)

	this.actual_duration = this.aura.duration

	return true
end

function scripts.aura_bullet_hero_mecha_mine.update(this, store)
	U.y_animation_wait(this)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.aura.radius * 0.75, this.aura.vis_flags, this.aura.vis_bans_trigger)

		if this.trigger or targets and #targets > 0 then
			S:queue(this.sound_explode)
			U.y_animation_play(this, "on", nil, store.tick_ts, false)

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.aura.radius, this.aura.vis_flags, this.aura.vis_bans_damage)

			if targets and #targets > 0 then
				for _, enemy in ipairs(targets) do
					if enemy and not enemy.dead then
						local d = E:create_entity("damage")

						d.damage_type = this.damage_type

						local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, this.pos, this.aura.radius)

						d.value = math.floor(this.damage_max - (this.damage_max - this.damage_min) * dist_factor)
						d.source_id = this.id
						d.target_id = enemy.id

						queue_damage(store, d)
					end
				end
			end

			local fx = E:create_entity(this.explosion_fx)

			fx.pos = V.vclone(this.pos)
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].runs = 0

			queue_insert(store, fx)

			this.render.sprites[1].hidden = true

			for _, e in pairs(store.entities) do
				if e.template_name == "hero_mecha" then
					e.max_mines_near = false

					break
				end
			end

			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.hero_mecha_ultimate = {}

function scripts.hero_mecha_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_mecha_ultimate.update(this, store)
	local function spawn_zeppelin(pi, spi, ni)
		local pos = P:node_pos(pi, spi, ni)
		local x_center = (store.visible_coords.left + store.visible_coords.right) / 2
		local spawn_pos = V.vclone(pos)
		local exit_pos = V.vclone(pos)
		local out_of_screen_offset = 100

		if x_center > spawn_pos.x then
			spawn_pos.x = store.visible_coords.left - out_of_screen_offset
			exit_pos.x = store.visible_coords.right + out_of_screen_offset
		else
			spawn_pos.x = store.visible_coords.right + out_of_screen_offset
			exit_pos.x = store.visible_coords.left - out_of_screen_offset
		end

		local zep = E:create_entity(this.entity)

		zep.pos = V.vclone(spawn_pos)
		zep.target_pos = V.vclone(pos)
		zep.exit_pos = V.vclone(exit_pos)
		zep.sound = this.sound
		zep.level = this.level

		queue_insert(store, zep)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

	if #nearest > 0 then
		local pi, spi, ni = unpack(nearest[1])

		if P:is_node_valid(pi, ni) then
			S:queue(this.sound)
			spawn_zeppelin(pi, 1, ni)
		end
	end

	queue_remove(store, this)
end

scripts.zeppelin_hero_mecha = {}

function scripts.zeppelin_hero_mecha.update(this, store)
	local a = this.ranged.attacks[1]
	local shoot_ts = store.tick_ts
	local fps_normal = 30
	local fps_slow = 20
	local d = E:create_entity(this.decal)

	d.render.sprites[1].ts = store.tick_ts
	d.pos = V.vclone(this.target_pos)

	queue_insert(store, d)

	local margin = this.flight_height + 100

	if this.pos.y > 768 - margin then
		this.pos.y = 768 - margin
		this.exit_pos.y = 768 - margin
		this.target_pos.y = 768 - margin
	end

	U.animation_start_group(this, "idle", this.exit_pos.x < this.pos.x, store.tick_ts, true, "layers")

	while math.abs(this.pos.x - this.target_pos.x) > this.attack_radius * 1.75 do
		U.force_motion_step(this, store.tick_length, this.target_pos)
		coroutine.yield()
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	while this.render.sprites[2].offset.y > this.flight_height_attack + 5 do
		local height_factor = (this.render.sprites[2].offset.y - this.flight_height_attack) / (this.flight_height - this.flight_height_attack)

		this.force_motion.max_v = this.speed_in_range + (this.speed_out_of_range - this.speed_in_range) * height_factor * 0.5

		U.force_motion_step(this, store.tick_length, this.exit_pos)
		coroutine.yield()
	end

	while math.abs(this.pos.x - this.target_pos.x) <= this.attack_radius do
		if store.tick_ts - shoot_ts > a.cooldown then
			local flight_time = E:get_template(a.bullet).bullet.flight_time
			local target, _, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, flight_time + a.shoot_time, a.vis_flags, a.vis_bans)

			if target and not target.health.dead and pred_pos then
				local an, af = U.animation_name_facing_point(this, a.animation, this.exit_pos, 3)

				U.animation_start(this, an, af, store.tick_ts, false, 3)
				U.animation_start(this, an, af, store.tick_ts, false, 4)

				local a_ts = store.tick_ts

				while store.tick_ts - a_ts < a.shoot_time do
					U.force_motion_step(this, store.tick_length, this.exit_pos)
					coroutine.yield()
				end

				local b = E:create_entity(a.bullet)

				b.bullet.from = V.v(this.pos.x + a.bullet_start_offset[1].x, this.pos.y + a.bullet_start_offset[1].y + this.render.sprites[2].offset.y)
				b.bullet.to = V.vclone(pred_pos)
				b.bullet.source_id = this.id
				b.bullet.target_id = target.id
				b.pos = V.vclone(b.bullet.from)
				b.bullet.level = this.level
				b.bullet.source_id = this.id

				queue_insert(store, b)

				while not U.animation_finished(this, 3) do
					U.force_motion_step(this, store.tick_length, this.exit_pos)
					coroutine.yield()
				end

				U.animation_start(this, "idle", this.exit_pos.x < this.pos.x, store.tick_ts, true, 3)
				U.animation_start(this, "idle", this.exit_pos.x < this.pos.x, store.tick_ts, true, 4)

				shoot_ts = store.tick_ts
			end
		end

		if (not this.render.sprites[5].fps or this.render.sprites[5].fps == fps_normal) and this.render.sprites[5].sync_flag then
			this.render.sprites[2].fps = fps_slow
			this.render.sprites[3].fps = fps_slow
			this.render.sprites[5].fps = fps_slow

			for i = 1, #this.render.sprites do
				if this.render.sprites[i].group == "layers" then
					U.animation_start(this, "idle", this.exit_pos.x < this.pos.x, store.tick_ts, true, i, true)
				end
			end
		end

		local height_factor = (this.render.sprites[2].offset.y - this.flight_height_attack) / (this.flight_height - this.flight_height_attack)

		this.force_motion.max_v = this.speed_in_range + (this.speed_out_of_range - this.speed_in_range) * height_factor

		U.force_motion_step(this, store.tick_length, this.exit_pos)
		coroutine.yield()
	end

	this.tween.reverse = true
	this.tween.ts = store.tick_ts
	this.force_motion.max_v = this.speed_out_of_range * 0.7

	while math.abs(this.pos.x - this.exit_pos.x) > 10 do
		if this.render.sprites[5].fps == fps_slow and this.render.sprites[5].sync_flag then
			this.render.sprites[2].fps = fps_normal
			this.render.sprites[3].fps = fps_normal
			this.render.sprites[5].fps = fps_normal

			for i = 1, #this.render.sprites do
				if this.render.sprites[i].group == "layers" then
					U.animation_start(this, "idle", this.exit_pos.x < this.pos.x, store.tick_ts, true, i, true)
				end
			end
		end

		U.force_motion_step(this, store.tick_length, this.exit_pos)

		local height_factor = (this.render.sprites[2].offset.y - this.flight_height_attack) / (this.flight_height - this.flight_height_attack)

		this.force_motion.max_v = this.speed_in_range + (this.speed_out_of_range - this.speed_in_range) * height_factor

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.hero_venom = {}

function scripts.hero_venom.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]
	this.melee.attacks[2].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[2].damage_max = ls.melee_damage_max[hl]

	local s, sl

	s = this.hero.skills.ranged_tentacle
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - HEARTSEEKER - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]
		b.bleed_chance = s.bleed_chance[sl]

		local m = E:get_template(b.bullet.mods[1])

		m.dps.damage_min = s.bleed_damage_min[sl]
		m.dps.damage_max = s.bleed_damage_max[sl]
		m.dps.damage_every = s.bleed_every[sl]
		m.modifier.duration = s.bleed_duration[sl]
	end

	s = this.hero.skills.inner_beast
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - INNER BEAST - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
	end

	if sl > 0 then
		local damage_min = ls.melee_damage_min[hl] * s.damage_factor[sl]
		local damage_max = ls.melee_damage_max[hl] * s.damage_factor[sl]

		this.melee.attacks[3].damage_min = damage_min
		this.melee.attacks[3].damage_max = damage_max
		this.melee.attacks[4].damage_min = damage_min
		this.melee.attacks[4].damage_max = damage_max
		this.melee.attacks[5].damage_min = damage_min
		this.melee.attacks[5].damage_max = damage_max
	end

	s = this.hero.skills.floor_spikes
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - FLOOR SPIKES - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.spikes = s.spikes[sl]

		local sp = E:get_template(a.spike_template[1])

		sp.damage_min = s.damage_min[sl]
		sp.damage_max = s.damage_max[sl]

		local sp = E:get_template(a.spike_template[2])

		sp.damage_min = s.damage_min[sl]
		sp.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.eat_enemy
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - EAT ENEMY - %i", this.template_name, hl, sl)

		local a = this.melee.attacks[6]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.regen = s.regen[sl]
		a.hp_trigger = s.hp_trigger[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local aura = E:get_template(uc.aura)

		aura.end_damage_min = s.damage_min[sl]
		aura.end_damage_max = s.damage_max[sl]
		aura.aura.duration = s.duration[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_venom.get_info(this)
	local a = this.is_transformed and this.melee.attacks[3] or this.melee.attacks[1]
	local min, max = a.damage_min, a.damage_max

	min, max = min * this.unit.damage_factor, max * this.unit.damage_factor

	return {
		type = STATS_TYPE_SOLDIER,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		damage_type = a.damage_type,
		damage_icon = this.info.damage_icon,
		armor = this.health.armor,
		respawn = this.health.dead_lifetime
	}
end

function scripts.hero_venom.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.hero_venom.update(this, store)
	local h = this.health
	local a, skill, brk, sta
	local ranged_tentacle_attack = this.timed_attacks.list[1]
	local inner_beast_attack = this.timed_attacks.list[2]
	local floor_spikes_attack = this.timed_attacks.list[3]
	local eat_enemy_attack = this.melee.attacks[6]
	local last_ts = store.tick_ts
	local last_target
	local last_target_ts = store.tick_ts
	local base_speed = this.motion.max_speed

	this.is_transformed = false

	local original_speed = this.motion.max_speed

	if not ranged_tentacle_attack.disabled then
		ranged_tentacle_attack.ts = store.tick_ts - ranged_tentacle_attack.cooldown
	end

	if not inner_beast_attack.disabled then
		inner_beast_attack.ts = store.tick_ts - inner_beast_attack.cooldown
	end

	if not floor_spikes_attack.disabled then
		floor_spikes_attack.ts = store.tick_ts - floor_spikes_attack.cooldown
	end

	if not eat_enemy_attack.disabled then
		eat_enemy_attack.ts = store.tick_ts - eat_enemy_attack.cooldown
	end

	local function y_transform_in()
		local a = inner_beast_attack
		local start_ts = store.tick_ts

		S:queue(a.sound_in, {
			delay = fts(10)
		})

		this.health.ignore_damage = true

		U.y_animation_play(this, a.animation_in, nil, store.tick_ts)

		this.health.ignore_damage = false
		a.ts = start_ts
		last_ts = start_ts

		SU.hero_gain_xp_from_skill(this, skill)

		this.melee.attacks[1].disabled = true
		this.melee.attacks[2].disabled = true
		this.melee.attacks[3].disabled = false
		this.melee.attacks[4].disabled = false
		this.melee.attacks[5].disabled = false
		this._bar_offset = V.vclone(this.health_bar.offset)
		this._bar_type = this.health_bar.type
		this._click_rect = table.deepclone(this.ui.click_rect)
		this._hit_mod_offset = V.vclone(this.unit.hit_offset)
		this.health_bar.offset = V.vclone(this.beast.health_bar_offset)
		this.health_bar.type = this.beast.health_bar_type
		this.ui.click_rect = table.deepclone(this.beast.click_rect)
		this.unit.hit_offset = V.vclone(this.beast.hit_mod_offset)
		this.unit.mod_offset = V.vclone(this.beast.hit_mod_offset)
		this.render.sprites[1].prefix = "hero_venom_hero_beast"
		this.unit.size = UNIT_SIZE_MEDIUM
		this.is_transformed = true
	end

	local function y_transform_out()
		local a = inner_beast_attack

		S:queue(a.sound_out, {
			delay = fts(10)
		})
		U.y_animation_play(this, a.animation_out, nil, store.tick_ts)

		this.melee.attacks[1].disabled = false
		this.melee.attacks[2].disabled = false
		this.melee.attacks[3].disabled = true
		this.melee.attacks[4].disabled = true
		this.melee.attacks[5].disabled = true
		this.health_bar.offset = V.vclone(this._bar_offset)
		this.health_bar.type = this._bar_type
		this.ui.click_rect = table.deepclone(this._click_rect)
		this.unit.hit_offset = V.vclone(this._hit_mod_offset)
		this.unit.mod_offset = V.vclone(this._hit_mod_offset)
		this.render.sprites[1].prefix = "hero_venom_hero"
		this.unit.size = UNIT_SIZE_SMALL
		this.is_transformed = false
	end

	this.health_bar.hidden = false

	while true do
		if h.dead then
			if this.is_transformed then
				y_transform_out()
			end

			local d = E:create_entity(this.death_decal)

			d.pos.x, d.pos.y = this.pos.x, this.pos.y
			d.hero_venom = this

			queue_insert(store, d)
			SU.y_hero_death_and_respawn_kr5(store, this)

			this.motion.max_speed = base_speed
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				local r = this.nav_rally
				local tw = this.slimewalk
				local force_slimewalk = false

				for _, p in pairs(this.nav_grid.waypoints) do
					if GR:cell_is(p.x, p.y, bor(TERRAIN_WATER, TERRAIN_SHALLOW, TERRAIN_NOWALK)) then
						force_slimewalk = true

						break
					end
				end

				if not this.is_transformed and (force_slimewalk or V.dist(this.pos.x, this.pos.y, r.pos.x, r.pos.y) > tw.min_distance) then
					r.new = false

					U.unblock_target(store, this)

					local vis_bans = this.vis.bans

					this.vis.bans = F_ALL
					this.health.immune_to = F_ALL

					local slimewalk_extra_speed_factor = (original_speed + tw.extra_speed) / original_speed

					this.motion.max_speed = this.motion.max_speed * slimewalk_extra_speed_factor
					this.unit.marker_hidden = true
					this.health_bar.hidden = true

					S:queue(this.sound_events.change_rally_point)
					S:queue(this.slimewalk.sound)

					::label_356_0::

					local dest = r.pos
					local n = this.nav_grid
					local an, af = U.animation_name_facing_point(this, tw.animations[1], this.motion.dest)

					U.y_animation_play(this, an, not af, store.tick_ts)

					while not V.veq(this.pos, dest) do
						local w = table.remove(n.waypoints, 1) or dest

						U.set_destination(this, w)

						local an, af = U.animation_name_facing_point(this, tw.animations[2], this.motion.dest)

						U.animation_start(this, an, af, store.tick_ts, true, 1, true)

						local runs = this.render.sprites[1].runs - 1

						while not this.motion.arrived do
							if r.new then
								r.new = false

								goto label_356_0
							end

							U.walk(this, store.tick_length)
							coroutine.yield()

							this.motion.speed.x, this.motion.speed.y = 0, 0

							if this.render.sprites[1].runs ~= runs then
								local slimewalk_decal = E:create_entity(this.slimewalk.decal)

								slimewalk_decal.ts = store.tick_ts
								slimewalk_decal.pos = V.vclone(this.pos)

								U.animation_start(slimewalk_decal, "idle", false, store.tick_ts)
								queue_insert(store, slimewalk_decal)

								runs = this.render.sprites[1].runs
							end
						end
					end

					S:stop(this.slimewalk.sound)
					SU.hide_modifiers(store, this, true)
					U.y_animation_play(this, tw.animations[3], nil, store.tick_ts)
					SU.show_modifiers(store, this, true)

					this.motion.max_speed = this.motion.max_speed / slimewalk_extra_speed_factor
					this.vis.bans = vis_bans
					this.health.immune_to = 0
					this.unit.marker_hidden = nil
					this.health_bar.hidden = nil
				elseif SU.y_hero_new_rally(store, this) then
					goto label_356_2
				end
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			if SU.hero_level_up(store, this) then
				if this.is_transformed then
					local fx = E:create_entity(this.beast.lvl_up_fx)

					fx.pos = V.vclone(this.pos)

					for i = 1, #fx.render.sprites do
						fx.render.sprites[i].ts = store.tick_ts
					end

					queue_insert(store, fx)
				else
					U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
				end
			end

			skill = this.hero.skills.ranged_tentacle
			a = ranged_tentacle_attack

			if not this.is_transformed and not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)

				if not target then
					SU.delay_attack(store, a, fts(10))
				else
					local enemy_id = target.id
					local enemy_pos = target.pos

					last_ts = store.tick_ts

					local an, af, ai = U.animation_name_facing_point(this, a.animation, enemy_pos)

					U.animation_start(this, an, af, store.tick_ts, false)
					S:queue(a.sound)

					local start_offset = V.vclone(a.bullet_start_offset)

					if af then
						start_offset.x = start_offset.x * -1
					end

					U.y_wait(store, a.shoot_time)

					if SU.soldier_interrupted(this) then
						-- block empty
					else
						local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), a.min_range, a.max_range, a.shoot_time, a.vis_flags, a.vis_bans)

						if target then
							enemy_id = target.id
							enemy_pos = target.pos
						end

						if not target then
							-- block empty
						else
							a.ts = last_ts

							local b = E:create_entity(a.bullet)

							b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.vclone(pred_pos)
							b.bullet.to.x = b.bullet.to.x + target.unit.hit_offset.x
							b.bullet.to.y = b.bullet.to.y + target.unit.hit_offset.y
							b.bullet.target_id = enemy_id
							b.bullet.source_id = this.id
							b.bullet.level = this.hero.level

							queue_insert(store, b)
							SU.hero_gain_xp_from_skill(this, skill)
							U.y_animation_wait(this)

							goto label_356_2
						end
					end
				end
			end

			a = inner_beast_attack
			skill = this.hero.skills.inner_beast

			if not this.is_transformed and not a.disabled and this.health.hp <= this.health.hp_max * skill.trigger_hp and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				y_transform_in()
			end

			if this.is_transformed and store.tick_ts - a.ts > skill.duration then
				y_transform_out()
			end

			skill = this.hero.skills.floor_spikes
			a = floor_spikes_attack

			if not this.is_transformed and not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, a.range_trigger_min, a.range_trigger_max, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))

					goto label_356_1
				end

				local targets = table.filter(enemies, function(k, v)
					local vpi = v.nav_path.pi
					local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
						vpi
					})
					local pi, spi, ni = unpack(nearest[1])

					return ni > v.nav_path.ni
				end)

				if not targets or #targets < a.min_targets then
					SU.delay_attack(store, a, fts(10))

					goto label_356_1
				end

				local path = targets[1].nav_path.pi
				local start_ts = store.tick_ts

				S:queue(a.sound_in, {
					delay = fts(10)
				})

				local flip = targets[1].pos.x < this.pos.x

				U.animation_start(this, a.animation_in, flip, store.tick_ts, false)

				if SU.y_hero_wait(store, this, a.cast_time) then
					goto label_356_2
				end

				a.ts = start_ts
				last_ts = start_ts

				SU.hero_gain_xp_from_skill(this, skill)

				local nodes_between_spikes = 2
				local spikes = {}

				local function spawn_spike(pi, spi, ni, spike_id)
					local pos = P:node_pos(pi, spi, ni)

					pos.x = pos.x + math.random(-4, 4)
					pos.y = pos.y + math.random(-5, 5)

					local s = E:create_entity(a.spike_template[math.random(1, #a.spike_template)])

					s.pos = V.vclone(pos)

					queue_insert(store, s)

					spikes[spike_id] = s
				end

				local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
					path
				})

				if #nearest > 0 then
					local pi, spi, ni = unpack(nearest[1])
					local initial_offset = 1

					ni = ni - initial_offset

					local count = a.spikes / 3
					local ni_aux
					local spike_id = 1

					for i = 1, count do
						ni_aux = ni - i * nodes_between_spikes

						if P:is_node_valid(pi, ni_aux) then
							spawn_spike(pi, 1, ni_aux, spike_id)

							spike_id = spike_id + 1

							U.y_wait(store, fts(1))
						end

						ni_aux = ni - i * (nodes_between_spikes + 1)

						if P:is_node_valid(pi, ni_aux) then
							spawn_spike(pi, 2, ni_aux, spike_id)

							spike_id = spike_id + 1

							U.y_wait(store, fts(1))
							spawn_spike(pi, 3, ni_aux, spike_id)

							spike_id = spike_id + 1

							U.y_wait(store, fts(1))
						end
					end
				end

				U.animation_start(this, a.animation_idle, nil, store.tick_ts, true)
				U.y_wait(store, fts(20))
				S:queue(a.sound_out)

				for i = #spikes, 1, -1 do
					spikes[i].hide = true

					U.y_wait(store, fts(1))
				end

				U.animation_start(this, a.animation_out, nil, store.tick_ts, false)
				SU.y_hero_animation_wait(this)

				goto label_356_2
			end

			::label_356_1::

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if sta == A_DONE then
				if this.is_transformed then
					this.health.hp = this.health.hp + this.health.hp_max * this.beast.regen_health

					if this.health.hp > this.health.hp_max then
						this.health.hp = this.health.hp_max
					end
				elseif this.melee.last_attack.attack == eat_enemy_attack then
					this.health.hp = this.health.hp + this.health.hp_max * eat_enemy_attack.regen

					if this.health.hp > this.health.hp_max then
						this.health.hp = this.health.hp_max
					end

					local mod = E:create_entity(eat_enemy_attack.mod_regen)

					mod.modifier.target_id = this.id

					queue_insert(store, mod)
				end
			end

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_356_2::

		coroutine.yield()
	end
end

scripts.bullet_hero_venom_ranged_tentacle = {}

function scripts.bullet_hero_venom_ranged_tentacle.insert(this, store, script)
	if math.random(0, 100) > this.bleed_chance * 100 then
		this.bullet.mods = {
			"mod_bullet_hero_venom_ranged_tentacle_stun"
		}
	end

	return true
end

scripts.decal_hero_venom_spike = {}

function scripts.decal_hero_venom_spike.update(this, store, script)
	U.y_animation_play(this, "in", false, store.tick_ts)
	U.animation_start(this, "idle", false, store.tick_ts, true)

	local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, this.damage_radius, this.vis_flags, this.vis_bans)

	if enemies and #enemies > 0 then
		for i = 1, #enemies do
			local d = E:create_entity("damage")

			d.damage_type = this.damage_type
			d.value = math.random(this.damage_min, this.damage_max)
			d.source_id = this.id
			d.target_id = enemies[i].id

			queue_damage(store, d)
		end
	end

	while true do
		if this.hide then
			U.y_animation_play(this, "out", false, store.tick_ts)

			this.render.sprites[1].hidden = true

			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.mod_hero_venom_eat_enemy_regen = {}

function scripts.mod_hero_venom_eat_enemy_regen.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			for _, s in pairs(this.render.sprites) do
				local flip_sign = 1

				if target.render then
					flip_sign = target.render.sprites[1].flip_x and -1 or 1
				end

				s.offset.x, s.offset.y = target.render.sprites[1].offset.x * flip_sign, target.render.sprites[1].offset.y
			end
		end

		coroutine.yield()
	end
end

scripts.decal_hero_venom_death = {}

function scripts.decal_hero_venom_death.update(this, store, script)
	U.y_wait(store, fts(19))

	this.render.sprites[1].hidden = false

	U.animation_start(this, "idle", false, store.tick_ts, false)

	while true do
		if this.tween.disabled and this.hero_venom.render.sprites[1].name == "respawn" then
			this.tween.disabled = false
			this.tween.remove = true
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.hero_venom_ultimate = {}

function scripts.hero_venom_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and SU5.valid_node_interval(x, y, this.offset_back, this.offset_forward, 1, NF_RALLY)
end

function scripts.hero_venom_ultimate.update(this, store)
	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

	if #nearest > 0 then
		local pi, spi, ni = unpack(nearest[1])

		if P:is_node_valid(pi, ni) then
			S:queue(this.sound)

			local aura = E:create_entity(this.aura)

			aura.aura.source_id = this.id
			aura.aura.ts = store.tick_ts

			local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

			if #nodes < 1 then
				log.debug("cannot insert venom ulti, no valid nodes nearby %s,%s", x, y)

				return nil
			end

			local pi, spi, ni = unpack(nodes[1])
			local npos = P:node_pos(pi, 1, ni)

			aura.pos = npos
			aura.pos_pi = pi
			aura.pos_ni = ni

			S:queue(this.sound)
			queue_insert(store, aura)
		end
	end

	queue_remove(store, this)
end

scripts.aura_hero_venom_ultimate = {}

function scripts.aura_hero_venom_ultimate.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	U.animation_start(this, "in", false, store.tick_ts, false)
	U.y_wait(store, this.slow_delay)

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.render.sprites[1].name == "in" and U.animation_finished(this) then
			U.animation_start(this, "idle", false, store.tick_ts, true)
		end

		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration + this.slow_delay then
			U.animation_start(this, "attack", false, store.tick_ts, false)
			S:queue(this.sound_attack)
			U.y_wait(store, fts(10))

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				local d = E:create_entity("damage")

				d.damage_type = this.end_damage_type
				d.value = math.random(this.end_damage_min, this.end_damage_max)
				d.source_id = this.id
				d.target_id = target.id

				queue_damage(store, d)
			end

			U.y_animation_wait(this)

			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_336_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_336_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_336_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_336_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_336_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.hero_robot = {}

function scripts.hero_robot.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local s, sl

	s = this.hero.skills.jump
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - JUMP - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.damage_min = s.damage_min[sl]
		a.damage_max = s.damage_max[sl]

		local aura = E:get_template(a.aura)
		local mod = E:get_template(aura.aura.mod)

		mod.modifier.duration = s.stun_duration[sl]
	end

	s = this.hero.skills.fire
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - FIRE - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)

		b.bullet.damage_min = s.damage_min[sl]
		b.bullet.damage_max = s.damage_max[sl]

		local aura = E:get_template(b.aura_on_hit)

		aura.aura.duration = s.smoke_duration[sl]

		local mod = E:get_template(aura.aura.mod)

		mod.modifier.duration = s.slow_duration[sl]
	end

	s = this.hero.skills.explode
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - EXPLODE - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.damage_min = s.damage_min[sl]
		a.damage_max = s.damage_max[sl]

		local mod = E:get_template(a.mod)

		mod.dps.damage_min = s.burning_damage_min[sl]
		mod.dps.damage_max = s.burning_damage_max[sl]
	end

	s = this.hero.skills.uppercut
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - UPPERCUT - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.life_threshold = s.life_threshold[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local aura = E:get_template(uc.entity)

		aura.damage_min = s.damage_min[sl]
		aura.damage_max = s.damage_max[sl]

		local mod = E:get_template(aura.aura.mod)

		mod.dps.damage_min = s.burning_damage_min[sl]
		mod.dps.damage_max = s.burning_damage_max[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_robot.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.hero_robot.update(this, store)
	local h = this.health
	local a, skill, brk, sta
	local last_ts = store.tick_ts
	local last_target
	local last_target_ts = store.tick_ts
	local base_speed = this.motion.max_speed
	local jump_attack = this.timed_attacks.list[1]
	local fire_attack = this.timed_attacks.list[2]
	local explode_attack = this.timed_attacks.list[3]
	local uppercut_attack = this.timed_attacks.list[4]
	local ps1, ps2

	if not jump_attack.disabled then
		jump_attack.ts = store.tick_ts - jump_attack.cooldown
	end

	if not fire_attack.disabled then
		fire_attack.ts = store.tick_ts - fire_attack.cooldown
	end

	if not explode_attack.disabled then
		explode_attack.ts = store.tick_ts - explode_attack.cooldown
	end

	if not uppercut_attack.disabled then
		uppercut_attack.ts = store.tick_ts - uppercut_attack.cooldown
	end

	local function explosion_damage(point, radius, damage_min, damage_max, damage_type, damage_bans, damage_flags, mod_to_apply)
		local enemies = table.filter(store.entities, function(k, v)
			return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, damage_bans) == 0 and band(v.vis.bans, damage_flags) == 0 and U.is_inside_ellipse(v.pos, point, radius)
		end)

		for _, enemy in pairs(enemies) do
			local d = E:create_entity("damage")

			d.damage_type = damage_type

			local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, point, radius)

			d.value = math.floor(damage_max - (damage_max - damage_min) * dist_factor)
			d.source_id = this.id
			d.target_id = enemy.id

			queue_damage(store, d)

			if mod_to_apply then
				local mod = E:create_entity(mod_to_apply)

				mod.modifier.target_id = enemy.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)
			end
		end
	end

	ps1 = E:create_entity(this.particles_name_1)
	ps1.particle_system.emit = true
	ps1.particle_system.track_id = this.id

	queue_insert(store, ps1)

	ps2 = E:create_entity(this.particles_name_2)
	ps2.particle_system.emit = true
	ps2.particle_system.track_id = this.id

	queue_insert(store, ps2)

	this.health_bar.hidden = false

	while true do
		if h.dead then
			ps1.particle_system.emit = false
			ps2.particle_system.emit = false

			SU.y_hero_death_and_respawn_kr5(store, this)

			ps1.particle_system.emit = true
			ps2.particle_system.emit = true
			this.motion.max_speed = base_speed
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				local r = this.nav_rally
				local tw = this.flywalk
				local force_flywalk = false

				for _, p in pairs(this.nav_grid.waypoints) do
					if GR:cell_is(p.x, p.y, bor(TERRAIN_WATER, TERRAIN_SHALLOW, TERRAIN_NOWALK)) then
						force_flywalk = true

						break
					end
				end

				if force_flywalk or V.dist(this.pos.x, this.pos.y, r.pos.x, r.pos.y) > tw.min_distance then
					ps1.particle_system.emit = false
					ps2.particle_system.emit = false
					r.new = false

					U.unblock_target(store, this)

					local vis_bans = this.vis.bans

					this.vis.bans = F_ALL
					this.health.immune_to = F_ALL
					this.on_flywalk = true

					local extra_speed_factor = (base_speed + tw.extra_speed) / base_speed

					this.motion.max_speed = this.motion.max_speed * extra_speed_factor
					this.unit.marker_hidden = true
					this.health_bar.hidden = true
					this.ui.click_rect = this.ui.click_rect_fly

					S:queue(this.sound_events.change_rally_point)
					S:queue(this.flywalk.sound)

					local an, af = U.animation_name_facing_point(this, tw.animations[1], r.pos)

					U.animation_start(this, an, af, store.tick_ts)

					::label_341_0::

					local dest = r.pos
					local n = this.nav_grid

					while not V.veq(this.pos, dest) do
						local w = table.remove(n.waypoints, 1) or dest

						U.set_destination(this, w)

						local runs = this.render.sprites[1].runs

						while not this.motion.arrived do
							if r.new then
								r.new = false

								goto label_341_0
							end

							U.walk(this, store.tick_length)
							coroutine.yield()

							this.motion.speed.x, this.motion.speed.y = 0, 0

							if this.render.sprites[1].runs ~= runs then
								local an, af = U.animation_name_facing_point(this, tw.animations[2], this.motion.dest)

								U.animation_start(this, an, af, store.tick_ts, true, 1, true)

								runs = this.render.sprites[1].runs
							end
						end
					end

					SU.hide_modifiers(store, this, true)
					U.y_animation_play(this, tw.animations[3], nil, store.tick_ts)
					SU.show_modifiers(store, this, true)

					this.ui.click_rect = this.ui.click_rect_nofly
					this.motion.max_speed = this.motion.max_speed / extra_speed_factor
					this.vis.bans = vis_bans
					this.health.immune_to = 0
					this.unit.marker_hidden = nil
					this.health_bar.hidden = nil
					this.on_flywalk = false
					ps1.particle_system.emit = true
					ps2.particle_system.emit = true
				elseif SU.y_hero_new_rally(store, this) then
					goto label_341_1
				end
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)
			end

			skill = this.hero.skills.jump
			a = jump_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				if this.soldier.target_id ~= nil then
					SU.delay_attack(store, a, fts(5))
				else
					local target, _, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans, function(e, origin)
						return e.motion and e.motion.max_speed and e.motion.max_speed > 0 and P:is_node_valid(e.nav_path.pi, e.nav_path.ni)
					end)

					if not target then
						SU.delay_attack(store, a, fts(5))
					else
						local n_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni)

						if V.dist2(n_pos.x, n_pos.y, target.pos.x, target.pos.y) > 25 then
							SU.delay_attack(store, a, fts(5))
						else
							local new_ni = target.nav_path.ni + a.fall_ahead
							local target_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, new_ni)

							last_ts = store.tick_ts

							S:queue(a.sound_cast)
							U.unblock_target(store, this)

							local bans = this.vis.bans

							this.vis.bans = F_ALL

							SU.hide_modifiers(store, this, true)
							SU.hide_auras(store, this, true)

							ps1.particle_system.emit = false
							ps2.particle_system.emit = false

							local an, af, ai = U.animation_name_facing_point(this, a.animation_prepare, target_pos)

							U.y_animation_play(this, an, af, store.tick_ts, 1)

							local an, af, ai = U.animation_name_facing_point(this, a.animation, target_pos)

							U.animation_start(this, an, af, store.tick_ts, false)

							local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans, function(e, origin)
								return e.motion and e.motion.max_speed and e.motion.max_speed > 0 and P:is_node_valid(e.nav_path.pi, e.nav_path.ni)
							end)

							if target then
								new_ni = target.nav_path.ni + a.fall_ahead
								target_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, new_ni)
							end

							local dest = V.vclone(target_pos)

							U.set_destination(this, dest)

							local animation_length = fts(20)
							local remaining_time = animation_length
							local start_jump_ts = store.tick_ts

							S:queue(a.sound_impact, a.sound_impact_args)

							while animation_length > store.tick_ts - start_jump_ts do
								local distance_x = math.abs(this.pos.x - this.motion.dest.x)
								local distance_y = math.abs(this.pos.y - this.motion.dest.y)

								if this.pos.x - this.motion.dest.x < 0 then
									this.pos.x = this.pos.x + distance_x / (remaining_time / store.tick_length)
								else
									this.pos.x = this.pos.x - distance_x / (remaining_time / store.tick_length)
								end

								if this.pos.y - this.motion.dest.y < 0 then
									this.pos.y = this.pos.y + distance_y / (remaining_time / store.tick_length)
								else
									this.pos.y = this.pos.y - distance_y / (remaining_time / store.tick_length)
								end

								remaining_time = remaining_time - store.tick_length

								coroutine.yield()
							end

							this.motion.arrived = true
							this.nav_rally.pos = V.vclone(this.pos)
							this.nav_rally.center = V.vclone(this.pos)
							a.ts = last_ts

							local aura = E:create_entity(a.aura)

							aura.pos = V.v(dest.x, dest.y - 10)
							aura.owner = this
							aura.aura.source_id = this.id

							queue_insert(store, aura)
							explosion_damage(dest, a.damage_radius, a.damage_min, a.damage_max, a.damage_type, a.damage_bans, a.damage_flags)

							this.vis.bans = bans
							this.vis._bans = nil

							SU.show_modifiers(store, this, true)
							SU.show_auras(store, this, true)
							SU.hero_gain_xp_from_skill(this, skill)
							U.y_animation_wait(this)

							ps1.particle_system.emit = true
							ps2.particle_system.emit = true

							goto label_341_1
						end
					end
				end
			end

			skill = this.hero.skills.fire
			a = fire_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				if this.soldier.target_id ~= nil then
					SU.delay_attack(store, a, fts(10))
				else
					local target, enemies, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)

					if not target then
						SU.delay_attack(store, a, fts(10))
					elseif #enemies < a.min_targets then
						SU.delay_attack(store, a, fts(10))
					else
						last_ts = store.tick_ts

						local final_target = target

						S:queue(a.sound, a.sound_args)

						ps1.particle_system.emit = false
						ps2.particle_system.emit = false

						local an, af, ai = U.animation_name_facing_point(this, a.animation, final_target.pos)

						U.animation_start(this, an, af, store.tick_ts, false)
						U.y_wait(store, a.shoot_time)

						local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)

						if target then
							final_target = target
						end

						local path = final_target.nav_path.pi
						local nodes_between_shoots = 6

						local function fire_bullet(pi, spi, ni)
							local pos = P:node_pos(pi, spi, ni)

							pos.x = pos.x + math.random(-4, 4)
							pos.y = pos.y + math.random(-5, 5)

							local b = E:create_entity(a.bullet)

							b.pos.x, b.pos.y = this.pos.x + a.bullet_start_offset.x, this.pos.y + a.bullet_start_offset.y
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = pos
							b.bullet.source_id = this.id

							queue_insert(store, b)
						end

						local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
							path
						})

						if #nearest > 0 then
							local pi, spi, ni = unpack(nearest[1])
							local initial_offset = 1
							local direction = ni < final_target.nav_path.ni and -1 or 1

							ni = (ni - initial_offset) * direction

							local count = a.shoots / 3
							local ni_aux

							for i = 1, count do
								ni_aux = (ni - i * nodes_between_shoots) * direction

								if P:is_node_valid(pi, ni_aux) then
									fire_bullet(pi, 1, ni_aux)
								end

								ni_aux = (ni - i * (nodes_between_shoots + 1)) * direction

								if P:is_node_valid(pi, ni_aux) then
									fire_bullet(pi, 2, ni_aux)
									fire_bullet(pi, 3, ni_aux)
								end
							end
						end

						a.ts = last_ts

						SU.hero_gain_xp_from_skill(this, skill)
						U.y_animation_wait(this)

						ps1.particle_system.emit = true
						ps2.particle_system.emit = true

						goto label_341_1
					end
				end
			end

			skill = this.hero.skills.explode
			a = explode_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, enemies, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)

				if not target then
					SU.delay_attack(store, a, fts(10))
				elseif #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					last_ts = store.tick_ts

					S:queue(a.sound)

					ps1.particle_system.emit = false
					ps2.particle_system.emit = false

					local an, af, ai = U.animation_name_facing_point(this, a.animation, pred_pos)

					U.animation_start(this, an, af, store.tick_ts, false)
					U.y_wait(store, a.load_time)

					a.ts = last_ts

					local decal = E:create_entity(a.decal)

					decal.pos = V.v(this.pos.x, this.pos.y)
					decal.render.sprites[1].ts = store.tick_ts

					queue_insert(store, decal)
					explosion_damage(this.pos, a.damage_radius, a.damage_min, a.damage_max, a.damage_type, a.damage_bans, a.damage_flags, a.mod)
					SU.hero_gain_xp_from_skill(this, skill)
					U.y_animation_wait(this)

					ps1.particle_system.emit = true
					ps2.particle_system.emit = true

					goto label_341_1
				end
			end

			skill = this.hero.skills.uppercut
			a = uppercut_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				if this.soldier.target_id == nil then
					SU.delay_attack(store, a, fts(5))
				elseif not this.motion.arrived then
					SU.delay_attack(store, a, fts(5))
				else
					local target = store.entities[this.soldier.target_id]

					if not target then
						SU.delay_attack(store, a, fts(5))
					elseif band(target.vis.flags, a.vis_bans) ~= 0 then
						SU.delay_attack(store, a, fts(5))
					elseif target.health.dead then
						SU.delay_attack(store, a, fts(5))
					else
						local current_life_percentage = target.health.hp * 100 / target.health.hp_max

						if current_life_percentage > a.life_threshold then
							SU.delay_attack(store, a, fts(5))
						else
							last_ts = store.tick_ts

							S:queue(a.sound)

							ps1.particle_system.emit = false
							ps2.particle_system.emit = false

							local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)

							U.animation_start(this, an, af, store.tick_ts, false)
							U.y_wait(store, a.shoot_time)

							local m = E:create_entity(a.mod)

							m.modifier.target_id = target.id
							m.modifier.source_id = this.id
							m.enemy_move_offset = a.enemy_move_offset

							queue_insert(store, m)

							a.ts = last_ts

							SU.hero_gain_xp_from_skill(this, skill)
							U.y_animation_wait(this)

							ps1.particle_system.emit = true
							ps2.particle_system.emit = true

							goto label_341_1
						end
					end
				end
			end

			if this.soldier.target_id ~= nil and this.motion.arrived then
				ps1.particle_system.emit = false
				ps2.particle_system.emit = false
			else
				ps1.particle_system.emit = true
				ps2.particle_system.emit = true
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_341_1::

		coroutine.yield()
	end
end

scripts.ps_hero_robot_smoke = {}

function scripts.ps_hero_robot_smoke.update(this, store)
	local source_sprite = store.entities[this.particle_system.track_id].render.sprites[1]

	while true do
		if source_sprite.flip_x then
			this.particle_system.emit_offset = this.particle_system.emit_offsets[2]
			this.particle_system.emit_direction = this.emit_direction_sides[2]
		else
			this.particle_system.emit_offset = this.particle_system.emit_offsets[1]
			this.particle_system.emit_direction = this.emit_direction_sides[1]
		end

		coroutine.yield()
	end

	return true
end

scripts.bullet_hero_robot_skill_fire = {}

function scripts.bullet_hero_robot_skill_fire.update(this, store)
	local b = this.bullet
	local mspeed = b.min_speed
	local target, ps
	local already_hit = {}

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead then
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
		this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

		coroutine.yield()
	end

	local enemies = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.damage_bans) == 0 and band(v.vis.bans, this.damage_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.damage_radius)
	end)

	for _, enemy in pairs(enemies) do
		local d = E:create_entity("damage")

		d.damage_type = this.bullet.damage_type

		local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, this.pos, this.damage_radius)

		d.value = math.floor(this.bullet.damage_max - (this.bullet.damage_max - this.bullet.damage_min) * dist_factor)
		d.source_id = this.id
		d.target_id = enemy.id

		queue_damage(store, d)
	end

	if this.aura_on_hit then
		local aura = E:create_entity(this.aura_on_hit)

		aura.pos.x, aura.pos.y = b.to.x, b.to.y
		aura.render.sprites[1].ts = store.tick_ts
		aura.render.sprites[1].runs = 0

		queue_insert(store, aura)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		queue_insert(store, sfx)
	end

	S:queue(this.sound)
	queue_remove(store, this)
end

scripts.aura_hero_robot_skill_fire_slow = {}

function scripts.aura_hero_robot_skill_fire_slow.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time
	this.render.sprites[1].flip_x = math.random(1, 2) == 1
	this.aura.duration = this.aura.duration - fts(math.random(1, 10))
	this.tween.props[1].keys[1] = {
		0,
		255
	}
	this.tween.props[1].keys[2] = {
		this.aura.duration - fts(12),
		255
	}
	this.tween.props[1].keys[3] = {
		this.aura.duration,
		0
	}
	this.tween.ts = store.tick_ts

	U.y_animation_play(this, "start", nil, store.tick_ts, 1)
	U.animation_start(this, "loop", nil, store.tick_ts, 1)

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_350_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_350_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_350_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.mod_hero_robot_skill_fire_slow = {}

function scripts.mod_hero_robot_skill_fire_slow.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	if target.unit.size == UNIT_SIZE_MEDIUM then
		this.render.sprites[1].scale = v(1.5, 1.5)
	elseif target.unit.size == UNIT_SIZE_LARGE then
		this.render.sprites[1].scale = v(2, 2)
	end

	this.tween.ts = store.tick_ts

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			break
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	this.tween.ts = store.tick_ts
	this.tween.reverse = true
	this.tween.remove = true
end

scripts.mod_hero_robot_skill_uppercut = {}

function scripts.mod_hero_robot_skill_uppercut.insert(this, store)
	local target = store.entities[this.modifier.target_id]
	local m = this.modifier

	if not target then
		return false
	end

	if band(target.vis.flags, this.modifier.vis_bans) ~= 0 then
		return false
	end

	if band(target.vis.bans, this.modifier.vis_flags) ~= 0 then
		return false
	end

	this._entity_frame_names = {}

	for _, es in pairs(target.render.sprites) do
		if es.animated then
			table.insert(this._entity_frame_names, es.frame_name)
		else
			table.insert(this._entity_frame_names, es.name)
		end
	end

	SU.stun_inc(target)

	target.vis.bans = F_ALL
	target.ui.can_click = false
	target.ui.can_select = false
	target.health_bar.hidden = true
	target.unit.show_blood_pool = false

	return true
end

function scripts.mod_hero_robot_skill_uppercut.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local is_on_right = store.entities[this.modifier.source_id].pos.x < this.pos.x
	local s = this.render.sprites[1]
	local is_exo = false

	for k, v in pairs(target.render.sprites) do
		if v.exo then
			is_exo = true

			break
		end
	end

	local es = E:create_entity(this.clone_decal)

	es.pos.y = es.pos.y + this.enemy_move_offset.y

	if is_on_right then
		es.pos.x = es.pos.x + this.enemy_move_offset.x
	else
		es.pos.x = es.pos.x - this.enemy_move_offset.x
	end

	start_ts = store.tick_ts
	es.tween.ts = store.tick_ts

	local offset_to_center = target.unit.hit_offset.y / 2

	es.render.sprites[1].offset.y = offset_to_center * -1
	es.tween.props[1].keys[2][1] = this.modifier.duration - fts(6)
	es.tween.props[1].keys[3][1] = this.modifier.duration
	es.render.sprites[1].z = Z_BULLETS

	if not is_exo then
		this._decal_clone = es
		es.pos.x, es.pos.y = target.pos.x, target.pos.y
		es.render.sprites[1] = table.deepclone(target.render.sprites[1])
		local sprite1 = es.render.sprites[1]
		sprite1.shader = es.shader
		sprite1.shader_args = es.shader_args
		sprite1.animated = false
		sprite1.prefix = nil
		sprite1.name = this._entity_frame_names[1]

		queue_insert(store, es)
		coroutine.yield()
		U.sprites_hide(target, nil, nil, true)
	end

	while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
		if is_on_right then
			es.pos.x = es.pos.x + this.fly_speed.x
			es.render.sprites[1].r = es.render.sprites[1].r - this.rotation_speed
		else
			es.pos.x = es.pos.x - this.fly_speed.x
			es.render.sprites[1].r = es.render.sprites[1].r + this.rotation_speed
		end

		es.pos.y = es.pos.y + this.fly_speed.y

		coroutine.yield()
	end

	local d = E:create_entity("damage")

	d.damage_type = bor(DAMAGE_INSTAKILL, DAMAGE_FX_NOT_EXPLODE, DAMAGE_NO_SPAWNS, DAMAGE_IGNORE_SHIELD)
	d.source_id = this.id
	d.target_id = target.id

	queue_damage(store, d)

	if not is_exo then
		queue_remove(store, es)
	end

	this._not_interrupted = true

	queue_remove(store, this)
end

scripts.hero_robot_ultimate = {}

function scripts.hero_robot_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and SU5.valid_node_interval(x, y, this.offset_back, 0, 1, NF_RALLY)
end

function scripts.hero_robot_ultimate.update(this, store)
	local targets = U.find_enemies_in_paths(store.entities, this.pos, 0, 50, nil, F_AREA, F_FLYING, true)
	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true)

	if #nearest < 1 then
		log.debug("cannot insert robot ulti, no valid nodes nearby %s,%s", x, y)

		return nil
	end

	local pi, spi, ni, dist

	if not targets or #targets == 0 then
		pi, spi, ni, dist = unpack(nearest[1])
	else
		for _, t in pairs(targets) do
			for _, n in pairs(nearest) do
				pi, spi, ni, dist = unpack(n)

				if dist > 20 then
					break
				end

				if t.enemy.nav_path and t.enemy.nav_path.pi == pi then
					goto label_356_0
				end
			end
		end
	end

	::label_356_0::

	S:queue(this.sound)

	local decal = E:create_entity(this.entity)
	local npos = P:node_pos(pi, 1, ni)

	decal.pos = npos
	decal.path_id = pi

	queue_insert(store, decal)
	queue_remove(store, this)
end

scripts.aura_hero_robot_ultimate_train = {}

function scripts.aura_hero_robot_ultimate_train.update(this, store)
	local first_hit_ts
	local last_hit_ts = 0
	local sid_rider = 1
	local sid_fx = 2
	local target_pos = this.pos
	local fading = false
	local spawned_fx = false
	local last_ni_decal = 0
	local last_ni_smoke = 0
	local path_ni = 1
	local path_spi = 1
	local path_pi = 1
	local available_paths = {}

	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end

	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, function(k, v)
			return not table.contains(store.level.ignore_walk_backwards_paths, v) and P:is_path_active(v)
		end)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, available_paths)

	if #nearest > 0 then
		path_pi, path_spi, path_ni = unpack(nearest[1])

		for _, n in pairs(nearest) do
			local _path_pi, _path_spi, _path_ni = unpack(n)

			if _path_pi == this.path_id then
				path_pi, path_spi, path_ni = _path_pi, _path_spi, _path_ni

				break
			end
		end
	end

	path_spi = 1
	path_ni = path_ni - 3
	last_ni_decal = path_ni
	last_ni_smoke = path_ni

	local distance = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	local function animation_name_facing_angle_hero_robot(group, angle_deg)
		local a = this.render.sprites[1]
		local o_name, o_flip, o_idx
		local a1, a2, a3, a4, a5, a6, a7, a8 = 22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5
		local quadrant = a._last_quadrant
		local angles = a.angles[group]

		if a1 <= angle_deg and angle_deg < a2 then
			o_name, o_flip, o_idx = angles[3], false, 3
			quadrant = 1
		elseif a2 <= angle_deg and angle_deg < a3 then
			o_name, o_flip, o_idx = angles[4], false, 4
			quadrant = 2
		elseif a3 <= angle_deg and angle_deg < a4 then
			o_name, o_flip, o_idx = angles[3], true, 3
			quadrant = 3
		elseif a4 <= angle_deg and angle_deg < a5 then
			o_name, o_flip, o_idx = angles[2], true, 2
			quadrant = 4
		elseif a5 <= angle_deg and angle_deg < a6 then
			o_name, o_flip, o_idx = angles[1], true, 1
			quadrant = 5
		elseif a6 <= angle_deg and angle_deg < a7 then
			o_name, o_flip, o_idx = angles[5], false, 5
			quadrant = 6
		elseif a7 <= angle_deg and angle_deg < a8 then
			o_name, o_flip, o_idx = angles[1], false, 1
			quadrant = 7
		else
			o_name, o_flip, o_idx = angles[2], false, 2
			quadrant = 8
		end

		return o_name, o_flip, o_idx
	end

	local function animation_name_facing_point_hero_robot(group, point, offset)
		local fx, fy = this.pos.x, this.pos.y

		if offset then
			fx, fy = fx + offset.x, fy + offset.y
		end

		local vx, vy = V.sub(point.x, point.y, fx, fy)
		local v_angle = V.angleTo(vx, vy)
		local angle = km.unroll(v_angle)
		local angle_deg = km.rad2deg(angle)

		return animation_name_facing_angle_hero_robot(group, angle_deg)
	end

	local function hit_enemies()
		local targets = table.filter(store.entities, function(k, v)
			return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
		end)

		for i, target in ipairs(targets) do
			local already_hit_target = false
			local has_mod, mods = U.has_modifiers(store, target, this.aura.mod)

			if has_mod then
				for _, mod in pairs(mods) do
					if mod.modifier.source_id == this.id then
						already_hit_target = true

						break
					end
				end
			end

			if already_hit_target then
				-- block empty
			elseif target and not target.health.dead and target.enemy then
				queue_damage(store, SU.create_attack_damage(this, target.id, this.id))

				local hit_fx = E:create_entity(this.hit_fx)

				hit_fx.pos = V.vclone(target.pos)
				hit_fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, hit_fx)

				local new_mod = E:create_entity(this.aura.mod)

				new_mod.modifier.target_id = target.id
				new_mod.modifier.source_id = this.id

				if this.aura.hide_source_fx and target.id == this.aura.source_id then
					new_mod.render = nil
				end

				queue_insert(store, new_mod)
			end
		end
	end

	local function rider_go_back_step()
		if V.veq(this.pos, target_pos) then
			this.motion.arrived = true

			return false
		else
			U.set_destination(this, target_pos)

			if U.walk(this, store.tick_length) then
				return false
			else
				local an, af = animation_name_facing_point_hero_robot("run", this.motion.dest)

				U.animation_start(this, an, af, store.tick_ts, -1)

				return true
			end
		end
	end

	local function run_backwards()
		local last_pos = this.pos

		distance = V.dist2(target_pos.x, target_pos.y, this.pos.x, this.pos.y)

		if distance < 25 then
			path_ni = path_ni - 3
			target_pos = P:node_pos(path_pi, path_spi, path_ni)
		end

		rider_go_back_step()

		if last_ni_decal - path_ni >= this.nodes_to_floor_decal then
			last_ni_decal = path_ni

			local decal = E:create_entity(this.floor_decal)

			decal.pos = V.vclone(this.pos)
			decal.render.sprites[1].ts = store.tick_ts
			decal.render.sprites[1].flip_x = math.random(1, 2) == 1

			queue_insert(store, decal)
		end

		if last_ni_smoke - path_ni >= this.nodes_to_smoke then
			last_ni_smoke = path_ni

			local fx = E:create_entity(this.smoke_fx)

			fx.pos = V.vclone(this.pos)
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].flip_x = math.random(1, 2) == 1

			local random_size = 1 + math.random(0, 3) / 10

			fx.render.sprites[1].scale = v(random_size, random_size)
			fx.tween.props[1].keys[4][1] = 1 + math.random(0, 5) / 10
			fx.tween.props[1].keys[3][1] = fx.tween.props[1].keys[4][1] - 0.2

			queue_insert(store, fx)

			local side_smoke = P:node_pos(path_pi, 2, path_ni + math.random(3, 5))
			local fx = E:create_entity(this.smoke_fx)

			fx.pos = side_smoke
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].flip_x = math.random(1, 2) == 1

			local random_size = 1 + math.random(0, 3) / 10

			fx.render.sprites[1].scale = v(random_size, random_size)
			fx.tween.props[1].keys[4][1] = 1 + math.random(0, 5) / 10
			fx.tween.props[1].keys[3][1] = fx.tween.props[1].keys[4][1] - 0.2

			queue_insert(store, fx)

			side_smoke = P:node_pos(path_pi, 3, path_ni + math.random(3, 5))

			local fx = E:create_entity(this.smoke_fx)

			fx.pos = side_smoke
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].flip_x = math.random(1, 2) == 1
			random_size = 1 + math.random(0, 3) / 10
			fx.render.sprites[1].scale = v(random_size, random_size)
			fx.tween.props[1].keys[4][1] = 1 + math.random(0, 5) / 10
			fx.tween.props[1].keys[3][1] = fx.tween.props[1].keys[4][1] - 0.2

			queue_insert(store, fx)
		end
	end

	local function check_start_fade()
		if fading then
			return false
		end

		local fade_duration = this.tween.props[1].keys[2][1]
		local n_pos = P:node_pos(path_pi, path_spi, path_ni - 5)

		if band(GR:cell_type(n_pos.x, n_pos.y), bor(TERRAIN_CLIFF, TERRAIN_WATER)) ~= 0 then
			this.tween.props[1].keys[2][1] = 0.25

			return true
		end

		if this.aura.duration >= 0 and store.tick_ts - this.aura.ts + fade_duration > this.aura.duration then
			return true
		end

		local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
			path_pi
		})

		if #nearest > 0 then
			path_pi, path_spi, path_ni = unpack(nearest[1])

			return path_ni < 10
		end

		return false
	end

	S:queue(this.sound)

	path_ni = path_ni - 3
	target_pos = P:node_pos(path_pi, path_spi, path_ni)

	local spawn_fx = E:create_entity(this.spawn_fx)

	spawn_fx.pos = V.vclone(this.pos)
	spawn_fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, spawn_fx)

	this.render.sprites[1].hidden = true

	U.y_wait(store, fts(4))

	local decal = E:create_entity(this.floor_decal)

	decal.pos = V.vclone(this.pos)
	decal.render.sprites[1].ts = store.tick_ts
	decal.render.sprites[1].flip_x = math.random(1, 2) == 1
	decal.render.sprites[1].scale = v(1.3, 1.3)

	queue_insert(store, decal)
	U.y_wait(store, fts(10))

	this.render.sprites[1].hidden = false
	this.tween.props[1].disabled = true
	this.tween.props[1].ts = store.tick_ts
	this.aura.ts = store.tick_ts

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.aura.duration or fading and this.render.sprites[1].alpha <= 0 then
			break
		end

		if check_start_fade() then
			fading = true
			this.tween.props[1].disabled = false
			this.tween.reverse = true
			this.tween.props[1].ts = store.tick_ts
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_357_0
			end
		end

		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			if this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
				goto label_357_0
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts

			hit_enemies()
		end

		run_backwards()

		::label_357_0::

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.hero_hunter = {}

function scripts.hero_hunter.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local s, sl

	s = this.hero.skills.heal_strike
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - HEAL STRIKE - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.damage_min = s.damage_min[sl]
		a.damage_max = s.damage_max[sl]
		a.heal_factor = s.heal_factor[sl]
		a.hits_to_trigger = s.hits_to_trigger[sl] - 1
	end

	s = this.hero.skills.ricochet
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - RICOCHET - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)

		b.bounces = s.bounces[sl]

		local m = E:get_template(b.bullet.mods[1])

		m.damage_min = s.damage_min[sl]
		m.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.shoot_around
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - SHOOT AROUND - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local aura = E:get_template(a.aura)

		aura.aura.damage_min = s.damage_min[sl]
		aura.aura.damage_max = s.damage_max[sl]
		aura.aura.duration = s.duration[sl]
	end

	s = this.hero.skills.beasts
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - BEASTS - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local entity = E:get_template(a.entity)

		entity.duration = s.duration[sl]
		entity.attacks.list[1].damage_min = s.damage_min[sl]
		entity.attacks.list[1].damage_max = s.damage_max[sl]
		entity.gold_to_steal = s.gold_to_steal[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local entity = E:get_template(uc.entity)

		entity.ranged.attacks[1].damage_min = s.damage_min[sl]
		entity.ranged.attacks[1].damage_max = s.damage_max[sl]
		uc.level = sl
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_hunter.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)
	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_hunter.update(this, store)
	local h = this.health
	local a, skill, brk, sta
	local last_ts = store.tick_ts
	local last_target
	local last_target_ts = store.tick_ts
	local base_speed = this.motion.max_speed
	local melee_attack = this.melee.attacks[1]
	local ranged_attack = this.ranged.attacks[1]
	local melee_hits = 0
	local heal_strike_ready = false
	local last_attack_ranged = false
	local aim_before_shot = true
	local heal_strike_attack = this.timed_attacks.list[1]
	local ricochet_attack = this.timed_attacks.list[2]
	local shoot_around_attack = this.timed_attacks.list[3]
	local beasts_attack = this.timed_attacks.list[4]
	local original_speed = this.motion.max_speed

	if not ricochet_attack.disabled then
		ricochet_attack.ts = store.tick_ts - ricochet_attack.cooldown
	end

	if not shoot_around_attack.disabled then
		shoot_around_attack.ts = store.tick_ts - shoot_around_attack.cooldown
	end

	if not beasts_attack.disabled then
		beasts_attack.ts = store.tick_ts - beasts_attack.cooldown
	end

	local function shoot_ricochet_arrow(store, this, target, attack, pred_pos)
		local attack_done = false
		local start_ts = store.tick_ts
		local bullet
		local bullet_to = pred_pos or target.pos
		local bullet_to_start = V.vclone(bullet_to)

		while store.tick_ts - start_ts < attack.shoot_time do
			if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
				goto label_369_0
			end

			coroutine.yield()
		end

		if attack.check_target_before_shot and (target.health.dead or not store.entities[target.id]) then
			log.debug("target (%s) is dead or removed from store", target.id)
		elseif attack.max_track_distance and V.dist(target.pos.x, target.pos.y, bullet_to_start.x, bullet_to_start.y) > attack.max_track_distance then
			log.debug("target (%s) at %s,%s  exceeds attack.max_track_distance %s to %s,%s", target.id, target.pos.x, target.pos.y, attack.max_track_distance, bullet_to_start.x, bullet_to_start.y)
		else
			S:queue(attack.sound_shoot)

			bullet = E:create_entity(attack.bullet)
			bullet.pos = V.vclone(this.pos)

			if attack.bullet_start_offset then
				local offset = attack.bullet_start_offset[ai]

				bullet.pos.x, bullet.pos.y = bullet.pos.x + (af and -1 or 1) * offset.x, bullet.pos.y + offset.y
			end

			bullet.bullet.from = V.vclone(bullet.pos)
			bullet.bullet.to = V.vclone(bullet_to)

			if not attack.ignore_hit_offset then
				bullet.bullet.to.x = bullet.bullet.to.x + target.unit.hit_offset.x
				bullet.bullet.to.y = bullet.bullet.to.y + target.unit.hit_offset.y
			end

			bullet.bullet.target_id = target.id
			bullet.bullet.source_id = this.id
			bullet.bullet.xp_dest_id = this.id
			bullet.bullet.level = attack.level

			if bullet.bullet.use_unit_damage_factor then
				bullet.bullet.damage_factor = this.unit.damage_factor
			end

			queue_insert(store, bullet)

			if attack.xp_from_skill then
				SU.hero_gain_xp_from_skill(this, this.hero.skills[attack.xp_from_skill])
			end

			attack_done = true
		end

		::label_369_0::

		return attack_done, bullet
	end

	local function explosion_damage(point, radius, damage_min, damage_max, damage_type, damage_bans, damage_flags, mod_to_apply)
		local enemies = table.filter(store.entities, function(k, v)
			return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, damage_bans) == 0 and band(v.vis.bans, damage_flags) == 0 and U.is_inside_ellipse(v.pos, point, radius)
		end)

		for _, enemy in pairs(enemies) do
			local d = E:create_entity("damage")

			d.damage_type = damage_type

			local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, point, radius)

			d.value = math.floor(damage_max - (damage_max - damage_min) * dist_factor)
			d.source_id = this.id
			d.target_id = enemy.id

			queue_damage(store, d)

			if mod_to_apply then
				local mod = E:create_entity(mod_to_apply)

				mod.modifier.target_id = enemy.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)
			end
		end
	end

	local function animation_name_facing_angle_hero_hunter(group, angle_deg)
		local a = this.render.sprites[1]
		local o_name, o_flip, o_idx
		local a1, a2, a3, a4, a5, a6, a7, a8 = 22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5
		local quadrant = a._last_quadrant
		local angles = a.angles[group]

		if a1 <= angle_deg and angle_deg < a2 then
			o_name, o_flip, o_idx = angles[3], false, 3
			quadrant = 1
		elseif a2 <= angle_deg and angle_deg < a3 then
			o_name, o_flip, o_idx = angles[4], false, 4
			quadrant = 2
		elseif a3 <= angle_deg and angle_deg < a4 then
			o_name, o_flip, o_idx = angles[3], true, 3
			quadrant = 3
		elseif a4 <= angle_deg and angle_deg < a5 then
			o_name, o_flip, o_idx = angles[2], true, 2
			quadrant = 4
		elseif a5 <= angle_deg and angle_deg < a6 then
			o_name, o_flip, o_idx = angles[1], true, 1
			quadrant = 5
		elseif a6 <= angle_deg and angle_deg < a7 then
			o_name, o_flip, o_idx = angles[5], false, 5
			quadrant = 6
		elseif a7 <= angle_deg and angle_deg < a8 then
			o_name, o_flip, o_idx = angles[1], false, 1
			quadrant = 7
		else
			o_name, o_flip, o_idx = angles[2], false, 2
			quadrant = 8
		end

		return o_name, o_flip, o_idx
	end

	local function animation_name_facing_point_hero_hunter(e, group, point, idx, offset, use_path)
		local fx, fy

		if e.nav_path and use_path then
			local npos = P:node_pos(e.nav_path)

			fx, fy = npos.x, npos.y
		else
			fx, fy = e.pos.x, e.pos.y
		end

		if offset then
			fx, fy = fx + offset.x, fy + offset.y
		end

		local vx, vy = V.sub(point.x, point.y, fx, fy)
		local v_angle = V.angleTo(vx, vy)
		local angle = km.unroll(v_angle)
		local angle_deg = km.rad2deg(angle)

		return animation_name_facing_angle_hero_hunter(group, angle_deg)
	end

	local function y_soldier_do_ranged_attack_hero_hunter(store, this, target, attack, pred_pos)
		local attack_done = false
		local start_ts = store.tick_ts
		local bullet
		local bullet_to = pred_pos or target.pos
		local bullet_to_start = V.vclone(bullet_to)

		if aim_before_shot then
			local an, af, ai = U.animation_name_facing_point(this, attack.animation_prepare, bullet_to)

			U.y_animation_play(this, an, af, store.tick_ts, 1)

			local an, af, ai = animation_name_facing_point_hero_hunter(this, attack.animation_aim, bullet_to)

			U.y_animation_play(this, an, af, store.tick_ts, 1)

			aim_before_shot = false
		end

		local an, af, ai = animation_name_facing_point_hero_hunter(this, attack.animation, bullet_to)

		U.animation_start(this, an, af, store.tick_ts, false)
		S:queue(attack.sound, attack.sound_args)

		while store.tick_ts - start_ts < attack.shoot_time do
			if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
				goto label_374_0
			end

			coroutine.yield()
		end

		if attack.check_target_before_shot and (target.health.dead or not store.entities[target.id]) then
			log.debug("target (%s) is dead or removed from store", target.id)
		elseif attack.max_track_distance and V.dist(target.pos.x, target.pos.y, bullet_to_start.x, bullet_to_start.y) > attack.max_track_distance then
			log.debug("target (%s) at %s,%s  exceeds attack.max_track_distance %s to %s,%s", target.id, target.pos.x, target.pos.y, attack.max_track_distance, bullet_to_start.x, bullet_to_start.y)
		else
			S:queue(attack.sound_shoot)

			bullet = E:create_entity(attack.bullet)
			bullet.pos = V.vclone(this.pos)

			if attack.bullet_start_offset then
				local offset = attack.bullet_start_offset[ai]

				bullet.pos.x, bullet.pos.y = bullet.pos.x + (af and -1 or 1) * offset.x, bullet.pos.y + offset.y
			end

			bullet.bullet.from = V.vclone(bullet.pos)
			bullet.bullet.to = V.vclone(bullet_to)

			if not attack.ignore_hit_offset then
				bullet.bullet.to.x = bullet.bullet.to.x + target.unit.hit_offset.x
				bullet.bullet.to.y = bullet.bullet.to.y + target.unit.hit_offset.y
			end

			bullet.bullet.target_id = target.id
			bullet.bullet.source_id = this.id
			bullet.bullet.xp_dest_id = this.id
			bullet.bullet.level = this.hero.level

			if bullet.bullet.use_unit_damage_factor then
				bullet.bullet.damage_factor = this.unit.damage_factor
			end

			queue_insert(store, bullet)

			if attack.xp_from_skill then
				SU.hero_gain_xp_from_skill(this, this.hero.skills[attack.xp_from_skill])
			end

			attack_done = true

			while not U.animation_finished(this) do
				if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
					break
				end

				coroutine.yield()
			end
		end

		::label_374_0::

		return attack_done
	end

	local function y_hero_ranged_attack_hero_hunter(store, hero)
		local target, attack, pred_pos = SU.soldier_pick_ranged_target_and_attack(store, hero)

		if not target then
			return false, A_NO_TARGET
		end

		if not attack then
			return false, A_IN_COOLDOWN
		end

		local upg = UP:get_upgrade("heroes_lethal_focus")
		local triggered_lethal_focus = false
		local bullet_t = E:get_template(attack.bullet)
		local bullet_use_unit_damage_factor = bullet_t.bullet.use_unit_damage_factor
		local bullet_pop = bullet_t.bullet.pop
		local bullet_pop_conds = bullet_t.bullet.pop_conds

		if attack.basic_attack and upg then
			if not hero._lethal_focus_deck then
				hero._lethal_focus_deck = SU.deck_new(upg.trigger_cards, upg.total_cards)
			end

			triggered_lethal_focus = SU.deck_draw(hero._lethal_focus_deck)
		end

		if triggered_lethal_focus then
			hero.unit.damage_factor = hero.unit.damage_factor * upg.damage_factor
			bullet_t.bullet.use_unit_damage_factor = true
			bullet_t.bullet.pop = {
				"pop_crit"
			}
			bullet_t.bullet.pop_conds = DR_DAMAGE
		end

		local start_ts = store.tick_ts
		local attack_done

		U.set_destination(hero, hero.pos)

		if attack.loops then
			attack_done = SU.y_soldier_do_loopable_ranged_attack(store, hero, target, attack)
		else
			attack_done = y_soldier_do_ranged_attack_hero_hunter(store, hero, target, attack, pred_pos)
		end

		if attack_done then
			attack.ts = start_ts

			if attack.shared_cooldown then
				for _, aa in pairs(hero.ranged.attacks) do
					if aa ~= attack and aa.shared_cooldown then
						aa.ts = attack.ts
					end
				end
			end

			if hero.ranged.forced_cooldown then
				hero.ranged.forced_ts = start_ts
			end
		end

		if triggered_lethal_focus then
			hero.unit.damage_factor = hero.unit.damage_factor / upg.damage_factor
			bullet_t.bullet.use_unit_damage_factor = bullet_use_unit_damage_factor
			bullet_t.bullet.pop = bullet_pop
			bullet_t.bullet.pop_conds = bullet_pop_conds
		end

		if attack_done then
			return false, A_DONE
		else
			return true
		end
	end

	this.health_bar.hidden = false

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)

			this.motion.max_speed = base_speed
			aim_before_shot = true
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)

			aim_before_shot = true
		else
			while this.nav_rally.new do
				local r = this.nav_rally
				local tw = this.flywalk
				local force_flywalk = false

				for _, p in pairs(this.nav_grid.waypoints) do
					if GR:cell_is(p.x, p.y, bor(TERRAIN_WATER, TERRAIN_SHALLOW, TERRAIN_NOWALK)) then
						force_flywalk = true

						break
					end
				end

				aim_before_shot = true

				if force_flywalk or V.dist(this.pos.x, this.pos.y, r.pos.x, r.pos.y) > tw.min_distance then
					r.new = false

					U.unblock_target(store, this)

					local vis_bans = this.vis.bans

					this.vis.bans = F_ALL
					this.health.immune_to = F_ALL

					local flywalk_extra_speed_factor = (original_speed + tw.extra_speed) / original_speed

					this.motion.max_speed = this.motion.max_speed * flywalk_extra_speed_factor
					this.unit.marker_hidden = true
					this.health_bar.hidden = true
					this.on_flywalk = true

					S:queue(this.sound_events.change_rally_point)
					S:queue(this.flywalk.sound)

					local an, af = U.animation_name_facing_point(this, tw.animations[1], r.pos)

					U.animation_start(this, an, af, store.tick_ts)

					local ps

					::label_368_0::

					local dest = r.pos
					local n = this.nav_grid

					if ps ~= nil then
						ps.particle_system.emit = false

						queue_remove(store, ps)

						ps = nil
					end

					while not V.veq(this.pos, dest) do
						local w = table.remove(n.waypoints, 1) or dest

						U.set_destination(this, w)

						local runs = this.render.sprites[1].runs

						while not this.motion.arrived do
							if r.new then
								r.new = false

								goto label_368_0
							end

							if w.x < this.pos.x then
								this.render.sprites[1].flip_x = true
							else
								this.render.sprites[1].flip_x = false
							end

							if ps ~= nil then
								local offset_index = this.pos.x > w.x and 1 or 2

								ps.particle_system.emit_offset = ps.particle_system.emit_offsets[offset_index]
							end

							U.walk(this, store.tick_length)
							coroutine.yield()

							this.motion.speed.x, this.motion.speed.y = 0, 0

							if this.render.sprites[1].runs ~= runs then
								local an, af = U.animation_name_facing_point(this, tw.animations[2], w)

								U.animation_start(this, an, af, store.tick_ts, true, 1, true)

								runs = this.render.sprites[1].runs

								if ps == nil then
									ps = E:create_entity(this.flywalk.trail)
									ps.particle_system.emit = true
									ps.particle_system.track_id = this.id

									local offset_index = this.pos.x > r.pos.x and 1 or 2

									ps.particle_system.emit_offset = ps.particle_system.emit_offsets[offset_index]

									queue_insert(store, ps)
								end
							end
						end
					end

					if ps ~= nil then
						ps.particle_system.emit = false

						queue_remove(store, ps)
					end

					SU.hide_modifiers(store, this, true)
					U.y_animation_play(this, tw.animations[3], nil, store.tick_ts)
					SU.show_modifiers(store, this, true)

					this.motion.max_speed = this.motion.max_speed / flywalk_extra_speed_factor
					this.vis.bans = vis_bans
					this.health.immune_to = 0
					this.unit.marker_hidden = nil
					this.health_bar.hidden = nil
					this.on_flywalk = false
				elseif SU.y_hero_new_rally(store, this) then
					goto label_368_1
				end
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)
			end

			skill = this.hero.skills.beasts
			a = beasts_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < 1 then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)
					U.animation_start(this, a.animation, nil, store.tick_ts, 1)

					a.ts = start_ts
					last_ts = start_ts

					SU.hero_gain_xp_from_skill(this, skill)

					for i = 1, 2 do
						local offset_x = i == 1 and a.spawn_offset_x or a.spawn_offset_x * -1
						local offset_y = a.spawn_offset_y + math.random(1, 4) - 2
						local beast = E:create_entity(a.entity)

						beast.owner = this
						beast.pos = V.vclone(this.pos)
						beast.pos.x = beast.pos.x + offset_x
						beast.pos.y = beast.pos.y - offset_y
						beast.owner_offset = v(offset_x, offset_y)

						queue_insert(store, beast)
						U.y_wait(store, fts(2))
					end

					SU.y_hero_animation_wait(this)

					aim_before_shot = true
					last_ts = start_ts

					goto label_368_1
				end
			end

			skill = this.hero.skills.shoot_around
			a = shoot_around_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					U.animation_start(this, a.animations[1], nil, store.tick_ts, 1)
					
					if SU.y_hero_animation_wait(this) then
						-- block empty
					else
						S:queue(a.sound)
						
						a.ts = start_ts
						last_ts = start_ts
						
						SU.hero_gain_xp_from_skill(this, skill)
						
						local aura = E:create_entity(a.aura)
						
						aura.aura.source_id = this.id
						aura.aura.ts = store.tick_ts
						aura.pos = this.pos
						
						queue_insert(store, aura)
						this.health.immune_to = F_ALL
						U.animation_start(this, a.animations[2], nil, store.tick_ts, true)
						
						if SU.y_hero_wait(store, this, aura.aura.duration - (store.tick_ts - a.ts)) then
							S:stop(a.sound)
							S:queue(a.sound_interrupt)
						end
						
						S:stop(a.sound)
						S:queue(a.sound_interrupt)
						queue_remove(store, aura)
						this.health.immune_to = 0
						U.y_animation_play(this, a.animations[3], nil, store.tick_ts, 1)

						aim_before_shot = true
						last_ts = start_ts

						goto label_368_1
					end
				end
			end

			skill = this.hero.skills.ricochet
			a = ricochet_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), a.min_range, a.max_range_trigger, a.node_prediction, a.vis_flags, a.vis_bans)

				if not enemy then
					SU.delay_attack(store, a, fts(10))
				elseif enemy and #enemies >= ricochet_attack.min_targets then
					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, "mist_run_in", enemy.pos, 1)

					U.animation_start(this, an, af, store.tick_ts, 1)
					S:queue(a.sound)
					U.y_animation_play(this, "mist_run_in", nil, store.tick_ts, 1)

					local attack_done, bullet = shoot_ricochet_arrow(store, this, enemy, a, V.vclone(enemy.pos))

					U.animation_start(this, "mist_run_loop", nil, store.tick_ts, true)

					if attack_done then
						while not bullet.end_bounces do
							coroutine.yield()
						end
					end

					U.y_animation_play(this, "mist_run_end", nil, store.tick_ts, 1)

					ricochet_attack.ts = start_ts
					last_ts = start_ts

					goto label_368_1
				end
			end

			skill = this.hero.skills.heal_strike
			a = heal_strike_attack

			if not heal_strike_ready or this.soldier.target_id == nil then
				-- block empty
			elseif not this.motion.arrived then
				-- block empty
			else
				local target = store.entities[this.soldier.target_id]

				if not target then
					-- block empty
				elseif target.health.dead then
					-- block empty
				else
					last_ts = store.tick_ts

					local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)

					U.animation_start(this, an, af, store.tick_ts, false)
					U.y_wait(store, fts(18))
					S:queue(a.sound)
					U.y_wait(store, fts(7))

					local fx = E:create_entity(a.hit_fx)

					fx.render.sprites[1].pos = V.vclone(this.pos)
					fx.render.sprites[1].offset = V.v(a.hit_offset.x, a.hit_offset.y)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
					queue_damage(store, SU.create_attack_damage(a, target.id, this.id))

					this.health.hp = this.health.hp + target.health.hp_max * a.heal_factor

					if this.health.hp > this.health.hp_max then
						this.health.hp = this.health.hp_max
					end

					heal_strike_ready = false
					melee_hits = 0
					a.ts = last_ts

					SU.hero_gain_xp_from_skill(this, skill)
					U.y_animation_wait(this)

					aim_before_shot = true

					goto label_368_1
				end
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if not heal_strike_attack.disabled and sta == A_DONE and this.melee.last_attack.attack == melee_attack then
				melee_hits = melee_hits + 1

				if melee_hits >= heal_strike_attack.hits_to_trigger then
					heal_strike_ready = true
				end
			end

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				brk, sta = y_hero_ranged_attack_hero_hunter(store, this)

				if brk then
					-- block empty
				else
					if sta == A_DONE then
						last_attack_ranged = true
						aim_before_shot = false
					end

					if last_attack_ranged then
						if store.tick_ts - ranged_attack.ts > 2 then
							U.y_animation_play(this, "shoot_backtoidle", nil, store.tick_ts, 1)

							last_attack_ranged = false
							aim_before_shot = true
						end
					else
						SU.soldier_idle(store, this)

						aim_before_shot = true
					end

					SU.soldier_regen(store, this)
				end
			end
		end

		::label_368_1::

		coroutine.yield()
	end
end

scripts.arrow_hero_hunter_ricochet = {}

function scripts.arrow_hero_hunter_ricochet.update(this, store)
	local b = this.bullet
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)
	local bounce_count = 0
	local already_hit = {}
	local last_target
	local start_ts = store.tick_ts

	this.end_bounces = false

	local function create_arrow_trail(from, target)
		local bullet = E:create_entity(this.trail_arrow)

		bullet.pos = V.vclone(this.pos)
		bullet.bullet.from = V.vclone(from)
		bullet.bullet.to = V.vclone(target.pos)
		bullet.bullet.to.x = bullet.bullet.to.x + target.unit.hit_offset.x
		bullet.bullet.to.y = bullet.bullet.to.y + target.unit.hit_offset.y
		bullet.bullet.target_id = target.id
		bullet.bullet.source_id = this.id
		bullet.bullet.xp_dest_id = this.id

		queue_insert(store, bullet)
	end

	::label_404_0::

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	if last_target ~= nil then
		this.pos = V.vclone(last_target.pos)

		if last_target.unit.hit_offset then
			this.pos.x, this.pos.y = this.pos.x + last_target.unit.hit_offset.x, this.pos.y + last_target.unit.hit_offset.y
		end
	end

	if b.hit_time > fts(1) then
		while store.tick_ts - start_ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end
		end
	end

	if target then
		create_arrow_trail(this.pos, target)
	end

	if this.ray_duration then
		while store.tick_ts - start_ts < this.ray_duration do
			coroutine.yield()
		end
	end

	if target and not target.health.dead then
		S:queue(this.sound_bounce)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.source_id = this.id
				m.modifier.target_id = target.id
				m.bounce_count = bounce_count

				queue_insert(store, m)
			end
		end

		table.insert(already_hit, target.id)

		last_target = target
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		queue_insert(store, sfx)
	end

	S:queue(this.sound)
	U.y_wait(store, this.time_between_bounces)

	if target then
		local search_pos = V.vclone(target.pos)

		if bounce_count < this.bounces then
			local targets = U.find_enemies_in_range(store.entities, search_pos, 0, this.bounce_range, b.vis_flags, b.vis_bans, function(v)
				return not table.contains(already_hit, v.id)
			end)

			if targets then
				table.sort(targets, function(e1, e2)
					return V.dist(this.pos.x, this.pos.y, e1.pos.x, e1.pos.y) < V.dist(this.pos.x, this.pos.y, e2.pos.x, e2.pos.y)
				end)

				target = targets[1]
				bounce_count = bounce_count + 1
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
				b.target_id = target.id

				goto label_404_0
			end
		end
	end

	this.end_bounces = true

	queue_remove(store, this)
end

scripts.arrow_hero_hunter_ricochet_trail = {}

function scripts.arrow_hero_hunter_ricochet_trail.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	if this.ray_duration then
		while store.tick_ts - s.ts < this.ray_duration do
			update_sprite()
			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.mod_hero_hunter_ricochet_attack = {}

function scripts.mod_hero_hunter_ricochet_attack.update(this, store, script)
	local m = this.modifier
	local start_ts = store.tick_ts
	local already_hit = false

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local anim_index = km.zmod(this.bounce_count + 1, #this.animations)

	this.render.sprites[1].name = this.animations[anim_index]
	this.render.sprites[1].ts = store.tick_ts

	while true do
		if not already_hit and store.tick_ts - m.ts >= this.hit_delay then
			local d = E:create_entity("damage")

			d.damage_type = this.damage_type
			d.value = math.random(this.damage_min, this.damage_max)
			d.target_id = target.id
			d.source_id = this.id

			queue_damage(store, d)

			already_hit = true
		end

		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y

				if target.render.sprites[1].flip_x then
					s.offset.x = s.offset.x - this.enemy_distance
				else
					s.offset.x = s.offset.x + this.enemy_distance
				end

				s.flip_x = not target.render.sprites[1].flip_x
			end
		end

		coroutine.yield()
	end
end

scripts.aura_hero_hunter_shoot_around = {}

function scripts.aura_hero_hunter_shoot_around.update(this, store, script)
	this.aura.ts = store.tick_ts

	local last_hit_ts = 0
	local cycles_count = 0
	local last_fx = store.tick_ts

	local function distribute_fx(x, y, qty)
		if qty < 1 then
			return nil
		end

		local nodes = P:nearest_nodes(x, y, nil, nil, true)

		if #nodes < 1 then
			log.debug("cannot insert fx, no valid nodes nearby %s,%s", x, y)
		end

		local opi, ospi, oni = unpack(nodes[1])
		local offset_options = {
			-2,
			-4,
			-6,
			2,
			4,
			6
		}
		local positions = {}

		for i, offset in ipairs(offset_options) do
			if qty <= #positions then
				break
			end

			local ni = oni + offset
			local spi = km.zmod(ospi + i, 3)
			local npos = P:node_pos(opi, spi, ni)

			if P:is_node_valid(opi, ni) and band(GR:cell_type(npos.x, npos.y), bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) == 0 then
				table.insert(positions, npos)
			end
		end

		return positions
	end

	while true do
		if this.aura.cycles then
			if cycles_count >= this.aura.cycles then
				break
			end
		elseif this.aura.duration >= 0 and store.tick_ts - this.aura.ts >= this.aura.duration + this.aura.level * this.aura.duration_inc then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead then
				queue_remove(store, this)

				return
			end

			if te and te.pos then
				this.pos.x, this.pos.y = te.pos.x, te.pos.y
			end
		end

		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			cycles_count = cycles_count + 1
			last_hit_ts = store.tick_ts

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.excluded_entities or not table.contains(this.aura.excluded_entities, v.id))
			end)

			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id

				local dmin, dmax = this.aura.damage_min, this.aura.damage_max

				if this.aura.damage_inc then
					dmin = dmin + this.aura.damage_inc * this.aura.level
					dmax = dmax + this.aura.damage_inc * this.aura.level
				end

				d.value = math.random(dmin, dmax)
				d.damage_type = this.aura.damage_type
				d.track_damage = this.aura.track_damage
				d.xp_dest_id = this.aura.xp_dest_id
				d.xp_gain_factor = this.aura.xp_gain_factor

				queue_damage(store, d)

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local m = E:create_entity(mod_name)

					m.modifier.level = this.aura.level
					m.modifier.target_id = target.id
					m.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						m.render = nil
					end

					queue_insert(store, m)
				end
			end
		end

		if store.tick_ts - last_fx >= this.fx_every then
			local positions = distribute_fx(this.pos.x, this.pos.y, 9)

			positions = table.random_order(positions)

			for i = 1, this.fx_amount do
				if i <= #positions then
					local fx = E:create_entity(this.fx)

					fx.pos = positions[i]
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end
			end

			last_fx = store.tick_ts
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.bullet_hero_hunter_ranged_attack = {}

function scripts.bullet_hero_hunter_ranged_attack.update(this, store)
	local b = this.bullet
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]

	b.damage_min = b.damage_min_config[b.level]
	b.damage_max = b.damage_max_config[b.level]

	U.y_wait(store, b.flight_time)

	if target then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if band(target.vis.flags, F_FLYING) ~= 0 then
			local fx = E:create_entity(b.hit_fx)

			fx.pos = V.vclone(target.pos)

			if target.flight_height then
				fx.pos.y = fx.pos.y + target.flight_height
			end

			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		else
			if b.hit_fx then
				local fx = E:create_entity(b.hit_fx)

				fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end

			if b.floor_fx and band(target.vis.flags, F_CLIFF) == 0 then
				local fx = E:create_entity(b.floor_fx)

				fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end
		end
	end

	queue_remove(store, this)
end

scripts.bullet_hero_hunter_ultimate_ranged_attack = {}

function scripts.bullet_hero_hunter_ultimate_ranged_attack.update(this, store)
	local b = this.bullet
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]

	b.damage_min = b.damage_min_config[b.level]
	b.damage_max = b.damage_max_config[b.level]

	U.y_wait(store, b.flight_time)

	if target then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if band(target.vis.flags, F_FLYING) ~= 0 then
			local fx = E:create_entity(b.hit_fx)

			fx.pos.x, fx.pos.y = target.pos.x, target.pos.y + target.flight_height
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		else
			if b.hit_fx then
				local fx = E:create_entity(b.hit_fx)

				fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end

			if b.floor_fx and band(target.vis.flags, F_CLIFF) == 0 then
				local fx = E:create_entity(b.floor_fx)

				fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end
		end
	end

	queue_remove(store, this)
end

scripts.soldier_hero_hunter_beast = {}

function scripts.soldier_hero_hunter_beast.update(this, store)
	local sf = this.render.sprites[1]
	local fm = this.force_motion
	local attack = this.attacks.list[1]
	local target = this.enemy_target
	local move_to_owner = false
	local enemies_stole_gold = {}

	sf.offset.y = this.flight_height
	attack.ts = store.tick_ts

	local last_time_change_pos = store.tick_ts
	local idle_change_pos = V.v(0, 0)

	local function move(dest)
		sf.flip_x = dest.x < this.pos.x

		U.force_motion_step(this, store.tick_length, dest)

		return V.dist(this.pos.x, this.pos.y, dest.x, dest.y)
	end

	local function do_attack()
		local target_h = target.unit.hit_offset.y
		local target_pos = V.v(target.pos.x, target.pos.y)

		if target.unit.head_offset then
			target_pos.x, target_pos.y = target_pos.x + target.unit.head_offset.x, target_pos.y + target.unit.head_offset.y
		elseif target.unit.hit_offset then
			target_pos.x, target_pos.y = target_pos.x + target.unit.hit_offset.x, target_pos.y + target.unit.hit_offset.y
		end

		local dist = V.dist(this.pos.x, this.pos.y, target_pos.x, target_pos.y)

		while true do
			if target.health.dead then
				break
			end

			if dist < 5 and math.abs(sf.offset.y - target_h) < 5 then
				break
			end

			dist = move(target_pos)

			local move_height = target_h > sf.offset.y and 2 or -2

			sf.offset.y = km.clamp(0, this.flight_height * 1.5, sf.offset.y + move_height)

			coroutine.yield()
		end

		if target.health.dead then
			attack.ts = store.tick_ts

			return false
		end

		this.pos.x, this.pos.y = target_pos.x, target_pos.y - 1
		sf.offset.y = target_h

		U.animation_start(this, "attack", nil, store.tick_ts, false)

		attack.ts = store.tick_ts

		local already_hit = false
		local start_attack_ts = store.tick_ts

		this.force_motion.max_a = this.force_motion.max_a * 1.5
		this.force_motion.max_v = this.force_motion.max_v * 1.5

		while not U.animation_finished(this) do
			if not already_hit and store.tick_ts - start_attack_ts >= attack.shoot_time then
				already_hit = true

				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id
				d.value = math.random(attack.damage_min, attack.damage_max)
				d.damage_type = attack.damage_type

				queue_damage(store, d)

				if not table.contains(enemies_stole_gold, target.id) and math.random(0, 100) <= this.chance_to_steal then
					local fx = E:create_entity(this.steal_fx)

					fx.pos = V.vclone(target.pos)
					fx.pos.y = fx.pos.y + this.fx_offset_y
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)

					store.player_gold = store.player_gold + this.gold_to_steal

					table.insert(enemies_stole_gold, target.id)
				end
			end

			move(target.pos)
			coroutine.yield()
		end

		this.force_motion.max_a = this.force_motion.max_a / 1.5
		this.force_motion.max_v = this.force_motion.max_v / 1.5

		U.animation_start(this, "fly", nil, store.tick_ts, true)

		return true
	end

	U.y_animation_play(this, "spawn", nil, store.tick_ts, 1)
	U.animation_start(this, "fly", nil, store.tick_ts, true)

	local start_ts = store.tick_ts

	while true do
		if store.tick_ts - start_ts >= this.duration then
			break
		end

		if target and not store.entities[target.id] or target and target.health.dead then
			target = nil
		elseif target and not target.health.dead and not P:is_node_valid(target.nav_path.pi, target.nav_path.ni) then
			target = nil
		end

		local distance_from_owner = V.dist(this.owner.pos.x, this.owner.pos.y, this.pos.x, this.pos.y)

		if distance_from_owner > this.max_distance_from_owner then
			if target then
				local _, targets = U.find_foremost_enemy(store.entities, tpos(this.owner), 0, attack.range, false, attack.vis_flags, attack.vis_bans, function(v)
					return not SU.has_modifiers(store, v, this.mark_mod)
				end)

				if targets and #targets > 0 then
					target = targets[1]

					local mark_mod = E:create_entity(this.mark_mod)

					mark_mod.modifier.source_id = this.id
					mark_mod.modifier.target_id = target.id
					mark_mod.modifier.duration = this.mark_mod_duration

					queue_insert(store, mark_mod)

					this._mark_mod = mark_mod
				else
					move_to_owner = true
				end
			else
				move_to_owner = true
			end
		end

		if target then
			local distance_from_target = V.dist(this.pos.x, this.pos.y, target.pos.x, target.pos.y)

			if store.tick_ts - attack.ts > attack.cooldown and distance_from_target < this.min_distance_to_attack and not do_attack() then
				-- block empty
			end
		else
			local _, targets = U.find_foremost_enemy(store.entities, tpos(this.owner), 0, attack.range, false, attack.vis_flags, attack.vis_bans, function(v)
				return not SU.has_modifiers(store, v, this.mark_mod)
			end)

			if targets and #targets > 0 then
				target = targets[1]

				local mark_mod = E:create_entity(this.mark_mod)

				mark_mod.modifier.source_id = this.id
				mark_mod.modifier.target_id = target.id
				mark_mod.modifier.duration = this.mark_mod_duration

				queue_insert(store, mark_mod)

				this._mark_mod = mark_mod
			end
		end

		if move_to_owner then
			local owner_pos = {}

			if store.tick_ts - last_time_change_pos >= this.idle_change_pos_cd then
				last_time_change_pos = store.tick_ts
				idle_change_pos.x = math.random(0, this.idle_change_pos_offset.x) - this.idle_change_pos_offset.x / 2
				idle_change_pos.y = math.random(0, this.idle_change_pos_offset.y) - this.idle_change_pos_offset.y / 2
			end

			owner_pos.x = this.owner.pos.x + this.owner_offset.x + idle_change_pos.x
			owner_pos.y = this.owner.pos.y + this.owner_offset.y + idle_change_pos.y

			move(owner_pos)

			local move_height = sf.offset.y < this.flight_height and 2 or -2

			sf.offset.y = km.clamp(0, this.flight_height * 1.5, sf.offset.y + move_height)
		elseif target then
			local pos = V.vclone(target.pos)

			move(pos)
		else
			move_to_owner = true

			local owner_pos = {}

			if store.tick_ts - last_time_change_pos >= this.idle_change_pos_cd then
				last_time_change_pos = store.tick_ts
				idle_change_pos.x = math.random(0, this.idle_change_pos_offset.x) - this.idle_change_pos_offset.x / 2
				idle_change_pos.y = math.random(0, this.idle_change_pos_offset.y) - this.idle_change_pos_offset.y / 2
			end

			owner_pos.x = this.owner.pos.x + this.owner_offset.x + idle_change_pos.x
			owner_pos.y = this.owner.pos.y + this.owner_offset.y + idle_change_pos.y

			move(owner_pos)

			local move_height = sf.offset.y < this.flight_height and 2 or -2

			sf.offset.y = km.clamp(0, this.flight_height * 1.5, sf.offset.y + move_height)
		end

		coroutine.yield()
	end

	this.render.sprites[2].hidden = true

	U.y_animation_play(this, "leave", nil, store.tick_ts, 1)
	queue_remove(store, this)
end

function scripts.soldier_hero_hunter_beast.remove(this, store)
	if this._mark_mod then
		queue_remove(store, this._mark_mod)
	end

	return true
end

scripts.hero_hunter_ultimate = {}

function scripts.hero_hunter_ultimate.can_fire_fn(this, x, y, store)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_hunter_ultimate.update(this, store)
	local x, y = this.pos.x, this.pos.y
	local e = E:create_entity(this.entity)

	e.pos.x = x
	e.pos.y = y
	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.level = this.level

	queue_insert(store, e)

	local a = E:create_entity(this.aura)

	a.pos = e.pos
	a.level = this.level
	a.aura.source_id = e.id

	queue_insert(store, a)
	S:queue(this.sound)
	queue_remove(store, this)
end

scripts.soldier_hero_hunter_ultimate = {}

function scripts.soldier_hero_hunter_ultimate.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts
	this.ranged.attacks[1].level = this.level
	this.hero_hunter_ref = nil

	for _, e in pairs(store.entities) do
		if e.template_name == "hero_hunter" then
			this.hero_hunter_ref = e

			break
		end
	end

	this.ranged.attacks[1].level = this.hero_hunter_ref.hero.skills.ultimate.level

	U.y_animation_play(this, "summon", nil, store.tick_ts, 1)

	while true do
		if this.hero_hunter_ref then
			local dist = V.dist(this.pos.x, this.pos.y, this.hero_hunter_ref.pos.x, this.hero_hunter_ref.pos.y)

			if dist <= this.distance_to_revive and this.hero_hunter_ref.health.dead and this.hero_hunter_ref.health.death_finished_ts then
				this.hero_hunter_ref.force_respawn = true
			end
		end

		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			if this.health.dead then
				this.reinforcement.fade = nil
				this.tween = nil
			else
				this.reinforcement.fade = true
			end

			this.health.hp = 0

			SU.remove_modifiers(store, this)

			this.ui.can_click = false

			SU.y_soldier_death(store, this)

			return
		end

		SU.soldier_courage_upgrade(store, this)

		while this.nav_rally.new do
			if SU.y_hero_new_rally(store, this) then
				goto label_424_0
			end
		end

		if this.ranged then
			brk, star = SU.y_soldier_ranged_attacks(store, this)

			if brk or star == A_DONE then
				goto label_424_0
			elseif star == A_IN_COOLDOWN then
				-- block empty
			end
		end

		SU.soldier_idle(store, this)
		SU.soldier_regen(store, this)

		::label_424_0::

		coroutine.yield()
	end
end

scripts.hero_dragon_gem = {}

function scripts.hero_dragon_gem.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]

	local b = E:get_template(this.ranged.attacks[1].bullet)

	b.bullet.damage_max = ls.ranged_damage_max[hl]
	b.bullet.damage_min = ls.ranged_damage_min[hl]

	local s

	s = this.hero.skills.stun

	local sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - STUN - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[2]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]

		local b = E:get_template(a.bullet)
		local aura = E:get_template(b.bullet.hit_payload)
		local mod = E:get_template(aura.aura.mod)

		mod.modifier.duration = s.duration[s.level]
	end

	s = this.hero.skills.floor_impact
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - FLOOR IMPACT - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[3]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]

		local d = E:get_template(a.entity)

		d.damage_min = s.damage_min[s.level]
		d.damage_max = s.damage_max[s.level]
	end

	s = this.hero.skills.crystal_instakill
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - CRYSTAL INSTAKILL - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[4]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]
		a.hp_max = s.hp_max[s.level]

		local m = E:get_template(a.mod)

		m.damage_aoe_min = s.damage_min[s.level]
		m.damage_aoe_max = s.damage_max[s.level]
	end

	s = this.hero.skills.crystal_totem
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - CRYSTAL TOTEM - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[5]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]

		local bullet = E:get_template(a.bullet)
		local aura = E:get_template(bullet.bullet.hit_payload)

		aura.aura.duration = s.duration[s.level]
		aura.damage_min = s.damage_min[s.level]
		aura.damage_max = s.damage_max[s.level]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]
		uc.max_shards = s.max_shards[sl]

		local decal = E:get_template(uc.decal)

		decal.damage_min = s.damage_min[sl]
		decal.damage_max = s.damage_max[sl]
	end

	this.health.hp = this.health.hp_max
end

function scripts.hero_dragon_gem.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_dragon_gem.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill
	local shots_with_mod = 0
	local shadow_sprite = this.render.sprites[2]
	local stun_attack = this.ranged.attacks[2]
	local floor_impact_attack = this.ranged.attacks[3]
	local crystal_instakill_attack = this.ranged.attacks[4]
	local crystal_totem_attack = this.ranged.attacks[5]
	local upg_lf = UP:get_upgrade("heroes_lethal_focus")

	if not stun_attack.disabled then
		stun_attack.ts = store.tick_ts - stun_attack.cooldown
	end

	if not floor_impact_attack.disabled then
		floor_impact_attack.ts = store.tick_ts - floor_impact_attack.cooldown
	end

	if not crystal_instakill_attack.disabled then
		crystal_instakill_attack.ts = store.tick_ts - crystal_instakill_attack.cooldown
	end

	if not crystal_totem_attack.disabled then
		crystal_totem_attack.ts = store.tick_ts - crystal_totem_attack.cooldown
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts
	this.health_bar.hidden = false

	U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts - fts(4), this.idle_flip.loop, nil, true)

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
			U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				local r = this.nav_rally
				local start_pos = V.vclone(this.pos)
	
				SU.y_hero_new_rally(store, this)
	
				if V.dist(this.pos.x, this.pos.y, start_pos.x, start_pos.y) > this.passive_charge.distance_to_charge then
					local modifier = E:create_entity(this.passive_charge.mod)
	
					modifier.modifier.target_id = this.id
	
					queue_insert(store, modifier)
				end
			end
	
			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)
	
			if SU.hero_level_up(store, this) then
				-- block empty
			end
	
			for _, i in pairs(this.ranged.order) do
				do
					local a = this.ranged.attacks[i]
	
					if a.disabled then
						-- block empty
					elseif a.sync_animation and not this.render.sprites[1].sync_flag then
						-- block empty
					elseif store.tick_ts - a.ts < a.cooldown then
						-- block empty
					else
						if i == 2 then
							local targets_info = U.find_enemies_in_paths(store.entities, this.pos, a.range_nodes_min, a.range_nodes_max, nil, a.vis_flags, a.vis_bans)
	
							if not targets_info or #targets_info < a.min_targets then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local target
	
							for _, ti in pairs(targets_info) do
								if GR:cell_is(ti.enemy.pos.x, ti.enemy.pos.y, TERRAIN_LAND) then
									target = ti.enemy
	
									break
								end
							end
	
							if not target then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local start_ts = store.tick_ts
							local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)
	
							S:queue(a.sound)
							U.animation_start(this, an, af, store.tick_ts)
	
							if SU.y_hero_wait(store, this, a.shoot_time) then
								goto label_399_2
							end
	
							local b = E:create_entity(a.bullet)
	
							b.bullet.target_id = target.id
							b.bullet.source_id = this.id
							b.pos = V.vclone(this.pos)
	
							local bullet_start_offset = v(0, 0)
	
							if a.bullet_start_offset and #a.bullet_start_offset == 2 then
								local offset_index = af and 2 or 1
	
								bullet_start_offset = a.bullet_start_offset[offset_index]
							end
	
							b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
							b.pos.y = b.pos.y + bullet_start_offset.y
							b.bullet.from = V.vclone(b.pos)
	
							if b.bullet.ignore_hit_offset then
								b.bullet.to = V.v(target.pos.x, target.pos.y)
							else
								b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
							end
	
							queue_insert(store, b)
							U.y_animation_wait(this)
	
							a.ts = start_ts
	
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
	
							goto label_399_1
						end
	
						if i == 3 then
							local targets_info = U.find_enemies_in_paths(store.entities, this.pos, a.range_nodes_min, a.range_nodes_max, nil, a.vis_flags, a.vis_bans)
	
							if not targets_info or #targets_info < a.min_targets then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local target
	
							for _, ti in pairs(targets_info) do
								if GR:cell_is(ti.enemy.pos.x, ti.enemy.pos.y, TERRAIN_LAND) then
									target = ti.enemy
	
									break
								end
							end
	
							if not target then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local pi, spi, ni = target.nav_path.pi, target.nav_path.spi, target.nav_path.ni
							local available_paths = {}
	
							for k, v in pairs(P.paths) do
								table.insert(available_paths, k)
							end
	
							if store.level.ignore_walk_backwards_paths then
								available_paths = table.filter(available_paths, function(k, v)
									return not table.contains(store.level.ignore_walk_backwards_paths, v)
								end)
							end
	
							local nodes = P:nearest_nodes(this.pos.x, this.pos.y, available_paths, nil, nil, NF_RALLY)
	
							if #nodes < 1 then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local pi, spi, ni = unpack(nodes[1])
							local nodepos = P:node_pos(pi, spi, ni)
							local dist = V.dist(this.pos.x, this.pos.y, nodepos.x, nodepos.y)
	
							if dist > a.distance_to_start_node then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							S:queue(a.sound)
	
							local start_ts = store.tick_ts
							local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)
	
							U.animation_start(this, an, af, store.tick_ts)
							U.y_wait(store, a.fall_time)
	
							local floor_decal = E:create_entity(a.floor_decal)
	
							floor_decal.pos = V.vclone(this.pos)
							floor_decal.render.sprites[1].ts = store.tick_ts
	
							queue_insert(store, floor_decal)
	
							local shards = {}
	
							local function shard_too_close(new_pos)
								for _, shard in ipairs(shards) do
									local dist = V.dist(new_pos.x, new_pos.y, shard.x, shard.y)
	
									if dist < 10 then
										return true
									end
								end
	
								return false
							end
	
							for i = 1, #nodes do
								local pi, spi, ni = unpack(nodes[i])
								local nodepos = P:node_pos(pi, spi, ni)
								local dist = V.dist(this.pos.x, this.pos.y, nodepos.x, nodepos.y)
	
								if dist < a.distance_to_start_node then
									local ni_backwards = ni - a.initial_offset
									local ni_forward = ni + a.initial_offset
									local ni_aux
	
									for j = 1, a.shards do
										ni_aux = ni_backwards - (j - 1) * a.nodes_between_shards
	
										local new_pos
	
										if P:is_node_valid(pi, ni_aux) then
											new_pos = P:node_pos(pi, 1, ni_aux)
	
											if not shard_too_close(new_pos) then
												table.insert(shards, new_pos)
											end
										end
	
										ni_aux = ni_backwards - (j - 1) * (a.nodes_between_shards + 2)
	
										if P:is_node_valid(pi, ni_aux) then
											new_pos = P:node_pos(pi, 2, ni_aux)
	
											if not shard_too_close(new_pos) then
												table.insert(shards, new_pos)
											end
	
											new_pos = P:node_pos(pi, 3, ni_aux)
	
											if not shard_too_close(new_pos) then
												table.insert(shards, new_pos)
											end
										end
	
										ni_aux = ni_forward + (j - 1) * a.nodes_between_shards
	
										if P:is_node_valid(pi, ni_aux) then
											new_pos = P:node_pos(pi, 1, ni_aux)
	
											if not shard_too_close(new_pos) then
												table.insert(shards, new_pos)
											end
										end
	
										ni_aux = ni_forward + (j - 1) * (a.nodes_between_shards + 2)
	
										if P:is_node_valid(pi, ni_aux) then
											new_pos = P:node_pos(pi, 2, ni_aux)
	
											if not shard_too_close(new_pos) then
												table.insert(shards, new_pos)
											end
	
											new_pos = P:node_pos(pi, 3, ni_aux)
	
											if not shard_too_close(new_pos) then
												table.insert(shards, new_pos)
											end
										end
									end
								end
							end
	
							table.sort(shards, function(e1, e2)
								return V.dist(this.pos.x, this.pos.y, e1.x, e1.y) < V.dist(this.pos.x, this.pos.y, e2.x, e2.y)
							end)
	
							local controller = E:create_entity(a.controller)
	
							controller.shards = shards
							controller.pos = V.vclone(this.pos)
							controller.entity = a.entity
	
							queue_insert(store, controller)
							U.y_animation_wait(this)
	
							a.ts = start_ts
	
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
	
							goto label_399_1
						end
	
						if i == 4 then
							local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, 0, a.vis_flags, a.vis_bans)
	
							if not target then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							if target.health and target.health.hp_max > a.hp_max then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local start_ts = store.tick_ts
	
							S:queue(a.sound, a.sound_args)
	
							local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)
	
							U.animation_start(this, an, af, store.tick_ts)
							U.y_wait(store, a.shoot_time)
	
							local mod = E:create_entity(a.mod)
	
							mod.modifier.target_id = target.id
							mod.modifier.source_id = this.id
	
							queue_insert(store, mod)
							U.y_animation_wait(this)
	
							a.ts = start_ts
	
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
	
							goto label_399_1
						end
	
						if i == 5 then
							local _, enemies = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range_trigger, false, a.vis_flags, a.vis_bans)
	
							if not enemies or #enemies < a.min_targets then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local aim_target, _ = U.find_entity_most_surrounded(enemies)
	
							if P:nodes_to_goal(aim_target.nav_path) < a.nodes_prediction + 10 then
								SU.delay_attack(store, a, 0.4)
	
								goto label_399_1
							end
	
							local bullet = E:create_entity(a.bullet)
							local node_offset = P:predict_enemy_node_advance(aim_target, bullet.bullet.flight_time)
	
							node_offset = node_offset + a.nodes_prediction

							if not P:is_node_valid(aim_target.nav_path.pi, aim_target.nav_path.ni + node_offset) then
								SU.delay_attack(store, a, 0.4)

								goto label_399_1
							end
	
							local bullet_to = P:node_pos(aim_target.nav_path.pi, 1, aim_target.nav_path.ni + node_offset, true)
							local start_ts = store.tick_ts
	
							S:queue(a.sound)
	
							local an, af, ai = U.animation_name_facing_point(this, a.animation, bullet_to)
	
							U.animation_start(this, an, af, store.tick_ts)
							U.y_wait(store, a.shoot_time)
	
							bullet.pos = V.vclone(this.pos)
							bullet.pos.x = bullet.pos.x + a.bullet_start_offset.x
							bullet.pos.y = bullet.pos.y + a.bullet_start_offset.y
							bullet.bullet.from = V.vclone(bullet.pos)
							bullet.bullet.to = V.vclone(bullet_to)
							bullet.bullet.target_id = aim_target.id
							bullet.bullet.source_id = this.id
	
							queue_insert(store, bullet)
							U.y_animation_wait(this)
	
							a.ts = start_ts
	
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
	
							goto label_399_1
						end
	
						if i == 1 then
							local bullet_t = E:get_template(a.bullet)
							local flight_time = a.estimated_flight_time or 1
							local pos_offset = v(this.pos.x + a.ignore_offset.x, this.pos.y + a.ignore_offset.y)
							local targets = U.find_enemies_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)
	
							if targets then
								local target = targets[1]
								local start_ts = store.tick_ts
								local start_fx, b, targets
								local node_offset = P:predict_enemy_node_advance(target, flight_time)
								local t_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + node_offset)
								local an, af, ai = U.animation_name_facing_point(this, a.animation, t_pos)
	
								U.animation_start(this, an, af, store.tick_ts)
								S:queue(a.start_sound, a.start_sound_args)
	
								while store.tick_ts - start_ts < a.shoot_time do
									if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
										goto label_399_0
									end
	
									coroutine.yield()
								end
	
								targets = {
									target
								}
								b = E:create_entity(a.bullet)
	
								if a.type == "aura" then
									b.pos.x, b.pos.y = target.pos.x, target.pos.y
									b.aura.ts = store.tick_ts
								else
									b.bullet.target_id = target.id
									b.bullet.source_id = this.id
									b.bullet.xp_dest_id = this.id
									b.pos = V.vclone(this.pos)
	
									local bullet_start_offset = v(0, 0)
	
									if a.bullet_start_offset and #a.bullet_start_offset == 2 then
										local offset_index = af and 2 or 1
	
										bullet_start_offset = a.bullet_start_offset[offset_index]
									end
	
									b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
									b.pos.y = b.pos.y + bullet_start_offset.y
									b.bullet.from = V.vclone(b.pos)
	
									if b.bullet.ignore_hit_offset then
										b.bullet.to = V.v(target.pos.x, target.pos.y)
									else
										b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
									end
	
									b.bullet.shot_index = i
									b.initial_impulse = 10
	
									if b.bullet.use_unit_damage_factor then
										b.bullet.damage_min = b.bullet.damage_min * this.unit.damage_factor
										b.bullet.damage_max = b.bullet.damage_max * this.unit.damage_factor
									end
	
									if upg_lf then
										if not this._lethal_focus_deck then
											this._lethal_focus_deck = SU.deck_new(upg_lf.trigger_cards, upg_lf.total_cards)
										end
	
										local triggered_lethal_focus = SU.deck_draw(this._lethal_focus_deck)
	
										if triggered_lethal_focus then
											b.bullet.damage_factor = b.bullet.damage_factor * upg_lf.damage_factor_area
											b.bullet.pop = {
												"pop_crit"
											}
											b.bullet.pop_chance = 1
											b.bullet.pop_conds = DR_DAMAGE
										end
									end
								end
	
								queue_insert(store, b)
	
								if a.xp_from_skill then
									SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
								end
	
								a.ts = start_ts
	
								while not U.animation_finished(this) do
									if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
										goto label_399_0
									end
	
									coroutine.yield()
								end
	
								a.ts = start_ts
	
								if U.has_modifiers(store, this, this.passive_charge.mod) then
									shots_with_mod = shots_with_mod + 1
	
									if shots_with_mod >= this.passive_charge.shots_amount then
										SU.remove_modifiers(store, this, this.passive_charge.mod)
	
										shots_with_mod = 0
									end
								end
	
								U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
	
								::label_399_0::
	
								if start_fx then
									start_fx.render.sprites[1].hidden = true
								end
	
								goto label_399_1
							end
						end
					end
				end
	
				::label_399_1::
			end
	
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_399_2::

		coroutine.yield()
	end
end

scripts.bolt_hero_dragon_gem_attack = {}

function scripts.bolt_hero_dragon_gem_attack.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false
	local target = store.entities[b.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	local is_flying = U.flag_has(target.vis.flags, F_FLYING)

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if is_flying then
		b.hit_fx = b.hit_fx_flying
		b.ignore_hit_offset = false
	else
		b.hit_fx = b.hit_fx_floor
		b.ignore_hit_offset = true
	end

	::label_404_0::

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

		if ps then
			ps.particle_system.emit = true
		end
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		if target and target.health and not target.health.dead then
			if b.ignore_hit_offset then
				b.to.x, b.to.y = target.pos.x, target.pos.y
			else
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end

			new_target = false
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end
	end

	while b.store and not b.target_id do
		coroutine.yield()

		if b.target_id then
			mspeed = b.min_speed
			new_target = true

			goto label_404_0
		end
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y

	S:queue(this.sound_hit)

	local function explosion(r, damage_min, damage_max, dty)
		local target_bans = bit.bor(F_FLYING)
		local target_pos = V.vclone(this.pos)

		if is_flying then
			target_bans = 0

			if target and target.flight_height then
				target_pos.y = target_pos.y - target.flight_height
			end
		end

		local targets = U.find_enemies_in_range(store.entities, target_pos, 0, r, 0, target_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				d.value = math.random(damage_min, damage_max)
				d.damage_type = dty
				d.target_id = target.id
				d.source_id = b.source_id
				d.xp_gain_factor = b.xp_gain_factor
				d.xp_dest_id = b.source_id

				queue_damage(store, d)
			end
		end
	end

	local p = SU.create_bullet_pop(store, this)

	if p then
		queue_insert(store, p)
	end

	explosion(this.damage_range, b.damage_min, b.damage_max, b.damage_type)

	if not is_flying and b.payload then
		for _, v in ipairs(b.payload) do
			local hp

			if type(v) == "string" then
				hp = E:create_entity(v)
			else
				hp = v
			end

			hp.pos.x, hp.pos.y = b.to.x, b.to.y
			hp.render.sprites[1].ts = store.tick_ts

			queue_insert(store, hp)
		end
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.aura_hero_dragon_gem_skill_stun = {}

function scripts.aura_hero_dragon_gem_skill_stun.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	}, true)
	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)
	local fx = E:create_entity(this.surround_fx)

	fx.pos.x, fx.pos.y = npos.x - 20, npos.y
	fx.render.sprites[1].ts = store.tick_ts
	fx.render.sprites[1].runs = 0

	queue_insert(store, fx)

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_406_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_406_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_406_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_406_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_406_0::

		coroutine.yield()
	end

	U.y_wait(store, fts(5))

	fx = E:create_entity(this.surround_fx)
	fx.pos.x, fx.pos.y = npos.x + 20, npos.y - 20
	fx.render.sprites[1].ts = store.tick_ts
	fx.render.sprites[1].runs = 0

	queue_insert(store, fx)
	U.y_wait(store, fts(5))

	fx = E:create_entity(this.surround_fx)
	fx.pos.x, fx.pos.y = npos.x + 15, npos.y + 20
	fx.render.sprites[1].ts = store.tick_ts
	fx.render.sprites[1].runs = 0
	fx.render.sprites[1].flip_x = true

	queue_insert(store, fx)
	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.decal_hero_dragon_gem_crystal_tomb = {}

function scripts.decal_hero_dragon_gem_crystal_tomb.update(this, store)
	U.y_animation_play(this, "death_crystals", nil, store.tick_ts, 1)

	while true do
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.controller_hero_dragon_gem_skill_floor_impact_spawner = {}

function scripts.controller_hero_dragon_gem_skill_floor_impact_spawner.update(this, store)
	local function spawn_shard(pos)
		pos.x = pos.x + math.random(-4, 4)
		pos.y = pos.y + math.random(-5, 5)

		local s = E:create_entity(this.entity)

		s.pos = V.vclone(pos)
		s.dragon_pos = V.vclone(this.pos)

		queue_insert(store, s)
	end

	for i = 1, #this.shards do
		spawn_shard(this.shards[i])
		U.y_wait(store, fts(1))
	end

	queue_remove(store, this)
end

scripts.decal_hero_dragon_gem_floor_impact_shard = {}

function scripts.decal_hero_dragon_gem_floor_impact_shard.update(this, store)
	this.render.sprites[1].flip_x = this.dragon_pos.x > this.pos.x

	U.animation_start(this, "start", nil, store.tick_ts, 1)
	U.y_wait(store, this.damage_time)
	U.y_animation_wait(this)
	U.animation_start(this, "idle", nil, store.tick_ts, 1)

	local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.damage_range, 0, bit.bor(F_FLYING, F_CLIFF))

	if targets then
		for _, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.value = math.random(this.damage_min, this.damage_max)
			d.damage_type = this.damage_type
			d.target_id = target.id
			d.source_id = this.id

			queue_damage(store, d)
			
			if this.mod then
				local mod = E:create_entity(this.mod)

				mod.modifier.target_id = target.id
				mod.modifier.duration = this.stun_duration

				queue_insert(store, mod)
			end
		end
	end

	U.y_wait(store, this.duration_time + fts(math.random(1, 10) - 5))
	U.animation_start(this, "end", nil, store.tick_ts, 1)
	U.y_animation_wait(this)
	queue_remove(store, this)
end

scripts.mod_hero_dragon_gem_crystal_instakill = {}

function scripts.mod_hero_dragon_gem_crystal_instakill.update(this, store)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	if target.unit.size == UNIT_SIZE_SMALL then
		this.render.sprites[1].scale = v(0.8, 0.8)
	else
		this.render.sprites[1].scale = v(1, 1)
	end

	this.pos = target.pos
	start_ts = store.tick_ts

	if m.animation_phases then
		U.animation_start(this, "start", nil, store.tick_ts)

		while not U.animation_finished(this) do
			if not target_hidden and m.hide_target_delay and store.tick_ts - start_ts > m.hide_target_delay then
				target_hidden = true

				if target.ui then
					target.ui.can_click = false
				end

				if target.health_bar then
					target.health_bar.hidden = true
				end

				U.sprites_hide(target, nil, nil, true)
				SU.hide_modifiers(store, target, true, this)
				SU.hide_auras(store, target, true)
			end

			coroutine.yield()
		end
	end

	local d = E:create_entity("damage")

	d.value = 1
	d.damage_type = this.damage_type
	d.target_id = target.id
	d.source_id = this.id

	queue_damage(store, d)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
		if this.render and m.use_mod_offset and target.unit.mod_offset and not m.custom_offsets then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	S:queue(this.explode_sound)

	if m.animation_phases then
		U.animation_start(this, "explosion", nil, store.tick_ts)

		if target_hidden then
			if target.ui then
				target.ui.can_click = true
			end

			if target.health_bar and not target.health.dead then
				target.health_bar.hidden = nil
			end

			U.sprites_show(target, nil, nil, true)
			SU.show_modifiers(store, target, true, this)
			SU.show_auras(store, target, true)
		end

		U.y_wait(store, this.explode_time)

		local explode_fx = E:create_entity(this.explode_fx)

		explode_fx.pos = V.vclone(target.pos)
		explode_fx.tween.ts = store.tick_ts

		queue_insert(store, explode_fx)

		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.damage_range, 0, this.damage_aoe_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				d.value = math.random(this.damage_aoe_min, this.damage_aoe_max)
				d.damage_type = this.damage_type_aoe
				d.target_id = target.id
				d.source_id = this.id

				queue_damage(store, d)
			end
		end

		while not U.animation_finished(this) do
			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.aura_hero_dragon_gem_crystal_totem = {}

function scripts.aura_hero_dragon_gem_crystal_totem.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	local floor_decal = E:create_entity(this.floor_decal)

	floor_decal.pos = V.vclone(this.pos)
	floor_decal.tween.ts = store.tick_ts

	queue_insert(store, floor_decal)
	S:queue(this.pulse_sound)
	U.y_animation_play(this, "spawn", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_413_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_413_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_413_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_413_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.damage_range, 0, this.damage_bans)

			if targets then
				for _, target in pairs(targets) do
					local d = E:create_entity("damage")

					d.value = math.random(this.damage_min, this.damage_max)
					d.damage_type = this.damage_type
					d.target_id = target.id
					d.source_id = this.id

					queue_damage(store, d)
				end
			end

			local floor_decal = E:create_entity(this.floor_decal)

			floor_decal.pos = V.vclone(this.pos)
			floor_decal.tween.ts = store.tick_ts

			queue_insert(store, floor_decal)
			U.y_animation_play(this, "shock", nil, store.tick_ts)
			U.animation_start(this, "idle", nil, store.tick_ts, true)
		end

		::label_413_0::

		coroutine.yield()
	end

	this.tween.ts = store.tick_ts
	this.tween.disabled = false

	U.y_wait(store, fts(15))
	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.hero_dragon_gem_ultimate = {}

function scripts.hero_dragon_gem_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_dragon_gem_ultimate.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true, NF_POWER_3)

	if #nodes < 1 then
		log.error("hero_dragon_gem_ultimate: could not find valid node")
		queue_remove(store, this)

		return
	end

	local target_pos = {}
	local node = {
		spi = 1,
		pi = nodes[1][1],
		ni = nodes[1][3]
	}
	local node_pos = P:node_pos(node)
	local count = this.max_shards

	local function shard_too_close(new_pos)
		for _, shard in ipairs(target_pos) do
			local dist = V.dist(new_pos.x, new_pos.y, shard.x, shard.y)

			if dist < this.distance_between_shards then
				return true
			end
		end

		return false
	end

	local _, targets = U.find_nearest_enemy(store.entities, this.pos, 0, this.range, this.vis_flags, this.vis_bans)

	table.insert(target_pos, node_pos)

	if targets then
		for _, v in ipairs(targets) do
			if count > #target_pos then
				local node_offset = P:predict_enemy_node_advance(v, this.prediction_nodes)
				local e_pos = P:node_pos(v.nav_path.pi, v.nav_path.spi, v.nav_path.ni + node_offset)

				table.insert(target_pos, V.vclone(e_pos))
			end
		end
	end

	if count > #target_pos then
		local available_paths = {}

		for k, v in pairs(P.paths) do
			table.insert(available_paths, k)
		end

		if store.level.ignore_walk_backwards_paths then
			available_paths = table.filter(available_paths, function(k, v)
				return not table.contains(store.level.ignore_walk_backwards_paths, v)
			end)
		end

		local safe_break = 1000
		local nearest = P:nearest_nodes(this.pos.x, this.pos.y, available_paths)

		if nearest and #nearest > 0 then
			local path_pi, path_spi, path_ni = unpack(nearest[1])
			local spi = {
				1,
				3,
				2
			}

			while count > #target_pos do
				local ni_random = math.random(this.random_ni_spread * -1, this.random_ni_spread)
				local spi_random = spi[count % 3 + 1]
				local pos_spawn = P:node_pos(path_pi, spi_random, path_ni + ni_random)

				if not shard_too_close(pos_spawn) then
					table.insert(target_pos, pos_spawn)
				end

				safe_break = safe_break - 1

				if safe_break <= 0 then
					break
				end
			end
		end
	end

	for _, pos in ipairs(target_pos) do
		local decal = E:create_entity(this.decal)

		decal.pos = V.vclone(pos)

		queue_insert(store, decal)
		U.y_wait(store, this.spawn_delay)
	end

	queue_remove(store, this)
end

scripts.bullet_hero_dragon_gem_ultimate_shard = {}

function scripts.bullet_hero_dragon_gem_ultimate_shard.update(this, store)
	local b = this.bullet
	local speed = b.max_speed

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) >= 2 * (speed * store.tick_length) do
		b.speed.x, b.speed.y = V.mul(speed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
		this.render.sprites[1].r = 0

		coroutine.yield()
	end

	local targets = U.find_targets_in_range(store.entities, b.to, 0, b.damage_radius, b.damage_flags, b.damage_bans)

	if targets then
		for _, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.damage_type = b.damage_type
			d.value = b.damage_max
			d.source_id = this.id
			d.target_id = target.id

			queue_damage(store, d)

			if b.mod then
				local mod = E:create_entity(b.mod)

				mod.modifier.target_id = target.id

				queue_insert(store, mod)
			end
		end
	end

	if b.hit_fx then
		SU.insert_sprite(store, b.hit_fx, this.pos)
	end

	if b.arrive_decal then
		local decal = E:create_entity(b.arrive_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts
		decal.tween.ts = store.tick_ts

		queue_insert(store, decal)
	end

	queue_remove(store, this)
end

scripts.decal_hero_dragon_gem_ultimate_shard = {}

function scripts.decal_hero_dragon_gem_ultimate_shard.update(this, store)
	this.render.sprites[1].hidden = true

	local x_bullet_offset = {
		0,
		10,
		-10,
		10
	}
	local y_bullet_offset = {
		-10,
		-5,
		0,
		-5
	}

	for i = 1, 4 do
		local bullet = E:create_entity(this.bullet)
		local bullet_pos = V.vclone(this.pos)

		bullet_pos.x = bullet_pos.x + x_bullet_offset[i]
		bullet_pos.y = bullet_pos.y + y_bullet_offset[i]
		bullet.pos = V.vclone(bullet_pos)
		bullet.pos.y = bullet.pos.y + 200
		bullet.bullet.from = V.vclone(bullet.pos)
		bullet.bullet.to = V.vclone(bullet_pos)

		queue_insert(store, bullet)
		U.y_wait(store, fts(2))
	end

	U.y_wait(store, this.damage_time)

	this.render.sprites[1].hidden = false

	for _, v in ipairs(this.fx_on_arrival) do
		local fx = E:create_entity(v)

		fx.pos = V.vclone(this.pos)
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	local floor_decal = E:create_entity(this.floor_decal)

	floor_decal.pos = V.vclone(this.pos)
	floor_decal.render.sprites[1].ts = store.tick_ts

	queue_insert(store, floor_decal)

	local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.damage_range, 0, bit.bor(F_CLIFF))

	if targets then
		for _, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.value = math.random(this.damage_min, this.damage_max)
			d.damage_type = this.damage_type
			d.target_id = target.id
			d.source_id = this.id

			queue_damage(store, d)
		end
	end

	this.tween.ts = store.tick_ts
	this.tween.disabled = false

	U.y_wait(store, this.tween.props[1].keys[2][1])
	queue_remove(store, this)
end

scripts.mod_hero_dragon_gem_passive_charge = {}

function scripts.mod_hero_dragon_gem_passive_charge.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local start_countdown = false

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end
end

scripts.hero_bird = {}

function scripts.hero_bird.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]

	local b = E:get_template(this.ranged.attacks[1].bullet)

	b.bullet.damage_max = ls.ranged_damage_max[hl]
	b.bullet.damage_min = ls.ranged_damage_min[hl]

	local s

	s = this.hero.skills.cluster_bomb

	local sl = s.level

	if initial and sl > 0 then
		log.info("LEVELUP - %s - %i - CLUSTER BOMB - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local b = E:get_template(a.bullet)
		local controller = E:get_template(b.bullet.hit_payload)
		local b_part = E:get_template(controller.part_template)

		b_part.bullet.damage_min = s.explosion_damage_min[sl]
		b_part.bullet.damage_max = s.explosion_damage_max[sl]

		local aura = E:get_template(b_part.bullet.hit_payload)

		aura.aura.duration = s.fire_duration[sl]

		local mod = E:get_template(aura.aura.mod)

		mod.dps.damage_min = s.burn_damage_min[sl]
		mod.dps.damage_max = s.burn_damage_max[sl]
	end

	s = this.hero.skills.shout_stun
	sl = s.level

	if initial and sl > 0 then
		log.info("LEVELUP - %s - %i - SHOUT_STUN - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local m1 = E:get_template(a.mods[1])

		m1.modifier.duration = s.stun_duration[sl]

		local m2 = E:get_template(a.mods[2])

		m2.modifier.duration = m1.modifier.duration + s.slow_duration[sl]
	end

	s = this.hero.skills.gattling
	sl = s.level

	if initial and sl > 0 then
		log.info("LEVELUP - %s - %i - GATTLING - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.duration = s.duration[sl]
		a.damage_min = s.damage_min[sl]
		a.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.eat_instakill
	sl = s.level

	if initial and sl > 0 then
		log.info("LEVELUP - %s - %i - EAT INSTAKILL - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.hp_max = s.hp_max[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local child = E:get_template(uc.child)

		child.melee.attacks[1].damage_min = s.damage_min[sl]
		child.melee.attacks[1].damage_max = s.damage_max[sl]
		child.duration = s.duration[sl]
	end

	this.health.hp = this.health.hp_max
end

function scripts.hero_bird.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_bird.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill
	local shadow_sprite = this.render.sprites[2]
	local basic_attack = this.ranged.attacks[1]
	local cluster_bomb_attack = this.timed_attacks.list[1]
	local shout_stun_attack = this.timed_attacks.list[2]
	local gattling_attack = this.timed_attacks.list[3]
	local eat_instakill_attack = this.timed_attacks.list[4]

	for i = 1, #this.timed_attacks.list do
		if not this.timed_attacks.list[i].disabled then
			this.timed_attacks.list[i].ts = store.tick_ts - this.timed_attacks.list[i].cooldown
		end
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts
	this.health_bar.hidden = false

	U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
	U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
			U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				local r = this.nav_rally
				local start_pos = V.vclone(this.pos)
	
				SU.y_hero_new_rally(store, this)
			end
	
			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)
	
			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "levelup", nil, store.tick_ts, 1)
			end
	
			for _, a in pairs(this.timed_attacks.list) do
				if a.disabled then
					-- block empty
				elseif a.sync_animation and not this.render.sprites[1].sync_flag then
					-- block empty
				elseif store.tick_ts - a.ts < a.cooldown then
					-- block empty
				elseif a == cluster_bomb_attack then
					local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)
	
					if not targets or #targets < a.min_targets or not pred_pos then
						-- block empty
					else
						local start_ts = store.tick_ts
						local b
						local bullet_start_offset = v(0, 0)
						local an, af, ai = U.animation_name_facing_point(this, a.animation, pred_pos)
	
						U.animation_start(this, an, af, store.tick_ts)
						S:queue(a.start_sound, a.start_sound_args)
	
						if SU.y_hero_wait(store, this, a.shoot_time) then
							-- block empty
						else
							b = E:create_entity(a.bullet)
							b.bullet.target_id = target.id
							b.bullet.source_id = this.id
							b.bullet.xp_dest_id = this.id
							b.pos = V.vclone(this.pos)
	
							if a.bullet_start_offset and #a.bullet_start_offset == 2 then
								local offset_index = af and 2 or 1
	
								bullet_start_offset = a.bullet_start_offset[offset_index]
							end
	
							b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
							b.pos.y = b.pos.y + bullet_start_offset.y
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.v(pred_pos.x, pred_pos.y + a.first_explosion_height)
	
							if b.bullet.use_unit_damage_factor then
								b.bullet.damage_factor = this.unit.damage_factor
							end
	
							queue_insert(store, b)
	
							a.ts = start_ts
	
							if SU.y_hero_wait(store, this, a.explosion_time) then
								-- block empty
							else
								do
									local ray = E:create_entity(a.ray)
	
									ray.pos = V.vclone(this.pos)
	
									local offset = a.ray_start_offset[1]
	
									if this.render.sprites[1].flip_x then
										offset = a.ray_start_offset[2]
									end
	
									ray.pos.x = ray.pos.x + offset.x
									ray.pos.y = ray.pos.y + offset.y
									ray.render.sprites[1].ts = store.tick_ts
	
									local b_pos_x, b_pos_y = SU.position_in_parabola(store.tick_ts - b.bullet.ts + fts(8.5), b.bullet.from, b.bullet.speed, b.bullet.g)
	
									ray.render.sprites[1].r = V.angleTo(b_pos_x - this.pos.x, b_pos_y - this.pos.y)
									ray.render.sprites[1].scale.x = V.dist(b_pos_x, b_pos_y, this.pos.x, this.pos.y) / a.ray_width
	
									queue_insert(store, ray)
								end
	
								if a.xp_from_skill then
									SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
								end
	
								if SU.y_hero_animation_wait(this) then
									-- block empty
								else
									U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
								end
							end
						end
	
						break
					end
				elseif a == shout_stun_attack then
					local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.radius, a.node_prediction, a.vis_flags, a.vis_bans)
	
					if not targets or #targets < a.min_targets or not pred_pos then
						-- block empty
					else
						local start_ts = store.tick_ts
						local an, af, ai = U.animation_name_facing_point(this, a.animation, pred_pos)
	
						U.animation_start(this, an, af, store.tick_ts)
						S:queue(a.sound)
	
						if SU.y_hero_wait(store, this, a.shoot_time) then
							-- block empty
						else
							local targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.radius, a.vis_flags, a.vis_bans)
	
							if targets and #targets > 0 then
								for _, t in pairs(targets) do
									local mods = a.mods or {
										a.mod
									}
	
									for _, m in pairs(mods) do
										local mod = E:create_entity(m)
	
										mod.modifier.target_id = t.id
										mod.modifier.source_id = this.id
	
										queue_insert(store, mod)
									end
								end
							end
	
							local decal = E:create_entity(a.decal)
	
							decal.pos = V.vclone(this.pos)
							decal.render.sprites[1].ts = store.tick_ts
	
							queue_insert(store, decal)
	
							a.ts = start_ts
	
							if a.xp_from_skill then
								SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
							end
	
							if SU.y_hero_animation_wait(this) then
								-- block empty
							else
								U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
							end
						end
					end
				elseif a == gattling_attack then
					local target, _, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)
	
					if not target or not pred_pos then
						-- block empty
					else
						local start_ts = store.tick_ts
						local an, af, ai = U.animation_name_facing_point(this, a.animation_in, pred_pos)
	
						U.animation_start(this, an, af, store.tick_ts, false)
	
						if SU.y_hero_animation_wait(this) then
							-- block empty
						else
							if not target or target.health.dead then
								target, _, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)
	
								if not target or target.health.dead then
									goto label_424_1
								end
							end
	
							local shoot_start_ts = store.tick_ts
	
							S:queue(a.sound)
	
							local an, af, ai = U.animation_name_facing_point(this, a.animation_loop, target.pos)
	
							U.animation_start(this, an, af, store.tick_ts, true)
	
							local function do_gattling_damage(target)
								local d = E:create_entity("damage")
	
								d.damage_type = a.damage_type
								d.value = math.random(a.damage_min, a.damage_max)
								d.source_id = this.id
								d.target_id = target.id
	
								queue_damage(store, d)
	
								local fx = E:create_entity(a.hit_fx)
	
								fx.pos = V.vclone(target.pos)
	
								if target.unit and target.unit.hit_offset then
									fx.pos.x = fx.pos.x + target.unit.hit_offset.x
									fx.pos.y = fx.pos.y + target.unit.hit_offset.y
								end
	
								fx.render.sprites[1].ts = store.tick_ts
	
								queue_insert(store, fx)
							end
	
							local shoot_count = 0
	
							while store.tick_ts - shoot_start_ts < a.duration and target and not target.health.dead do
								if band(target.vis.flags, F_FLYING) ~= 0 then
									do_gattling_damage(target)
								else
									local ni = target.nav_path.ni + P:predict_enemy_node_advance(target, fts(10))
									local f_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, ni)
									local rand_var = 15
									local b_pos = V.vclone(f_pos)
	
									b_pos.x = b_pos.x + math.random(-rand_var, rand_var)
									b_pos.y = b_pos.y + math.random(-rand_var, rand_var)
	
									local decal = E:create_entity(a.decal)
	
									decal.pos = V.vclone(b_pos)
									decal.render.sprites[1].ts = store.tick_ts
	
									queue_insert(store, decal)
	
									local targets = U.find_enemies_in_range(store.entities, target.pos, 0, rand_var * 1.5, a.vis_flags, bor(F_FLYING))
	
									if not targets or #targets == 0 then
										goto label_424_0
									end
	
									for _, t in pairs(targets) do
										do_gattling_damage(t)
									end
								end
	
								this.render.sprites[1].flip_x = target.pos.x < this.pos.x
	
								::label_424_0::
	
								if SU.y_hero_wait(store, this, a.shoot_every) then
									goto label_424_1
								end
							end
	
							a.ts = start_ts
	
							S:stop(a.sound)
							S:queue(a.sound_end)
	
							local an, af, ai = U.animation_name_facing_point(this, a.animation_out, target.pos)
	
							U.animation_start(this, an, af, store.tick_ts, false)
	
							if a.xp_from_skill then
								SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
							end
	
							if SU.y_hero_animation_wait(this) then
								-- block empty
							else
								U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
							end
						end
					end
				elseif a == eat_instakill_attack then
					local target, _, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans, function(e, o)
						return e.health.hp < a.hp_max
					end)
	
					if not target or not pred_pos then
						-- block empty
					else
						local start_ts = store.tick_ts
						local an, af, ai = U.animation_name_facing_point(this, a.animation, pred_pos)
	
						U.animation_start(this, an, af, store.tick_ts)
	
						if af then
							pred_pos.x = pred_pos.x + a.eat_offset_x
						else
							pred_pos.x = pred_pos.x - a.eat_offset_x
						end
	
						local prep_time = fts(12)
	
						S:queue(a.sound)
	
						if SU.y_hero_wait(store, this, prep_time) then
							-- block empty
						else
							local fly_time = a.shoot_time - prep_time
							local fly_start_ts = store.tick_ts
							local step_x, step_y = V.sub(pred_pos.x, pred_pos.y, this.pos.x, this.pos.y)
							local step_mag = 1 / (fly_time * FPS * 2)
	
							step_x, step_y = step_x * step_mag, step_y * step_mag
	
							while fly_time > store.tick_ts - fly_start_ts do
								this.pos.x = this.pos.x + step_x
								this.pos.y = this.pos.y + step_y
	
								coroutine.yield()
							end
	
							local d = E:create_entity("damage")
	
							d.damage_type = DAMAGE_INSTAKILL
							d.value = 10
							d.source_id = this.id
							d.target_id = target.id
	
							queue_damage(store, d)
	
							a.ts = start_ts
	
							if a.xp_from_skill then
								SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
							end
	
							if SU.y_hero_animation_wait(this) then
								-- block empty
							else
								U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
							end
						end
					end
				end
	
				::label_424_1::
			end
	
			y_hero_ranged_attacks(store, this)
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		coroutine.yield()
	end
end

scripts.decal_hero_bird_tomb = {}

function scripts.decal_hero_bird_tomb.update(this, store)
	U.y_animation_play(this, "death", nil, store.tick_ts, 1)

	while true do
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.controller_bullet_hero_bird_cluster_bomb_part = {}

function scripts.controller_bullet_hero_bird_cluster_bomb_part.update(this, store)
	local floor_pos = V.vclone(this.pos)

	floor_pos.y = floor_pos.y - this.explosion_height

	local nodes = {}
	local floor_node = P:nearest_nodes(floor_pos.x, floor_pos.y)[1]
	local path_pi, path_spi, path_ni = unpack(floor_node)

	table.insert(nodes, 1, P:node_pos(path_pi, 1, path_ni + 3))
	table.insert(nodes, 2, P:node_pos(path_pi, 2, path_ni))
	table.insert(nodes, 3, P:node_pos(path_pi, 3, path_ni - 3))

	for _, n in ipairs(nodes) do
		local part = E:create_entity(this.part_template)

		part.pos = V.vclone(this.pos)
		part.bullet.from = V.vclone(part.pos)
		part.bullet.to = V.vclone(n)
		part.bullet.source_id = this.source_id
		part.bullet.xp_dest_id = this.source_id

		queue_insert(store, part)
	end

	queue_remove(store, this)
end

scripts.aura_hero_bird_cluster_bomb_fire = {}

function scripts.aura_hero_bird_cluster_bomb_fire.remove(this, store)
	if this.tween.remove then
		return true
	end

	this.tween.ts = store.tick_ts
	this.tween.reverse = true
	this.tween.remove = true
	this.tween.props[1].keys[2][1] = fts(10)
	this.tween.props[2].keys[2][1] = fts(10)

	return false
end

scripts.hero_bird_ultimate = {}

function scripts.hero_bird_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_bird_ultimate.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true, NF_POWER_3)

	if #nodes < 1 then
		log.error("hero_bird_ultimate: could not find valid node")
		queue_remove(store, this)

		return
	end

	local node = {
		spi = 1,
		pi = nodes[1][1],
		ni = nodes[1][3]
	}
	local node_pos = P:node_pos(node)
	local child1 = E:create_entity(this.child)

	child1.pos = V.vclone(node_pos)
	child1.pos.x = child1.pos.x - 50
	child1.render.sprites[1].flip_x = false
	child1.child_id = 1

	queue_insert(store, child1)

	local child2 = E:create_entity(this.child)

	child2.pos = V.vclone(node_pos)
	child2.pos.x = child2.pos.x + 50
	child2.render.sprites[1].flip_x = true
	child2.child_id = 2

	queue_insert(store, child2)
	S:queue(this.sound_cast)
	queue_remove(store, this)
end

scripts.hero_bird_ultimate_child = {}

function scripts.hero_bird_ultimate_child.update(this, store)
	local sd = this.render.sprites[1]
	local ss = this.render.sprites[2]
	local a = this.melee.attacks[1]
	local fm = this.force_motion
	local attack_ts, search_ts = 0, 0
	local target, targets, dist
	local dest = V.v(this.pos.x, this.pos.y)

	this.start_ts = store.tick_ts

	local orbit_phase = 0

	fm.a_step = fm.a_step + math.random(-3, 3)
	this.tween.ts = U.frandom(0, 1)

	local oos = {
		V.v(-20, 0),
		V.v(20, 7)
	}
	local oo = oos[this.child_id]

	if this.child_id == 1 then
		this.tween.ts = store.tick_ts
	else
		this.tween.ts = store.tick_ts - 1
	end

	local start_pos = V.vclone(this.pos)

	U.animation_start(this, "in", nil, store.tick_ts, false, this.sid_bird)
	U.y_ease_keys(store, {
		ss
	}, {
		"alpha"
	}, {
		0
	}, {
		255
	}, fts(17))
	U.animation_start(this, "idle", nil, store.tick_ts, true, this.sid_bird)

	while true do
		if this.duration and store.tick_ts - this.start_ts > this.duration then
			break
		end

		::label_432_0::

		target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, this.target_range, 0, a.vis_flags, a.vis_bans, function(e, origin)
			return V.dist2(e.pos.x, e.pos.y, start_pos.x, start_pos.y) < this.chase_range * this.chase_range
		end)

		if target and store.tick_ts - this.start_ts > 0.7 then
			::label_432_1::

			repeat
				dest.x, dest.y = target.pos.x + oo.x + target.unit.hit_offset.x, target.pos.y + oo.y
				sd.flip_x = dest.x < this.pos.x

				U.force_motion_step(this, store.tick_length, dest)
				coroutine.yield()

				dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)

				if this.duration and store.tick_ts - this.start_ts > this.duration then
					goto label_432_2
				end
			until dist < a.range or target.health.dead or band(a.vis_flags, target.vis.bans) ~= 0

			if not target or target.health.dead then
				goto label_432_0
			end

			if store.entities[target.id] and not target.health.dead and band(a.vis_flags, target.vis.bans) == 0 then
				local an, af = U.animation_name_facing_point(this, a.animation, target.pos, 1)

				U.y_animation_play(this, an, af, store.tick_ts, 1, this.sid_bird)
				U.animation_start(this, "projectile", af, store.tick_ts, true, this.sid_bird)

				local fly_attack_time = 0.15
				local dest_fh = target.unit.hit_offset.y + 20
				local old_keys1 = this.tween.props[1].keys
				local old_keys2 = this.tween.props[2].keys

				this.tween.props[1].keys = {
					{
						0,
						v(0, this.flight_height)
					},
					{
						fly_attack_time,
						v(0, dest_fh)
					}
				}
				this.tween.props[1].loop = false
				this.tween.props[2].keys = {
					{
						0,
						v(0.75, 0.75)
					},
					{
						fly_attack_time,
						v(1, 1)
					}
				}
				this.tween.props[2].loop = false
				this.tween.ts = store.tick_ts

				local start_pos = V.vclone(this.pos)
				local ni = target.nav_path.ni + P:predict_enemy_node_advance(target, fly_attack_time)
				local dest_atk = P:node_pos(target.nav_path.pi, target.nav_path.spi, ni)

				U.y_ease_keys(store, {
					this.pos,
					this.pos
				}, {
					"x",
					"y"
				}, {
					start_pos.x,
					start_pos.y
				}, {
					dest_atk.x,
					dest_atk.y
				}, fly_attack_time)

				if target.health.dead or band(a.vis_flags, target.vis.bans) ~= 0 then
					-- block empty
				else
					if math.random() < a.sound_chance then
						S:queue(a.sound)
					end

					do
						local d = SU.create_attack_damage(a, target.id, this.id)

						queue_damage(store, d)

						local fx = E:create_entity(a.hit_fx)

						fx.pos.x, fx.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
						fx.render.sprites[1].ts = store.tick_ts
						fx.render.sprites[1].runs = 0

						queue_insert(store, fx)
					end

					fly_attack_time = fts(8)

					U.animation_start(this, "attack_out", nil, store.tick_ts, true, this.sid_bird)
				end

				local start_offset_y = this.render.sprites[1].offset.y

				this.tween.props[1].keys = {
					{
						0,
						v(0, start_offset_y)
					},
					{
						fly_attack_time,
						v(0, this.flight_height)
					}
				}
				this.tween.props[2].keys = {
					{
						0,
						v(1, 1)
					},
					{
						fly_attack_time,
						v(0.75, 0.75)
					}
				}
				this.tween.ts = store.tick_ts
				dest_atk.x = dest_atk.x - (start_pos.x - dest_atk.x)
				start_pos.x = this.pos.x
				dest_atk.y = dest_atk.y - (start_pos.y - dest_atk.y)
				start_pos.y = this.pos.y

				U.y_ease_keys(store, {
					this.pos,
					this.pos
				}, {
					"x",
					"y"
				}, {
					start_pos.x,
					start_pos.y
				}, {
					dest_atk.x,
					dest_atk.y
				}, fly_attack_time)

				this.tween.props[1].keys = old_keys1
				this.tween.props[1].loop = true
				this.tween.props[2].keys = old_keys2
				this.tween.props[2].loop = true
				this.tween.ts = store.tick_ts

				U.animation_start(this, "idle", nil, store.tick_ts, true, this.sid_bird)

				if this.duration and store.tick_ts - this.start_ts > this.duration then
					break
				end

				U.y_wait(store, a.cooldown)

				local dx, dy = V.sub(target.pos.x, target.pos.y, start_pos.x, start_pos.y)
				local dist2 = V.len2(dx, dy)

				attack_ts = store.tick_ts

				if this.duration and store.tick_ts - this.start_ts > this.duration then
					break
				end

				if not target.health.dead and dist2 < this.chase_range * this.chase_range then
					goto label_432_1
				end
			end
		end

		if V.dist2(this.pos.x, this.pos.y, start_pos.x, start_pos.y) > 25 then
			local dest = start_pos

			this.render.sprites[1].flip_x = dest.x < this.pos.x

			U.force_motion_step(this, store.tick_length, dest)
		end

		coroutine.yield()
	end

	::label_432_2::

	U.y_ease_keys(store, {
		sd,
		sd.offset,
		ss
	}, {
		"alpha",
		"y",
		"alpha"
	}, {
		255,
		this.flight_height,
		255
	}, {
		0,
		85,
		0
	}, 0.4)
	queue_remove(store, this)
end

scripts.hero_witch = {}

function scripts.hero_witch.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	for i = 1, #this.ranged.attacks[1].bullets do
		local bt = E:get_template(this.ranged.attacks[1].bullets[i])

		bt.bullet.damage_min = ls.ranged_damage_min[hl]
		bt.bullet.damage_max = ls.ranged_damage_max[hl]
	end

	local s, sl

	s = this.hero.skills.soldiers
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - SOLDIERS - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.soldiers_amount = s.soldiers_amount[sl]

		local e = E:get_template(a.entity)

		e.health.hp_max = s.hp_max[sl]
		e.melee.attacks[1].damage_max = s.damage_max[sl]
		e.melee.attacks[1].damage_min = s.damage_min[sl]
	end

	s = this.hero.skills.polymorph
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - POLYMORPH - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.cooldown = s.cooldown[sl]
		a.hp_max = s.hp_max[sl]

		local b = E:get_template(a.bullet)
		local m = E:get_template(b.bullet.mod)

		m.modifier.duration = s.duration[sl]
		a.disabled = nil
	end

	s = this.hero.skills.disengage
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - DISENGAGE - %i", this.template_name, hl, sl)

		local d = this.dodge

		d.disabled = nil
		d.cooldown = s.cooldown[sl]

		local e = E:get_template(this.dodge.decoy)

		e.health.hp_max = s.hp_max[sl]
		e.melee.attacks[1].damage_max = s.melee_damage_max[sl]
		e.melee.attacks[1].damage_min = s.melee_damage_min[sl]

		local a = E:get_template(e.death_spawns.name)
		local m = E:get_template(a.aura.mod)

		m.modifier.duration = s.stun_duration[sl]
	end

	s = this.hero.skills.path_aoe
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - PATH AOE - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]

		local aur = E:get_template(a.new_entity)

		aur.aura.duration = s.duration[sl]
		aur.damage_min = s.damage_min[sl]
		aur.damage_max = s.damage_max[sl]
		aur.tween.props[1].keys = {
			{
				0,
				0
			},
			{
				aur.start_wait_time,
				0
			},
			{
				aur.start_wait_time + fts(10),
				255
			},
			{
				aur.aura.duration - 0.5,
				255
			},
			{
				aur.aura.duration,
				0
			}
		}
		aur.tween.props[2].keys = {
			{
				0,
				0
			},
			{
				aur.start_wait_time + fts(4),
				0
			},
			{
				aur.start_wait_time + fts(5),
				200
			},
			{
				aur.start_wait_time + fts(9),
				255
			},
			{
				aur.aura.duration - 0.7,
				255
			},
			{
				aur.aura.duration,
				0
			}
		}
		aur.tween.props[3].keys = {
			{
				0,
				v(0, 0)
			},
			{
				aur.start_wait_time + fts(4),
				v(0, 0)
			},
			{
				aur.start_wait_time + fts(5),
				v(0.9, 0.9)
			},
			{
				aur.start_wait_time + fts(9),
				v(1.1, 1.1)
			},
			{
				aur.start_wait_time + fts(11),
				v(1, 1)
			}
		}
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]
		uc.max_targets = s.max_targets[sl]

		local mtel = E:get_template(uc.mod_teleport)
		local mend = E:get_template(mtel.end_mod)

		mend.modifier.duration = s.duration[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_witch.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.hero_witch.can_dodge(store, this, ranged_attack, attack, enemy)
	local skill = this.hero.skills.disengage

	if enemy and enemy.health and not enemy.health.dead and not this.dodge.disabled and this.health.hp / this.health.hp_max < this.dodge.hp_to_trigger then
		local enp = enemy.nav_path
		local new_ni = enp.ni
		local node_limit = math.floor(skill.min_distance_from_end / P.average_node_dist)
		local node_jump = math.floor(skill.distance / P.average_node_dist)
		local nodes_to_goal = P:nodes_to_goal(enp)

		if node_limit < nodes_to_goal then
			new_ni = new_ni + math.min(nodes_to_goal - 1, node_jump)

			local new_pos = P:node_pos(enp.pi, enp.spi, new_ni)

			this.dodge.new_pos = new_pos

			return true
		end
	end

	return false
end

function scripts.hero_witch.update(this, store)
	local last_ts = store.tick_ts
	local h = this.health
	local a, skill, brk, stam, star
	local ultimate = this.hero.skills.ultimate
	local basic_attack = this.melee.attacks[1]
	local basic_ranged = this.ranged.attacks[1]
	local skill_soldiers_attack = this.timed_attacks.list[1]
	local skill_polymorph = this.timed_attacks.list[2]
	local skill_path_aoe_attack = this.timed_attacks.list[3]
	local p_sys

	this.health_bar.hidden = false
	p_sys = E:create_entity(this.particles_name_1)
	p_sys.particle_system.emit = false
	p_sys.particle_system.track_id = this.id

	queue_insert(store, p_sys)

	if not skill_soldiers_attack.disabled then
		skill_soldiers_attack.ts = store.tick_ts - skill_soldiers_attack.cooldown
	end

	if not skill_polymorph.disabled then
		skill_polymorph.ts = store.tick_ts - skill_polymorph.cooldown
	end

	if not skill_path_aoe_attack.disabled then
		skill_path_aoe_attack.ts = store.tick_ts - skill_path_aoe_attack.cooldown
	end

	local function custom_new_rally()
		local r = this.nav_rally

		if r.new then
			p_sys.particle_system.emit = true
			r.new = false

			U.unblock_target(store, this)

			if this.sound_events then
				S:queue(this.sound_events.change_rally_point)
			end

			local vis_bans = this.vis.bans
			local prev_immune = this.health.immune_to

			this.vis.bans = F_ALL
			this.health.immune_to = r.immune_to

			local out = SU.y_hero_walk_waypoints(store, this)

			U.animation_start(this, "idle", nil, store.tick_ts, true)

			p_sys.particle_system.emit = false
			this.vis.bans = vis_bans
			this.health.immune_to = prev_immune

			return out
		end
	end

	local function create_soldier(e_template, s_offset)
		local e = E:create_entity(e_template)

		e.pos.x = this.pos.x + s_offset.x
		e.pos.y = this.pos.y + s_offset.y
		e.nav_rally.center = V.v(this.pos.x, this.pos.y)
		e.nav_rally.pos = V.vclone(e.pos)

		queue_insert(store, e)
	end

	while true do
		if h.dead then
			p_sys.particle_system.emit = false

			SU.y_hero_death_and_respawn_kr5(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if custom_new_rally(store, this) then
					goto label_437_0
				end
			end

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "level_up", nil, store.tick_ts, 1)
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			skill = this.hero.skills.soldiers
			a = skill_soldiers_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a
				.vis_bans)

				if not enemies or #enemies < a.min_targets then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts

					S:queue(a.sound)

					local an, af, _ = U.animation_name_facing_point(this, a.animation, enemies[1].pos)

					U.animation_start(this, an, af, store.tick_ts, false)

					if SU.y_hero_wait(store, this, a.cast_time) then
						-- block empty
					else
						a.ts = start_ts
						last_ts = start_ts

						SU.hero_gain_xp_from_skill(this, skill)

						enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
							a.vis_bans)

						for i = 1, a.soldiers_amount do
							create_soldier(a.entity, a.soldiers_offset[i])
						end

						SU.y_hero_animation_wait(this)
					end

					goto label_437_0
				end
			end

			a = this.timed_attacks.list[3]
			skill = this.hero.skills.path_aoe

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range,
					a.node_prediction, a.vis_flags, a.vis_bans)

				if not targets or #targets < a.min_targets or not pred_pos then
					SU.delay_attack(store, a, fts(10))
				else
					local nearest = P:nearest_nodes(pred_pos.x, pred_pos.y)

					if #nearest > 0 then
						local path_pi, path_spi, path_ni = unpack(nearest[1])

						path_spi = 1
						pred_pos = P:node_pos(path_pi, path_spi, path_ni)
					end

					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, a.animation, pred_pos)

					U.animation_start(this, an, af, store.tick_ts, 1, nil)
					S:queue(a.sound)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_437_0
					end

					local ne = E:create_entity(a.new_entity)

					ne.source_id = this.id
					ne.pos.x, ne.pos.y = pred_pos.x, pred_pos.y

					queue_insert(store, ne)
					SU.y_hero_animation_wait(this)

					a.ts = start_ts
					last_ts = a.ts

					SU.hero_gain_xp_from_skill(this, skill)
				end
			end

			if not this.dodge.disabled and this.dodge.active and this.vis.bans ~= F_ALL then
				local enemy = store.entities[this.soldier.target_id]

				if not enemy then
					-- block empty
				else
					local enemy_pos = enemy.pos
					local enemy_id = enemy.id

					this.dodge.active = false
					this.dodge.ts = store.tick_ts

					local new_pos = this.dodge.new_pos

					S:queue(this.dodge.sound)
					U.unblock_target(store, this)

					local bans = this.vis.bans

					this.vis.bans = F_ALL

					SU.hide_modifiers(store, this, true)
					SU.hide_auras(store, this, true)
					U.animation_start(this, this.dodge.animation_dissapear, nil, store.tick_ts, false)
					U.y_wait(store, fts(6))
					create_soldier(this.dodge.decoy, V.v(0, 0))
					U.y_animation_wait(this)
					U.y_wait(store, fts(3))

					this.pos.x, this.pos.y = new_pos.x, new_pos.y
					this.nav_rally.center = V.vclone(this.pos)
					this.nav_rally.pos = V.vclone(this.pos)

					SU.hero_gain_xp_from_skill(this, this.hero.skills.disengage)
					U.y_animation_play(this, this.dodge.animation_appear, nil, store.tick_ts)

					this.vis.bans = bans
					this.vis._bans = nil

					SU.show_modifiers(store, this, true)
					SU.show_auras(store, this, true)
					U.animation_start(this, "idle", nil, store.tick_ts, true)
				end
			end

			brk, stam = y_hero_melee_block_and_attacks(store, this)

			if brk or stam ~= A_NO_TARGET then
				-- block empty
			else
				if store.tick_ts - basic_ranged.ts >= basic_ranged.cooldown then
					local enemy, enemies, enemy_pos = U.find_foremost_enemy(store.entities, this.pos,
						basic_ranged.min_range, basic_ranged.max_range, basic_ranged.node_prediction,
						basic_ranged.vis_flags, basic_ranged.vis_bans)

					if not enemy then
						SU.delay_attack(store, basic_ranged, fts(10))
					elseif enemy then
						local start_ts = store.tick_ts
						local enemy_id = enemy.id

						S:queue(basic_ranged.sound)

						local an, af, _ = U.animation_name_facing_point(this, basic_ranged.animation, enemy_pos)

						U.animation_start(this, an, af, store.tick_ts, false)

						if SU.y_hero_wait(store, this, basic_ranged.shoot_time) then
							-- block empty
						else
							for i = 1, #basic_ranged.bullets do
								local bullet = E:create_entity(basic_ranged.bullets[i])

								bullet.bullet.damage_factor = this.unit.damage_factor
								bullet.bullet.source_id = this.id
								bullet.bullet.to = enemy_pos
								bullet.bullet.target_id = store.entities[enemy_id] and enemy_id or nil

								local start_offset = basic_ranged.bullet_start_offset[af and 2 or 1][i]

								bullet.bullet.from = V.v(this.pos.x + start_offset.x, this.pos.y + start_offset.y)
								bullet.bullet.xp_dest_id = this.id
								bullet.bullet.xp_gain_factor = basic_ranged.xp_gain_factor
								bullet.pos = V.vclone(bullet.bullet.from)

								queue_insert(store, bullet)
							end

							basic_ranged.ts = start_ts

							if SU.y_hero_animation_wait(this) then
								-- block empty
							end
						end
					end
				end

				a = this.timed_attacks.list[2]

				if not a.disabled and store.tick_ts - a.ts >= a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
					local enemy, enemies = U.find_foremost_enemy(store.entities, this.pos, 0, a.range, false, a
					.vis_flags, a.vis_bans, function(e)
						return e.health and e.health.hp_max <= a.hp_max and
						P:nodes_to_goal(e.nav_path) >= a.max_nodes_to_goal
					end)

					if not enemy then
						SU.delay_attack(store, a, fts(10))
					else
						local start_ts = store.tick_ts
						local enemy_pos = V.vclone(enemy.pos)
						local enemy_id = enemy.id
						local an, af, _ = U.animation_name_facing_point(this, a.animation, enemy_pos)

						U.animation_start(this, an, af, store.tick_ts, false)

						if SU.y_hero_wait(store, this, a.shoot_time) then
							-- block empty
						else
							local bullet = E:create_entity(a.bullet)

							bullet.bullet.damage_factor = this.unit.damage_factor
							bullet.bullet.source_id = this.id
							bullet.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x,
								enemy.pos.y + enemy.unit.hit_offset.y)
							bullet.bullet.target_id = store.entities[enemy_id] and enemy_id or nil

							local start_offset = a.bullet_start_offset[af and 1 or 2]

							bullet.bullet.from = V.v(this.pos.x + start_offset.x, this.pos.y + start_offset.y)
							bullet.bullet.xp_dest_id = this.id
							bullet.bullet.xp_gain_factor = basic_ranged.xp_gain_factor
							bullet.bullet.level = this.hero.skills.polymorph.level
							bullet.pos = V.vclone(bullet.bullet.from)
							bullet.pred_pos = enemy_pos
							bullet.source_id = this.id

							queue_insert(store, bullet)

							a.ts = start_ts
							last_ts = start_ts

							SU.hero_gain_xp_from_skill(this, this.hero.skills.polymorph)
							SU.y_hero_animation_wait(this)
						end
					end
				end

				if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
					-- block empty
				elseif SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_437_0::

		coroutine.yield()
	end
end

scripts.hero_witch_ultimate = {}

function scripts.hero_witch_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_witch_ultimate.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	}, true)

	if #nodes < 1 then
		return false
	end

	local pi, spi, ni = unpack(nodes[1])
	local npos = P:node_pos(pi, spi, ni)

	S:queue(this.sound_cast)

	local d = E:create_entity(this.teleport_decal)

	d.pos = V.vclone(npos)
	d.render.sprites[1].ts = store.tick_ts

	queue_insert(store, d)
	U.y_wait(store, fts(5))

	local target, targets = U.find_nearest_enemy(store.entities, npos, 0, this.radius, this.vis_flags, this.vis_bans)

	if not target or not targets or #targets < 1 then
		return true
	end

	local num_targets = math.min(#targets, this.max_targets)

	for i = 1, num_targets do
		local t = targets[i]
		local mod_mark = E:create_entity(this.mod_mark)

		mod_mark.modifier.target_id = t.id
		mod_mark.modifier.source_id = this.id

		queue_insert(store, mod_mark)
		S:queue(this.sound_teleport_in)

		local mod_teleport = E:create_entity(this.mod_teleport)

		mod_teleport.modifier.target_id = t.id
		mod_teleport.modifier.source_id = this.id

		queue_insert(store, mod_teleport)
		S:queue(this.sound_teleport_out, {
			delay = mod_teleport.hold_time
		})
	end

	queue_remove(store, this)
end

scripts.mod_hero_witch_ultimate_teleport = {}

function scripts.mod_hero_witch_ultimate_teleport.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		target.health.ignore_damage = false

		SU.stun_dec(target)

		local mod_sleep = E:create_entity(this.end_mod)

		mod_sleep.modifier.target_id = target.id
		mod_sleep.modifier.source_id = this.source_id

		queue_insert(store, mod_sleep)
	end

	return true
end

scripts.bullet_hero_witch_basic = {}

function scripts.bullet_hero_witch_basic.insert(this, store, script)
	local b = this.bullet

	if this.impulse_per_distance then
		local dx, dy = V.sub(b.to.x, b.to.y, b.from.x, b.from.y)
		local dist = V.len(dx, dy)

		this.initial_impulse = this.impulse_per_distance * dist
	end

	if b.target_id then
		local target = store.entities[b.target_id]

		if not target or band(target.vis.bans, F_RANGED) ~= 0 then
			return false
		end
	end

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	local s = this.render.sprites[1]

	if not b.ignore_rotation then
		s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
	end

	U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

	return true
end

function scripts.bullet_hero_witch_basic.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local pred_pos

	if target then
		pred_pos = P:predict_enemy_pos(target, fts(5))
	else
		pred_pos = b.to
	end

	local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			local d = math.max(math.abs(target.pos.x + hit_offset.x - b.to.x),
				math.abs(target.pos.y + hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id,
					this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.level = b.level

				queue_insert(store, m)
			end
		end
	elseif b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	this.render.sprites[1].hidden = true

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.aura_hero_witch_path_aoe = {}

function scripts.aura_hero_witch_path_aoe.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts
	this.tween.props[1].ts = store.tick_ts
	this.tween.props[2].ts = store.tick_ts
	this.tween.props[3].ts = store.tick_ts

	local start_fx = E:create_entity(this.start_fx)

	start_fx.pos = V.vclone(this.pos)
	start_fx.render.sprites[1].ts = store.tick_ts
	start_fx.render.sprites[1].runs = 0
	start_fx.render.sprites[2].ts = store.tick_ts
	start_fx.render.sprites[2].runs = 0

	queue_insert(store, start_fx)
	U.y_wait(store, this.start_wait_time)
	S:queue(this.sound_impact)

	local targets = table.filter(store.entities, function(k, v)
		return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and
		band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and
		(not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and
		(not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and
		(not this.aura.filter_source or this.aura.source_id ~= v.id)
	end)

	for i, target in ipairs(targets) do
		local d = E:create_entity("damage")

		d.damage_type = this.damage_type
		d.value = math.random(this.damage_min, this.damage_max)
		d.source_id = this.id
		d.target_id = target.id

		queue_damage(store, d)
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_447_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_447_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_447_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_447_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and
				band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and
				(not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and
				(not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and
				(not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_447_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.bullet_witch_skill_polymorph = {}

function scripts.bullet_witch_skill_polymorph.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	::label_450_0::

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

		if ps then
			ps.particle_system.emit = true
		end
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		if target and target.health and not target.health.dead then
			if b.ignore_hit_offset then
				b.to.x, b.to.y = target.pos.x, target.pos.y
			else
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end

			new_target = false
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end
	end

	while b.store and not b.target_id do
		coroutine.yield()

		if b.target_id then
			mspeed = b.min_speed
			new_target = true

			goto label_450_0
		end
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)
		local u = UP:get_upgrade("mage_spell_of_penetration")

		if u and math.random() < u.chance then
			d.damage_type = DAMAGE_TRUE
		end

		queue_damage(store, d)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.source_id = this.source_id
				m.modifier.level = b.level

				queue_insert(store, m)
			end
		end

		if b.hit_payload then
			local hp = b.hit_payload

			hp.pos.x, hp.pos.y = this.pos.x, this.pos.y

			queue_insert(store, hp)
		end
	end

	if b.payload then
		local hp = b.payload

		hp.pos.x, hp.pos.y = b.to.x, b.to.y

		queue_insert(store, hp)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.mod_hero_witch_skill_polymorph = {}

function scripts.mod_hero_witch_skill_polymorph.insert(this, store)
	local target = store.entities[this.modifier.target_id]
	local hero = store.entities[this.modifier.source_id]

	if target then
		this.target_ref = target

		for _, s in ipairs(target.render.sprites) do
			s.hidden = true
		end

		hero.polymorph_enemy = {
			enemy = target
		}

		SU.remove_modifiers(store, target)
		SU.remove_auras(store, target)
		queue_remove(store, target)
		U.unblock_all(store, target)

		if target.ui then
			target.ui.can_click = false
		end

		target.main_script.co = nil
		target.main_script.runs = 0

		if target.count_group then
			target.count_group.in_limbo = true
		end

		target.trigger_deselect = true

		local is_flying = U.flag_has(target.vis.flags, F_FLYING)
		local pumpkin = E:create_entity(is_flying and this.entity_t_flying or this.entity_t)

		pumpkin.pos = target.pos
		pumpkin.nav_path = target.nav_path
		pumpkin.health.hp_max = target.health.hp_max * this.entity_hp[this.modifier.level]
		pumpkin.health.hp = target.health.hp * this.entity_hp[this.modifier.level]
		pumpkin.enemy.gold = target.enemy.gold

		queue_insert(store, pumpkin)

		hero.polymorph_enemy.pumpkin = pumpkin

		return true
	end

	return false
end

function scripts.mod_hero_witch_skill_polymorph.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = this.target_ref

	this.pos = target.pos

	while true do
		if m.duration >= 0 and store.tick_ts - m.ts > m.duration then
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

function scripts.mod_hero_witch_skill_polymorph.remove(this, store)
	local hero = store.entities[this.modifier.source_id]

	if hero and hero.polymorph_enemy and hero.polymorph_enemy.enemy then
		local target = hero.polymorph_enemy.enemy
		local pumpkin = hero.polymorph_enemy.pumpkin

		if pumpkin and store.entities[pumpkin.id] and not pumpkin.health.dead then
			for _, s in ipairs(target.render.sprites) do
				s.hidden = false
			end

			target.main_script.runs = 1

			if target.ui then
				target.ui.can_click = true
			end

			target.pos = V.vclone(pumpkin.pos)
			target.nav_path = pumpkin.nav_path
			target.health.hp = target.health.hp_max * pumpkin.health.hp / pumpkin.health.hp_max

			queue_insert(store, target)

			pumpkin.trigger_deselect = true

			S:queue(this.sound_transform_out)

			local sfx = E:create_entity(this.transform_fx)

			sfx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
			sfx.render.sprites[1].ts = store.tick_ts
			sfx.render.sprites[1].runs = 0

			if target and sfx.render.sprites[1].size_names then
				sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
			end

			queue_insert(store, sfx)
			queue_remove(store, pumpkin)
		end

		hero.polymorph_enemy = nil
	end

	return true
end

scripts.aura_hero_witch_decoy_explotion = {}

function scripts.aura_hero_witch_decoy_explotion.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_454_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_454_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_454_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_454_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and
				band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and
				(not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and
				(not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and
				(not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_454_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.soldier_hero_witch_decoy = {}

function scripts.soldier_hero_witch_decoy.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts

	if this.reinforcement.fade or this.reinforcement.fade_in then
		SU.y_reinforcement_fade_in(store, this)
	elseif this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.health_bar.hidden = true

		U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	local function y_custom_death(store, this)
		U.unblock_target(store, this)
		S:queue(this.sound_death)

		local can_spawn = this.death_spawns and
		band(this.health.last_damage_types,
			bor(DAMAGE_EAT, DAMAGE_NO_SPAWNS, this.death_spawns.no_spawn_damage_types or 0)) == 0

		if can_spawn and this.death_spawns.concurrent_with_death then
			SU.do_death_spawns(store, this)
			coroutine.yield()

			can_spawn = false
		end

		local h = this.health

		if band(h.last_damage_types, bor(DAMAGE_DISINTEGRATE, DAMAGE_DISINTEGRATE_BOSS)) ~= 0 then
			this.unit.hide_during_death = true

			local fx = E:create_entity("fx_soldier_desintegrate")

			fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		elseif band(h.last_damage_types, bor(DAMAGE_EAT)) ~= 0 then
			this.unit.hide_during_death = true
		elseif band(h.last_damage_types, bor(DAMAGE_HOST)) ~= 0 then
			S:queue(this.sound_events.death_by_explosion)

			this.unit.hide_during_death = true

			local fx = E:create_entity("fx_unit_explode")

			fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].name = fx.render.sprites[1].size_names[this.unit.size]

			queue_insert(store, fx)

			if this.unit.show_blood_pool and this.unit.blood_color ~= BLOOD_NONE then
				local decal = E:create_entity("decal_blood_pool")

				decal.pos = V.vclone(this.pos)
				decal.render.sprites[1].ts = store.tick_ts
				decal.render.sprites[1].name = this.unit.blood_color

				queue_insert(store, decal)
			end
		elseif this.reinforcement and (this.reinforcement.fade or this.reinforcement.fade_out) then
			SU.y_reinforcement_fade_out(store, this)

			return
		else
			S:queue(this.sound_events.death, this.sound_events.death_args)
			U.y_animation_play(this, "death", nil, store.tick_ts, 1)

			this.ui.can_select = false
		end

		this.health.death_finished_ts = store.tick_ts

		if this.ui then
			if IS_TRILOGY then
				this.ui.can_click = not this.unit.hide_after_death
			else
				this.ui.can_click = this.ui.can_click and not this.unit.hide_after_death
			end

			this.ui.z = -1
		end

		if this.unit.hide_during_death or this.unit.hide_after_death then
			for _, s in pairs(this.render.sprites) do
				s.hidden = true
			end
		end

		if this.unit.fade_time_after_death then
			local delay = this.unit.fade_time_after_death
			local duration = this.unit.fade_duration_after_death

			if this.health and this.health.delete_after and duration then
				delay = this.health.delete_after - store.tick_ts - duration
			end

			SU.fade_out_entity(store, this, delay, duration)
		end
	end

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			if IS_KR5 then
				SU.remove_modifiers(store, this)
			end

			y_custom_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_456_1
				end
			end

			if this.ranged then
				brk, star = SU.y_soldier_ranged_attacks(store, this)

				if brk or star == A_DONE then
					goto label_456_1
				elseif star == A_IN_COOLDOWN then
					goto label_456_0
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				goto label_456_1
			end

			if SU.soldier_go_back_step(store, this) then
				goto label_456_1
			end

			::label_456_0::

			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_456_1::

		coroutine.yield()
	end
end

scripts.hero_dragon_bone = {}

function scripts.hero_dragon_bone.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]

	local b = E:get_template(this.ranged.attacks[1].bullet)

	b.bullet.damage_max = ls.ranged_damage_max[hl]
	b.bullet.damage_min = ls.ranged_damage_min[hl]

	local s

	s = this.hero.skills.cloud

	local sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - PLAGUE CLOUD - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[2]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]

		local b = E:get_template(a.bullet)
		local aura = E:get_template(b.bullet.hit_payload)

		aura.aura.duration = s.duration[s.level]
	end

	s = this.hero.skills.nova
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - DISEASE NOVA - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[3]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]
		a.damage_min = s.damage_min[s.level]
		a.damage_max = s.damage_max[s.level]
	end

	s = this.hero.skills.rain
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - SPINE RAIN - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[4]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]

		local b = E:get_template(a.entity)

		b.bullet.damage_min = s.damage_min[s.level]
		b.bullet.damage_max = s.damage_max[s.level]
		a.bones = s.bones_count[s.level]

		local mod = E:get_template(b.bullet.mod)
		mod.modifier.duration = s.stun_time[sl]
	end

	s = this.hero.skills.burst
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - SPREADING BURST - %i", this.template_name, hl, sl)

		local a = this.ranged.attacks[5]

		a.disabled = nil
		a.cooldown = s.cooldown[s.level]
		a.proj_count = s.proj_count[s.level]

		local bullet = E:get_template(a.bullet)

		bullet.bullet.damage_min = s.damage_min[s.level]
		bullet.bullet.damage_max = s.damage_max[s.level]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]

		local dog = E:get_template(uc.dog)

		dog.reinforcement.duration = s.duration[sl]
		dog.health.hp_max = s.hp[sl]
		dog.melee.attacks[1].damage_min = s.damage_min[sl]
		dog.melee.attacks[1].damage_max = s.damage_max[sl]
	end

	this.health.hp = this.health.hp_max
end

function scripts.hero_dragon_bone.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_dragon_bone.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill
	local shots_with_mod = 0
	local shadow_sprite = this.render.sprites[2]
	local cloud_attack = this.ranged.attacks[2]
	local nova_attack = this.ranged.attacks[3]
	local rain_attack = this.ranged.attacks[4]
	local burst_attack = this.ranged.attacks[5]
	local upg_lf = UP:get_upgrade("heroes_lethal_focus")

	if not cloud_attack.disabled then
		cloud_attack.ts = store.tick_ts - cloud_attack.cooldown
	end

	if not nova_attack.disabled then
		nova_attack.ts = store.tick_ts - nova_attack.cooldown
	end

	if not rain_attack.disabled then
		rain_attack.ts = store.tick_ts - rain_attack.cooldown
	end

	if not burst_attack.disabled then
		burst_attack.ts = store.tick_ts - burst_attack.cooldown
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts
	this.health_bar.hidden = false

	U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts - fts(4), this.idle_flip.loop, nil, true)

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
			U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, true)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				local r = this.nav_rally
				local start_pos = V.vclone(this.pos)
	
				SU.y_hero_new_rally(store, this)
			end
	
			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)
	
			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "lvlup", nil, store.tick_ts, 1)
			end
	
			for _, i in pairs(this.ranged.order) do
				do
					local a = this.ranged.attacks[i]
	
					if a.disabled then
						-- block empty
					elseif a.sync_animation and not this.render.sprites[1].sync_flag then
						-- block empty
					elseif store.tick_ts - a.ts < a.cooldown then
						-- block empty
					else
						if i == 1 then
							local bullet_t = E:get_template(a.bullet)
							local flight_time = a.estimated_flight_time or 1
							local targets = U.find_enemies_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)
	
							if targets then
								local target = targets[1]
								local start_ts = store.tick_ts
								local b, targets
								local node_offset = P:predict_enemy_node_advance(target, flight_time)
								local t_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi,
									target.nav_path.ni + node_offset)
								local an, af, ai = U.animation_name_facing_point(this, a.animation, t_pos)
	
								U.animation_start(this, an, af, store.tick_ts)
								S:queue(a.start_sound, a.start_sound_args)
	
								while store.tick_ts - start_ts < a.shoot_time do
									if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
										goto label_460_0
									end
	
									coroutine.yield()
								end
	
								targets = {
									target
								}
								b = E:create_entity(a.bullet)
								b.bullet.target_id = target.id
								b.bullet.source_id = this.id
								b.bullet.xp_dest_id = this.id
								b.pos = V.vclone(this.pos)
	
								if a.bullet_start_offset and #a.bullet_start_offset == 2 then
									local bullet_start_offset = v(0, 0)
	
									if #a.bullet_start_offset == 2 then
										local offset_index = af and 2 or 1
	
										bullet_start_offset = a.bullet_start_offset[offset_index]
									else
										bullet_start_offset = V.vclone(a.bullet_start_offset)
									end
	
									b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
									b.pos.y = b.pos.y + bullet_start_offset.y
								end
	
								b.bullet.from = V.vclone(b.pos)
	
								if b.bullet.ignore_hit_offset then
									b.bullet.to = V.v(target.pos.x, target.pos.y)
								else
									b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x,
										target.pos.y + target.unit.hit_offset.y)
								end
	
								b.bullet.shot_index = i
	
								if b.bullet.use_unit_damage_factor then
									b.bullet.damage_factor = this.unit.damage_factor
								end
	
								if upg_lf then
									if not this._lethal_focus_deck then
										this._lethal_focus_deck = SU.deck_new(upg_lf.trigger_cards, upg_lf.total_cards)
									end
	
									local triggered_lethal_focus = SU.deck_draw(this._lethal_focus_deck)
	
									if triggered_lethal_focus then
										b.bullet.damage_factor = b.bullet.damage_factor * upg_lf.damage_factor_area
										b.bullet.pop = {
											"pop_crit"
										}
										b.bullet.pop_chance = 1
										b.bullet.pop_conds = DR_DAMAGE
									end
								end
	
								queue_insert(store, b)
	
								if a.xp_from_skill then
									SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
								end
	
								a.ts = start_ts
	
								while not U.animation_finished(this) do
									if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
										goto label_460_0
									end
	
									coroutine.yield()
								end
	
								a.ts = start_ts
	
								U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts,
									this.idle_flip.loop, nil, true)
	
								::label_460_0::
	
								goto label_460_3
							end
						end
	
						if i == 2 then
							local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range,
								a.max_range, a.shoot_time + fts(10), a.vis_flags, a.vis_bans, function(v, o)
								return GR:cell_is(v.pos.x, v.pos.y, TERRAIN_LAND)
							end)
	
							if not targets or not pred_pos or #targets < a.min_targets then
								SU.delay_attack(store, a, 0.4)
	
								goto label_460_3
							end
	
							local target = targets[1]
							local start_ts = store.tick_ts
							local an, af, ai = U.animation_name_facing_point(this, a.animation, pred_pos)
	
							S:queue(a.sound)
							U.animation_start(this, an, af, store.tick_ts)
	
							if SU.y_hero_wait(store, this, a.shoot_time) then
								goto label_460_4
							end
	
							local b = E:create_entity(a.bullet)
	
							b.bullet.target_id = target.id
							b.bullet.source_id = this.id
							b.pos = V.vclone(this.pos)
	
							local offset_index = af and 2 or 1
							local bullet_start_offset = a.bullet_start_offset[offset_index]
	
							b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
							b.pos.y = b.pos.y + bullet_start_offset.y
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.vclone(pred_pos)
	
							queue_insert(store, b)
	
							a.ts = start_ts
	
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
	
							if SU.y_hero_animation_wait(this) then
								goto label_460_4
							end
	
							goto label_460_3
						end
	
						if i == 3 then
							if not GR:cell_is(this.pos.x, this.pos.y, TERRAIN_LAND) then
								goto label_460_3
							end
	
							local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range,
								a.max_range, a.hit_time, a.vis_flags, a.vis_bans_target, function(v, o)
								return GR:cell_is(v.pos.x, v.pos.y, TERRAIN_LAND)
							end)
	
							if not targets or not pred_pos or #targets < a.min_targets then
								SU.delay_attack(store, a, 0.2)
	
								goto label_460_3
							end
	
							local target = targets[1]
							local start_ts = store.tick_ts
							local an, af, ai = U.animation_name_facing_point(this, a.animation, pred_pos)
	
							S:queue(a.sound)
							U.animation_start(this, an, af, store.tick_ts)
	
							if SU.y_hero_wait(store, this, a.hit_time) then
								goto label_460_4
							end
	
							local targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.damage_radius, a
							.vis_flags, a.vis_bans_damage)
	
							if targets then
								for i, v in ipairs(targets) do
									local d = E:create_entity("damage")
	
									d.source_id = this.id
									d.target_id = v.id
	
									local dist_factor = U.dist_factor_inside_ellipse(v.pos, this.pos, a.damage_radius)
	
									d.value = math.floor(a.damage_max - (a.damage_max - a.damage_min) * dist_factor)
									d.value = d.value * this.unit.damage_factor
									d.damage_type = a.damage_type
	
									queue_damage(store, d)
	
									local m = E:create_entity(a.mod)
	
									m.modifier.target_id = v.id
									m.modifier.source_id = this.id
	
									queue_insert(store, m)
								end
							end
	
							a.ts = start_ts
	
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
							SU.y_hero_animation_wait(this)
							U.y_animation_play(this, "respawn", nil, store.tick_ts, 1)
	
							goto label_460_3
						end
	
						if i == 4 then
							local target = U.find_random_enemy(store.entities, this.pos, a.min_range, a.max_range,
								a.vis_flags, a.vis_bans)
	
							if not target then
								SU.delay_attack(store, a, 0.4)
	
								goto label_460_3
							end
	
							local pi, spi, ni = target.nav_path.pi, target.nav_path.spi, target.nav_path.ni
							local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {
								pi
							}, nil, nil, NF_RALLY)
	
							if #nodes < 1 then
								SU.delay_attack(store, a, 0.4)
	
								goto label_460_3
							end
	
							local s_pi, s_spi, s_ni = unpack(nodes[1])
	
							S:queue(a.sound)
	
							local flip = target.pos.x < this.pos.x
	
							U.animation_start(this, a.animation, flip, store.tick_ts)
	
							if SU.y_hero_wait(store, this, a.spawn_time) then
								goto label_460_4
							end
	
							local delay = 0
							local n_step = ni < s_ni and -2 or 2
	
							ni = km.clamp(1, #P:path(s_pi), ni < s_ni and ni + 6 or ni)
	
							for i = 1, a.bones do
								local e = E:create_entity(a.entity)
	
								e.pos = P:node_pos(pi, spi, ni)
	
								local types = {
									"a",
									"b",
									"c"
								}
								local type = types[math.random(1, 3)]
	
								e.bone_type = type
								e.render.sprites[1].flip_x = flip
								e.render.sprites[2].flip_x = flip
								e.delay = delay
								e.bullet.source_id = this.id
	
								queue_insert(store, e)
	
								delay = delay + fts(U.frandom(1, 3))
								ni = ni + n_step
								spi = km.zmod(spi + math.random(1, 2), 3)
							end
	
							U.y_animation_wait(this)
	
							a.ts = store.tick_ts
	
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
	
							goto label_460_4
						end
	
						if i == 5 then
							local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, math.min(a.max_range, 200), 
							a.spawn_time + a.node_prediction, a.vis_flags, a.vis_bans_target, function(v, o)
								return GR:cell_is(v.pos.x, v.pos.y, TERRAIN_LAND)
							end)
	
							if not target or not targets or #targets < a.min_targets then
								SU.delay_attack(store, a, 0.4)
							else
								target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, 
								a.spawn_time + a.node_prediction, a.vis_flags, a.vis_bans_target, function(v, o)
									return GR:cell_is(v.pos.x, v.pos.y, TERRAIN_LAND)
								end)
	
								S:queue(a.sound)
	
								local flip = target.pos.x < this.pos.x
	
								U.animation_start(this, a.animation, flip, store.tick_ts)
	
								if SU.y_hero_wait(store, this, a.spawn_time) then
									goto label_460_4
								end
	
								local function shuffle_table(nodes)
									for i = #nodes, 2, -1 do
										local j = math.random(i)
	
										nodes[i], nodes[j] = nodes[j], nodes[i]
									end
	
									return nodes
								end
	
								local function shoot_bullet_to_target(target)
									local node_offset = P:predict_enemy_node_advance(target, a.node_prediction)
									local e_ni = target.nav_path.ni + node_offset
									local e_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, e_ni)
									local b = E:create_entity(a.bullet)
	
									b.pos.x, b.pos.y = this.pos.x + a.bullet_start_offset.x,
										this.pos.y + a.bullet_start_offset.y
									b.bullet.from = V.vclone(b.pos)
									b.bullet.to = e_pos
									b.bullet.source_id = this.id
									b.bullet.target_id = target.id
	
									queue_insert(store, b)
								end
	
								local function shoot_bullet_to_pos(pos)
									local b = E:create_entity(a.bullet)
	
									b.pos.x, b.pos.y = this.pos.x + a.bullet_start_offset.x,
										this.pos.y + a.bullet_start_offset.y
									b.bullet.from = V.vclone(b.pos)
									b.bullet.to = pos
									b.bullet.source_id = this.id
	
									queue_insert(store, b)
								end
	
								local function insertAIntoB(tableA, tableB)
									for i, v in ipairs(tableA) do
										table.insert(tableB, v)
									end
								end
	
								local selected_targets = {}
								local selected_positions = {}
								local max_dist2 = a.max_dist_between_tgts * a.max_dist_between_tgts
								local tempTargets = {}
								local repeatCount = 0
								if not targets or #targets == 0 then
									goto label_460_1
								end
	
								insertAIntoB(targets, tempTargets)
								for j = 1, a.proj_count do
									if #tempTargets == 0 then
										if repeatCount >= 3 then
											break
										end
										insertAIntoB(targets, tempTargets)
										repeatCount = repeatCount + 1
									end
									local sel_target = tempTargets[1]
	
									table.insert(selected_targets, sel_target)
									table.remove(tempTargets, 1)
								end
	
								if #selected_targets == a.proj_count then
									goto label_460_2
								end
	
								::label_460_1::
	
								do
									local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, 0, a.max_range, nil, nil, nil, {
										1
									})
	
									shuffle_table(nodes)
	
									for j = #selected_targets + 1, a.proj_count do
										local sel_node = nodes[1]
	
										table.insert(selected_positions, sel_node)
										table.remove(nodes, 1)
	
										for k = #nodes, 1, -1 do
											local n = nodes[k]
	
											if max_dist2 > V.dist2(sel_node.x, sel_node.y, n.x, n.y) then
												table.remove(nodes, k)
											end
										end
									end
								end
	
								::label_460_2::
								if #selected_targets > 2 then
									shuffle_table(selected_targets)
								end
								for _, t in ipairs(selected_targets) do
									shoot_bullet_to_target(t)
									U.y_wait(store, a.wait_between_shots)
								end
	
								if #selected_positions > 2 then
									shuffle_table(selected_positions)
								end
								for _, p in ipairs(selected_positions) do
									shoot_bullet_to_pos(p)
									U.y_wait(store, a.wait_between_shots)
								end
	
								U.y_animation_wait(this)
	
								a.ts = store.tick_ts
	
								SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
	
								goto label_460_4
							end
						end
					end
				end
	
				::label_460_3::
			end
	
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_460_4::

		coroutine.yield()
	end
end

scripts.bolt_dragon_bone_basic_attack = {}

function scripts.bolt_dragon_bone_basic_attack.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false
	local target = store.entities[b.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	local is_flying = U.flag_has(target.vis.flags, F_FLYING)

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	b.hit_fx = is_flying and b.hit_fx_flying or b.hit_fx_floor
	b.ignore_hit_offset = not is_flying

	S:queue(this.sound_events.travel)

	s.z = Z_BULLETS
	s.sort_y_offset = nil

	U.animation_start(this, "idle", nil, store.tick_ts, true)

	if ps then
		ps.particle_system.emit = true
	end

	while V.dist2(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length * (mspeed * store.tick_length) do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		if target and target.health and not target.health.dead then
			b.to = V.vclone(target.pos)

			if not b.ignore_hit_offset then
				b.to.x, b.to.y = b.to.x + target.unit.hit_offset.x, b.to.y + target.unit.hit_offset.y
			end

			new_target = false
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end
	end

	this.pos = V.vclone(b.to)

	S:queue(this.sound_events.hit)

	local function explosion(r, damage_min, damage_max, dty)
		local target_bans = bit.bor(F_FLYING)
		local target_pos = V.vclone(this.pos)

		if is_flying then
			target_bans = 0

			if target and target.flight_height then
				target_pos.y = target_pos.y - target.flight_height
			end
		end

		local targets = U.find_enemies_in_range(store.entities, target_pos, 0, r, 0, target_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				d.value = math.random(damage_min, damage_max)
				d.damage_type = dty
				d.target_id = target.id
				d.source_id = b.source_id
				d.xp_gain_factor = b.xp_gain_factor
				d.xp_dest_id = b.source_id

				queue_damage(store, d)

				if b.mod then
					local mod = E:create_entity(b.mod)

					mod.modifier.target_id = target.id
					mod.modifier.source_id = b.source_id
					mod.xp_dest_id = b.source_id

					queue_insert(store, mod)
				end
			end
		end
	end

	local p = SU.create_bullet_pop(store, this)

	if p then
		queue_insert(store, p)
	end

	explosion(this.damage_range, b.damage_min, b.damage_max, b.damage_type)

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.mod_dragon_bone_plague = {}

function scripts.mod_dragon_bone_plague.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target and target.health.dead and band(target.health.last_damage_types, DAMAGE_EAT) == 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.spread_radius, this.modifier.vis_flags,
			this.modifier.vis_bans)

		if targets then
			for _, t in pairs(targets) do
				local m = E:create_entity(this.template_name)

				m.modifier.target_id = t.id
				m.modifier.source_id = this.modifier.source_id
				m.modifier.xp_dest_id = this.modifier.xp_dest_id

				queue_insert(store, m)

				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = t.id
				d.value = this.spread_damage
				d.damage_type = this.dps.damage_type

				local dmin, dmax = this.spread_damage_min, this.spread_damage_max
				local dist_factor = U.dist_factor_inside_ellipse(t.pos, target.pos, this.spread_radius)

				d.value = math.floor(dmax - (dmax - dmin) * dist_factor)

				queue_damage(store, d)
			end
		end

		local fx = E:create_entity(this.spread_fx)

		fx.pos = V.vclone(this.pos)

		if target and this.modifier.use_mod_offset and target.unit.mod_offset then
			local mo = target.unit.mod_offset

			fx.pos.x, fx.pos.y = fx.pos.x + mo.x, fx.pos.y + mo.y
			fx.render.sprites[1].sort_y_offset = -mo.y
		end

		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	return true
end

scripts.bullet_dragon_bone_cloud = {}

function scripts.bullet_dragon_bone_cloud.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

	s.r = angle

	local dist_offset = 0

	if this.dist_offset then
		dist_offset = this.dist_offset
	end

	s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width

	U.y_wait(store, b.hit_time)

	local hp = E:create_entity(b.hit_payload)

	hp.aura.level = this.bullet.level
	hp.aura.source_id = this.id
	hp.pos = V.vclone(dest)

	queue_insert(store, hp)
	U.y_animation_wait(this)
	queue_remove(store, this)
end

scripts.aura_dragon_bone_cloud = {}

function scripts.aura_dragon_bone_cloud.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	this.tween.ts = store.tick_ts

	local nearest_nodes = P:nearest_nodes(this.pos.x, this.pos.y)
	local pi, spi, ni = unpack(nearest_nodes[1])
	local cloud_1 = E:create_entity(this.decal_cloud_t)

	cloud_1.pos = P:node_pos(pi, 1, ni + 3)
	cloud_1.tween.ts = store.tick_ts

	queue_insert(store, cloud_1)

	local cloud_2 = E:create_entity(this.decal_cloud_t)

	cloud_2.pos = P:node_pos(pi, 1, ni - 3)
	cloud_2.tween.ts = store.tick_ts

	queue_insert(store, cloud_2)

	local cloud_3 = E:create_entity(this.decal_cloud_t)

	cloud_3.pos = P:node_pos(pi, 2, ni)
	cloud_3.tween.ts = store.tick_ts

	queue_insert(store, cloud_3)

	local cloud_4 = E:create_entity(this.decal_cloud_t)

	cloud_4.pos = P:node_pos(pi, 3, ni)
	cloud_4.tween.ts = store.tick_ts

	queue_insert(store, cloud_4)

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.aura.radius, this.aura.vis_flags,
				this.aura.vis_bans)

			if targets then
				for i, target in ipairs(targets) do
					local mods = this.aura.mods or {
						this.aura.mod
					}

					for _, mod_name in pairs(mods) do
						local new_mod = E:create_entity(mod_name)

						new_mod.modifier.level = this.aura.level
						new_mod.modifier.target_id = target.id
						new_mod.modifier.source_id = this.id

						if this.aura.hide_source_fx and target.id == this.aura.source_id then
							new_mod.render = nil
						end

						queue_insert(store, new_mod)

						victims_count = victims_count + 1
					end
				end
			end
		end

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)

	this.tween.reverse = true
	this.tween.remove = true
	this.tween.ts = store.tick_ts

	local clouds = {
		cloud_1,
		cloud_2,
		cloud_3,
		cloud_4
	}

	for i, v in ipairs(clouds) do
		v.tween.reverse = true
		v.tween.remove = true
		v.tween.ts = store.tick_ts
	end
end

scripts.bullet_dragon_bone_rain = {}

function scripts.bullet_dragon_bone_rain.insert(this, store)
	this.render.sprites[1].name = this.sprite_prefix .. this.bone_type .. "_green_air"
	this.render.sprites[2].name = this.sprite_prefix .. this.bone_type .. "_ground"

	if this.render.sprites[1].flip_x then
		this.tween.props[3].keys[1][2].x = -this.tween.props[3].keys[1][2].x
		this.tween.props[3].keys[2][2].x = -this.tween.props[3].keys[2][2].x
	end

	return true
end

function scripts.bullet_dragon_bone_rain.update(this, store)
	local b = this.bullet

	U.sprites_hide(this)

	if this.delay then
		U.y_wait(store, this.delay)
	end

	U.sprites_show(this)

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	U.y_wait(store, b.hit_time)

	this.render.sprites[1].name = this.sprite_prefix .. this.bone_type .. "_green_ground"
	this.render.sprites[1].offset = V.vv(0)
	this.render.sprites[2].hidden = false

	for i = 1, 3 do
		this.tween.props[i].disabled = true
	end

	this.tween.props[4].disabled = false
	this.tween.ts = store.tick_ts

	local fx = E:create_entity(b.hit_fx)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts
	fx.render.sprites[1].runs = 0

	if this.bone_type == "c" then
		fx.render.sprites[1].scale = V.vv(0.6)
	end

	queue_insert(store, fx)

	local decal = E:create_entity(b.hit_decal)

	decal.pos = V.vclone(this.pos)
	decal.render.sprites[1].ts = store.tick_ts

	queue_insert(store, decal)
	S:queue(this.sound_events.hit)

	local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.damage_flags, b.damage_bans)

	if targets then
		for _, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.damage_type = b.damage_type
			d.source_id = this.id
			d.target_id = target.id
			d.value = math.random(b.damage_min, b.damage_max)

			queue_damage(store, d)

			local m = E:create_entity(b.mod)

			m.modifier.source_id = this.id
			m.modifier.target_id = target.id
			m.modifier.xp_dest_id = b.source_id

			queue_insert(store, m)
		end
	end

	U.y_wait(store, b.duration - b.hit_time)

	this.render.sprites[2].hidden = true

	local fx = E:create_entity(b.vanish_fx)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts
	fx.render.sprites[1].runs = 0

	queue_insert(store, fx)

	this.tween.props[4].disabled = true
	this.tween.props[5].disabled = false
	this.tween.ts = store.tick_ts
	this.tween.remove = true
end

scripts.bolt_dragon_bone_burst = {}

function scripts.bolt_dragon_bone_burst.insert(this, store, script)
	local b = this.bullet

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	local s = this.render.sprites[1]

	if not b.ignore_rotation then
		s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
	end

	U.animation_start(this, "idle", nil, store.tick_ts, s.loop)

	return true
end

function scripts.bolt_dragon_bone_burst.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps
	local dmin, dmax = b.damage_min, b.damage_max

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	local function do_hit(hit_pos)
		local is_flying

		if target then
			local d = E:create_entity("damage")

			d.damage_type = b.damage_type
			d.value = math.random(dmin, dmax)
			d.source_id = this.id
			d.target_id = target.id

			queue_damage(store, d)

			is_flying = U.flag_has(target.vis.flags, F_FLYING)

			local m = E:create_entity(b.mod)

			m.modifier.source_id = this.id
			m.modifier.target_id = target.id
			m.modifier.xp_dest_id = b.source_id

			queue_insert(store, m)
		end

		S:queue(this.sound_events.hit)

		if is_flying then
			local fx = E:create_entity(b.hit_fx_flying)

			fx.pos = V.vclone(hit_pos)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		else
			local fx = E:create_entity(b.hit_fx_floor)

			fx.pos = V.vclone(hit_pos)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		end
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local pred_pos

	if target then
		pred_pos = P:predict_enemy_pos(target, fts(5))
	else
		pred_pos = b.to
	end

	local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			local d = math.max(math.abs(target.pos.x + hit_offset.x - b.to.x),
				math.abs(target.pos.y + hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id,
					this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	this.render.sprites[1].hidden = true

	do_hit(b.to)

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false
	end

	U.y_wait(store, fts(10))
	queue_remove(store, this)
end

scripts.hero_dragon_bone_ultimate = {}

function scripts.hero_dragon_bone_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.hero_dragon_bone_ultimate.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true, NF_POWER_3)

	if #nodes < 1 then
		log.error("hero_dragon_bone_ultimate: could not find valid node")
		queue_remove(store, this)

		return
	end

	local x, y = this.pos.x, this.pos.y
	local pos1 = V.v(x + 12, y - 12)
	local pos2 = V.v(x - 12, y + 12)
	local fx = E:create_entity(this.spawn_fx)

	fx.pos = V.vclone(pos1)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	local fx = E:create_entity(this.spawn_fx)

	fx.pos = V.vclone(pos2)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)
	U.y_wait(store, this.spawn_time)

	local e = E:create_entity(this.dog)

	e.pos = V.vclone(pos1)
	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.id

	queue_insert(store, e)

	e = E:create_entity(this.dog)
	e.pos = V.vclone(pos2)
	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.id

	queue_insert(store, e)
	queue_remove(store, this)
end

scripts.hero_dragon_arb = {}

function scripts.hero_dragon_arb.get_info(this)
	local a = this.ranged.attacks[1]
	local b = E:get_template(a.bullet)
	local min, max = b.bullet.damage_min, b.bullet.damage_max

	min, max = min * this.unit.damage_factor, max * this.unit.damage_factor
	min, max = math.ceil(min), math.ceil(max)

	return {
		type = STATS_TYPE_SOLDIER,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		damage_type = b.bullet.damage_type,
		damage_icon = this.info.damage_icon,
		armor = this.health.armor,
		magic_armor = this.health.magic_armor,
		respawn = this.health.dead_lifetime
	}
end

function scripts.hero_dragon_arb.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.health.magic_armor = ls.magic_armor[hl]

	local b = E:get_template(this.ranged.attacks[1].bullet)

	b.bullet.damage_max = ls.ranged_damage_max[hl]
	b.bullet.damage_min = ls.ranged_damage_min[hl]

	local s, sl

	s = this.hero.skills.arborean_spawn
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - ARBOREAN SPAWN - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
	end

	s = this.hero.skills.tower_runes
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - TOWER RUNES - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.max_targets = s.max_targets[sl]

		local bullet = E:get_template(a.bullet)
		local mod = E:get_template(bullet.bullet.hit_mod)

		mod.damage_factor = s.damage_factor[sl]
		mod.modifier.duration = s.duration[sl]
	end

	s = this.hero.skills.thorn_bleed
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - THORN BLEED - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.instakill_chance = s.instakill_chance[sl]

		local mod = E:get_template(a.mod[1])

		mod.modifier.duration = s.duration[sl]
		mod.damage_speed_ratio = s.damage_speed_ratio[sl]
	end

	s = this.hero.skills.tower_plants
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - TOWER PLANTS - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.max_targets = s.max_targets[sl]

		local p_lin = E:get_template(a.plant_linirea)

		p_lin.duration = s.duration[sl]

		local p_lin_b = E:get_template(p_lin.bullet_attack.bullet)
		local p_lin_b_mod = E:get_template(p_lin_b.bullet.mod)

		p_lin_b_mod.hps.heal_max = s.heal_max[sl]
		p_lin_b_mod.hps.heal_min = s.heal_min[sl]

		local p_da = E:get_template(a.plant_dark_army)

		p_da.duration = s.duration[sl]

		local p_da_mod_slow = E:get_template("mod_hero_dragon_arb_plant_dark_army_slow")

		p_da_mod_slow.slow.factor = s.slow_factor[sl]

		local p_da_mod_dps = E:get_template("mod_hero_dragon_arb_plant_dark_army_dps")

		p_da_mod_dps.dps.damage_min = s.damage_min[sl]
		p_da_mod_dps.dps.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if initial and s.level > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]
	end

	local mod = E:get_template(s.mod)

	mod.inflicted_damage_factor = s.inflicted_damage_factor[sl]
	mod.extra_magic_armor = s.extra_magic_armor[sl]
	mod.extra_armor = s.extra_armor[sl]
	mod.fast.factor = s.speed_factor[sl]
	this.health.hp = this.health.hp_max
end

function scripts.hero_dragon_arb.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_dragon_arb.update(this, store)
	local h = this.health
	local he = this.hero
	local a, skill
	local shadow_sprite = this.render.sprites[2]
	local upg_lf = UP:get_upgrade("heroes_lethal_focus")

	this.ultimate_ts = store.tick_ts

	local s_ult = this.hero.skills.ultimate
	local attack_arborean_spawns = this.timed_attacks.list[1]
	local attack_thorn_bleed = this.timed_attacks.list[2]
	local attack_tower_runes = this.timed_attacks.list[3]
	local attack_tower_plants = this.timed_attacks.list[4]
	local power_index = 2

	if this.template_name == store.selected_team[2] then
		power_index = 3
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts
	this.health_bar.hidden = false

	local passive_controller = E:create_entity(this.controller_passive)

	queue_insert(store, passive_controller)

	local function attack_is_tower_valid(v, a)
		local is_tower = v.tower and not v.pending_removal and not v.tower.blocked and (not a.excluded_templates or not table.contains(a.excluded_templates, v.template_name)) and v.vis and band(v.vis.flags, a.vis_bans) == 0 and band(v.vis.bans, a.vis_flags) == 0 and not table.contains(a.exclude_tower_kind, v.tower.kind) and v.tower.can_be_mod and U.is_inside_ellipse(v.pos, this.pos, a.max_range) and (a.min_range == 0 or not U.is_inside_ellipse(v.pos, this.pos, a.min_range))

		return is_tower
	end

	local function attack_get_towers(a)
		local targets = table.filter(store.entities, function(k, v)
			return attack_is_tower_valid(v, a)
		end)

		if targets and #targets > 0 then
			return targets
		end

		return nil
	end

	this.desired_rotation = 0

	local function update_dragon_rotation(new_rotation)
		if new_rotation then
			this.desired_rotation = new_rotation
		end

		local current_rotation = math.abs(this.render.sprites[1].r)
		local rotation = U.ease_value(current_rotation, this.desired_rotation, 0.2, "linear")

		if not this.render.sprites[1].flip_x then
			rotation = -rotation
		end

		this.render.sprites[1].r = rotation
		this.render.sprites[3].r = rotation
	end

	local function y_hero_dragon_arb_walk_waypoints(store, this, animation)
		local animation = animation or "walk"
		local r = this.nav_rally
		local n = this.nav_grid
		local dest = r.pos
		local x_to_flip = KR_GAME == "kr5" and 2 or 0
		local last_af

		while not V.veq(this.pos, dest) do
			local w = table.remove(n.waypoints, 1) or dest
			local unsnap = #n.waypoints > 0

			U.set_destination(this, w)

			local an, af = U.animation_name_facing_point(this, animation, this.motion.dest)
			local new_af = af

			if x_to_flip > math.abs(this.pos.x - this.motion.dest.x) then
				new_af = last_af
			end

			U.animation_start(this, an, new_af, store.tick_ts, true)

			last_af = new_af

			local start_ts = store.tick_ts
			local time_to_accel = 0.7
			local dist_to_break = 50
			local orig_vx = r.pos.x - this.pos.x
			local rotation_multiplier = math.min(math.abs(orig_vx) / 300, 1)
			local current_dir = -1

			if orig_vx > 0 then
				current_dir = 1
			end

			local same_dir = false

			if this.old_rally_dir == current_dir then
				same_dir = true
			end

			local old_rally_ease_step = same_dir and this.old_rally_ease_step or nil

			this.old_rally_dir = current_dir

			while not this.motion.arrived do
				if this.health.dead and not this.health.ignore_damage then
					return true
				end

				if r.new then
					return false
				end

				local vx, vy = V.sub(r.pos.x, r.pos.y, this.pos.x, this.pos.y)
				local dist = V.len(vx, vy)
				local stored_max_speed = this.motion.max_speed
				local target_ease_step, ease_from

				if dist_to_break < dist then
					target_ease_step = (store.tick_ts - start_ts) / time_to_accel
					ease_from = 0
				else
					target_ease_step = dist / dist_to_break
					ease_from = 20
				end

				local ease_step = target_ease_step

				if old_rally_ease_step then
					ease_step = U.ease_value(old_rally_ease_step, target_ease_step, math.min(1, (store.tick_ts - start_ts) / (time_to_accel / 2)), "linear")
				end

				this.motion.max_speed = U.ease_value(ease_from, stored_max_speed, ease_step, "quad-in")
				this.old_rally_ease_step = ease_step

				local desired_rotation = math.rad(13 * this.motion.max_speed / stored_max_speed) * rotation_multiplier

				update_dragon_rotation(desired_rotation)
				U.walk(this, store.tick_length, nil, unsnap)

				this.motion.max_speed = stored_max_speed

				coroutine.yield()

				this.motion.speed.x, this.motion.speed.y = 0, 0
			end

			this.old_rally_ease_step = nil
			this.old_rally_dir = nil
		end
	end

	local function y_hero_dragon_arb_new_rally(store, this)
		local r = this.nav_rally

		if r.new then
			r.new = false

			U.unblock_target(store, this)

			if this.sound_events then
				S:queue(this.sound_events.change_rally_point)
			end

			local vis_bans = this.vis.bans
			local prev_immune = this.health.immune_to

			this.vis.bans = F_ALL
			this.health.immune_to = r.immune_to

			local out = y_hero_dragon_arb_walk_waypoints(store, this)

			U.animation_start(this, "idle", nil, store.tick_ts, true)

			this.vis.bans = vis_bans
			this.health.immune_to = prev_immune

			return out
		end
	end

	U.animation_start_group(this, this.idle_flip.last_animation, nil, store.tick_ts - fts(4), this.idle_flip.loop, this.render.sprites[1].group)

	while true do
		if h.dead then
			signal.emit("lock-user-power", power_index)
			SU.remove_modifiers(store, this, this.hero.skills.ultimate.mod)
			U.sprites_hide(this, 3, 3, true)
			SU.y_hero_death_and_respawn_kr5(store, this)
			U.animation_start_group(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, this.render.sprites[1].group)
			U.sprites_show(this, 3, 3, true)

			this.tween.props[2].disabled = false
			this.tween.props[2].ts = store.tick_ts
			this.tween.reverse = false

			signal.emit("unlock-user-power", power_index)
		end

		if this.ultimate_active and store.tick_ts > this.ultimate_ts + s_ult.duration[s_ult.level] then
			this.tween.reverse = true
			this.tween.props[2].disabled = false
			this.tween.props[2].ts = store.tick_ts

			SU.y_hero_wait(store, this, this.tween.props[2].keys[2][1])

			this.ultimate_active = false

			SU.remove_modifiers(store, this, s_ult.mod)
		end

		while this.nav_rally.new do
			local r = this.nav_rally
			local start_pos = V.vclone(this.pos)

			y_hero_dragon_arb_new_rally(store, this)
		end

		SU.heroes_visual_learning_upgrade(store, this)
		SU.heroes_lone_wolves_upgrade(store, this)
		SU.alliance_merciless_upgrade(store, this)
		SU.alliance_corageous_upgrade(store, this)

		if SU.hero_level_up(store, this) then
			U.y_animation_play_group(this, "lvlup", nil, store.tick_ts, 1, this.render.sprites[1].group)
		end

		for _, i in pairs(this.ranged.order) do
			do
				local a = this.ranged.attacks[i]

				if a.disabled then
					-- block empty
				elseif a.sync_animation and not this.render.sprites[1].sync_flag then
					-- block empty
				elseif store.tick_ts - a.ts < a.cooldown then
					-- block empty
				elseif i == 1 then
					local bullet_t = E:get_template(a.bullet)
					local flight_time = bullet_t.bullet.flight_time
					local target = U.find_random_enemy(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans, function(v)
						if not v.nav_path then
							return false
						end
						if a.nodes_limit and (P:get_start_node(v.nav_path.pi) + a.nodes_limit > v.nav_path.ni or P:get_end_node(v.nav_path.pi) - a.nodes_limit < v.nav_path.ni) then
							return false
						end
						return true
					end)

					if target then
						local start_ts = store.tick_ts
						local b, targets, emit_ps, emit_ts, bullet_start_offset
						local apply_thorn_bleed = false

						if not attack_thorn_bleed.disabled and store.tick_ts - attack_thorn_bleed.ts >= attack_thorn_bleed.cooldown then
							apply_thorn_bleed = true
						end

						local node_offset = P:predict_enemy_node_advance(target, flight_time)
						local t_pos = P:node_pos(target.nav_path.pi, target.nav_path.spi, target.nav_path.ni + node_offset)
						local an, af, ai = U.animation_name_facing_point(this, a.animation, t_pos)

						U.animation_start_group(this, an, af, store.tick_ts, false, this.render.sprites[1].group)
						S:queue(a.start_sound, a.start_sound_args)

						local triggered_lethal_focus

						while store.tick_ts - start_ts < a.shoot_times[1] do
							if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
								goto label_575_0
							end

							coroutine.yield()
						end

						if apply_thorn_bleed then
							attack_thorn_bleed.ts = start_ts
						end
						
						S:queue(a.sound)

						b = E:create_entity(a.bullet_ray)
						b.bullet.target_id = target.id
						b.bullet.source_id = this.id
						b.bullet.xp_dest_id = this.id
						b.pos = V.vclone(this.pos)
						bullet_start_offset = v(0, 0)

						if a.bullet_start_offset and #a.bullet_start_offset == 2 then
							local offset_index = af and 2 or 1

							bullet_start_offset = a.bullet_start_offset[offset_index]
						end

						b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
						b.pos.y = b.pos.y + bullet_start_offset.y
						b.bullet.from = V.vclone(b.pos)

						if b.bullet.ignore_hit_offset then
							b.bullet.to = V.v(t_pos.x, t_pos.y)
						else
							b.bullet.to = V.v(t_pos.x + target.unit.hit_offset.x, t_pos.y + target.unit.hit_offset.y)
						end

						queue_insert(store, b)

						if this.ultimate_active or apply_thorn_bleed then
							local diff = V.v(b.bullet.to.x - b.pos.x, b.bullet.to.y - b.pos.y)
							local normal_x, normal_y = V.normalize(diff.x, diff.y)
							local angle = V.angleTo(normal_x, normal_y)

							local function create_mouth_fx(fx_t, offset)
								local fx = E:create_entity(fx_t)

								fx.pos = V.v(b.pos.x + normal_x * offset, b.pos.y + normal_y * offset)

								local s = fx.render.sprites[1]

								s.r = angle
								s.ts = store.tick_ts
								s.flip_x = this.render.sprites[1].flip_x

								if s.flip_x then
									s.r = s.r + math.rad(180)
								end

								queue_insert(store, fx)
							end

							if this.ultimate_active then
								create_mouth_fx(a.ultimate_fx, a.ultimate_fx_offset)
							end

							if apply_thorn_bleed then
								create_mouth_fx(a.spikes_fx, a.spikes_fx_offset)
							end
						end

						if apply_thorn_bleed then
							b = E:create_entity(a.bullet_spikes)
							b.bullet.target_id = target.id
							b.bullet.source_id = this.id
							b.bullet.xp_dest_id = this.id
							b.pos = V.vclone(this.pos)
							bullet_start_offset = v(0, 0)

							if a.bullet_start_offset and #a.bullet_start_offset == 2 then
								local offset_index = af and 2 or 1

								bullet_start_offset = a.bullet_start_offset[offset_index]
							end

							b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x + math.random(-5, 5)
							b.pos.y = b.pos.y + bullet_start_offset.y + math.random(-5, 5)
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.v(t_pos.x + math.random(-20, 20), t_pos.y + math.random(-20, 20))

							queue_insert(store, b)
							SU.hero_gain_xp_from_skill(this, this.hero.skills.thorn_bleed)
						end

						if a.xp_from_skill then
							SU.hero_gain_xp_from_skill(this, this.hero.skills[a.xp_from_skill])
						end

						if upg_lf then
							if not this._lethal_focus_deck then
								this._lethal_focus_deck = SU.deck_new(upg_lf.trigger_cards, upg_lf.total_cards)
							end

							triggered_lethal_focus = SU.deck_draw(this._lethal_focus_deck)
						end

						for shot_time_i = 1, #a.shoot_times do
							while store.tick_ts - start_ts < a.shoot_times[shot_time_i] do
								if this.unit.is_stunned or this.health.dead or this.nav_rally and this.nav_rally.new then
									goto label_575_0
								end

								coroutine.yield()
							end

							b = E:create_entity(a.bullet)
							b.bullet.target_id = target.id
							b.bullet.source_id = this.id
							b.bullet.xp_gain_factor = a.xp_gain_factor
							b.bullet.xp_dest_id = this.id
							b.pos = V.vclone(this.pos)
							bullet_start_offset = v(0, 0)

							if a.bullet_start_offset and #a.bullet_start_offset == 2 then
								local offset_index = af and 2 or 1

								bullet_start_offset = a.bullet_start_offset[offset_index]
							end

							b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x + math.random(-5, 5)
							b.pos.y = b.pos.y + bullet_start_offset.y + math.random(-5, 5)
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.v(t_pos.x + math.random(-20, 20), t_pos.y + math.random(-20, 20))
							b.bullet.damage_max = b.bullet.damage_max / #a.shoot_times
							b.bullet.damage_min = b.bullet.damage_min / #a.shoot_times
							b.bullet.shot_index = i

							if b.bullet.use_unit_damage_factor then
								b.bullet.damage_factor = this.unit.damage_factor
							end

							b.cached_controller_dragon_arb_passive_id = passive_controller.id

							if apply_thorn_bleed then
								b.bullet.mod = table.deepclone(attack_thorn_bleed.mod)

								if this.ultimate_active then
									b.instakill_chance = attack_thorn_bleed.instakill_chance
								end
							end

							if triggered_lethal_focus then
								b.bullet.damage_factor = b.bullet.damage_factor * upg_lf.damage_factor_area
								b.bullet.pop = {
									"pop_crit"
								}
								b.bullet.pop_chance = 1
								b.bullet.pop_conds = DR_DAMAGE
							end

							queue_insert(store, b)
						end



						a.ts = start_ts

						SU.y_hero_animation_wait(this)
						U.animation_start_group(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, this.render.sprites[1].group)

						::label_575_0::

						goto label_575_1
					end
				end
			end

			::label_575_1::
		end

		skill = this.hero.skills.arborean_spawn
		a = attack_arborean_spawns

		if not a.disabled and store.tick_ts - a.ts > a.cooldown then
			local plant_zones = table.filter(passive_controller.root_zones, function(k, v)
				if not U.is_inside_ellipse({
					x = v.x,
					y = v.y
				}, this.pos, a.max_range) then
					return false
				end

				if a.min_range ~= 0 and not not U.is_inside_ellipse({
					x = v.x,
					y = v.y
				}, this.pos, a.min_range) then
					return false
				end

				local enemies = U.find_enemies_in_range(store.entities, {
					x = v.x,
					y = v.y
				}, 0, a.spawn_max_range_to_enemy, a.vis_flags, a.vis_bans)

				if not enemies or #enemies < 1 then
					return false
				end

				return true
			end)

			if not plant_zones or #plant_zones < a.min_targets then
				SU.delay_attack(store, a, fts(10))
			else
				plant_zones = table.random_order(plant_zones)
				plant_zones = table.slice(plant_zones, 1, a.max_targets)

				local start_ts = store.tick_ts

				S:queue(a.sound)
				U.animation_start_group(this, a.animation, nil, store.tick_ts, false, this.render.sprites[1].group)

				if SU.y_hero_wait(store, this, a.cast_time) then
					goto label_575_2
				end

				a.ts = start_ts

				SU.hero_gain_xp_from_skill(this, skill)

				for i = 1, #plant_zones do
					local zone_target = plant_zones[i]
					local b = E:create_entity(a.bullet)

					b.bullet.target_id = nil
					b.bullet.source_id = this.id
					b.bullet.xp_dest_id = this.id
					b.pos = V.vclone(this.pos)

					local bullet_start_offset = v(0, 0)
					local af = this.render.sprites[1].flip_x

					if a.bullet_start_offset and #a.bullet_start_offset == 2 then
						local offset_index = af and 2 or 1

						bullet_start_offset = a.bullet_start_offset[offset_index]
					end

					b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
					b.pos.y = b.pos.y + bullet_start_offset.y
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = V.v(zone_target.x, zone_target.y)
					b.bullet.level = skill.level
					b.bullet.payload = (this.ultimate_active and a.spawn_evolved or a.spawn) .. "_lvl" .. skill.level
					b.cached_controller_dragon_arb_passive_id = passive_controller.id
					b.zone_target_id = zone_target.zone_id

					queue_insert(store, b)

					if SU.y_hero_wait(store, this, a.shoots_delay) then
						goto label_575_2
					end
				end

				SU.y_hero_animation_wait(this)
			end
		end

		skill = this.hero.skills.tower_runes
		a = attack_tower_runes

		if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.wave_group_number > 0 then
			local towers = attack_get_towers(a)

			if not towers then
				SU.delay_attack(store, a, fts(10))
			else
				local start_ts = store.tick_ts

				S:queue(a.sound)
				U.animation_start_group(this, a.animation, nil, store.tick_ts, false, this.render.sprites[1].group)

				if SU.y_hero_wait(store, this, a.cast_time) then
					goto label_575_2
				end

				towers = attack_get_towers(a)

				if not towers then
					SU.delay_attack(store, a, fts(60))
					SU.y_hero_animation_wait(this)

					goto label_575_2
				end

				towers = table.random_order(towers)
				towers = table.slice(towers, 1, a.max_targets)
				a.ts = start_ts

				SU.hero_gain_xp_from_skill(this, skill)

				for i = 1, #towers do
					local target = towers[i]

					if not store.entities[target.id] then
						-- block empty
					elseif not attack_is_tower_valid(target, a) then
						-- block empty
					else
						local b = E:create_entity(a.bullet)

						b.bullet.target_id = target.id
						b.bullet.source_id = this.id
						b.bullet.xp_dest_id = this.id
						b.pos = V.vclone(this.pos)

						local bullet_start_offset = v(0, 0)
						local af = this.render.sprites[1].flip_x

						if a.bullet_start_offset and #a.bullet_start_offset == 2 then
							local offset_index = af and 2 or 1

							bullet_start_offset = a.bullet_start_offset[offset_index]
						end

						b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
						b.pos.y = b.pos.y + bullet_start_offset.y
						b.bullet.from = V.vclone(b.pos)
						b.bullet.to = V.v(target.pos.x, target.pos.y + 16)

						queue_insert(store, b)

						if SU.y_hero_wait(store, this, a.shoots_delay) then
							goto label_575_2
						end
					end
				end

				SU.y_hero_animation_wait(this)
			end
		end

		skill = this.hero.skills.tower_plants
		a = attack_tower_plants

		if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.wave_group_number > 0 then
			local towers = attack_get_towers(a)

			if not towers then
				SU.delay_attack(store, a, fts(10))
			else
				local start_ts = store.tick_ts

				S:queue(a.sound)
				U.animation_start_group(this, a.animation, nil, store.tick_ts, false, this.render.sprites[1].group)

				if SU.y_hero_wait(store, this, a.cast_time) then
					goto label_575_2
				end

				towers = attack_get_towers(a)

				if not towers then
					SU.delay_attack(store, a, fts(60))
					SU.y_hero_animation_wait(this)

					goto label_575_2
				end

				towers = table.random_order(towers)
				towers = table.slice(towers, 1, a.max_targets)
				a.ts = start_ts

				SU.hero_gain_xp_from_skill(this, skill)

				for i = 1, #towers do
					local target = towers[i]

					if not store.entities[target.id] then
						-- block empty
					elseif not attack_is_tower_valid(target, a) then
						-- block empty
					else
						local b = E:create_entity(a.bullet)

						b.bullet.target_id = target.id
						b.bullet.source_id = this.id
						b.bullet.xp_dest_id = this.id
						b.pos = V.vclone(this.pos)

						local bullet_start_offset = v(0, 0)
						local af = this.render.sprites[1].flip_x

						if a.bullet_start_offset and #a.bullet_start_offset == 2 then
							local offset_index = af and 2 or 1

							bullet_start_offset = a.bullet_start_offset[offset_index]
						end

						b.pos.x = b.pos.x + (af and -1 or 1) * bullet_start_offset.x
						b.pos.y = b.pos.y + bullet_start_offset.y
						b.bullet.from = V.vclone(b.pos)
						b.bullet.to = V.vclone(target.tower.default_rally_pos)

						if target.tower.team == TEAM_LINIREA then
							b.bullet.hit_payload = a.plant_linirea
						else
							b.bullet.hit_payload = a.plant_dark_army
						end

						queue_insert(store, b)
						SU.y_hero_wait(store, this, a.shots_delay)
					end
				end

				SU.y_hero_animation_wait(this)
			end
		end

		SU.soldier_idle(store, this)

		this.render.sprites[3].flip_x = this.render.sprites[1].flip_x

		SU.soldier_regen(store, this)

		::label_575_2::

		coroutine.yield()
	end
end

scripts.bullet_hero_dragon_arb_breath_splint = {}

function scripts.bullet_hero_dragon_arb_breath_splint.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local function random_float(lower, greater)
		return lower + math.random() * (greater - lower)
	end

	this.tween.ts = store.tick_ts

	if this.size_variation then
		this.render.sprites[1].scale = V.vv(1 + random_float(-this.size_variation, this.size_variation))

		local speed_variation = random_float(-this.speed_variation, this.speed_variation)

		this.bullet.min_speed = this.bullet.min_speed + this.bullet.min_speed * speed_variation
		this.bullet.max_speed = this.bullet.max_speed + this.bullet.max_speed * speed_variation
	end

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

		if ps then
			ps.particle_system.emit = true
		end
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y

	local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.damage_flags, b.damage_bans)

	if targets and #targets > 0 then
		local mod_hit_times = {}

		for _, e in pairs(targets) do
			if e.health and not e.health.dead then
				local d = SU.create_bullet_damage(b, e.id, this.id)
				local u = UP:get_upgrade("mage_spell_of_penetration")

				if u and math.random() < u.chance then
					d.damage_type = DAMAGE_TRUE
				end

				queue_damage(store, d)

				local passive_mark_mod = E:create_entity(this.passive_mark_mod)

				passive_mark_mod.modifier.target_id = e.id
				passive_mark_mod.cached_controller_dragon_arb_passive_id = this.cached_controller_dragon_arb_passive_id

				queue_insert(store, passive_mark_mod)

				if b.mod then
					for _, v in pairs(b.mod) do
						do
							local mod = E:create_entity(v)

							if mod.chance and math.random() >= mod.chance then
								-- block empty
							else
								if mod.max_targets_per_hit then
									if not mod_hit_times[v] then
										mod_hit_times[v] = 0
									end

									if mod_hit_times[v] >= mod.max_targets_per_hit then
										goto label_585_0
									else
										mod_hit_times[v] = mod_hit_times[v] + 1
									end
								end

								mod.modifier.target_id = e.id

								if this.instakill_chance and e.vis and e.vis.flags and band(e.vis.flags, bor(F_MINIBOSS, F_BOSS)) == 0 then
									mod.instakill_chance = this.instakill_chance
								end

								mod.cached_controller_dragon_arb_passive_id = this.cached_controller_dragon_arb_passive_id

								queue_insert(store, mod)
							end
						end

						::label_585_0::
					end
				end
			end
		end
	end

	local terrain_type = band(GR:cell_type(this.pos.x, this.pos.y), TERRAIN_TYPES_MASK)

	if b.payload and terrain_type ~= TERRAIN_WATER then
		local hp = E:create_entity(table.random(b.payload))

		hp.pos.x, hp.pos.y = b.to.x, b.to.y

		local hp_s = hp.render.sprites[1]
		local this_s = this.render.sprites[1]

		hp_s.ts = store.tick_ts

		local hp_scale = hp_s.scale and V.vclone(hp_s.scale) or V.vv(1)
		local scale_diff = V.v(this_s.scale.x - hp_scale.x, this_s.scale.y - hp_scale.y)

		hp_s.scale = V.v(hp_scale.x + scale_diff.x * 0.5, hp_scale.y + scale_diff.y * 0.5)

		if b.from.x > b.to.x then
			hp_s.flip_x = true
		end

		queue_insert(store, hp)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.bullet_hero_dragon_arb_arborean_spawn = {}

function scripts.bullet_hero_dragon_arb_arborean_spawn.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local fm = this.force_motion
	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local iix, iiy = V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y)

	if this.initial_impulse_angle_variation_d then
		local variation_rad = math.rad(this.initial_impulse_angle_variation_d)

		variation_rad = -variation_rad + 2 * variation_rad * math.random()
		this.initial_impulse_angle_abs = this.initial_impulse_angle_abs + variation_rad
	end

	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

		if ps then
			ps.particle_system.emit = true
		end
	end

	while true do
		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y

	S:queue(this.sound_hit)
	table.insert(store.entities[this.cached_controller_dragon_arb_passive_id].root_zones_dequeue, this.zone_target_id)

	if b.payload then
		local hp = E:create_entity(b.payload)
		local nearest_nodes = P:nearest_nodes(b.to.x, b.to.y, nil, {
			1,
			2,
			3
		}, true)
		local pi, spi, ni = unpack(nearest_nodes[1])

		hp.nav_path.pi = pi
		hp.nav_path.ni = ni
		hp.nav_path.spi = spi
		hp.pos.x, hp.pos.y = b.to.x, b.to.y
		hp.render.sprites[1].ts = store.tick_ts

		queue_insert(store, hp)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.hero_dragon_arb_ultimate = {}

function scripts.hero_dragon_arb_ultimate.can_fire_fn(this, x, y)
	return true
end

function scripts.hero_dragon_arb_ultimate.update(this, store)
	S:queue(this.ultimate_sound)

	for _, v in pairs(store.entities) do
		if v.template_name == "hero_dragon_arb" then
			v.ultimate_active = true
			v.ultimate_ts = store.tick_ts

			local s_ult = v.hero.skills.ultimate

			if not U.has_modifiers(store, v, s_ult.mod) then
				local modifier = E:create_entity(s_ult.mod)

				modifier.modifier.target_id = v.id
				modifier.modifier.source_id = this.id

				queue_insert(store, modifier)

				for i, a in ipairs(v.timed_attacks.list) do
					if not a.disabled then
						a.ts = store.tick_ts - a.cooldown - store.tick_length
						if i == 2 then
							a.ts = a.ts + v.ranged.attacks[1].cooldown
						end
					end
				end
			end
		elseif table.contains(this.soldiers_target, v.template_name) and not v.health.dead then
			local mod = E:create_entity(this.soldiers_polymorph_mod)

			mod.modifier.target_id = v.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)
		end
	end

	queue_remove(store, this)
end

scripts.mod_hero_dragon_arb_ultimate = {}

function scripts.mod_hero_dragon_arb_ultimate.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or not target.unit then
		return false
	end

	if this.received_damage_factor then
		target.health.damage_factor = target.health.damage_factor * this.received_damage_factor
	end

	if this.inflicted_damage_factor then
		target.unit.damage_factor = target.unit.damage_factor * this.inflicted_damage_factor
	end

	if this.extra_armor then
		SU.armor_inc(target, this.extra_armor)
	end

	if this.extra_magic_armor then
		SU.magic_armor_inc(target, this.extra_magic_armor)
	end

	target.motion.max_speed = target.motion.max_speed * this.fast.factor

	U.sprites_show(target, this.ultimate_sid, this.ultimate_sid, true)

	target.tween.props[2].disabled = false
	target.tween.props[2].ts = store.tick_ts
	target.tween.reverse = false

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_hero_dragon_arb_ultimate.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if target and target.health and target.unit then
		if this.received_damage_factor then
			target.health.damage_factor = target.health.damage_factor / this.received_damage_factor
		end

		if this.inflicted_damage_factor then
			target.unit.damage_factor = target.unit.damage_factor / this.inflicted_damage_factor
		end

		if this.extra_armor then
			SU.armor_dec(target, this.extra_armor)
		end

		if this.extra_magic_armor then
			SU.magic_armor_dec(target, this.extra_magic_armor)
		end

		target.motion.max_speed = target.motion.max_speed / this.fast.factor

		U.sprites_hide(target, this.ultimate_sid, this.ultimate_sid, true)

		target.tween.props[2].disabled = false
		target.tween.props[2].ts = store.tick_ts
		target.tween.reverse = true
	end

	return true
end

function scripts.mod_hero_dragon_arb_ultimate.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local start_countdown = false

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end
end

scripts.soldier_hero_dragon_arb_spawn = {}

function scripts.soldier_hero_dragon_arb_spawn.get_info(this)
	local t = scripts.soldier_barrack.get_info(this)

	t.respawn = nil

	return t
end

function scripts.soldier_hero_dragon_arb_spawn.update(this, store, script)
	local attack = this.melee.attacks[1]
	local target
	local next_pos = V.vclone(this.pos)
	local brk, sta, nearest

	this.reinforcement.ts = store.tick_ts

	if this.doing_spawn_anim_ts == nil or this.doing_spawn_anim_ts then
		local spawn_anim_ts = this.spawn_anim_ts and this.spawn_anim_ts or store.tick_ts

		this.spawn_anim_ts = spawn_anim_ts

		U.y_animation_play(this, "spawn", nil, spawn_anim_ts, 1)

		this.doing_spawn_anim_ts = false
	end

	this.tween.ts = store.tick_ts

	if #this.tween.props > 1 then
		this.tween.props[3].disabled = false
	end

	local function break_fn()
		if this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			return true
		end

		return false
	end

	local function adjust_tween_for_despawn()
		this.tween.ts = store.tick_ts
		this.tween.props[1].disabled = false

		if #this.tween.props > 1 then
			this.tween.props[2].disabled = false
			this.tween.props[3].disabled = true
		end

		this.tween.remove = false
		this.tween.reverse = false
		this.tween.disabled = true
	end

	while true do
		if this.health.dead or not next_pos then
			this.ui.can_click = false

			adjust_tween_for_despawn()
			SU.y_soldier_death(store, this)
			queue_remove(store, this)

			return
		end

		if this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			this.ui.can_click = false

			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			adjust_tween_for_despawn()
			SU.y_soldier_death(store, this)
			queue_remove(store, this)

			return
		end

		if this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
		else
			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			else
				nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
					this.nav_path.pi
				}, {
					this.nav_path.spi
				})

				if nearest and nearest[1] and nearest[1][3] < this.nav_path.ni then
					this.nav_path.ni = nearest[1][3]
				end

				while next_pos and not target and not this.health.dead and not this.unit.is_stunned and not break_fn() do
					U.set_destination(this, next_pos)

					local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

					U.animation_start(this, an, af, store.tick_ts, -1)
					U.walk(this, store.tick_length)
					coroutine.yield()

					target = U.find_foremost_enemy(store.entities, this.pos, 0, this.melee.range, false, attack.vis_flags, attack.vis_bans)
					next_pos = P:next_entity_node(this, store.tick_length)

					if not next_pos or not P:is_node_valid(this.nav_path.pi, this.nav_path.ni) or GR:cell_is(next_pos.x, next_pos.y, bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) then
						next_pos = nil
					end
				end

				target = nil
			end
		end

		coroutine.yield()
	end
end

scripts.mod_hero_dragon_arb_bleed = {}

function scripts.mod_hero_dragon_arb_bleed.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead then
		return false
	end

	if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	if target and target.unit and this.render then
		local s = this.render.sprites[1]

		s.ts = store.tick_ts

		if s.size_names then
			s.name = s.size_names[target.unit.size]
		end

		if s.size_scales then
			s.scale = s.size_scales[target.unit.size]
		end

		if target.render then
			s.z = target.render.sprites[1].z
		end
	end

	this.dps.ts = store.tick_ts - this.dps.damage_every
	this.modifier.ts = store.tick_ts

	signal.emit("mod-applied", this, target)

	local passive_mark_mod = E:create_entity(this.passive_mark_mod)

	passive_mark_mod.modifier.target_id = target.id
	passive_mark_mod.cached_controller_dragon_arb_passive_id = this.cached_controller_dragon_arb_passive_id

	queue_insert(store, passive_mark_mod)

	return true
end

function scripts.mod_hero_dragon_arb_bleed.update(this, store, script)
	local cycles, total_damage = 0, 0
	local m = this.modifier
	local nodes_dt = 0
	local dps = this.dps
	local fx_ts = 0

	local function do_damage(target, value, damage_type)
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = damage_type
		d.pop = dps.pop
		d.pop_chance = dps.pop_chance
		d.pop_conds = dps.pop_conds

		queue_damage(store, d)

		local passive_mark_mod = E:create_entity(this.passive_mark_mod)

		passive_mark_mod.modifier.target_id = target.id
		passive_mark_mod.cached_controller_dragon_arb_passive_id = this.cached_controller_dragon_arb_passive_id

		queue_insert(store, passive_mark_mod)
	end

	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	if this.instakill_chance and not U.flag_has(target.vis.flags, this.instakill_vis_bans) and not U.flag_has(target.vis.bans, this.instakill_vis_flags) and math.random() < this.instakill_chance then
		do_damage(target, 0, DAMAGE_INSTAKILL)
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

		if store.tick_ts - m.ts >= m.duration - 1e-09 then
			if dps.damage_last then
				do_damage(target, dps.damage_last, dps.damage_type)
			end

			break
		end

		if this.render and m.use_mod_offset and target.unit.mod_offset then
			local so = this.render.sprites[1].offset

			so.x, so.y = target.unit.mod_offset.x, target.unit.mod_offset.y
		end

		if dps.damage_every and store.tick_ts - dps.ts >= dps.damage_every then
			cycles = cycles + 1
			dps.ts = dps.ts + dps.damage_every

			local damage = target.motion.max_speed * this.damage_speed_ratio

			do_damage(target, damage, dps.damage_type)

			if dps.fx and (not dps.fx_every or store.tick_ts - fx_ts >= dps.fx_every) then
				fx_ts = store.tick_ts

				local fx = E:create_entity(dps.fx)

				if dps.fx_tracks_target then
					fx.pos = target.pos

					if m.use_mod_offset and target.unit.mod_offset then
						fx.render.sprites[1].offset.x = target.unit.mod_offset.x
						fx.render.sprites[1].offset.y = target.unit.mod_offset.y
					end
				else
					fx.pos = V.vclone(this.pos)

					if m.use_mod_offset and target.unit.mod_offset then
						fx.pos.x, fx.pos.y = fx.pos.x + target.unit.mod_offset.x, fx.pos.y + target.unit.mod_offset.y
					end
				end

				fx.render.sprites[1].ts = store.tick_ts
				fx.render.sprites[1].runs = 0

				if fx.render.sprites[1].size_names then
					fx.render.sprites[1].name = fx.render.sprites[1].size_names[target.unit.size]
				end

				if fx.render.sprites[1].use_blood_color and target.unit.blood_color then
					fx.render.sprites[1].name = fx.render.sprites[1].name .. "_" .. target.unit.blood_color
				end

				if dps.fx_target_flip and target and target.render then
					fx.render.sprites[1].flip_x = target.render.sprites[1].flip_x
				end

				queue_insert(store, fx)
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.bullet_hero_dragon_arb_tower_buff = {}

function scripts.bullet_hero_dragon_arb_tower_buff.update(this, store, script)
	local b = this.bullet
	local mspeed = b.min_speed
	local target, ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if b.target_id then
		S:queue(this.sound_events.travel)
	else
		S:queue(this.sound_events.summon)
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		if b.target_id then
			target = store.entities[b.target_id]
		end

		if target then
			if b.max_track_distance then
				local d = math.max(math.abs(target.pos.x - b.to.x), math.abs(target.pos.y - b.to.y))

				if d > b.max_track_distance then
					b.target_id = nil
					target = nil
				end
			else
				b.to.x, b.to.y = target.pos.x, target.pos.y
			end
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		else
			this.render.sprites[1].r = 0
			this.render.sprites[1].flip_x = b.to.x < this.pos.x
		end

		if ps then
			ps.particle_system.emit_direction = this.render.sprites[1].r
		end

		coroutine.yield()
	end

	if target then
		local mod = E:create_entity(b.hit_mod)

		mod.modifier.target_id = target.id
		mod.modifier.source_id = b.source

		queue_insert(store, mod)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, sfx)
	end

	if this.tween then
		ps.particle_system.emit = false
		this.tween.disabled = false
		this.tween.ts = store.tick_ts

		U.y_wait(store, fts(10))
	end

	queue_remove(store, this)
end

scripts.mod_hero_dragon_arb_tower_buff = {}

function scripts.mod_hero_dragon_arb_tower_buff.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		this.pos = target.pos
	end

	m.ts = store.tick_ts

	if this.tween then
		this.tween.ts = store.tick_ts
	end

	U.y_animation_play_group(this, "start", nil, store.tick_ts, 1, this.render.sprites[1].group)
	U.animation_start_group(this, "idle", nil, store.tick_ts, true, this.render.sprites[1].group)

	while store.tick_ts - m.ts < m.duration - this.out_anim_duration do
		coroutine.yield()
	end

	U.y_animation_play_group(this, "end", nil, store.tick_ts, 1, this.render.sprites[1].group)
	queue_remove(store, this)
end

scripts.decal_hero_dragon_arb_tower_plant_linirea = {}

function scripts.decal_hero_dragon_arb_tower_plant_linirea.update(this, store, script)
	local a = this.bullet_attack

	this.spawn_ts = store.tick_ts
	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

	U.y_animation_play(this, "spawn", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	a.ts = store.tick_ts - a.cooldown

	while true do
		if store.tick_ts - this.spawn_ts > this.duration then
			SU.remove_modifiers(store, this)
			U.y_animation_play(this, "end", nil, store.tick_ts, 1)
			queue_remove(store, this)

			return
		end

		if store.tick_ts - a.ts > a.cooldown then
			local target = U.find_nearest_soldier(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans, function(v, origin)
				return v.health and not v.health.dead and v.health.hp < v.health.hp_max and not U.has_modifiers(store, v, a.mark_mod)
			end)

			if not target then
				SU.delay_attack(store, a, 0.2)
			else
				local mark_mod = E:create_entity(a.mark_mod)

				mark_mod.modifier.target_id = target.id
				mark_mod.modifier.source_id = this.id

				queue_insert(store, mark_mod)

				a.ts = store.tick_ts
				a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

				local b = E:create_entity(a.bullet)
				local shooting_right = this.pos.x < target.pos.x
				local boffset = a.bullet_start_offset[shooting_right and 1 or 2]

				b.bullet.from = V.v(this.pos.x + boffset.x, this.pos.y + boffset.y)
				b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
				b.bullet.target_id = target.id
				b.bullet.source_id = this.id
				b.pos = V.vclone(b.bullet.from)

				local target_pos = target.pos
				local an, af = U.animation_name_facing_point(this, a.animation, target_pos)

				U.animation_start(this, an, af, store.tick_ts, false)
				U.y_wait(store, a.shoot_time)
				queue_insert(store, b)
				S:queue("ArrowSound")
				U.y_animation_wait(this)
				U.animation_start(this, "idle", nil, store.tick_ts)
			end
		end

		coroutine.yield()
	end
end

scripts.decal_hero_dragon_arb_tower_plant_dark_army = {}

function scripts.decal_hero_dragon_arb_tower_plant_dark_army.update(this, store, script)
	local a = this.area_attack

	this.spawn_ts = store.tick_ts
	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

	U.y_animation_play(this, "spawn", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	a.ts = store.tick_ts - a.cooldown

	while true do
		if store.tick_ts - this.spawn_ts > this.duration then
			SU.remove_modifiers(store, this)
			U.y_animation_play(this, "end", nil, store.tick_ts, 1)
			queue_remove(store, this)

			return
		end

		if store.tick_ts - a.ts > a.cooldown then
			local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, a.hit_time, a.vis_flags, a.vis_bans)

			if not target or not pred_pos then
				-- block empty
			else
				a.ts = store.tick_ts

				S:queue(a.sound)

				local flip_x = pred_pos.x < this.pos.x

				U.animation_start(this, a.animation, flip_x, store.tick_ts, false)
				U.y_wait(store, a.hit_time)

				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if enemies and #enemies > 0 then
					local e = E:create_entity(a.aura)

					e.pos.x, e.pos.y = this.pos.x, this.pos.y
					e.owner = this
					e.aura.source_id = this.id

					queue_insert(store, e)
				end

				U.y_animation_wait(this)
			end
		end

		coroutine.yield()
	end
end

scripts.bullet_hero_dragon_arb_linirea_plant_heal = {}

function scripts.bullet_hero_dragon_arb_linirea_plant_heal.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local iix, iiy = V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			local d = math.max(math.abs(target.pos.x + hit_offset.x - b.to.x), math.abs(target.pos.y + hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)
	elseif b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	this.render.sprites[1].hidden = true

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if b.mod and target and not target.health.dead then
		local mod = E:create_entity(b.mod)

		mod.modifier.target_id = target.id
		mod.modifier.source_id = this.id

		queue_insert(store, mod)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.mod_hero_dragon_arb_plant_linirea_heal = {}

function scripts.mod_hero_dragon_arb_plant_linirea_heal.update(this, store, script)
	local m = this.modifier
	local hps = this.hps
	local duration = m.duration

	if m.duration_inc then
		duration = duration + m.level * m.duration_inc
	end

	local heal_min = hps.heal_min
	local heal_max = hps.heal_max

	if hps.heal_min_inc and hps.heal_max_inc then
		heal_min = hps.heal_min + m.level * hps.heal_min_inc
		heal_max = hps.heal_max + m.level * hps.heal_max_inc
	end

	if hps.heal_inc then
		heal_min = hps.heal_min + m.level * hps.heal_inc
		heal_max = hps.heal_max + m.level * hps.heal_inc
	end

	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	if target.unit and target.unit.size == UNIT_SIZE_LARGE then
		for _, v in pairs(this.render.sprites) do
			v.scale = V.v(1.4, 1.4)
		end
	end

	if target.vis and band(target.vis.flags, F_FLYING) ~= 0 then
		U.sprites_hide(this, 1, 2, true)
	end

	if target.render and target.render.sprites[1].z == Z_FLYING_HEROES then
		this.render.sprites[3].z = Z_FLYING_HEROES + 1
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or duration < store.tick_ts - m.ts then
			queue_remove(store, this)

			return
		end

		if this.render and m.use_mod_offset and target.unit.mod_offset then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				if not s.exclude_mod_offset then
					s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
				end
			end
		end

		if hps.heal_every and store.tick_ts - hps.ts >= hps.heal_every then
			hps.ts = store.tick_ts

			local hp_start = target.health.hp

			target.health.hp = target.health.hp + math.random(heal_min, heal_max)
			target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp)

			local heal_amount = target.health.hp - hp_start

			target.health.hp_healed = (target.health.hp_healed or 0) + heal_amount

			signal.emit("entity-healed", this, target, heal_amount)

			if hps.fx then
				local fx = E:create_entity(hps.fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts
				fx.render.sprites[1].runs = 0

				queue_insert(store, fx)
			end
		end

		coroutine.yield()
	end
end

scripts.mod_hero_dragon_arb_ultimate_paragons_polymorph = {}

function scripts.mod_hero_dragon_arb_ultimate_paragons_polymorph.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		this.target_ref = target

		for _, s in ipairs(target.render.sprites) do
			s.hidden = true
		end

		SU.remove_modifiers(store, target)
		SU.remove_auras(store, target)
		queue_remove(store, target)
		U.unblock_target(store, target)

		if target.ui then
			target.ui.can_click = false
		end

		target.main_script.co = nil
		target.main_script.runs = 0

		if target.count_group then
			target.count_group.in_limbo = true
		end

		local polymorph_template

		for k, v in pairs(this.entity_t) do
			if target.template_name == v[1] then
				polymorph_template = v[2]

				break
			end
		end

		local entity_poly = E:create_entity(polymorph_template)

		entity_poly.pos = target.pos
		entity_poly.nav_path = target.nav_path

		queue_insert(store, entity_poly)

		entity_poly.doing_spawn_anim_ts = target.doing_spawn_anim_ts
		entity_poly.spawn_anim_ts = target.spawn_anim_ts

		return true
	end

	return false
end

scripts.decal_hero_dragon_arb_passive_plant = {}

function scripts.decal_hero_dragon_arb_passive_plant.update(this, store)
	if this.delay then
		U.y_wait(store, this.delay)
	end

	local start_ts = store.tick_ts

	this.render.sprites[1].hidden = nil

	U.y_animation_play(this, "start", nil, store.tick_ts)

	while not this.destroy_plant do
		if U.find_first_target(store.entities, this.pos, 0, 25, this.vis_flags, this.vis_bans) then
			U.y_animation_play(this, "loop", nil, store.tick_ts, 1)
		end

		coroutine.yield()
	end

	U.y_wait(store, this.destroy_plant)
	U.y_animation_play(this, "end", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.controller_hero_dragon_arb_passive = {}

function scripts.controller_hero_dragon_arb_passive.update(this, store)
	local last_expansion_ts = store.tick_ts - this.zone_expansion_cooldown
	local available_paths = {}

	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end

	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, function(k, v)
			return not table.contains(store.level.ignore_walk_backwards_paths, v) and P:is_path_active(v)
		end)
	end

	this.root_zones_dequeue = {}
	this.root_zones_queue = {}
	this.root_zones = {}

	local zone_last_id = 1

	local function insert_root_zone(pos)
		local original_pos = V.vclone(pos)
		local nearest_nodes = P:nearest_nodes(pos.x, pos.y, nil, nil, true)

		if not nearest_nodes or #nearest_nodes < 1 then
			return
		end

		local pi, spi, ni = unpack(nearest_nodes[1])

		if band(GR:cell_type(pos.x, pos.y), bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) ~= 0 then
			return
		end

		local function is_over_other_zone()
			for _, v in pairs(this.root_zones) do
				if V.dist(v.x, v.y, pos.x, pos.y) <= this.zones_radius then
					return true
				end
			end

			return false
		end

		if is_over_other_zone() then
			local nodes_offset_plus = 0
			local nodes_offset_minus = 0
			local can_expand_plus = true
			local can_expand_minus = true
			local nodes_offset_inc = 3
			local found_new_pos = false

			while not found_new_pos and (can_expand_plus or can_expand_minus) do
				if can_expand_minus then
					nodes_offset_minus = nodes_offset_minus + nodes_offset_inc

					if P:is_node_valid(pi, ni - nodes_offset_minus) then
						pos = P:node_pos(pi, spi, ni - nodes_offset_minus)

						if band(GR:cell_type(pos.x, pos.y), bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) == 0 then
							if not is_over_other_zone() then
								found_new_pos = true
								can_expand_plus = false
								ni = ni - nodes_offset_minus
							end
						else
							can_expand_minus = false
						end
					else
						can_expand_minus = false
					end
				end

				if can_expand_plus then
					nodes_offset_plus = nodes_offset_plus + nodes_offset_inc

					if P:is_node_valid(pi, ni + nodes_offset_plus) then
						pos = P:node_pos(pi, spi, ni + nodes_offset_plus)

						if band(GR:cell_type(pos.x, pos.y), bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) == 0 then
							if not is_over_other_zone() then
								found_new_pos = true
								can_expand_minus = false
								ni = ni + nodes_offset_plus
							end
						else
							can_expand_plus = false
						end
					else
						can_expand_plus = false
					end
				end
			end

			if not found_new_pos then
				pos = V.vclone(original_pos)
			end
		end

		local zone = {}

		zone.x = pos.x
		zone.y = pos.y
		zone.ts = store.tick_ts + this.zones_duration
		zone.plant_decal_ids = {}
		zone.aura_entity = nil
		zone.zone_id = zone_last_id + 1
		zone_last_id = zone.zone_id

		local aura = E:create_entity(this.aura_slow)

		aura.aura.source_id = this.id
		aura.aura.ts = store.tick_ts
		aura.pos = {
			x = zone.x,
			y = zone.y
		}

		queue_insert(store, aura)

		zone.aura_entity = aura

		local nodes_count = this.zones_radius / P.average_node_dist
		local ni_inc = 2

		for i = 1, nodes_count do
			local spi = km.zmod(i, 3)

			if P:is_node_valid(pi, ni) then
				local root_pos = P:node_pos(pi, spi, ni)
				local in_another_zone = false

				for _, v in pairs(this.root_zones) do
					if V.dist(v.x, v.y, root_pos.x, root_pos.y) <= this.zones_radius then
						in_another_zone = true

						break
					end

					if v.plant_decals_ids then
						for _, other_zone_root_id in pairs(v.plant_decals_ids) do
							local o_root = store.entities[other_zone_root_id]

							if o_root and V.dist(o_root.pos.x, o_root.pos.y, root_pos.x, root_pos.y) < 20 then
								in_another_zone = true

								break
							end
						end

						if in_another_zone then
							break
						end
					end
				end

				if not in_another_zone then
					root_pos.x, root_pos.y = root_pos.x + math.random(0, 8), root_pos.y + math.random(0, 8)

					local root = E:create_entity(this.plant_decal .. "_" .. math.random(1, 2, 3))

					root.render.sprites[1].flip_x = math.random() < 0.5
					root.delay = U.frandom(0, 0.3)
					root.pos = root_pos
					root.path_i = pi
					root.node_i = ni
					root.s_path_i = spi

					queue_insert(store, root)
					table.insert(zone.plant_decal_ids, root.id)
				end
			end

			if i % 3 == 0 then
				ni = ni - ni_inc - math.random(2, 3)
			end
		end

		table.insert(this.root_zones, zone)
	end

	local function process_new_zones_queue()
		if store.tick_ts >= last_expansion_ts + this.zone_expansion_cooldown and #this.root_zones_queue > 0 then
			insert_root_zone(this.root_zones_queue[1])

			this.root_zones_queue = {}
			last_expansion_ts = store.tick_ts
		end
	end

	local function process_zones()
		for i = #this.root_zones, 1, -1 do
			local zone = this.root_zones[i]
			local is_in_dequeue = false

			if table.contains(this.root_zones_dequeue, zone.zone_id) then
				is_in_dequeue = true

				table.removeobject(this.root_zones_dequeue, zone.zone_id)
			end

			if store.tick_ts >= zone.ts or is_in_dequeue then
				for _, v in pairs(zone.plant_decal_ids) do
					local plant_decal = store.entities[v]
					local in_range_of_another_zone = false

					for i2 = 1, #this.root_zones do
						if i2 ~= i then
							local zone2 = this.root_zones[i2]

							if V.dist(plant_decal.pos.x, plant_decal.pos.y, zone2.x, zone2.y) <= this.zones_radius then
								in_range_of_another_zone = true

								table.insert(zone2.plant_decal_ids, plant_decal.id)

								break
							end
						end
					end

					if not in_range_of_another_zone then
						plant_decal.destroy_plant = math.random() * 0.5
					end
				end

				queue_remove(store, zone.aura_entity)
				table.remove(this.root_zones, i)
			end
		end
	end

	while true do
		process_new_zones_queue()
		process_zones()
		coroutine.yield()
	end
end

scripts.mod_hero_dragon_arb_passive_mark = {}

function scripts.mod_hero_dragon_arb_passive_mark.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return false
	end

	if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	if target.health.dead then
		table.insert(store.entities[this.cached_controller_dragon_arb_passive_id].root_zones_queue, {
			x = target.pos.x,
			y = target.pos.y
		})

		return false
	end

	this.modifier.ts = store.tick_ts

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_hero_dragon_arb_passive_mark.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target or not target.health.dead then
		return true
	end

	table.insert(store.entities[this.cached_controller_dragon_arb_passive_id].root_zones_queue, {
		x = target.pos.x,
		y = target.pos.y
	})

	return true
end

scripts.hero_spider = {}

function scripts.hero_spider.level_up(this, store, initial)
	local hl = this.hero.level
	local ls = this.hero.level_stats

	this.health.hp_max = ls.hp_max[hl]
	this.regen.health = ls.regen_health[hl]
	this.health.armor = ls.armor[hl]
	this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
	this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]

	local bt = E:get_template(this.ranged.attacks[1].bullet)

	bt.bullet.damage_min = ls.ranged_damage_min[hl]
	bt.bullet.damage_max = ls.ranged_damage_max[hl]

	local melee_dot = E:get_template(this.melee.attacks[1].mod)

	melee_dot.dps.damage_min = ls.melee_dot_damage_min[hl]
	melee_dot.dps.damage_max = ls.melee_dot_damage_max[hl]

	local s, sl

	s = this.hero.skills.instakill_melee
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - INSTAKILL_MELEE - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[1]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.life_threshold = s.life_threshold[sl]
	end

	s = this.hero.skills.area_attack
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - AREA ATTACK - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[2]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
	end

	s = this.hero.skills.tunneling
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - TUNNELING - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[3]

		a.disabled = nil
	end

	s = this.hero.skills.supreme_hunter
	sl = s.level

	if sl > 0 and initial then
		log.info("LEVELUP - %s - %i - SUPREME HUNTER - %i", this.template_name, hl, sl)

		local a = this.timed_attacks.list[4]

		a.disabled = nil
		a.cooldown = s.cooldown[sl]
		a.damage_min = s.damage_min[sl]
		a.damage_max = s.damage_max[sl]
	end

	s = this.hero.skills.ultimate
	sl = s.level

	if sl > 0 then
		log.info("LEVELUP - %s - %i - ULTIMATE - %i", this.template_name, hl, sl)

		local uc = E:get_template(s.controller_name)

		uc.cooldown = s.cooldown[sl]
		uc.spawn_amount = s.spawn_amount[sl]

		local spider = E:get_template(uc.spider)

		spider.reinforcement.duration = s.duration[sl]
		spider.health.hp_max = s.hp[sl]
		spider.melee.attacks[1].damage_min = s.damage_min[sl]
		spider.melee.attacks[1].damage_max = s.damage_max[sl]
	end

	this.health.hp = this.health.hp_max
	this.hero.melee_active_status = {}

	for index, attack in ipairs(this.melee.attacks) do
		this.hero.melee_active_status[index] = attack.disabled
	end
end

function scripts.hero_spider.insert(this, store)
	this.hero.fn_level_up(this, store, true)

	this.melee.order = U.attack_order(this.melee.attacks)
	this.ranged.order = U.attack_order(this.ranged.attacks)

	return true
end

function scripts.hero_spider.update(this, store)
	local h = this.health
	local brk, sta
	local last_ts = store.tick_ts
	local a, skill
	local instakill_on_melee_attack = this.timed_attacks.list[1]
	local area_attack_attack = this.timed_attacks.list[2]
	local tunneling_attack = this.timed_attacks.list[3]
	local supreme_hunter_attack = this.timed_attacks.list[4]

	if not instakill_on_melee_attack.disabled then
		instakill_on_melee_attack.ts = store.tick_ts - instakill_on_melee_attack.cooldown
	end

	if not area_attack_attack.disabled then
		area_attack_attack.ts = store.tick_ts - area_attack_attack.cooldown
	end

	if not supreme_hunter_attack.disabled then
		supreme_hunter_attack.ts = store.tick_ts - supreme_hunter_attack.cooldown
	end

	local function y_hero_spider_new_rally(store, this)
		local r = this.nav_rally

		if r.new then
			r.new = false

			U.unblock_target(store, this)

			if this.sound_events then
				S:queue(this.sound_events.change_rally_point)
			end

			if SU.hero_will_teleport(this, r.pos) then
				local tp = this.teleport
				local vis_bans = this.vis.bans

				this.vis.bans = F_ALL
				this.health.ignore_damage = true
				this.health_bar.hidden = true

				local an, af = U.animation_name_facing_point(this, tp.animations[1], r.pos)

				U.animation_start(this, an, af, store.tick_ts, 1, nil)
				U.y_wait(store, fts(16))
				S:queue(tp.sound_in)

				if tp.fx_out then
					local fx = E:create_entity(tp.fx_out)

					fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
					fx.render.sprites[1].ts = store.tick_ts
					fx.render.sprites[2].ts = store.tick_ts

					if fx.tween then
						fx.tween.ts = store.tick_ts
					end

					queue_insert(store, fx)
				end

				SU.y_hero_animation_wait(this)

				skill = this.hero.skills.tunneling
				a = tunneling_attack

				U.sprites_hide(this, nil, nil, true)

				if tp.delay > 0 then
					U.y_wait(store, tp.delay)
				end

				S:queue(tp.sound_appear)

				local fx_approach = E:create_entity("fx_hero_spider_teleport_approach")

				fx_approach.pos.x, fx_approach.pos.y = r.pos.x, r.pos.y
				fx_approach.render.sprites[1].ts = store.tick_ts

				if r.pos.x < this.pos.x then
					fx_approach.render.sprites[1].flip_x = true
				end

				queue_insert(store, fx_approach)
				U.y_wait(store, tp.duration)

				fx_approach.leave = true

				U.sprites_show(this, nil, nil, true)

				this.pos.x, this.pos.y = r.pos.x, r.pos.y

				U.set_destination(this, this.pos)

				this.motion.speed.x, this.motion.speed.y = 0, 0

				if tp.fx_in then
					local fx = E:create_entity(tp.fx_in)

					fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
					fx.render.sprites[1].ts = store.tick_ts
					fx.render.sprites[2].ts = store.tick_ts

					if fx.tween then
						fx.tween.ts = store.tick_ts
					end

					queue_insert(store, fx)
				end

				S:queue(tp.sound_out)

				if not a.disabled then
					local decal = E:create_entity(a.hit_decal)

					decal.pos.x, decal.pos.y = this.pos.x, this.pos.y
					decal.render.sprites[1].ts = store.tick_ts

					queue_insert(store, decal)

					local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.damage_radius, 0, a.vis_flags, a.vis_bans_damage)

					if target and targets then
						for _, enemy in ipairs(targets) do
							if enemy and not enemy.dead then
								local d = E:create_entity("damage")

								d.damage_type = a.damage_type
								d.value = math.random(a.damage_min[skill.level], a.damage_max[skill.level])
								d.source_id = this.id
								d.target_id = enemy.id

								queue_damage(store, d)
							end
						end
					end

					SU.hero_gain_xp_from_skill(this, skill)
				end

				U.y_animation_play(this, tp.animations[2], nil, store.tick_ts)

				this.health_bar.hidden = false
				this.vis.bans = vis_bans
				this.health.ignore_damage = false

				return true
			else
				local vis_bans = this.vis.bans
				local prev_immune = this.health.immune_to

				this.vis.bans = F_ALL
				this.health.immune_to = r.immune_to

				local out = SU.y_hero_walk_waypoints(store, this)

				U.animation_start(this, "idle", nil, store.tick_ts, true)

				this.vis.bans = vis_bans
				this.health.immune_to = prev_immune

				return out
			end
		end
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true)

	this.health_bar.hidden = false

	while true do
		if h.dead then
			SU.y_hero_death_and_respawn_kr5(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if y_hero_spider_new_rally(store, this) then
					goto label_734_1
				end
			end

			SU.heroes_visual_learning_upgrade(store, this)
			SU.heroes_lone_wolves_upgrade(store, this)
			SU.alliance_merciless_upgrade(store, this)
			SU.alliance_corageous_upgrade(store, this)

			skill = this.hero.skills.instakill_melee
			a = instakill_on_melee_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				if this.soldier.target_id == nil then
					SU.delay_attack(store, a, fts(5))
				elseif not this.motion.arrived then
					SU.delay_attack(store, a, fts(5))
				else
					local target = store.entities[this.soldier.target_id]

					if not target then
						SU.delay_attack(store, a, fts(5))
					else
						local is_boss = U.flag_has(target.vis.flags, bor(F_BOSS, F_MINIBOSS))

						if is_boss then
							SU.delay_attack(store, a, fts(5))
						elseif target.health.dead then
							SU.delay_attack(store, a, fts(5))
						elseif not target.unit.is_stunned then
							SU.delay_attack(store, a, fts(5))
						else
							local health_to_compare = a.use_current_health_instead_of_max and target.health.hp or target.health.hp_max

							if health_to_compare > a.life_threshold then
								SU.delay_attack(store, a, fts(5))
							else
								last_ts = store.tick_ts

								local an, af, ai = U.animation_name_facing_point(this, a.animation, target.pos)

								U.animation_start(this, an, af, store.tick_ts, false)
								S:queue("HeroSpiderInstakill")
								U.y_wait(store, a.shoot_time)

								local m = E:create_entity(a.mod)

								m.modifier.target_id = target.id
								m.modifier.source_id = this.id

								queue_insert(store, m)

								a.ts = last_ts

								SU.hero_gain_xp_from_skill(this, skill)
								U.y_animation_wait(this)

								goto label_734_1
							end
						end
					end
				end
			end

			a = this.timed_attacks.list[2]
			skill = this.hero.skills.area_attack

			if not a.disabled and store.tick_ts - a.ts > a.cooldown and store.tick_ts - last_ts > a.min_cooldown then
				local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.damage_radius, 0, a.vis_flags, a.vis_bans_trigger)

				if not targets or #targets < a.min_targets or not pred_pos then
					SU.delay_attack(store, a, fts(10))
				else
					local start_ts = store.tick_ts
					local an, af = U.animation_name_facing_point(this, a.animation, pred_pos)

					U.animation_start(this, an, af, store.tick_ts, 1, nil)
					S:queue(a.sound)

					if SU.y_hero_wait(store, this, a.cast_time) then
						goto label_734_1
					end

					local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.damage_radius, 0, a.vis_flags, a.vis_bans_damage)

					if target and targets then
						for _, enemy in ipairs(targets) do
							if enemy and not enemy.dead then
								local d = E:create_entity("damage")

								d.damage_type = a.damage_type
								d.value = math.random(a.damage_min[skill.level], a.damage_max[skill.level])
								d.source_id = this.id
								d.target_id = enemy.id

								queue_damage(store, d)

								local mod = E:create_entity(a.mod)

								mod.modifier.target_id = enemy.id
								mod.modifier.source_id = this.id
								mod.modifier.duration = fts(skill.stun_time[skill.level])

								queue_insert(store, mod)

								local decal = E:create_entity(a.hit_decal)

								decal.pos = V.vclone(this.pos)
								decal.render.sprites[1].ts = store.tick_ts

								queue_insert(store, decal)
							end
						end
					end

					SU.y_hero_animation_wait(this)

					a.ts = start_ts
					last_ts = a.ts

					SU.hero_gain_xp_from_skill(this, skill)

					if not this.timed_attacks.list[4].disabled and this.timed_attacks.list[4].cooldown - (store.tick_ts - this.timed_attacks.list[4].ts) < 1 then
						this.timed_attacks.list[4].ts = store.tick_ts - this.timed_attacks.list[4].cooldown + 1
					end

					goto label_734_1
				end
			end

			a = this.timed_attacks.list[4]
			skill = this.hero.skills.supreme_hunter

			if not a.disabled and store.tick_ts - a.ts > a.cooldown then
				local blocked_enemy = this.soldier.target_id and store.entities[this.soldier.target_id]

				if not blocked_enemy and SU.soldier_pick_melee_target(store, this) then
					SU.delay_attack(store, a, 0.3333333333333333)

					goto label_734_0
				end

				local targets = U.find_enemies_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans, function(e)
					local ni_s = P:get_visible_start_node(e.nav_path.pi)
					local ni_e = P:get_visible_end_node(e.nav_path.pi)

					return e ~= blocked_enemy and e.nav_path.ni > ni_s + a.node_margin and e.nav_path.ni < ni_e - a.node_margin
				end)

				if not targets then
					SU.delay_attack(store, a, 0.3333333333333333)

					goto label_734_0
				end

				table.sort(targets, function(e1, e2)
					return e1.health.hp > e2.health.hp
				end)

				local target = targets[1]
				local initial_pos = V.vclone(this.pos)
				local initial_flip = this.render.sprites[1].flip_x
				local _bans = this.vis.bans

				this.vis.bans = F_ALL
				this.health.ignore_damage = true

				S:queue(a.sound_supreme)
				U.animation_start(this, a.animations[1], nil, store.tick_ts)
				U.y_wait(store, fts(14))

				this.health_bar.hidden = true

				U.y_wait(store, fts(3))

				if U.is_blocked_valid(store, this) then
					local blocked = store.entities[this.soldier.target_id]
					local m = E:create_entity("mod_hero_spider_stun")

					m.modifier.target_id = blocked.id
					m.modifier.source_id = this.id

					queue_insert(store, m)
				end

				U.y_animation_wait(this)

				local m = E:create_entity("mod_hero_spider_stun")

				m.modifier.target_id = target.id
				m.modifier.source_id = this.id

				queue_insert(store, m)

				local lpos, lflip = U.melee_slot_position(this, target, 2)

				this.pos.x, this.pos.y = lpos.x, lpos.y

				U.animation_start(this, a.animations[2], lflip, store.tick_ts)
				U.y_wait(store, fts(20))

				this.health_bar.hidden = nil

				queue_damage(store, SU.create_attack_damage(a, target.id, this.id))
				U.y_animation_wait(this)

				if this.nav_rally.new then
					this.nav_rally.new = false
					this.pos.x, this.pos.y = this.nav_rally.pos.x, this.nav_rally.pos.y
				else
					this.pos.x, this.pos.y = initial_pos.x, initial_pos.y
				end

				U.animation_start(this, a.animations[3], initial_flip, store.tick_ts)
				U.y_wait(store, fts(5))

				this.health_bar.hidden = nil
				this.vis.bans = _bans
				this.health.ignore_damage = nil

				U.y_animation_wait(this)
				SU.hero_gain_xp_from_skill(this, skill)

				a.ts = store.tick_ts
			end

			::label_734_0::

			if SU.hero_level_up(store, this) then
				U.y_animation_play(this, "level_up", nil, store.tick_ts, 1)
			end

			brk, sta = y_hero_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			else
				brk, sta = y_hero_ranged_attacks(store, this)

				if brk then
					-- block empty
				elseif SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_734_1::

		coroutine.yield()
	end
end

scripts.fx_hero_spider_teleport_approach = {}

function scripts.fx_hero_spider_teleport_approach.update(this, store)
	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "loop", nil, store.tick_ts, true, 1, true)

	while not this.leave do
		coroutine.yield()
	end

	U.y_animation_play(this, "run", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.mod_hero_spider_skill_instakill_melee = {}

function scripts.mod_hero_spider_skill_instakill_melee.insert(this, store)
	local target = store.entities[this.modifier.target_id]
	local m = this.modifier

	if not target then
		return false
	end

	if band(target.vis.flags, this.modifier.vis_bans) ~= 0 then
		return false
	end

	if band(target.vis.bans, this.modifier.vis_flags) ~= 0 then
		return false
	end

	SU.stun_inc(target)

	target.vis.bans = F_ALL
	target.ui.can_click = false
	target.ui.can_select = false
	target.health_bar.hidden = true

	return true
end

function scripts.mod_hero_spider_skill_instakill_melee.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos
	start_ts = store.tick_ts

	local d = E:create_entity("damage")

	d.damage_type = bor(DAMAGE_INSTAKILL, DAMAGE_FX_NOT_EXPLODE, DAMAGE_NO_SPAWNS, DAMAGE_IGNORE_SHIELD)
	d.source_id = this.id
	d.target_id = target.id

	queue_damage(store, d)

	this._not_interrupted = true
	this.pos = target.pos

	U.y_animation_play(this, "run", nil, store.tick_ts, 1)
	queue_remove(store, this)
end

scripts.controller_hero_spider_ultimate = {}

function scripts.controller_hero_spider_ultimate.can_fire_fn(this, x, y)
	return GR:cell_is_only(x, y, TERRAIN_LAND) and P:valid_node_nearby(x, y, nil, NF_RALLY)
end

function scripts.controller_hero_spider_ultimate.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, true, NF_POWER_3)

	if #nodes < 1 then
		log.error("controller_hero_spider_ultimate: could not find valid node")
		queue_remove(store, this)

		return
	end

	local x, y = this.pos.x, this.pos.y
	local spawn_formations = {
		{
			V.v(x, y)
		},
		{
			V.v(x + 12, y - 12),
			V.v(x - 12, y + 12)
		},
		{
			V.v(x + 14, y - 12),
			V.v(x - 14, y - 12),
			V.v(x, y + 12)
		},
		{
			V.v(x + 12, y - 12),
			V.v(x - 12, y + 12),
			V.v(x - 16, y - 12),
			V.v(x + 16, y + 12)
		},
		{
			V.v(x, y),
			V.v(x + 14, y - 17),
			V.v(x - 14, y + 17),
			V.v(x - 22, y - 13),
			V.v(x + 22, y + 13)
		}
	}

	if this.spawn_amount > #spawn_formations then
		this.spawn_amount = #spawn_formations
	end

	local spawn_positions = spawn_formations[this.spawn_amount]

	if this.spawn_fx then
		for _, pos in pairs(spawn_positions) do
			local fx = E:create_entity(this.spawn_fx)

			fx.pos = V.vclone(pos)
			fx.render.sprites[1].ts = store.tick_ts
			fx.nav_rally = V.v(x, y)
			fx.squad_id = this.id

			queue_insert(store, fx)
			U.y_wait(store, U.frandom(0, 0.2))
		end

		U.y_wait(store, 0.4)
		S:queue(this.spawn_sound)
		U.y_wait(store, 0.4)
	end

	queue_remove(store, this)
end

scripts.mod_soldier_hero_spider_ultimate_stun = {}

function scripts.mod_soldier_hero_spider_ultimate_stun.insert(this, store, script)
	if math.random(0, 100) > this.stun_chance * 100 then
		return false
	end

	return scripts.mod_stun.insert(this, store, script)
end

scripts.fx_hero_spider_ultimate_spawn = {}

function scripts.fx_hero_spider_ultimate_spawn.update(this, store)
	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "loop", false, store.tick_ts, true)
	U.y_wait(store, 0.5)
	U.animation_start(this, "out", nil, store.tick_ts)
	S:queue(this.spawn_sound)

	local fx = E:create_entity(this.spawn_fx_decal)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	local e = E:create_entity(this.spider)

	e.pos = V.vclone(this.pos)
	e.nav_rally.center = V.vclone(this.nav_rally)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.squad_id

	queue_insert(store, e)

	while not U.animation_finished(this) do
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.soldier_reinforcement_kr5 = {}

function scripts.soldier_reinforcement_kr5.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts

	signal.emit("spawned-reinforcement", this)

	if this.reinforcement.fade or this.reinforcement.fade_in then
		SU.y_reinforcement_fade_in(store, this)
	elseif this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.health_bar.hidden = true

		U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if this.health.dead then
			this.reinforcement.fade = false
			this.reinforcement.fade_out = false
			this.ui.can_click = false
			this.tween = nil

			SU.y_soldier_death(store, this)

			return
		end

		if this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0
			this.ui.can_click = false

			SU.remove_modifiers(store, this)
			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			while this.nav_rally.new do
				if this.nav_rally.move_order then
					U.y_wait(store, this.nav_rally.move_order * math.random() * 0.3)
				end

				if SU.y_hero_new_rally(store, this) then
					goto label_481_1
				end
			end

			if this.dodge and this.dodge.active then
				this.dodge.active = false

				if this.dodge.animation then
					U.animation_start(this, this.dodge.animation, nil, store.tick_ts, 1)

					while not U.animation_finished(this) do
						coroutine.yield()
					end
				end

				signal.emit("soldier-dodge", this)
			end

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_481_1
				end
			end

			if this.ranged then
				brk, star = SU.y_soldier_ranged_attacks(store, this)

				if brk or star == A_DONE then
					goto label_481_1
				elseif star == A_IN_COOLDOWN then
					goto label_481_0
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				goto label_481_1
			end

			if SU.soldier_go_back_step(store, this) then
				goto label_481_1
			end

			::label_481_0::

			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_481_1::

		coroutine.yield()
	end
end

scripts.soldier_reinforcement_special_dark_army = {}

function scripts.soldier_reinforcement_special_dark_army.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts

	local raise_arms_cd = 3
	local raise_arms_ts = store.tick_ts - raise_arms_cd

	this.crows_idle = true

	signal.emit("spawned-reinforcement", this)

	for i = 1, 2 do
		local c = E:create_entity(this.crow_entity)

		c.pos = V.vclone(this.pos)

		if i == 0 then
			c.pos.x, c.pos.y = this.pos.x - c.orbit_radius, this.pos.y - c.flight_height
		else
			c.pos.x, c.pos.y = this.pos.x + c.orbit_radius, this.pos.y + c.flight_height
		end

		c.owner = this
		c.crow_id = i

		queue_insert(store, c)
	end

	if this.reinforcement.fade or this.reinforcement.fade_in then
		SU.y_reinforcement_fade_in(store, this)
	elseif this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.health_bar.hidden = true

		U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if this.health.dead then
			this.reinforcement.fade = false
			this.reinforcement.fade_out = false
			this.tween = nil

			SU.y_soldier_death(store, this)

			return
		end

		if this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			while this.nav_rally.new do
				if SU.y_hero_new_rally(store, this) then
					goto label_482_0
				end
			end

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_482_0
				end
			end

			if this.crows_idle and this.raise_arms and raise_arms_cd < store.tick_ts - raise_arms_ts then
				local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, this.crows_range)

				if target then
					U.y_animation_play(this, "attack", target.pos.x < this.pos.x, store.tick_ts)
				end

				raise_arms_ts = store.tick_ts
				this.raise_arms = false
				this.crows_idle = false

				goto label_482_0
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_482_0::

		coroutine.yield()
	end
end

scripts.crow_reinforcement_special_dark_army = {}

function scripts.crow_reinforcement_special_dark_army.update(this, store)
	local sd = this.render.sprites[1]
	local ss = this.render.sprites[2]
	local a = this.melee.attacks[1]
	local fm = this.force_motion
	local attack_ts, search_ts = 0, 0
	local target, targets, dist
	local dest = V.v(this.pos.x, this.pos.y)

	this.start_ts = store.tick_ts

	local orbit_phase = 0

	fm.a_step = fm.a_step + math.random(-3, 3)
	this.tween.ts = U.frandom(0, 1)

	local oos = {
		V.v(-20, 0),
		V.v(20, 7)
	}
	local oo = oos[this.crow_id]

	if this.crow_id == 1 then
		this.tween.ts = store.tick_ts
	else
		this.tween.ts = store.tick_ts - 1
	end

	U.animation_start(this, "idle", true, store.tick_ts, true)

	while true do
		if this.owner.reinforcement.duration and store.tick_ts - this.owner.reinforcement.ts > this.owner.reinforcement.duration then
			break
		end

		if this.owner.health.dead or this.owner.health.hp == 0 then
			U.y_animation_play(this, "death", false, store.tick_ts)
			queue_remove(store, this)

			return
		end

		target, targets = U.find_foremost_enemy(store.entities, this.owner.pos, 0, this.target_range, 0, a.vis_flags, a.vis_bans)

		if target and store.tick_ts - this.start_ts > 0.7 then
			this.owner.raise_arms = true

			::label_483_0::

			repeat
				dest.x, dest.y = target.pos.x + oo.x + target.unit.hit_offset.x, target.pos.y + oo.y + target.unit.hit_offset.y
				sd.flip_x = dest.x < this.pos.x

				U.force_motion_step(this, store.tick_length, dest)
				coroutine.yield()

				dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)

				if this.owner.reinforcement.duration and store.tick_ts - this.owner.reinforcement.ts > this.owner.reinforcement.duration then
					goto label_483_1
				end
			until dist < a.range or target.health.dead or band(a.vis_flags, target.vis.bans) ~= 0

			if store.entities[target.id] and not target.health.dead and band(a.vis_flags, target.vis.bans) == 0 then
				if math.random() < a.sound_chance then
					S:queue(a.sound)
				end

				local an, af = U.animation_name_facing_point(this, a.animation, target.pos, 1)

				U.animation_start(this, an, af, store.tick_ts, 1)

				local d = SU.create_attack_damage(a, target.id, this.id)

				queue_damage(store, d)

				local fx = E:create_entity(a.hit_fx)

				fx.pos.x, fx.pos.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
				fx.render.sprites[1].ts = store.tick_ts
				fx.render.sprites[1].runs = 0

				queue_insert(store, fx)

				while not U.animation_finished(this) do
					U.force_motion_step(this, store.tick_length, dest)

					sd.flip_x = this.pos.x > target.pos.x

					coroutine.yield()
				end

				U.animation_start(this, "idle", nil, store.tick_ts, true)
				U.y_wait(store, a.cooldown)

				local dx, dy = V.sub(target.pos.x, target.pos.y, this.owner.pos.x, this.owner.pos.y)
				local dist2 = V.len2(dx, dy)

				attack_ts = store.tick_ts

				if this.owner.reinforcement.duration and store.tick_ts - this.owner.reinforcement.ts > this.owner.reinforcement.duration then
					break
				end

				if this.owner.health.dead or this.owner.health.hp == 0 then
					U.y_animation_play(this, "death", false, store.tick_ts)
					queue_remove(store, this)

					return
				end

				if not target.health.dead and dist2 < this.chase_range * this.chase_range then
					goto label_483_0
				end
			end
		end

		orbit_phase = orbit_phase + this.orbit_speed * store.tick_length

		local a = (this.crow_id * math.pi + orbit_phase) % (2 * math.pi)
		local orb_center = V.vclone(this.owner.pos)

		orb_center.y = orb_center.y + this.flight_height

		local dest = U.point_on_ellipse(orb_center, this.orbit_radius, a)

		this.render.sprites[1].flip_x = dest.x < this.pos.x

		U.force_motion_step(this, store.tick_length, dest)

		this.owner.raise_arms = false
		this.owner.crows_idle = true

		coroutine.yield()
	end

	::label_483_1::

	U.y_ease_keys(store, {
		sd,
		sd.offset,
		ss
	}, {
		"alpha",
		"y",
		"alpha"
	}, {
		255,
		this.flight_height,
		255
	}, {
		0,
		85,
		0
	}, 0.4)
	queue_remove(store, this)
end

scripts.relics = {}

function scripts.relics.default_insert(this, store, script)
	local hero = store.entities[this.relic.owner_id]

	this.relic.fn_level_up(this, store, hero)

	return true
end

scripts.relic_none = {}

function scripts.relic_none.fn_level_up(this, store, hero)
	local hl = hero.hero.level

	log.info("%s - level up - hl:%i", this.template_name, hl)

	local rl = GS.relic_lvl_steps[hl]

	if rl then
		this.relic.level = rl

		log.info("%s - level up - rl:%i", this.template_name, rl)
	end
end

scripts.relic_banner_of_command = {}

function scripts.relic_banner_of_command.fn_level_up(this, store, hero)
	local hl = hero.hero.level

	log.info("%s - level up - hl:%i", this.template_name, hl)

	local b = this.balance
	local rl = GS.relic_lvl_steps[hl]

	if rl then
		this.relic.level = rl

		log.info("%s - level up - rl:%i", this.template_name, rl)

		this.cooldown = b.cooldown[rl]

		local soldier = E:get_template(this.soldier_template)
		local bs = b.soldier

		soldier.melee.attacks[1].damage_max = bs.damage_max[rl]
		soldier.melee.attacks[1].damage_min = bs.damage_min[rl]
		soldier.health.hp_max = bs.hp[rl]
		soldier.health.armor = bs.armor[rl]
		soldier.regen.health = bs.regen_health[rl]
	end
end

function scripts.relic_banner_of_command.update(this, store, script)
	local last_ts = store.tick_ts
	local owner_id = this.relic.owner_id

	local function distribute_summons(x, y, qty)
		if qty < 1 then
			return nil
		end

		local nodes = P:nearest_nodes(x, y, nil, nil, true)

		if #nodes < 1 then
			log.debug("cannot insert summons, no valid nodes nearby %s,%s", x, y)

			return nil
		end

		local opi, ospi, oni = unpack(nodes[1])
		local offset_options = {
			-4,
			-6,
			-8,
			4,
			6,
			8
		}
		local positions = {}

		for i, offset in ipairs(offset_options) do
			if qty <= #positions then
				break
			end

			local ni = oni + offset
			local spi = km.zmod(ospi + i, 3)
			local npos = P:node_pos(opi, spi, ni)

			if P:is_node_valid(opi, ni) and band(GR:cell_type(npos.x, npos.y), bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) == 0 then
				table.insert(positions, npos)
			end
		end

		if qty > #positions then
			log.debug("could not find valid offsets for summons around %s,%s", x, y)

			return nil
		end

		return positions
	end

	while true do
		local hero = store.entities[owner_id]

		if not hero then
			-- block empty
		else
			while hero.health.dead do
				coroutine.yield()
			end

			if store.tick_ts - last_ts >= this.cooldown then
				last_ts = store.tick_ts

				local positions = distribute_summons(hero.pos.x, hero.pos.y, 6)

				positions = table.random_order(positions)

				if positions then
					local position = positions[1]
					local e = E:create_entity(this.soldier_template)

					e.pos = V.vclone(position)
					e.nav_rally.center = V.vclone(e.pos)
					e.nav_rally.pos = V.vclone(e.pos)
					e.soldier.tower_id = this.id

					queue_insert(store, e)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.relic_locket_of_the_unforgiven = {}

function scripts.relic_locket_of_the_unforgiven.fn_level_up(this, store, hero)
	local hl = hero.hero.level

	log.info("%s - level up - hl:%i", this.template_name, hl)

	local b = this.balance
	local rl = GS.relic_lvl_steps[hl]

	if rl then
		this.relic.level = rl

		log.info("%s - level up - rl:%i", this.template_name, rl)

		this.max_skeletons = b.max_skeletons[rl]

		local soldier = E:get_template(this.soldier_template)
		local bs = b.skeleton

		soldier.melee.attacks[1].damage_max = bs.damage_min[rl]
		soldier.melee.attacks[1].damage_min = bs.damage_max[rl]
		soldier.health.hp_max = bs.hp[rl]
	end
end

function scripts.relic_locket_of_the_unforgiven.update(this, store, script)
	local last_ts = store.tick_ts
	local skeletons_count = 0
	local cg = store.count_groups[this.count_group_type]
	local owner_id = this.relic.owner_id

	log.info("NecroTick - start")

	while true do
		local hero = store.entities[owner_id]

		if not hero then
			-- block empty
		else
			while hero.health.dead do
				coroutine.yield()
			end

			if store.tick_ts - last_ts >= this.aura.cycle_time then
				last_ts = store.tick_ts
				skeletons_count = 0

				for _, e in pairs(store.entities) do
					if e and e.health and not e.health.dead and e.soldier and e.soldier.tower_id == this.id then
						skeletons_count = skeletons_count + 1
					end
				end

				local max_spawns = this.max_skeletons - skeletons_count

				if max_spawns < 1 then
					-- block empty
				else
					local dead_enemies = table.filter(store.entities, function(k, v)
						return v.enemy and v.vis and v.health and v.health.dead and band(v.health.last_damage_types, bor(DAMAGE_EAT)) == 0 and band(v.vis.bans, F_SKELETON) == 0 and store.tick_ts - v.health.death_ts >= v.health.dead_lifetime - this.aura.cycle_time and U.is_inside_ellipse(v.pos, hero.pos, this.range)
					end)

					dead_enemies = table.slice(dead_enemies, 1, max_spawns)

					for _, dead in pairs(dead_enemies) do
						dead.vis.bans = bor(dead.vis.bans, F_SKELETON)
						dead.health.delete_after = 0

						local e = E:create_entity(this.soldier_template)

						e.pos = V.vclone(dead.pos)

						if dead.enemy.necromancer_offset then
							e.pos.x = e.pos.x + dead.enemy.necromancer_offset.x * (dead.render.sprites[1].flip_x and -1 or 1)
							e.pos.y = e.pos.y + dead.enemy.necromancer_offset.y
						end

						e.nav_rally.center = V.vclone(e.pos)
						e.nav_rally.pos = V.vclone(e.pos)
						e.soldier.tower_id = this.id

						queue_insert(store, e)
					end
				end
			end
		end

		coroutine.yield()
	end
end

scripts.relic_guardian_orb = {}

function scripts.relic_guardian_orb.fn_level_up(this, store, hero)
	local hl = hero.hero.level

	log.info("%s - level up - hl:%i", this.template_name, hl)

	local b = this.balance
	local rl = GS.relic_lvl_steps[hl]

	if rl then
		this.relic.level = rl

		log.info("%s - level up - rl:%i", this.template_name, rl)

		local bullet = E:get_template(this.ranged.attacks[1].bullet)

		bullet.bullet.damage_max = b.damage_max[rl]
		bullet.bullet.damage_min = b.damage_min[rl]
	end
end

function scripts.relic_guardian_orb.update(this, store)
	local sb_sid, ss_sid = 1, 2
	local sb = this.render.sprites[sb_sid]
	local ss = this.render.sprites[ss_sid]
	local ra = this.ranged.attacks[1]
	local fm = this.force_motion

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local ramp_radius = fm.ramp_radius
		local df = (not ramp_radius or ramp_radius < dist) and 1 or math.max(dist / ramp_radius, 0.1)

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step * df, dx, dy)))
		fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
		fm.v.x, fm.v.y = V.trim(fm.max_v, fm.v.x, fm.v.y)
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = V.mul(-1 * fm.fr / store.tick_length, fm.v.x, fm.v.y)
	end

	local function find_target(hero, range)
		if not hero or hero.health.dead then
			return nil
		end

		local target, targets = U.find_foremost_enemy(store.entities, hero.pos, 0, range, false, ra.vis_flags, ra.vis_bans)

		return target
	end

	local charge_ts, wait_ts, shoot_ts, search_ts, shots = 0, 0, 0, 0, 0
	local target, targets, dist
	local dest = V.v(0, 0)
	local ps = E:create_entity(this.particles_name)

	ps.particle_system.track_id = this.id
	ps.particle_system.track_offset = V.v(0, this.flight_height)

	queue_insert(store, ps)

	while true do
		local hero = store.entities[this.relic.owner_id]

		while not hero do
			coroutine.yield()
		end

		this.pos.x = hero.pos.x
		this.pos.y = hero.pos.y
		dest.x = this.pos.x
		dest.y = this.pos.y

		goto label_493_1

		::label_493_0::

		sb.z = Z_BULLETS
		sb.sort_y_offset = 0
		ss.hidden = false
		ps.particle_system.emit = false
		this.chasing_target_id = target.id
		dest.x, dest.y = target.pos.x, target.pos.y

		repeat
			dist = V.dist(this.pos.x, this.pos.y, dest.x, dest.y)

			move_step(dest)
			coroutine.yield()
		until dist < ra.shoot_range or target.health.dead or band(ra.vis_flags, target.vis.bans) ~= 0

		if store.entities[target.id] and not target.health.dead and band(ra.vis_flags, target.vis.bans) == 0 then
			if store.tick_ts - shoot_ts > ra.cooldown then
				shoot_ts = store.tick_ts

				U.animation_start(this, "shoot", nil, store.tick_ts, false, sb_sid)
				U.y_wait(store, ra.shoot_time)

				local b = E:create_entity(ra.bullet)

				b.pos.x, b.pos.y = this.pos.x + sb.offset.x, this.pos.y + sb.offset.y
				b.bullet.from = V.vclone(b.pos)
				b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
				b.bullet.target_id = target.id
				b.bullet.source_id = this.id

				queue_insert(store, b)
				U.y_animation_wait(this, sb_sid)
				U.animation_start(this, "big", nil, store.tick_ts, true, sb_sid)
			end

			if V.dist(this.pos.x, this.pos.y, hero.pos.x, hero.pos.y) < this.hero_max_distance then
				goto label_493_0
			end
		end

		::label_493_1::

		wait_ts = store.tick_ts
		this.chasing_target_id = nil

		U.animation_start(this, "big", nil, store.tick_ts, true, sb_sid)

		::label_493_2::

		search_ts = store.tick_ts
		target = find_target(hero, ra.max_range)

		if target then
			goto label_493_0
		end

		while store.tick_ts - search_ts < ra.search_cooldown do
			if V.dist(this.pos.x, this.pos.y, hero.pos.x, hero.pos.y) > this.hero_idle_distance then
				dest.x = hero.pos.x
				dest.y = hero.pos.y
			end

			move_step(dest)
			coroutine.yield()
		end

		goto label_493_2
	end
end

scripts.relic_mirror_of_inversion = {}

function scripts.relic_mirror_of_inversion.fn_level_up(this, store, hero)
	local hl = hero.hero.level

	log.info("%s - level up - hl:%i", this.template_name, hl)

	local b = this.balance
	local rl = GS.relic_lvl_steps[hl]

	local function flip_damage(damage_type)
		if U.flag_has(damage_type, DAMAGE_PHYSICAL) then
			damage_type = U.flag_clear(damage_type, DAMAGE_PHYSICAL)
			damage_type = U.flag_set(damage_type, DAMAGE_MAGICAL)
		elseif U.flag_has(damage_type, DAMAGE_MAGICAL) then
			damage_type = U.flag_clear(damage_type, DAMAGE_MAGICAL)
			damage_type = U.flag_set(damage_type, DAMAGE_PHYSICAL)
		end

		return damage_type
	end

	if rl then
		this.relic.level = rl

		log.info("%s - level up - rl:%i", this.template_name, rl)

		local damage_type_container

		if hero.ranged then
			for i, value in ipairs(hero.ranged.attacks) do
				if value.basic_attack then
					local bulletT = E:get_template(value.bullet)

					damage_type_container = bulletT.bullet

					log.info("Basic attack was ranged.attack[%i] with bullet %s", i, value.bullet)

					break
				end
			end
		end

		if hero.melee then
			for i, value in ipairs(hero.melee.attacks) do
				if value.basic_attack then
					damage_type_container = value

					log.info("Basic attack was melee.attack[%i]", i)

					break
				end
			end
		end

		if damage_type_container and not this.old_damage_type or this.old_damage_type ~= damage_type_container.damage_type then
			damage_type_container.damage_type = flip_damage(damage_type_container.damage_type)
			this.old_damage_type = damage_type_container.damage_type
		end
	end
end

scripts.relic_hammer_of_the_blessed = {}

function scripts.relic_hammer_of_the_blessed.fn_level_up(this, store, hero)
	local hl = hero.hero.level

	log.info("%s - level up - hl:%i", this.template_name, hl)

	local b = this.balance
	local rl = GS.relic_lvl_steps[hl]

	if rl then
		this.relic.level = rl

		log.info("%s - level up - rl:%i", this.template_name, rl)
	end
end

function scripts.relic_hammer_of_the_blessed.update(this, store, script)
	local last_ts = store.tick_ts
	local skeletons_count = 0
	local owner_id = this.relic.owner_id

	log.info("Hammer - start")

	while true do
		local hero = store.entities[owner_id]

		if not hero then
			-- block empty
		else
			while hero.health.dead do
				coroutine.yield()
			end

			if store.tick_ts - last_ts >= this.aura.cycle_time then
				last_ts = store.tick_ts

				local targets = U.find_soldiers_in_range(store.entities, hero.pos, 0, this.range, 0, 0, function(e)
					return e ~= hero and e.health.hp < e.health.hp_max
				end)
				local health_percent = this.balance.heal_percent[this.relic.level]

				if targets then
					for _, target in ipairs(targets) do
						local m = E:create_entity(this.mod)

						m.modifier.target_id = target.id
						m.modifier.source_id = this.id

						local hp_gain = math.ceil(target.health.hp_max * health_percent)

						log.info("Healing (%i) %s for %f * %i = %i", target.id, target.template_name, health_percent, target.health.hp_max, hp_gain)

						m.hps.heal_min = hp_gain
						m.hps.heal_max = hp_gain

						queue_insert(store, m)
					end
				end
			end
		end

		coroutine.yield()
	end
end

scripts.tower_sylvan_archers = {}

function scripts.tower_sylvan_archers.get_info(this)
	local o = scripts.tower_common.get_info(this)

	return o
end

function scripts.tower_sylvan_archers.insert(this, store)
	return true
end

function scripts.tower_sylvan_archers.update(this, store)
	local shooter_sids = {
		3,
		4
	}
	local shooter_idx = 2
	local a = this.attacks
	local aa = this.attacks.list[1]
	local an, af
	local a_ricochet = this.attacks.list[2]
	local a_mark = this.attacks.list[3]
	local pow_r = this.powers.multishot
	local pow_m = this.powers.hunting_mark

	local function shot_animation(attack, shooter_idx, enemy)
		local ssid = shooter_sids[shooter_idx]
		local soffset = this.render.sprites[ssid].offset
		local s = this.render.sprites[ssid]
		local an, af = U.animation_name_facing_point(this, attack.animation, enemy.pos, ssid, soffset)

		U.animation_start(this, an, af, store.tick_ts, 1, ssid)
	end

	local function shot_bullet(attack, shooter_idx, enemy, level)
		local ssid = shooter_sids[shooter_idx]
		local shooting_up = tpos(this).y < enemy.pos.y
		local shooting_right = tpos(this).x < enemy.pos.x
		local soffset = this.render.sprites[ssid].offset
		local boffset = attack.bullet_start_offset[shooting_up and 1 or 2]
		local b = E:create_entity(attack.bullet)

		b.pos.x = this.pos.x + soffset.x + boffset.x * (shooting_right and 1 or -1)
		b.pos.y = this.pos.y + soffset.y + boffset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		b.bullet.target_id = enemy.id
		b.bullet.level = level
		b.bullet.damage_factor = this.tower.damage_factor

		if b.bullet.flight_time_factor then
			local dist = V.dist(b.bullet.to.x, b.bullet.to.y, b.bullet.from.x, b.bullet.from.y)

			b.bullet.flight_time = b.bullet.flight_time_min + dist / a.range * b.bullet.flight_time_factor
		end

		queue_insert(store, b)
	end

	aa.ts = store.tick_ts

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			for k, pow in pairs(this.powers) do
				if pow.changed then
					pow.changed = nil

					if pow.level == 1 then
						local pa = this.attacks.list[pow.attack_idx]

						pa.ts = store.tick_ts
					end
				end
			end

			if pow_m.level > 0 and store.tick_ts - a_mark.ts > a_mark.cooldown then
				local sa = a_mark
				local pow = pow_m
				local enemy = U.find_foremost_enemy(store.entities, tpos(this), 0, sa.range, false, sa.vis_flags, sa.vis_bans, function(e)
					return not U.has_modifiers(store, e, "mod_arrow_silver_mark")
				end)

				if enemy then
					sa.ts = store.tick_ts
					shooter_idx = km.zmod(shooter_idx + 1, #shooter_sids)

					shot_animation(sa, shooter_idx, enemy)

					while store.tick_ts - sa.ts < sa.shoot_time do
						coroutine.yield()
					end

					if V.dist(tpos(this).x, tpos(this).y, enemy.pos.x, enemy.pos.y) <= a.range * 1.1 then
						shot_bullet(sa, shooter_idx, enemy, pow.level)
					end

					U.y_animation_wait(this, shooter_sids[shooter_idx])

					aa.ts = store.tick_ts
				end
			end

			if pow_r.level > 0 and store.tick_ts - a_ricochet.ts > a_ricochet.cooldown then
				local sa = a_ricochet
				local pow = pow_r
				local enemy = U.find_foremost_enemy(store.entities, tpos(this), 0, sa.range, false, sa.vis_flags, sa.vis_bans)

				if enemy then
					local close_enemy = U.find_enemies_in_range(store.entities, tpos(enemy), 0, sa.bounce_range, sa.vis_flags, sa.vis_bans, function(e)
						return e ~= enemy
					end)

					if close_enemy then
						sa.ts = store.tick_ts
						shooter_idx = km.zmod(shooter_idx + 1, #shooter_sids)

						shot_animation(sa, shooter_idx, enemy)

						while store.tick_ts - sa.ts < sa.shoot_time do
							coroutine.yield()
						end

						if V.dist(tpos(this).x, tpos(this).y, enemy.pos.x, enemy.pos.y) <= a.range * 1.1 then
							shot_bullet(sa, shooter_idx, enemy, pow.level)
						end

						U.y_animation_wait(this, shooter_sids[shooter_idx])

						aa.ts = store.tick_ts
					end
				end
			end

			if store.tick_ts - aa.ts > aa.cooldown then
				local enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

				if not enemy then
					-- block empty
				else
					aa.ts = store.tick_ts
					shooter_idx = km.zmod(shooter_idx + 1, #shooter_sids)

					shot_animation(aa, shooter_idx, enemy)

					while store.tick_ts - aa.ts < aa.shoot_time do
						coroutine.yield()
					end

					if V.dist(tpos(this).x, tpos(this).y, enemy.pos.x, enemy.pos.y) <= a.range then
						shot_bullet(aa, shooter_idx, enemy, 0)
					end

					U.y_animation_wait(this, shooter_sids[shooter_idx])
				end
			end

			if store.tick_ts - aa.ts > this.tower.long_idle_cooldown then
				for _, sid in pairs(shooter_sids) do
					local an, af = U.animation_name_facing_point(this, "idle", this.tower.long_idle_pos, sid)

					U.animation_start(this, an, af, store.tick_ts, -1, sid)
				end
			end

			coroutine.yield()
		end
	end
end

scripts.tower_sylvan_archers_mark_mod = {}

function scripts.tower_sylvan_archers_mark_mod.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or not target.unit then
		return false
	end

	local damage_factor = this.received_damage_factor[this.modifier.level]

	target.health.damage_factor = target.health.damage_factor * damage_factor

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.tower_sylvan_archers_mark_mod.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos
	m.duration = m.durations[m.level]
	m.ts = store.tick_ts

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or store.tick_ts - m.ts > m.duration then
			this.tween.props[3].disabled = nil
			this.tween.props[4].disabled = nil
			this.tween.props[3].ts = store.tick_ts
			this.tween.props[4].ts = store.tick_ts

			U.y_wait(store, this.tween.props[3].keys[2][1])
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

function scripts.tower_sylvan_archers_mark_mod.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target and target.health and target.unit then
		local damage_factor = this.received_damage_factor[this.modifier.level]

		target.health.damage_factor = target.health.damage_factor / damage_factor
	end

	return true
end

scripts.tower_royal_archers = {}

function scripts.tower_royal_archers.update(this, store)
	local shooter_sids = {
		3,
		4
	}
	local shooter_idx = 1
	local a = this.attacks
	local aa = this.attacks.list[1]
	local ap = this.attacks.list[2]

	if not a._last_target_pos then
		a._last_target_pos = {}

		for i = 1, #shooter_sids do
			a._last_target_pos[i] = v(REF_W, 0)
		end
	end

	this.rapacious_hunter_tamer = nil

	local function shot_animation(attack, shooter_idx, pos)
		local ssid = shooter_sids[shooter_idx]
		local soffset = this.render.sprites[ssid].offset
		local s = this.render.sprites[ssid]
		local an, af = U.animation_name_facing_point(this, attack.animation, pos, ssid, soffset)

		U.animation_start(this, an, af, store.tick_ts, 1, ssid)
	end

	local function shot_bullet(attack, shooter_idx, enemy, level)
		local ssid = shooter_sids[shooter_idx]
		local shooting_up = tpos(this).y < enemy.pos.y
		local shooting_right = not this.render.sprites[ssid].flip_x
		local soffset = this.render.sprites[ssid].offset
		local boffset = attack.bullet_start_offset[shooting_up and 1 or 2]
		local b = E:create_entity(attack.bullet)

		b.pos.x = this.pos.x + soffset.x + boffset.x * (shooting_right and 1 or -1)
		b.pos.y = this.pos.y + soffset.y + boffset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		b.bullet.target_id = enemy.id
		b.bullet.source_id = this.id
		b.bullet.level = level
		b.bullet.damage_factor = this.tower.damage_factor
		b.bullet.flight_time = 2 * (math.sqrt(2 * b.bullet.fixed_height * b.bullet.g * -1) / b.bullet.g * -1)

		queue_insert(store, b)
	end

	local function shot_bullet_armor_piercer(attack, shooter_idx, enemy, level, index)
		local ssid = shooter_sids[shooter_idx]
		local shooting_up = tpos(this).y < enemy.pos.y
		local shooting_right = tpos(this).x < enemy.pos.x
		local soffset = this.render.sprites[ssid].offset
		local boffset = attack.bullet_start_offset[shooting_up and 1 or 2]
		local b = E:create_entity(attack.bullet)

		b.pos.x = this.pos.x + soffset.x + boffset.x * (shooting_right and 1 or -1)
		b.pos.y = this.pos.y + soffset.y + boffset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		b.bullet.target_id = enemy.id
		b.bullet.source_id = this.id
		b.bullet.level = level
		b.bullet.damage_factor = this.tower.damage_factor
		b.bullet.damage_max = b.bullet.damage_max_config[b.bullet.level]
		b.bullet.damage_min = b.bullet.damage_min_config[b.bullet.level]
		b.bullet.reduce_armor = b.bullet.reduce_armor[b.bullet.level]

		if b.bullet.fixed_height then
			local height = b.bullet.fixed_height + (index - 1) * 15

			b.bullet.fixed_height = height
		end

		b.bullet.flight_time = b.bullet.flight_time + index * fts(6)

		queue_insert(store, b)
	end

	local function prepare_targets_armor_piercer(enemy, enemies)
		local reload_enemy, reload_enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, ap.range_effect, false, ap.vis_flags, ap.vis_bans)

		if reload_enemy and #reload_enemies > 0 then
			enemy = reload_enemy
			enemies = reload_enemies
		end

		local targets = {}
		local first_target_on_left = enemy.pos.x < this.pos.x

		for i = 1, 3 do
			local enemy_index = km.zmod(i, #enemies)
			local e = enemies[enemy_index]

			if first_target_on_left and e.pos.x < this.pos.x then
				table.insert(targets, e)
			elseif not first_target_on_left and e.pos.x > this.pos.x then
				table.insert(targets, e)
			elseif i > 1 then
				table.insert(targets, targets[i - 1])
			end
		end

		table.sort(targets, function(e1, e2)
			return V.dist(this.pos.x, this.pos.y, e1.pos.x, e1.pos.y) > V.dist(this.pos.x, this.pos.y, e2.pos.x, e2.pos.y)
		end)

		return targets
	end

	local function check_upgrades_purchase()
		if this.powers then
			for _, pow in pairs(this.powers) do
				if pow.changed then
					pow.changed = nil

					if pow == this.powers.rapacious_hunter then
						this.render.sprites[this.sid_rapacious_hunter].hidden = false

						if not this.rapacious_hunter_tamer then
							local s = E:create_entity(pow.entity)

							s.pos.x, s.pos.y = V.add(this.pos.x, this.pos.y, pow.entity_offset.x, pow.entity_offset.y)
							s.owner = this
							s.level = pow.level
							this.rapacious_hunter_tamer = s

							queue_insert(store, s)

							local fx = E:create_entity(pow.purchase_fx)

							fx.pos = s.pos
							fx.render.sprites[1].ts = store.tick_ts

							queue_insert(store, fx)
						else
							this.rapacious_hunter_tamer.level = pow.level
						end
					else
						local pa = this.attacks.list[pow.attack_idx]

						pa.cooldown = pow.cooldown[pow.level]

						if pow.level == 1 then
							pa.ts = store.tick_ts - pa.cooldown
						end
					end
				end
			end
		end
	end

	aa.ts = store.tick_ts - aa.cooldown + a.attack_delay_on_spawn

	for idx, ssid in ipairs(shooter_sids) do
		local soffset = this.render.sprites[ssid].offset
		local s = this.render.sprites[ssid]
		local an, af = U.animation_name_facing_point(this, "idle", a._last_target_pos[idx], ssid, soffset)

		U.animation_start(this, an, af, store.tick_ts, 1, ssid)
	end

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			check_upgrades_purchase()
			SU.towers_swaped(store, this, this.attacks.list)

			if this.powers and this.powers.armor_piercer then
				local pow_p = this.powers.armor_piercer

				if pow_p.level > 0 and store.tick_ts - ap.ts > ap.cooldown and this.tower.can_do_magic then
					local enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, ap.range_trigger, false, ap.vis_flags, ap.vis_bans)

					if not enemy then
						SU.delay_attack(store, ap, fts(10))
					else
						local start_ts = store.tick_ts

						shooter_idx = km.zmod(shooter_idx + 1, #shooter_sids)

						shot_animation(ap, shooter_idx, enemy.pos)
						S:queue(ap.sound)

						while store.tick_ts - start_ts < ap.shoot_time do
							check_upgrades_purchase()
							coroutine.yield()
						end

						local targets = prepare_targets_armor_piercer(enemy, enemies)
						local arrow_number = 1

						if targets[1].pos.x < this.pos.x then
							local ssid = shooter_sids[shooter_idx]

							this.render.sprites[ssid].flip_x = true
						end

						for _, enemy in pairs(targets) do
							shot_bullet_armor_piercer(ap, shooter_idx, enemy, pow_p.level, arrow_number)
							U.y_wait(store, ap.time_between_arrows)

							arrow_number = arrow_number + 1
						end

						U.y_animation_wait(this, shooter_sids[shooter_idx])

						ap.ts = start_ts
						aa.ts = start_ts
					end
				end
			end

			if store.tick_ts - aa.ts > aa.cooldown then
				local trigger_enemy, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

				if not trigger_enemy then
					SU.delay_attack(store, aa, fts(10))
				else
					aa.ts = store.tick_ts
					shooter_idx = km.zmod(shooter_idx + 1, #shooter_sids)

					shot_animation(aa, shooter_idx, trigger_enemy.pos)

					while store.tick_ts - aa.ts < aa.shoot_time do
						check_upgrades_purchase()
						coroutine.yield()
					end

					local enemy, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

					enemy = enemy or trigger_enemy

					shot_bullet(aa, shooter_idx, enemy, 0)

					a._last_target_pos[shooter_idx].x, a._last_target_pos[shooter_idx].y = enemy.pos.x, enemy.pos.y

					U.y_animation_wait(this, shooter_sids[shooter_idx])
				end
			end

			if store.tick_ts - aa.ts > this.tower.long_idle_cooldown then
				for _, sid in pairs(shooter_sids) do
					local an, af = U.animation_name_facing_point(this, "idle", this.tower.long_idle_pos, sid)

					U.animation_start(this, an, af, store.tick_ts, -1, sid)
				end
			end

			coroutine.yield()
		end
	end
end

function scripts.tower_royal_archers.remove(this, store)
	if this.rapacious_hunter_tamer then
		queue_remove(store, this.rapacious_hunter_tamer)

		local eagle = this.rapacious_hunter_tamer.entity_spawned

		if eagle then
			queue_remove(store, eagle)
		end
	end

	return true
end

scripts.tower_royal_archers_pow_rapacious_hunter_tamer = {}

function scripts.tower_royal_archers_pow_rapacious_hunter_tamer.update(this, store)
	local ab = this.attacks.list[1]
	local last_cheer = store.tick_ts
	local last_idle = store.tick_ts
	local next_idle = math.random(this.idle.min_cooldown, this.idle.max_cooldown)

	this.entity_spawned = nil

	U.y_animation_play(this, "in_animation", nil, store.tick_ts, 1)

	while true do
		if this.entity_spawned then
			if this.entity_spawned.return_to_owner == true then
				U.y_animation_play(this, "return", nil, store.tick_ts, 1)

				this.entity_spawned = nil
			elseif store.tick_ts - last_cheer > this.min_cheer_cooldown and this.entity_spawned.engage_combat == true then
				if math.random() < this.cheer_chance or store.tick_ts - last_cheer > this.max_time_without_cheer then
					U.y_animation_play(this, "cheer_up", nil, store.tick_ts, 1)
					U.y_animation_play(this, "idle_3", nil, store.tick_ts, 1)
				end

				last_cheer = store.tick_ts
			end
		end

		if not this.entity_spawned then
			local enemy = U.find_foremost_enemy(store.entities, tpos(this), 0, ab.range, false, ab.vis_flags, ab.vis_bans)

			if enemy then
				ab.ts = store.tick_ts

				local mark_mod = E:create_entity(ab.mark_mod)

				mark_mod.modifier.source_id = this.id
				mark_mod.modifier.target_id = enemy.id
				mark_mod.modifier.duration = ab.mark_mod_duration

				queue_insert(store, mark_mod)
				U.animation_start(this, ab.animation, nil, store.tick_ts, false)

				while store.tick_ts - ab.ts < ab.cast_time do
					coroutine.yield()
				end

				local p = E:create_entity(ab.entity)

				p.enemy_target = enemy
				p.level = this.level
				p.owner = this
				p.mark_mod = mark_mod
				p.pos.x, p.pos.y = V.add(this.pos.x, this.pos.y, p.owner_offset.x, p.owner_offset.y)
				this.entity_spawned = p

				queue_insert(store, p)

				ab.ts = store.tick_ts

				U.y_animation_wait(this)
				U.y_animation_play(this, "idle_3", nil, store.tick_ts, 1)

				last_cheer = store.tick_ts
			elseif next_idle < store.tick_ts - last_idle then
				U.y_animation_play(this, this.idle.animation, nil, store.tick_ts, 1)

				last_idle = store.tick_ts
				next_idle = math.random(this.idle.min_cooldown, this.idle.max_cooldown)
			end
		end

		coroutine.yield()
	end
end

scripts.tower_royal_archers_pow_rapacious_hunter_eagle = {}

function scripts.tower_royal_archers_pow_rapacious_hunter_eagle.update(this, store)
	local sf = this.render.sprites[1]
	local fm = this.force_motion
	local ca = this.attacks.list[1]
	local target = this.enemy_target
	local shots = 0
	local flip_multiplier = 1
	local tamer_attack = this.owner.attacks.list[1]
	local far_from_tower = false
	local target_still_valid = true

	this.return_to_owner = false
	this.engage_combat = false
	sf.offset.y = this.flight_height
	this.flight_height = this.flight_height_max
	ca.ts = store.tick_ts

	local move_to_owner = false

	local function move_step(destination)
		local dx, dy = V.sub(destination.x, destination.y, this.pos.x, this.pos.y)

		fm.v.x, fm.v.y = V.trim(this.orbital_speed, V.mul(5, dx, dy))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		sf.offset.y = km.clamp(0, this.flight_height, sf.offset.y + this.flight_speed * store.tick_length)

		if target and V.len(dx, dy) < 10 then
			local tx = target.pos.x - this.pos.x

			sf.flip_x = tx < 0
		else
			sf.flip_x = fm.v.x < 0
		end
	end

	local function return_to_owner(destination)
		local accel = this.return_accel
		local mspeed = this.min_speed
		local dist = V.dist(this.pos.x, this.pos.y, destination.x, destination.y)
		local start_dist = dist
		local start_h = sf.offset.y
		local target_h = this.owner_flight_height

		while dist > mspeed * store.tick_length do
			if not store.entities[this.owner.id] then
				this.tween.disabled = false
				this.tween.ts = store.tick_ts
				this.tween.reverse = true

				U.y_wait(store, this.tween.props[1].keys[2][1])
				queue_remove(store, this)
			end

			local tx, ty = destination.x, destination.y
			local dx, dy = V.mul(mspeed * store.tick_length, V.normalize(V.sub(tx, ty, this.pos.x, this.pos.y)))

			this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, dx, dy)
			sf.offset.y = km.clamp(0, this.flight_height * 1.5, start_h + (target_h - start_h) * (1 - dist / start_dist))
			sf.flip_x = dx < 0

			coroutine.yield()

			dist = V.dist(this.pos.x, this.pos.y, destination.x, destination.y)
			mspeed = km.clamp(this.min_speed, this.max_speed, mspeed + accel * store.tick_length)
		end

		this.return_to_owner = true

		queue_remove(store, this)
	end

	while true do
		local distance_from_target = V.dist(this.pos.x, this.pos.y, target.pos.x, target.pos.y)

		if not store.entities[target.id] or target.health.dead or far_from_tower or not target_still_valid then
			far_from_tower = false

			local _, targets = U.find_foremost_enemy(store.entities, tpos(this.owner), 0, tamer_attack.range, false, tamer_attack.vis_flags, tamer_attack.vis_bans)

			if targets and #targets > 0 then
				target = targets[1]
				target_still_valid = true

				local mark_mod = E:create_entity(tamer_attack.mark_mod)

				mark_mod.modifier.source_id = this.id
				mark_mod.modifier.target_id = target.id
				mark_mod.modifier.duration = tamer_attack.mark_mod_duration

				queue_insert(store, mark_mod)

				this.mark_mod = mark_mod
			else
				move_to_owner = true

				goto label_520_0
			end
		end

		if target and not target.health.dead then
			if not P:is_node_valid(target.nav_path.pi, target.nav_path.ni) then
				target_still_valid = false
			end

			if band(target.vis.flags, ca.vis_bans) ~= 0 or band(target.vis.bans, ca.vis_flags) ~= 0 then
				target_still_valid = false
			end
		end

		if store.tick_ts - ca.ts > ca.cooldown and distance_from_target < this.min_distance_to_attack then
			this.engage_combat = true

			U.y_animation_play(this, "attack_in", nil, store.tick_ts, 1)

			local trail = E:create_entity(ca.trail)

			trail.particle_system.track_id = this.id
			trail.particle_system.emit = true
			trail.particle_system.track_offset = sf.offset

			queue_insert(store, trail)
			S:queue(this.sound_events.descend)
			U.y_animation_play(this, "projectile", nil, store.tick_ts, 1)

			this.engage_combat = false

			local accel = this.attack_accel
			local start_h = sf.offset.y
			local target_h = target.unit.hit_offset.y
			local mspeed = this.min_speed
			local target_pos = V.v(target.pos.x, target.pos.y)

			-- if target.unit.head_offset then
			-- 	target_pos.x, target_pos.y = target_pos.x + target.unit.head_offset.x, target_pos.y + target.unit.head_offset.y
			-- end

			local dist = V.dist(this.pos.x, this.pos.y, target_pos.x, target_pos.y)
			local start_dist = dist

			while dist > mspeed * store.tick_length and not target.health.dead do
				local tx, ty = target_pos.x, target_pos.y
				local dx, dy = V.mul(mspeed * store.tick_length, V.normalize(V.sub(tx, ty, this.pos.x, this.pos.y)))

				this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, dx, dy)
				sf.offset.y = km.clamp(0, this.flight_height * 1.5, start_h + (target_h - start_h) * (1 - dist / start_dist))
				trail.particle_system.track_offset = sf.offset
				sf.flip_x = dx < 0

				local flip_sign = sf.flip_x and -1 or 1

				trail.particle_system.scales_x = {
					flip_sign,
					flip_sign
				}

				coroutine.yield()

				dist = V.dist(this.pos.x, this.pos.y, target_pos.x, target_pos.y)
				mspeed = km.clamp(this.min_speed, this.max_speed, mspeed + accel * store.tick_length)
			end

			if target.health.dead then
				queue_remove(store, trail)

				ca.ts = store.tick_ts
			else
				this.pos.x, this.pos.y = target_pos.x, target_pos.y - 1
				sf.offset.y = target_h
				trail.particle_system.track_offset = sf.offset

				S:queue(ca.sound)

				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id
				d.value = math.random(ca.damage_min[this.level], ca.damage_max[this.level])
				d.damage_type = ca.damage_type
				d.reduce_armor = ca.armor_penetration[this.level]

				queue_damage(store, d)

				local fx = E:create_entity(ca.hit_fx)

				fx.pos = V.vclone(target_pos)
				fx.render.sprites[1].offset = V.v(0, target_h)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)

				shots = shots + 1
				flip_multiplier = flip_multiplier * -1

				queue_remove(store, trail)
				U.y_animation_play(this, "attack_out", nil, store.tick_ts, 1)

				ca.ts = store.tick_ts
				far_from_tower = false

				local dist = V.dist(this.owner.pos.x, this.owner.pos.y, this.pos.x, this.pos.y)

				if dist > this.max_distance_from_tower then
					far_from_tower = true
				end
			end
		end

		::label_520_0::

		U.animation_start(this, "idle_1", nil, store.tick_ts, true)

		if move_to_owner then
			local owner_pos = {}

			owner_pos.x, owner_pos.y = V.add(this.owner.pos.x, this.owner.pos.y, this.owner_offset.x, this.owner_offset.y)

			return_to_owner(owner_pos)
		else
			local pos = V.vclone(target.pos)

			pos.x = pos.x + flip_multiplier * this.offset_x_after_hit

			move_step(pos)
		end

		coroutine.yield()
	end
end

function scripts.tower_royal_archers_pow_rapacious_hunter_eagle.remove(this, store)
	if this.mark_mod then
		queue_remove(store, this.mark_mod)
	end

	return true
end

scripts.tower_royal_archers_pow_rapacious_hunter_tamer_mark_mod = {}

function scripts.tower_royal_archers_pow_rapacious_hunter_tamer_mark_mod.update(this, store)
	local m = this.modifier

	m.ts = store.tick_ts

	while true do
		local target = store.entities[m.target_id]

		if not target or m.duration >= 0 and store.tick_ts - m.ts > m.duration then
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

scripts.tower_stargazers = {}

function scripts.tower_stargazers.get_info(this)
	local b = E:get_template(this.attacks.list[1].bullet)

	if not b.bullet.damage_min or not b.bullet.damage_max then
		b.bullet.damage_min = b.bullet.damage_min_config[this.tower.level]
		b.bullet.damage_max = b.bullet.damage_max_config[this.tower.level]
	end

	local o = scripts.tower_common.get_info(this)

	o.type = STATS_TYPE_TOWER_MAGE
	o.damage_min = math.ceil(b.bullet.damage_min_config[this.tower.level] * this.tower.damage_factor)
	o.damage_max = math.ceil(b.bullet.damage_max_config[this.tower.level] * this.tower.damage_factor)

	return o
end

function scripts.tower_stargazers.update(this, store, script)
	local last_target_pos
	local a = this.attacks
	local aa = this.attacks.list[1]
	local at = this.attacks.list[2]
	local as = this.attacks.list[3]
	local moon_sid = this.render.moon_sid
	local elf_sid = this.render.elf_sid
	local teleport_sid = this.render.teleport_sid
	local shots = 5
	local pow_t = this.powers and this.powers.teleport or nil
	local pow_s = this.powers and this.powers.stars_death or nil
	local last_ts = store.tick_ts - aa.cooldown

	a._last_target_pos = a._last_target_pos or v(REF_W, 0)
	aa.ts = store.tick_ts - aa.cooldown + a.attack_delay_on_spawn

	local ray_timing = aa.ray_timing
	local teleport_bans = F_ALL
	local attacks = {}
	local pows = {}

	if at then
		table.insert(attacks, at)
		table.insert(pows, pow_t)
	end

	if aa then
		table.insert(attacks, aa)
		table.insert(pows, nil)
	end

	while true do
		local enemy, enemies

		if this.powers then
			for k, pow in pairs(this.powers) do
				if pow.changed then
					pow.changed = nil

					if pow == pow_t then
						at.cooldown = pow.cooldown[pow.level]
						at.teleport_nodes_back = pow.teleport_nodes_back[pow.level]

						if pow.level == 1 then
							at.ts = store.tick_ts - at.cooldown
						end
					end
				end
			end
		end

		SU.towers_swaped(store, this, this.attacks.list)

		if this.tower.blocked then
			-- block empty
		else
			for i, aa in pairs(attacks) do
				local pow = pows[i]

				if (not pow or pow.level > 0) and store.tick_ts - aa.ts > aa.cooldown and store.tick_ts - last_ts > a.min_cooldown then
					if aa == at then
						if not this.tower.can_do_magic then
							goto label_continue
						end
						enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

						if not enemies then
							SU.delay_attack(store, at, fts(10))

							break
						end

						if not enemy or enemy.nav_path and enemy.nav_path.ni < aa.teleport_nodes_back then
							SU.delay_attack(store, at, fts(10))

							break
						end

						local start_ts = store.tick_ts

						S:queue(aa.sound_cast)
						U.y_animation_play(this, "attack_in_event_horizon", nil, store.tick_ts, false, elf_sid)

						this.render.sprites[teleport_sid].hidden = false

						U.animation_start(this, "idle", nil, store.tick_ts, false, teleport_sid)
						U.animation_start(this, "attack_loop_event_horizon", nil, store.tick_ts, true, elf_sid)
						S:queue(aa.sound_teleport_out)
						U.y_animation_play_group(this, "attack_in", nil, store.tick_ts, 1, "layers")
						U.animation_start_group(this, "atack_loop", nil, store.tick_ts, true, "layers")

						local enemy_new, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

						if enemy_new then
							enemy = enemy_new
						end

						enemies = U.find_enemies_in_range(store.entities, enemy.pos, 0, 100, aa.vis_flags, aa.vis_bans)

						local picked_enemies = {}
						local place_pi = enemy.nav_path.pi
						local middle = V.v(0, 0)

						if not enemies then
							middle.x = enemy.pos.x
							middle.y = enemy.pos.y
						end

						local count = aa.max_targets[pow.level]

						if enemies then
							if count > #enemies then
								count = #enemies
							end

							for i = 1, count do
								local enemy = enemies[i]
								local m = E:create_entity(aa.mod)

								m.modifier.target_id = enemy.id
								m.modifier.source_id = this.id

								queue_insert(store, m)

								local fx_size

								if enemy.unit.size == UNIT_SIZE_LARGE then
									fx_size = aa.enemy_fx_big
								else
									fx_size = aa.enemy_fx_small
								end

								local fx = E:create_entity(fx_size)

								fx.pos.x = enemy.pos.x + enemy.unit.mod_offset.x
								fx.pos.y = enemy.pos.y + enemy.unit.mod_offset.y
								fx.render.sprites[1].ts = store.tick_ts

								queue_insert(store, fx)

								middle.x = middle.x + enemy.pos.x
								middle.y = middle.y + enemy.pos.y
							end

							middle.x = middle.x / count
							middle.y = middle.y / count
						end

						local fx = E:create_entity(aa.fx)

						fx.pos.x = middle.x
						fx.pos.y = middle.y
						fx.render.sprites[1].ts = store.tick_ts

						queue_insert(store, fx)
						U.y_wait(store, 0.2)

						if enemies and #enemies > 0 then
							for i = 1, count do
								local enemy = enemies[i]
								local tpi, tni = P:find_valid_node(enemy.nav_path.pi, enemy.nav_path.ni - (aa.teleport_nodes_back + 5), 1, NF_ALL)
	
								if tni == nil then
									tni = fe.nav_path.ni
								end

								if band(enemy.vis.flags, at.vis_bans) == 0 and band(enemy.vis.bans, at.vis_flags) == 0 then
									local place_ni = tni + math.random(0, 5)

									if place_ni < 0 then
										place_ni = 5 + math.random(5, 10)
									end

									enemy._stargazer_bans = U.push_bans(enemy.vis, teleport_bans)

									table.insert(picked_enemies, {
										ni = place_ni,
										entity = enemy
									})
									SU.remove_modifiers(store, enemy)
									SU.remove_auras(store, enemy)
									queue_remove(store, enemy)
									U.unblock_all(store, enemy)

									if enemy.ui then
										enemy.ui.can_click = false
									end

									enemy.main_script.co = nil
									enemy.main_script.runs = 0

									if enemy.count_group then
										enemy.count_group.in_limbo = true
									end
								end
							end
						end

						U.y_wait(store, 0.5)
						queue_insert(store, fx)
						S:queue(aa.sound_teleport_in)
						U.y_animation_play(this, "attack_out", nil, store.tick_ts, false, elf_sid)
						U.animation_start(this, "idle", nil, store.tick_ts, true, elf_sid)
						U.animation_start_group(this, "attack_out", nil, store.tick_ts, 1, "layers")

						for i = #picked_enemies, 1, -1 do
							local p = picked_enemies[i]
							local enemy = p.entity

							enemy.nav_path.ni = p.ni
							enemy.pos = P:node_pos(enemy.nav_path)
							enemy.main_script.runs = 1

							if enemy.ui then
								enemy.ui.can_click = true
							end

							U.pop_bans(enemy.vis, enemy._stargazer_bans)

							enemy._stargazer_bans = nil

							queue_insert(store, enemy)
							table.remove(picked_enemies, i)

							local fx_size

							if enemy.unit.size == UNIT_SIZE_LARGE then
								fx_size = aa.enemy_fx_big
							else
								fx_size = aa.enemy_fx_small
							end

							local fx = E:create_entity(fx_size)

							fx.pos.x = enemy.pos.x + enemy.unit.mod_offset.x
							fx.pos.y = enemy.pos.y + enemy.unit.mod_offset.y
							fx.render.sprites[1].ts = store.tick_ts

							queue_insert(store, fx)
						end

						this.render.sprites[teleport_sid].hidden = true

						U.y_animation_wait_group(this, "layers")

						aa.ts = start_ts
					else
						enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

						if not enemies or not enemy then
							SU.delay_attack(store, aa, fts(10))

							break
						end

						local shooter_offset_y = aa.bullet_start_offset[1].y
						local tx, ty = V.sub(enemy.pos.x, enemy.pos.y, this.pos.x, this.pos.y + shooter_offset_y)
						local t_angle = km.unroll(V.angleTo(tx, ty))

						last_target_pos = V.vclone(enemy.pos)

						local start_ts = store.tick_ts

						U.animation_start(this, "attack_in", nil, store.tick_ts, false, elf_sid)
						U.y_wait(store, 0.5)
						U.animation_start(this, "attack_loop", nil, store.tick_ts, true, elf_sid)
						U.animation_start_group(this, "attack_in", nil, store.tick_ts, 1, "layers")
						U.y_wait(store, 0.25)
						U.animation_start_group(this, "atack_loop", nil, store.tick_ts, true, "layers")

						this.render.sprites[moon_sid].hidden = false

						U.animation_start(this, "start", nil, store.tick_ts, false, moon_sid)
						U.y_wait(store, 0.25)
						U.animation_start(this, "loop", nil, store.tick_ts, true, moon_sid)

						local _, new_enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

						if new_enemies then
							enemies = new_enemies
						end

						for i = 1, shots do
							enemy = enemies[km.zmod(i, #enemies)]

							local in_range = ignore_out_of_range_check or U.is_inside_ellipse(tpos(this), enemy.pos, a.range * 1.1)
							local bullet = E:create_entity(aa.bullet)

							bullet.bullet.shot_index = i
							bullet.bullet.damage_factor = this.tower.damage_factor
							bullet.bullet.source_id = this.id
							bullet.bullet.damage_min = bullet.bullet.damage_min_config[this.tower.level]
							bullet.bullet.damage_max = bullet.bullet.damage_max_config[this.tower.level]

							if in_range then
								if enemy.health and not enemy.health.dead then
									bullet.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
									bullet.bullet.target_id = enemy.id
								else
									bullet.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x + math.random(-20, 20), enemy.pos.y + enemy.unit.hit_offset.y + math.random(-20, 20))
									bullet.bullet.target_id = nil
								end
							else
								bullet.bullet.to = V.v(last_target_pos.x + math.random(-20, 20), last_target_pos.y + math.random(-20, 20))
								bullet.bullet.target_id = nil
							end

							if pow_s and pow_s.level > 0 and this.tower.can_do_magic then
								local m = E:create_entity(as.mod)

								m.modifier.target_id = enemy.id
								m.modifier.source_id = this.id
								m.modifier.level = pow_s.level

								queue_insert(store, m)
							end

							local start_offset = aa.bullet_start_offset[1]

							bullet.bullet.from = V.v(this.pos.x + start_offset.x, this.pos.y + start_offset.y)
							bullet.pos = V.vclone(bullet.bullet.from)
							bullet.bullet.level = this.tower.level

							queue_insert(store, bullet)
							U.y_wait(store, ray_timing)

							enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

							if not enemy then
								break
							end
						end

						U.animation_start(this, "attack_out", nil, store.tick_ts, false, elf_sid)
						U.y_wait(store, 0.25)
						U.animation_start(this, "idle", nil, store.tick_ts, true, elf_sid)
						U.animation_start_group(this, "attack_out", nil, store.tick_ts, 1, "layers")
						U.animation_start(this, "end", nil, store.tick_ts, false, moon_sid)
						U.y_wait(store, 0.25)

						this.render.sprites[moon_sid].hidden = true

						U.animation_start_group(this, "idle", nil, store.tick_ts, true, "layers")

						aa.ts = start_ts
					end
					::label_continue::
				end
			end
		end

		coroutine.yield()
	end
end

scripts.tower_arcane_wizard = {}

function scripts.tower_arcane_wizard.get_info(this)
	local b = E:get_template(this.attacks.list[1].bullet)

	if not b.bullet.damage_min or not b.bullet.damage_max then
		b.bullet.damage_min = b.bullet.damage_min_config[this.tower.level]
		b.bullet.damage_max = b.bullet.damage_max_config[this.tower.level]
	end

	local o = scripts.tower_common.get_info(this)

	o.type = STATS_TYPE_TOWER_MAGE

	local min = math.ceil(b.bullet.damage_min_config[this.tower.level] * this.tower.damage_factor)
	local max = math.ceil(b.bullet.damage_max_config[this.tower.level] * this.tower.damage_factor)

	o.damage_min = min
	o.damage_max = max

	return o
end

function scripts.tower_arcane_wizard.update(this, store)
	local shooter_sid = this.render.sid_shooter
	local a = this.attacks
	local ar = this.attacks.list[1]
	local ad = this.attacks.list[2]
	local ae = this.attacks.list[3]
	local pow_d = this.powers and this.powers.disintegrate or nil
	local pow_e = this.powers and this.powers.empowerment or nil
	local last_ts = store.tick_ts - ar.cooldown

	a._last_target_pos = a._last_target_pos or v(REF_W, 0)
	ar.ts = store.tick_ts - ar.cooldown + a.attack_delay_on_spawn

	local attacks = {}
	local pows = {}
	local empowerments_previews
	local first_time_empower = true

	if ad then
		table.insert(attacks, ad)
		table.insert(pows, pow_d)
	end

	if ae then
		table.insert(attacks, ae)
		table.insert(pows, pow_e)
	end

	if ar then
		table.insert(attacks, ar)
		table.insert(pows, nil)
	end

	local function find_target(aa)
		local target, _, pred_pos = U.find_strongest_enemy_in_range(store.entities, tpos(this), 0, a.range, aa.node_prediction, aa.vis_flags, aa.vis_bans, function(e)
			return not aa.excluded_templates or not table.contains(aa.excluded_templates, e.template_name)
		end)

		return target, pred_pos
	end

	do
		local soffset = this.shooter_offset
		local an, af, ai = U.animation_name_facing_point(this, "idle", a._last_target_pos, shooter_sid, soffset)

		U.animation_start_group(this, an, false, store.tick_ts, false, "layers")
	end

	::label_528_0::

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == pow_d then
							ad.cooldown = pow.cooldown[pow.level]

							if pow.level == 1 then
								ad.ts = store.tick_ts - ad.cooldown
							end
						end

						if pow == pow_e then
							ae.cooldown = pow.cooldown[pow.level]
							ae.ts = store.tick_ts - ae.cooldown
						end
					end
				end
			end

			SU.towers_swaped(store, this, this.attacks.list)

			if this.ui.hover_active and this.ui.args == "empowerment" and not empowerments_previews and pow_e and pow_e.level == 0 then
				empowerments_previews = {}

				local targets = table.filter(store.entities, function(k, v)
					return v.tower and v.tower.type == "holder" and v.ui.can_click and U.is_inside_ellipse(v.pos, this.pos, ae.max_range) or v.tower and not v.pending_removal and not v.tower.blocked and (not ae.excluded_templates or not table.contains(ae.excluded_templates, v.template_name)) and U.is_inside_ellipse(v.pos, this.pos, ae.max_range) and (ae.min_range == 0 or not U.is_inside_ellipse(v.pos, this.pos, ae.min_range)) and v.vis and band(v.vis.flags, ae.vis_bans) == 0 and band(v.vis.bans, ae.vis_flags) == 0 and not table.contains(ae.exclude_tower_kind, v.tower.kind) and not U.has_modifiers(store, v, ae.mod) and v.tower.can_be_mod
				end)

				if targets then
					for _, target in pairs(targets) do
						local decal = E:create_entity("decal_tower_arcane_wizard_empowerment_preview")

						decal.pos = target.pos
						decal.render.sprites[1].ts = store.tick_ts

						queue_insert(store, decal)
						table.insert(empowerments_previews, decal)
					end
				end
			elseif empowerments_previews and (not this.ui.hover_active or this.ui.args ~= "empowerment") then
				for _, decal in pairs(empowerments_previews) do
					queue_remove(store, decal)
				end

				empowerments_previews = nil
			end

			for i, aa in pairs(attacks) do
				local pow = pows[i]

				if (not pow or pow.level > 0) and store.tick_ts - aa.ts > aa.cooldown and store.tick_ts - last_ts > a.min_cooldown then
					if aa == ae then
						local towers = U.find_towers_in_range(store.entities, this.pos, ae, function(t)
							local has_mod, mods = U.has_modifiers(store, t, ae.mod)
							local max_factor = 1

							if has_mod and mods and #mods >= 1 then
								for k, v in pairs(mods) do
									if max_factor < v.damage_factor then
										max_factor = v.damage_factor
									end
								end
							end

							return t.tower.can_be_mod and max_factor < pow.damage_factor[pow.level] and band(t.vis.flags, ae.vis_bans) == 0 and band(t.vis.bans, ae.vis_flags) == 0 and not table.contains(ae.exclude_tower_kind, t.tower.kind)
						end)

						if not towers or #towers <= 0 then
							SU.delay_attack(store, ae, ae.cooldown)
						else
							local start_ts = store.tick_ts

							if first_time_empower then
								U.animation_start_group(this, aa.animation, false, store.tick_ts, false, "layers")
								U.y_wait(store, aa.shoot_time)

								first_time_empower = false
								last_ts = store.tick_ts
							end

							S:queue(a.sound)

							for _, tower in ipairs(towers) do
								local m = E:create_entity(ae.mod)

								m.modifier.source_id = this.id
								m.modifier.target_id = tower.id
								m.modifier.level = pow.level
								m.damage_factor = pow.damage_factor[pow.level]

								queue_insert(store, m)

								m = E:create_entity(ae.mod_fx)
								m.modifier.source_id = this.id
								m.modifier.target_id = tower.id
								m.modifier.level = pow.level
								m.pos = tower.pos

								queue_insert(store, m)
							end

							ae.ts = start_ts

							U.y_animation_wait_group(this, "layers")

							goto label_528_0
						end
					elseif (aa == ad and this.tower.can_do_magic) or aa ~= ad then
						local enemy, pred_pos = find_target(aa)

						if not enemy then
							SU.delay_attack(store, aa, fts(10))
						else
							local enemy_id = enemy.id
							local enemy_pos = enemy.pos

							last_ts = store.tick_ts

							if aa == ad then
								S:queue(ad.sound)
							end

							local soffset = this.shooter_offset
							local an, af, ai = U.animation_name_facing_point(this, aa.animation, enemy.pos, shooter_sid, soffset)

							a._last_target_pos.x, a._last_target_pos.y = enemy.pos.x, enemy.pos.y

							U.animation_start_group(this, an, false, store.tick_ts, false, "layers")

							local b = E:create_entity(aa.bullet)
							local start_offset = table.safe_index(aa.bullet_start_offset, ai)

							if aa.load_time then
								U.y_wait(store, aa.load_time)

								if b.bullet.out_fx then
									local fx = E:create_entity(b.bullet.out_fx)

									fx.pos.x, fx.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
									fx.render.sprites[1].ts = store.tick_ts

									queue_insert(store, fx)

									this.ray_fx_start = fx
								end

								U.y_wait(store, aa.shoot_time - aa.load_time)
							else
								U.y_wait(store, aa.shoot_time)

								if b.bullet.out_fx then
									local fx = E:create_entity(b.bullet.out_fx)

									fx.pos.x, fx.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
									fx.render.sprites[1].ts = store.tick_ts

									queue_insert(store, fx)

									this.ray_fx_start = fx
								end
							end

							enemy, pred_pos = find_target(aa)

							if enemy then
								enemy_id = enemy.id
								enemy_pos = enemy.pos

								if aa == ad then
									local is_boss = U.flag_has(enemy.vis.flags, bor(F_BOSS, F_MINIBOSS))

									if not is_boss then
										enemy.vis.bans = F_ALL
									end
								end
							end

							aa.ts = last_ts
							b.bullet.damage_min = b.bullet.damage_min_config[this.tower.level]
							b.bullet.damage_max = b.bullet.damage_max_config[this.tower.level]
							b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.vclone(enemy_pos)
							b.bullet.target_id = enemy_id
							b.bullet.source_id = this.id
							b.tower_ref = this

							if aa == ad then
								b.bullet.level = pow_d.level
							else
								b.bullet.level = this.tower.level
							end

							queue_insert(store, b)
							U.y_animation_wait_group(this, "layers")

							goto label_528_0
						end
					else
					end
				end
			end

			if store.tick_ts - ar.ts > this.tower.long_idle_cooldown then
				local soffset = this.shooter_offset
				local an, af, ai = U.animation_name_facing_point(this, "idle", this.tower.long_idle_pos, shooter_sid, soffset)

				U.animation_start_group(this, an, false, store.tick_ts, true, "layers")
			end

			coroutine.yield()
		end
	end
end

function scripts.tower_arcane_wizard.remove(this, store)
	if this.ray_fx_start then
		queue_remove(store, this.ray_fx_start)
	end

	if this.tower.level < 4 then
		return true
	end

	local ae = this.attacks.list[3]
	local pow_e = this.powers and this.powers.empowerment or nil

	if pow_e.level > 0 then
		local towers = U.find_towers_in_range(store.entities, this.pos, ae, function(t)
			return U.has_modifiers(store, t, ae.mod)
		end)

		if towers then
			for _, tower in ipairs(towers) do
				local mods = table.filter(store.entities, function(k, v)
					return v.modifier and v.template_name == ae.mod and v.modifier.target_id == tower.id and v.modifier.source_id == this.id 
				end)
				for index, value in ipairs(mods) do
					queue_remove(store, value)
				end

				mods = table.filter(store.entities, function(k, v)
					return v.modifier and v.template_name == ae.mod_fx and v.modifier.target_id == tower.id and v.modifier.source_id == this.id 
				end)
				for index, value in ipairs(mods) do
					queue_remove(store, value)
				end
			end
		end
	end

	return true
end

scripts.mod_tower_arcane_wizard_power_empowerment = {}

function scripts.mod_tower_arcane_wizard_power_empowerment.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		this.pos = target.pos
	end

	m.ts = store.tick_ts

	if this.tween then
		this.tween.ts = store.tick_ts
	end

	while store.tick_ts - m.ts < m.duration and store.entities[this.modifier.source_id] and not store.entities[this.modifier.source_id].pending_removal do
		coroutine.yield()
	end

	queue_remove(store, this)
end

function scripts.mod_tower_arcane_wizard_power_empowerment.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.tower then
		log.error("error removing mod_tower_factors %s", this.id)

		return true
	end

	if this.damage_factor then
		target.tower.damage_factor = target.tower.damage_factor / this.damage_factor
	end

	local source = store.entities[this.source_id]

	if source then
		source.attacks.list[3].ts = store.tick_ts
	end

	return true
end

scripts.tower_arcane_wizard_power_empowerment_mark_mod = {}

function scripts.tower_arcane_wizard_power_empowerment_mark_mod.update(this, store)
	local m = this.modifier

	m.ts = store.tick_ts

	while true do
		local target = store.entities[m.target_id]
		local source = store.entities[m.source_id]

		if not target or m.duration >= 0 and store.tick_ts - m.ts > m.duration or not store.entities[this.modifier.source_id] or store.entities[this.modifier.source_id].pending_removal then
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

scripts.mod_hero_lava_hotheaded_fx = {}

function scripts.mod_hero_lava_hotheaded_fx.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	if not target then
		queue_remove(store, this)
		return
	end
	local name = target.template_name

	m.ts = store.tick_ts

	U.y_animation_play(this, "in", nil, store.tick_ts, 1)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		target = store.entities[m.target_id]

		if not target or target.template_name ~= name or m.duration >= 0 and store.tick_ts - m.ts > m.duration then
			U.y_animation_play(this, "out", nil, store.tick_ts, 1)
			queue_remove(store, this)

			return
		end

		coroutine.yield()
	end
end

scripts.tower_arcane_wizard_ray_disintegrate_mod = {}

function scripts.tower_arcane_wizard_ray_disintegrate_mod.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		return
	end

	local is_boss = U.flag_has(target.vis.flags, bor(F_BOSS, F_MINIBOSS))

	if not is_boss then
		SU.stun_inc(target)
	end

	this.pos = target.pos
	m.ts = store.tick_ts

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

		if store.tick_ts - m.ts >= m.duration then
			if is_boss then
				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id
				d.damage_type = DAMAGE_MAGICAL
				d.value = this.boss_damage_config[m.level]

				queue_damage(store, d)

				break
			else
				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id
				d.damage_type = m.damage_type
				d.value = m.damage
				d.pop = m.pop
				d.pop_chance = m.pop_chance
				d.pop_conds = m.pop_conds

				queue_damage(store, d)

				break
			end
		end

		if this.render and m.use_mod_offset and target.unit.hit_offset then
			this.render.sprites[1].offset.x, this.render.sprites[1].offset.y = target.unit.hit_offset.x, target.unit.hit_offset.y
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.tower_big_bertha = {}

function scripts.tower_big_bertha.update(this, store, script)
	local tower_sid = 2
	local a = this.attacks
	local ab = this.attacks.list[1]
	local ac = this.attacks.list[2]
	local at = this.attacks.list[3]
	local pow_t = this.powers and this.powers.tar
	local pow_c = this.powers and this.powers.cluster
	local last_ts = store.tick_ts

	ab.ts = store.tick_ts

	local aa, pow
	local attacks = {
		at,
		ac,
		ab
	}
	local pows = {
		pow_t,
		pow_c
	}

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == pow_t then
							at.cooldown = pow_t.cooldown[pow_t.level]

							if pow.level == 1 then
								at.ts = store.tick_ts
							end
						elseif pow == pow_c then
							ac.cooldown = pow_c.cooldown[pow_c.level]

							if pow.level == 1 then
								ac.ts = store.tick_ts
							end
						end
					end
				end
			end

			for i, aa in pairs(attacks) do
				pow = pows[i]

				if aa and (not pow or pow.level > 0) and store.tick_ts - aa.ts > aa.cooldown and (not a.min_cooldown or store.tick_ts - last_ts > a.min_cooldown) then
					local trigger, enemies, trigger_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.range, aa.node_prediction, aa.vis_flags, aa.vis_bans)

					if not trigger then
						-- block empty
					else
						aa.ts = store.tick_ts
						last_ts = aa.ts

						U.animation_start_group(this, aa.animation, nil, store.tick_ts, false, "layers")
						U.y_wait(store, aa.shoot_time)

						local enemy, __, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.range, aa.node_prediction, aa.vis_flags, aa.vis_bans)
						local dest = enemy and pred_pos or trigger_pos

						if V.dist(tpos(this).x, tpos(this).y, dest.x, dest.y) <= aa.range then
							local b = E:create_entity(aa.bullet)

							b.pos.x, b.pos.y = this.pos.x + aa.bullet_start_offset.x, this.pos.y + aa.bullet_start_offset.y
							b.bullet.damage_factor = this.tower.damage_factor
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = dest
							b.bullet.level = pow and pow.level or 1
							b.bullet.target_id = enemy and enemy.id or trigger.id
							b.bullet.source_id = this.id

							queue_insert(store, b)
						end

						U.y_animation_wait_group(this, "layers")
					end
				end
			end

			U.animation_start(this, "idle", nil, store.tick_ts)
			coroutine.yield()
		end
	end
end

scripts.tower_ghost = {}

function scripts.tower_ghost.get_info(this)
	local s = E:create_entity(this.barrack.soldier_type)

	if this.powers then
		for pn, p in pairs(this.powers) do
			for i = 1, p.level do
				SU.soldier_power_upgrade(s, pn)
			end
		end
	end

	local s_info = s.info.fn(s)
	local attacks

	if s.melee and s.melee.attacks then
		attacks = s.melee.attacks
	elseif s.ranged and s.ranged.attacks then
		attacks = s.ranged.attacks
	end

	local min, max

	for _, a in pairs(attacks) do
		if a.damage_min then
			local damage_factor = this.tower.damage_factor

			min, max = a.damage_min * damage_factor, a.damage_max * damage_factor

			break
		end
	end

	if min and max then
		min, max = math.ceil(min), math.ceil(max)
	end

	return {
		type = STATS_TYPE_TOWER_BARRACK,
		hp_max = s.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = s.health.armor,
		respawn = s.health.dead_lifetime
	}
end

function scripts.tower_ghost.update(this, store, script)
	local spawn_time = 0.5
	local spawn_ts = store.tick_ts
	local spawn_id = 4

	while true do
		local b = this.barrack

		if this.powers then
			local sa = this.powers.soul_attack

			if sa.changed or this.tower_upgrade_persistent_data.swaped then
				sa.changed = nil

				for _, s in pairs(b.soldiers) do
					s.powers.soul_attack.level = sa.level
					s.powers.soul_attack.changed = true
				end
			end

			local ed = this.powers.extra_damage

			if ed.changed or this.tower_upgrade_persistent_data.swaped then
				ed.changed = nil

				for _, s in pairs(b.soldiers) do
					s.powers.extra_damage.level = ed.level
					s.powers.extra_damage.changed = true
				end
			end
		end

		this.tower_upgrade_persistent_data.swaped = nil

		if not this.tower.blocked then
			for i = 1, b.max_soldiers do
				local s = b.soldiers[i]

				if spawn_time < store.tick_ts - spawn_ts and (not s or s.health.dead and not store.entities[s.id]) then
					S:queue(this.sound_events.spawn_unit)

					s = E:create_entity(b.soldier_type)
					s.soldier.tower_id = this.id
					s.origin_spawn = true
					s.soldier.tower_soldier_idx = i
					s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
					s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers, math.pi * 0.25)
					s.nav_rally.new = true

					if this.powers then
						s.powers.soul_attack.level = this.powers.soul_attack.level
						s.powers.extra_damage.level = this.powers.extra_damage.level
					end

					queue_insert(store, s)

					b.soldiers[i] = s

					signal.emit("tower-spawn", this, s)

					spawn_ts = store.tick_ts
					this.render.sprites[spawn_id].hidden = false

					U.y_animation_play(this, "idle", nil, store.tick_ts, 1, spawn_id)

					this.render.sprites[spawn_id].hidden = true
				end
			end
		end

		if b.rally_new then
			b.rally_new = false

			signal.emit("rally-point-changed", this)

			local all_dead = true

			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers, math.pi * 0.25)
				s.nav_rally.new = true
				all_dead = all_dead and s.health.dead
			end

			if not all_dead then
				S:queue(this.sound_events.change_rally_point)
			end
		end

		coroutine.yield()
	end
end

function scripts.tower_ghost.soldier_insert(this, store)
	if scripts.soldier_barrack.insert(this, store) then
		local pow_d = this.powers and this.powers.soul_attack or nil

		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.level > 0 and p == pow_d then
					-- block empty
				end
			end
		end

		return true
	end

	return false
end

function scripts.tower_ghost.soldier_update(this, store, script)
	local damage_factor_prev = this.health.damage_factor
	local mod_damage

	if this.vis._bans then
		this.vis.bans = this.vis._bans
		this.vis._bans = nil
	end

	this.nav_rally._first_time = true

	local function y_soldier_new_rally_break_attack(store, this, break_fn)
		local r = this.nav_rally
		local out = false
		local vis_bans = this.vis.bans
		local prev_immune = this.health.immune_to

		this.health.immune_to = r.immune_to
		this.vis.bans = F_ALL

		if r.new then
			r.new = false

			U.unblock_target(store, this)
			U.set_destination(this, r.pos)

			if r.delay_max then
				U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop)

				local index = this.soldier.tower_soldier_idx or 0
				local tower = store.entities[this.soldier.tower_id]
				local total = tower and tower.barrack.max_soldiers or 1

				if SU.y_soldier_wait(store, this, index / total * r.delay_max) then
					goto label_545_0
				end
			end

			local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

			U.animation_start(this, an, af, store.tick_ts, -1)

			while not this.motion.arrived do
				if this.health.dead or this.unit.is_stunned then
					out = true

					U.set_destination(this, r.pos)

					local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

					U.animation_start(this, an, af, store.tick_ts, -1)

					r.new = false
				end

				if r.new then
					out = false

					break
				end

				if break_fn() then
					out = false

					break
				end

				if r._first_time then
					r._first_time = false

					local target = U.find_foremost_enemy(store.entities, r.center, 0, this.melee.range, false, F_BLOCK, bit.bor(F_CLIFF), function(e)
						return (not e.enemy.max_blockers or #e.enemy.blockers == 0) and band(GR:cell_type(e.pos.x, e.pos.y), TERRAIN_NOWALK) == 0 and (not this.melee.fn_can_pick or this.melee.fn_can_pick(this, e))
					end)

					if target then
						out = false

						break
					end
				end

				U.walk(this, store.tick_length)
				coroutine.yield()

				this.motion.speed.x, this.motion.speed.y = 0, 0
			end
		end

		::label_545_0::

		this.vis.bans = vis_bans
		this.health.immune_to = prev_immune

		return out
	end

	local function check_tower_damage_factor()
		if store.entities[this.soldier.tower_id] then
			for _, a in ipairs(this.melee.attacks) do
				if not a._original_damage_min then
					a._original_damage_min = a.damage_min
				end

				if not a._original_damage_max then
					a._original_damage_max = a.damage_max
				end

				a.damage_min = a._original_damage_min * store.entities[this.soldier.tower_id].tower.damage_factor
				a.damage_max = a._original_damage_max * store.entities[this.soldier.tower_id].tower.damage_factor
			end
		end
	end

	local function walk_break_fn()
		return pow_l and pow_l.changed
	end

	if this.nav_rally.new then
		this.render.sprites[1].hidden = true
		this.ui.can_click = false

		local ps1 = E:create_entity(this.particle)

		ps1.particle_system.emit = true
		ps1.particle_system.track_id = this.id

		queue_insert(store, ps1)

		local flight_time = 1
		local from = V.vclone(this.pos)
		local g = -0.7 / (fts(1) * fts(1))

		if not this.origin_spawn then
			flight_time = flight_time * 0.5
		end

		local speed = SU.initial_parabola_speed(from, this.nav_rally.pos, flight_time, g)
		local flying = true
		local ts = store.tick_ts
		local fpos = V.vclone(this.nav_rally.pos)

		while flying do
			coroutine.yield()

			this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - ts, from, speed, g)

			if flight_time - 0.05 < store.tick_ts - ts then
				this.pos.x = fpos.x
				this.pos.y = fpos.y
				flying = false
				ps1.particle_system.emit = false
			end
		end

		local spawn = E:create_entity("decal_soldier_tower_ghost_spawn")

		spawn.render.sprites[1].ts = store.tick_ts
		spawn.pos = V.vclone(fpos)

		queue_insert(store, spawn)
		U.y_wait(store, fts(8))

		this.render.sprites[1].hidden = false

		U.y_animation_play(this, "spawn", nil, store.tick_ts, 1)
		queue_remove(store, ps1)

		this.ui.can_click = true
	end

	local extra_damage_ts = store.tick_ts

	while true do
		if this.health.dead then
			this.ui.can_click = false

			if this.powers and this.powers.soul_attack.level > 0 then
				log.info("soul attack")

				local soul = E:create_entity(this.soul)

				soul.level = this.powers.soul_attack.level
				soul.pos = V.vclone(this.pos)

				queue_insert(store, soul)
			end

			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if y_soldier_new_rally_break_attack(store, this, walk_break_fn) then
					goto label_544_0
				end
			end

			check_tower_damage_factor()

			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if this.powers and this.powers.extra_damage.level > 0 then
				this.extra_damage_cooldown = this.powers.extra_damage.cooldowns[this.powers.extra_damage.level]
				if sta ~= A_NO_TARGET and (mod_damage or store.tick_ts - extra_damage_ts > this.extra_damage_cooldown) then
					if not mod_damage then
						mod_damage = E:create_entity(this.mod_extra_damage)
						mod_damage.modifier.target_id = this.id
						mod_damage.modifier.source_id = this.id
						mod_damage.modifier.ts = store.tick_ts
						mod_damage.inflicted_damage_factor = this.powers.extra_damage.damages[this.powers.extra_damage.level]

						queue_insert(store, mod_damage)
					else
						mod_damage.modifier.ts = store.tick_ts
					end
				end
			end

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			else
				extra_damage_ts = store.tick_ts

				if mod_damage and store.tick_ts - mod_damage.modifier.ts > mod_damage.modifier.duration then
					mod_damage = nil
				end

				if SU.soldier_go_back_step(store, this) then
					-- block empty
				else
					SU.soldier_idle(store, this)
					SU.soldier_regen(store, this)
				end
			end
		end

		::label_544_0::

		coroutine.yield()
	end
end

function scripts.tower_ghost.soul_update(this, store, script)
	U.y_wait(store, this.delay)

	this.render.sprites[1].hidden = false

	U.y_animation_play(this, "idle", nil, store.tick_ts, 1, 1)

	local function shoot_bullet(enemy, level)
		local b = E:create_entity(this.bullet)

		b.pos.x = this.pos.x
		b.pos.y = this.pos.y + 75
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x, enemy.pos.y)
		b.bullet.target_id = enemy.id
		b.bullet.damage_min = this.damage_min[level]
		b.bullet.damage_max = this.damage_max[level]
		b.slow_factor = this.slow_factor[level]
		b.slow_duration = this.slow_duration[level]
		b.damage_factor_duration = this.damage_factor_duration[level]

		queue_insert(store, b)
	end

	local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, this.radius, F_ENEMY, this.vis_bans)
	if enemies then
		local max = math.min(#enemies, this.max_targets[this.level])
		for i = 1, max do
			shoot_bullet(enemies[i], this.level)
		end
	end

	queue_remove(store, this)
end

function scripts.tower_ghost.soul_bolt_update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	::label_79_0::

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

		if ps then
			ps.particle_system.emit = true
		end
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		if target and target.health and not target.health.dead then
			if b.ignore_hit_offset then
				b.to.x, b.to.y = target.pos.x, target.pos.y
			else
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end

			new_target = false
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length,
			this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end
	end

	while b.store and not b.target_id do
		coroutine.yield()

		if b.target_id then
			mspeed = b.min_speed
			new_target = true

			goto label_79_0
		end
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)
		local u = UP:get_upgrade("mage_spell_of_penetration")

		if u and math.random() < u.chance then
			d.damage_type = DAMAGE_TRUE
		end

		queue_damage(store, d)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)
				m.modifier.target_id = b.target_id
				m.modifier.level = b.level

				if mod_name == "mod_tower_ghost_soul_slow" then
					m.slow.factor = this.slow_factor
					m.modifier.duration = this.slow_duration
				elseif mod_name == "mod_tower_ghost_soul_damage_factor" then
					m.modifier.duration = this.damage_factor_duration
				end

				queue_insert(store, m)
			end
		end

		if b.hit_payload then
			local hp = b.hit_payload

			hp.pos.x, hp.pos.y = this.pos.x, this.pos.y

			queue_insert(store, hp)
		end
	end

	if b.payload then
		local hp = b.payload

		hp.pos.x, hp.pos.y = b.to.x, b.to.y

		queue_insert(store, hp)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.tower_tricannon = {}

function scripts.tower_tricannon.update(this, store, script)
	local tower_sid = 2
	local a = this.attacks
	local ab = this.attacks.list[1]
	local am = this.attacks.list[2]
	local ao = this.attacks.list[3]
	local pow_m = this.powers and this.powers.bombardment
	local pow_o = this.powers and this.powers.overheat
	local last_ts = store.tick_ts - ab.cooldown

	ab.ts = store.tick_ts - ab.cooldown + a.attack_delay_on_spawn

	local aa, pow
	local attacks = {
		ao,
		am,
		ab
	}
	local pows = {
		pow_o,
		pow_m
	}
	local overheateble_attacks = {
		am,
		ab
	}

	local function shoot_bullet(attack, enemy, dest, bullet_idx)
		local b = E:create_entity(attack.bullet)
		local bullet_start_offset = bullet_idx and attack.bullet_start_offset[bullet_idx] or attack.bullet_start_offset

		b.pos.x, b.pos.y = this.pos.x + bullet_start_offset.x, this.pos.y + bullet_start_offset.y
		b.bullet.damage_factor = this.tower.damage_factor
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = dest

		if attack.bullet == attack.bullet_overheated then
			pow = pow_o
		end

		b.bullet.level = pow and pow.level or 1
		b.bullet.target_id = enemy and enemy.id
		b.bullet.source_id = this.id

		queue_insert(store, b)

		return b
	end

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == pow_m then
							am.cooldown = pow_m.cooldown[pow_m.level]

							if pow.level == 1 then
								am.ts = store.tick_ts - am.cooldown
							end
						elseif pow == pow_o then
							ao.cooldown = pow_o.cooldown[pow_o.level]
							ao.duration = pow_o.duration[pow_o.level]

							if pow.level == 1 then
								ao.ts = store.tick_ts - ao.cooldown
							end
						end
					end
				end
			end

			SU.towers_swaped(store, this, this.attacks.list)

			if ao and ao.active and store.tick_ts - ao.ts > ao.duration and (not am or not am.active) then
				ao.active = nil

				for _, attack in ipairs(overheateble_attacks) do
					attack.bullet = attack._default_bullet
				end

				U.y_animation_play_group(this, ao.animation_end, nil, store.tick_ts, false, "layers")

				if am and am.cooldown and store.tick_ts - am.ts > am.cooldown then
					am.ts = store.tick_ts - (am.cooldown - a.min_cooldown)
				end
			end

			for i, aa in pairs(attacks) do
				pow = pows[i]

				if aa and (not pow or pow.level > 0) and aa.cooldown and store.tick_ts - aa.ts > aa.cooldown and (not a.min_cooldown or store.tick_ts - last_ts > a.min_cooldown) then
					local trigger, enemies, trigger_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.range, aa.node_prediction, aa.vis_flags, aa.vis_bans)

					if not trigger then
						SU.delay_attack(store, aa, fts(10))
					else
						local trigger_path = trigger.nav_path.pi

						if aa == ab then
							aa.ts = store.tick_ts
							last_ts = aa.ts

							local trigger_target_positions = {}

							for j = 1, aa.bomb_amount do
								local enemy_index = km.zmod(j + 1, #enemies)
								local enemy = enemies[enemy_index]
								local ni = enemy.nav_path.ni + P:predict_enemy_node_advance(enemy, aa.node_prediction)
								local dest = P:node_pos(enemy.nav_path.pi, enemy.nav_path.spi, ni)

								table.insert(trigger_target_positions, dest)
							end

							local shoot_animation = aa.animation

							if ao and ao.active then
								shoot_animation = ao.animation_shoot
							end

							U.animation_start_group(this, shoot_animation, nil, store.tick_ts, false, "layers")
							U.y_wait(store, aa.shoot_time)
							S:queue(aa.sound)

							local _, enemies, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.range, aa.node_prediction, aa.vis_flags, aa.vis_bans)
							local target_positions = {}

							if enemies and #enemies > 0 then
								for j = 1, aa.bomb_amount do
									local enemy_index = km.zmod(j + 1, #enemies)
									local enemy = enemies[enemy_index]
									local ni = enemy.nav_path.ni + P:predict_enemy_node_advance(enemy, aa.node_prediction)
									local dest = P:node_pos(enemy.nav_path.pi, enemy.nav_path.spi, ni)

									table.insert(target_positions, {
										enemy = enemy,
										dest = dest
									})
								end
							else
								for j = 1, aa.bomb_amount do
									local trigger_target_positions_index = km.zmod(j + 1, #trigger_target_positions)
									local trigger_target_position = trigger_target_positions[trigger_target_positions_index]

									table.insert(target_positions, {
										dest = trigger_target_position
									})
								end
							end

							local enemies_hitted = {}

							for bullet_idx, target_position_data in ipairs(target_positions) do
								local enemy = target_position_data.enemy
								local pred = target_position_data.dest

								if enemy then
									local dest = P:predict_enemy_pos(enemy, aa.node_prediction)

									if U.is_inside_ellipse(tpos(this), dest, a.range * 1.05) then
										pred = dest

										table.insert(enemies_hitted, enemy.id)
									end
								end

								local enemy_hit_count = table.count(enemies_hitted, function(k, v)
									if v == enemy.id then
										return true
									end

									return false
								end)

								if not enemy or enemy and enemy_hit_count > 1 then
									pred.x = pred.x + U.frandom(0, ab.random_x_to_dest) * U.random_sign()
									pred.y = pred.y + U.frandom(0, ab.random_y_to_dest) * U.random_sign()

									local nearest_nodes = P:nearest_nodes(pred.x, pred.y)
									local pi, spi, ni = unpack(nearest_nodes[1])

									pred = P:node_pos(pi, spi, ni)
								end

								shoot_bullet(aa, nil, pred, bullet_idx)
								U.y_wait(store, aa.time_between_bombs)
							end

							U.y_animation_wait_group(this, "layers")

							aa.ts = last_ts
						elseif aa == am and this.tower.can_do_magic then
							aa.ts = store.tick_ts
							last_ts = aa.ts
							aa.active = true

							U.animation_start_group(this, aa.animation_start, nil, store.tick_ts, false, "layers")
							U.y_wait(store, aa.shoot_time)

							local enemy, __, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.range, aa.node_prediction, aa.vis_flags, aa.vis_bans)
							local dest = enemy and pred_pos or trigger_pos
							local dest_path = enemy and enemy.nav_path.pi or trigger_path
							local nearest_nodes = P:nearest_nodes(dest.x, dest.y, {
								dest_path
							})
							local pi, spi, ni = unpack(nearest_nodes[1])
							local spread = aa.spread[pow.level]
							local node_skip = aa.node_skip[pow.level]
							local nindices = {}

							for ni_candidate = ni - spread, ni + spread, node_skip do
								if P:is_node_valid(pi, ni_candidate) then
									table.insert(nindices, ni_candidate)
								end
							end

							table.append(nindices, table.map(nindices, function(index, value)
								return value + 1
							end))
							S:queue(aa.sounds[pow.level])
							U.animation_start_group(this, aa.animation_loop, nil, store.tick_ts, true, "layers")

							for _, ni_candidate in ipairs(table.random_order(nindices)) do
								local spi = math.random(1, 3)
								local destination = P:node_pos(pi, spi, ni_candidate)
								local b = shoot_bullet(aa, nil, destination, 1)
								local min_time = aa.time_between_bombs_min
								local max_time = aa.time_between_bombs_max

								U.y_wait(store, fts(math.random(min_time, max_time)))
							end

							U.y_animation_wait_group(this, "layers")
							U.animation_start_group(this, aa.animation_end, nil, store.tick_ts, false, "layers")
							U.y_animation_wait_group(this, "layers")
							aa.active = nil

							if ao and ao.cooldown and store.tick_ts - ao.ts > ao.cooldown then
								ao.ts = store.tick_ts - (ao.cooldown - a.min_cooldown)
							end
						elseif aa == ao and this.tower.can_do_magic then
							aa.ts = store.tick_ts
							aa.active = true

							for _, attack in ipairs(overheateble_attacks) do
								attack._default_bullet = attack.bullet
								attack.bullet = attack.bullet_overheated
							end

							S:queue(aa.sound)
							U.y_animation_play_group(this, aa.animation_charge, nil, store.tick_ts, false, "layers")
						end
					end
				end
			end

			local idle_animation = "idle"

			if ao and ao.active then
				idle_animation = ao.animation_idle
			end

			U.y_animation_play_group(this, idle_animation, nil, store.tick_ts, false, "layers")
			coroutine.yield()
		end
	end
end

scripts.mod_tricannon_overheat_dps = {}

function scripts.mod_tricannon_overheat_dps.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead then
		return false
	end

	if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	if target and target.unit and this.render then
		local s = this.render.sprites[1]

		s.ts = store.tick_ts

		if s.size_names then
			s.name = s.size_names[target.unit.size]
		end

		if s.size_scales then
			s.scale = s.size_scales[target.unit.size]
		end

		if target.render then
			s.z = target.render.sprites[1].z
		end
	end

	this.dps.damage_min = this.dps.damage_config[this.modifier.level]
	this.dps.damage_max = this.dps.damage_config[this.modifier.level]
	this.dps.ts = store.tick_ts - this.dps.damage_every
	this.modifier.ts = store.tick_ts

	signal.emit("mod-applied", this, target)

	return true
end

scripts.tower_paladin_covenant = {}

function scripts.tower_paladin_covenant.get_info(this)
	local s = E:create_entity(this.barrack.soldier_type)

	if this.powers then
		for pn, p in pairs(this.powers) do
			for i = 1, p.level do
				SU.soldier_power_upgrade(s, pn)
			end
		end
	end

	local s_info = s.info.fn(s)
	local attacks

	if s.melee and s.melee.attacks then
		attacks = s.melee.attacks
	elseif s.ranged and s.ranged.attacks then
		attacks = s.ranged.attacks
	end

	local min, max

	for _, a in pairs(attacks) do
		if a.damage_min then
			local damage_factor = this.tower.damage_factor

			min, max = a.damage_min * damage_factor, a.damage_max * damage_factor

			break
		end
	end

	if min and max then
		min, max = math.ceil(min), math.ceil(max)
	end

	return {
		type = STATS_TYPE_TOWER_BARRACK,
		hp_max = s.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = s.health.armor,
		respawn = s.health.dead_lifetime
	}
end

function scripts.tower_paladin_covenant.soldier_insert(this, store)
	if scripts.soldier_barrack.insert(this, store) then
		local pow_h = this.powers and this.powers.healing_prayer or nil
		local pow_l = this.powers and this.powers.lead or nil
		local a_h = this.timed_attacks and this.timed_attacks.list[1] or nil
		local a_l = this.timed_attacks and this.timed_attacks.list[2] or nil

		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.level > 0 then
					if p == pow_h then
						a_h.disabled = nil
						a_h.cooldown = p.cooldown[p.level]
						a_h.lost_health = p.health_trigger_factor[p.level]
					elseif p == pow_l and this.soldier.tower_soldier_idx and this.soldier.tower_soldier_idx == 1 then
						local b = p.b

						this.health.hp_max = b.hp
						this.health.hp = this.health.hp_max
						this.regen.health = b.regen_hp
						this.health.armor = b.armor
						this.melee.attacks[1].damage_min = b.basic_attack.damage_min
						this.melee.attacks[1].damage_max = b.basic_attack.damage_max
						this.melee.attacks[1].hit_time = p.hit_time
						this.melee.attacks[1].damage_type = DAMAGE_TRUE
						this.melee.attacks[2].damage_min = b.basic_attack.damage_min
						this.melee.attacks[2].damage_max = b.basic_attack.damage_max
						this.melee.attacks[2].hit_time = p.hit_time
						this.melee.attacks[2].damage_type = DAMAGE_TRUE
						this.render.sprites[1].prefix = p.sprite_prefix
						this.health_bar.type = p.health_bar_size
						this.health_bar.offset.y = this.health_bar.offset.y + 2
						this.soldier.is_captain = true
						this.info.portrait = p.portrait
						a_l.disabled = nil
						a_l.cooldown = p.cooldown[p.level]
						a_l.ts = store.tick_ts
					end
				end
			end
		end

		return true
	end

	return false
end

function scripts.tower_paladin_covenant.soldier_update(this, store, script)
	local brk, sta
	local pow_h = this.powers and this.powers.healing_prayer or nil
	local pow_l = this.powers and this.powers.lead or nil
	local a_h = this.timed_attacks and this.timed_attacks.list[1] or nil
	local a_l = this.timed_attacks and this.timed_attacks.list[2] or nil
	local damage_factor_prev = this.health.damage_factor
	local mods = {}

	if this.vis._bans then
		this.vis.bans = this.vis._bans
		this.vis._bans = nil
	end

	this.nav_rally._first_time = true

	local function y_soldier_new_rally_break_attack(store, this, break_fn)
		local r = this.nav_rally
		local out = false
		local vis_bans = this.vis.bans
		local prev_immune = this.health.immune_to

		this.health.immune_to = r.immune_to
		this.vis.bans = F_ALL

		if r.new then
			r.new = false

			U.unblock_target(store, this)
			U.set_destination(this, r.pos)

			if r.delay_max then
				U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop)

				local index = this.soldier.tower_soldier_idx or 0
				local tower = store.entities[this.soldier.tower_id]
				local total = tower and tower.barrack.max_soldiers or 1

				if SU.y_soldier_wait(store, this, index / total * r.delay_max) then
					goto label_559_0
				end
			end

			local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

			U.animation_start(this, an, af, store.tick_ts, -1)

			while not this.motion.arrived do
				if this.health.dead or this.unit.is_stunned then
					out = true

					break
				end

				if r.new then
					out = false

					U.set_destination(this, r.pos)

					local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

					U.animation_start(this, an, af, store.tick_ts, -1)

					r.new = false
				end

				if break_fn() then
					out = false

					break
				end

				if r._first_time then
					r._first_time = false

					local target = U.find_foremost_enemy(store.entities, r.center, 0, this.melee.range, false, F_BLOCK, bit.bor(F_CLIFF), function(e)
						return (not e.enemy.max_blockers or #e.enemy.blockers == 0) and band(GR:cell_type(e.pos.x, e.pos.y), TERRAIN_NOWALK) == 0 and (not this.melee.fn_can_pick or this.melee.fn_can_pick(this, e))
					end)

					if target then
						out = false

						break
					end
				end

				U.walk(this, store.tick_length)
				coroutine.yield()

				this.motion.speed.x, this.motion.speed.y = 0, 0
			end
		end

		::label_559_0::

		this.vis.bans = vis_bans
		this.health.immune_to = prev_immune

		return out
	end

	local function check_tower_damage_factor()
		if store.entities[this.soldier.tower_id] then
			for _, a in ipairs(this.melee.attacks) do
				if not a._original_damage_min then
					a._original_damage_min = a.damage_min
				end
				if not a._original_damage_max then
					a._original_damage_max = a.damage_max
				end

				a.damage_min = a._original_damage_min * store.entities[this.soldier.tower_id].tower.damage_factor
				a.damage_max = a._original_damage_max * store.entities[this.soldier.tower_id].tower.damage_factor
			end
		end
	end

	local function walk_break_fn()
		return pow_l and pow_l.changed
	end

	while true do
		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					SU.soldier_power_upgrade(this, pn)

					if p == pow_h then
						a_h.disabled = nil
						a_h.cooldown = p.cooldown[p.level]
						a_h.lost_health = p.health_trigger_factor[p.level]

						if p.level == 1 then
							a_h.ts = store.tick_ts - a_h.cooldown
						end
					elseif p == pow_l and this.soldier.tower_soldier_idx and this.soldier.tower_soldier_idx == 1 then
						local b = p.b

						this.health.hp_max = b.hp
						this.health.hp = this.health.hp_max
						this.regen.health = b.regen_hp
						this.health.armor = b.armor
						this.melee.attacks[1].damage_min = b.basic_attack.damage_min
						this.melee.attacks[1].damage_max = b.basic_attack.damage_max
						this.melee.attacks[1]._original_damage_min = b.basic_attack.damage_min
						this.melee.attacks[1]._original_damage_max = b.basic_attack.damage_max
						this.melee.attacks[1].hit_time = p.hit_time
						this.melee.attacks[1].damage_type = DAMAGE_TRUE
						this.melee.attacks[2].damage_min = b.basic_attack.damage_min
						this.melee.attacks[2].damage_max = b.basic_attack.damage_max
						this.melee.attacks[2]._original_damage_min = b.basic_attack.damage_min
						this.melee.attacks[2]._original_damage_max = b.basic_attack.damage_max
						this.melee.attacks[2].hit_time = p.hit_time
						this.melee.attacks[2].damage_type = DAMAGE_TRUE
						this.render.sprites[1].prefix = p.sprite_prefix
						this.soldier.is_captain = true
						this.health_bar.offset.y = this.health_bar.offset.y + 2
						this.info.portrait = p.portrait
						this.health_bar.type = p.health_bar_size

						for _, frame in ipairs(this.health_bar.frames) do
							local hb_sizes = HEALTH_BAR_SIZES[store.texture_size] or HEALTH_BAR_SIZES.default
							local hbsize = hb_sizes[this.health_bar.type]

							frame.bar_width = hbsize.x
							frame.scale = V.v(hbsize.x, hbsize.y)
							frame.offset.x = frame.offset.x - hbsize.x * frame.ss.ref_scale / 2
						end

						a_l.disabled = nil
						a_l.cooldown = p.cooldown[p.level]

						if p.level == 1 then
							a_l.ts = store.tick_ts
						end

						U.y_animation_play(this, this.powers.lead.animation_upgrade, nil, store.tick_ts, 1)
					end
				end
			end
		end

		if this.health.dead then
			this.ui.can_click = false

			SU.y_soldier_death(store, this)

			while true do
				if pow_l and pow_l.changed then
					queue_remove(store, this)
				end

				coroutine.yield()
			end
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if y_soldier_new_rally_break_attack(store, this, walk_break_fn) then
					goto label_558_0
				end
			end

			check_tower_damage_factor()

			if this.timed_attacks then
				do
					local a = a_h

					if not a.disabled and this.health.hp <= this.health.hp_max * a.lost_health and store.tick_ts - a.ts > a.cooldown then
						local needs_cleanup = false

						U.animation_start(this, a.animation .. "_start", nil, store.tick_ts)
						S:queue(a.sound)

						if SU.y_soldier_wait(store, this, a.hit_time[this.unit.is_captain and 2 or 1]) then
							-- block empty
						else
							a.ts = store.tick_ts
							needs_cleanup = true
							SU.remove_modifiers(store, this)
							mods = {}

							for _, m in ipairs(a.mods) do
								local mod = E:create_entity(m)

								mod.modifier.target_id = this.id
								mod.modifier.source_id = this.id
								mod.modifier.level = pow_h.level

								queue_insert(store, mod)
								table.insert(mods, mod)
							end

							this.health._damage_factor = this.health.damage_factor
							this.health.damage_factor = 0

							if SU.y_soldier_animation_wait(this) then
								-- block empty
							else
								U.animation_start(this, a.animation .. "_loop", nil, store.tick_ts, true)

								if SU.y_soldier_wait(store, this, a.duration - (store.tick_ts - a.ts)) then
									-- block empty
								else
									U.animation_start(this, a.animation .. "_end", nil, store.tick_ts)

									if SU.y_soldier_animation_wait(this) then
										-- block empty
									end
								end
							end
						end
					end
				end

				local a = a_l

				if not a.disabled and store.tick_ts - a.ts > a.cooldown then
					local _, enemies = U.find_foremost_enemy(store.entities, this.pos, 0, a.enemies_trigger_range, false, a.vis_flags, a.vis_bans)

					if not enemies or enemies and #enemies <= 0 then
						SU.delay_attack(store, a, fts(15))
					else
						U.animation_start(this, a.animation, nil, store.tick_ts)
						S:queue(a.sound)

						if SU.y_soldier_wait(store, this, a.hit_time) then
							goto label_558_0
						end

						a.ts = store.tick_ts

						SU.insert_sprite(store, a.fx, this.pos)

						do
							local e = E:create_entity(a.aura_name)

							e.pos.x, e.pos.y = this.pos.x, this.pos.y
							e.owner = this
							e.aura.source_id = this.id

							queue_insert(store, e)
						end

						if SU.y_soldier_animation_wait(this) then
							goto label_558_0
						end
					end
				end
			end

			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_558_0::

		coroutine.yield()
	end
end

scripts.tower_paladin_covenant_soldier_lvl4_invincibility = {}
function scripts.tower_paladin_covenant_soldier_lvl4_invincibility.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]
	if not target or not target.health or target.health.dead then
		return false
	end
	this.modifier.duration = this.invincibility_duration[this.modifier.level]
	this.modifier.ts = store.tick_ts
	signal.emit("mod-applied", this, target)
	return true
end

function scripts.tower_paladin_covenant_soldier_lvl4_invincibility.update(this, store, script)
	local m = this.modifier
	local duration = m.duration
	local target = store.entities[m.target_id]
	if not target then
		queue_remove(store, this)
		return
	end
	this.pos = target.pos
	while true do
		if not target or target.health.dead or duration < store.tick_ts - m.ts then
			queue_remove(store, this)
			return
		end
		coroutine.yield()
	end
end

function scripts.tower_paladin_covenant_soldier_lvl4_invincibility.remove(this, store, script)
	local target = store.entities[this.modifier.source_id]
	if target then
		target.health.damage_factor = target.health._damage_factor
	end
	return true
end

scripts.tower_demon_pit = {}

function scripts.tower_demon_pit.get_info(this)
	local b = E:create_entity(this.attacks.list[1].bullet)
	local d = E:create_entity(b.bullet.hit_payload)

	if this.powers then
		for pn, p in pairs(this.powers) do
			for i = 1, p.level do
				SU.soldier_power_upgrade(d, pn)
			end
		end
	end

	local s_info = d.info.fn(d)
	local attacks

	if d.melee and d.melee.attacks then
		attacks = d.melee.attacks
	elseif d.ranged and d.ranged.attacks then
		attacks = d.ranged.attacks
	end

	local min, max

	for _, a in pairs(attacks) do
		if a.damage_min then
			local damage_factor = this.tower.damage_factor

			min, max = a.damage_min * damage_factor, a.damage_max * damage_factor

			break
		end
	end

	if min and max then
		min, max = math.ceil(min), math.ceil(max)
	end

	return {
		type = STATS_TYPE_TOWER_BARRACK,
		hp_max = d.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = d.health.armor,
		respawn = d.health.dead_lifetime
	}
end

function scripts.tower_demon_pit.update(this, store, script)
	local a = this.attacks
	local ab = a.list[1]
	local ag = a.list[2]
	local last_ts = store.tick_ts - ab.cooldown

	ab.ts = store.tick_ts - ab.cooldown + a.attack_delay_on_spawn

	local attacks = {
		ag,
		ab
	}
	local pows = {}
	local pow_g, pow_m

	if this.powers then
		pows[1] = this.powers.big_guy
		pow_g = this.powers.big_guy
		pow_m = this.powers.master_exploders
	end

	local function shoot_bullet(attack, enemy, dest, pow)
		local b = E:create_entity(attack.bullet)
		local bullet_start_offset = attack.bullet_start_offset

		b.pos.x, b.pos.y = this.pos.x + bullet_start_offset.x, this.pos.y + bullet_start_offset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.vclone(dest)
		b.bullet.to.x = b.bullet.to.x + math.random(-10, 10)
		b.bullet.to.y = b.bullet.to.y + math.random(-10, 10)
		b.bullet.level = pow and pow.level or 1
		b.bullet.pow_level = pow and pow.level or nil
		b.bullet.target_id = enemy and enemy.id
		b.bullet.source_id = this.id

		queue_insert(store, b)

		return b
	end

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.powers then
				for _, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == pow_g then
							if pow.level == 1 then
								ag.ts = store.tick_ts
								ab.animation = "big_guy_attack"
								ab.animation_reload = "big_guy_reload_2"

								U.animation_start(this, "big_guy_buy", nil, store.tick_ts, false, this.demons_sid)
								U.y_animation_wait(this, this.demons_sid)
							end

							ag.cooldown = pow.cooldown[pow.level]
							ag.ts = store.tick_ts - ag.cooldown
						end
					end
				end
			end

			SU.towers_swaped(store, this, this.attacks.list)

			for i, aa in pairs(attacks) do
				local pow = pows[i]

				if aa and (not pow or pow.level > 0) and aa.cooldown and store.tick_ts - aa.ts > aa.cooldown and (not a.min_cooldown or store.tick_ts - last_ts > a.min_cooldown) then
					local trigger, _, shoot_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.max_range * 1.2, aa.node_prediction, aa.vis_flags, aa.vis_bans)

					if not trigger then
						SU.delay_attack(store, aa, fts(10))
					elseif aa == ag then
						last_ts = store.tick_ts

						U.animation_start(this, aa.animation, nil, store.tick_ts, false, this.demons_sid)
						U.y_wait(store, aa.shoot_time)

						local _, enemies, enemy_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.max_range * 1.2, aa.node_prediction, aa.vis_flags, aa.vis_bans)

						if enemies and #enemies > 0 then
							shoot_pos = enemy_pos
						end

						local b = shoot_bullet(aa, nil, shoot_pos, pow)

						U.y_animation_wait(this, this.demons_sid)
						U.animation_start(this, aa.animation_reload, nil, store.tick_ts, false, this.demons_sid)
						U.y_animation_wait(this, this.demons_sid)

						aa.ts = last_ts
					elseif aa == ab then
						last_ts = store.tick_ts

						local d = E:create_entity(this.decal_reload)

						d.render.sprites[1].name = this.animation_reload
						d.render.sprites[1].fps = this.render.sprites[this.demons_sid].fps
						d.pos = V.vclone(this.pos)

						queue_insert(store, d)
						U.y_animation_wait(d)
						U.animation_start(this, aa.animation_reload, nil, store.tick_ts, false, this.demons_sid)
						U.y_animation_wait(this, this.demons_sid)
						U.animation_start(this, aa.animation, nil, store.tick_ts, false, this.demons_sid)
						U.y_wait(store, aa.shoot_time)

						local _, enemies, enemy_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.max_range * 1.2, aa.node_prediction, aa.vis_flags, aa.vis_bans)
						local found_unblocked = false

						if enemies and #enemies > 0 then
							for _, e in ipairs(enemies) do
								if #e.enemy.blockers == 0 then
									shoot_pos = e.__ffe_pos
									found_unblocked = true

									break
								end
							end

							if not found_unblocked then
								shoot_pos = enemy_pos
							end
						end

						shoot_bullet(aa, nil, shoot_pos, pow_m)
						U.y_animation_wait(this, this.demons_sid)

						aa.ts = last_ts
					end
				end
			end

			coroutine.yield()
		end
	end
end

scripts.decal_tower_demon_pit_reload = {}

function scripts.decal_tower_demon_pit_reload.update(this, store, script)
	this.render.sprites[1].ts = store.tick_ts

	U.y_animation_wait(this)

	this.render.sprites[1].hidden = true

	queue_remove(store, this)
end

scripts.soldier_tower_demon_pit = {}

function scripts.soldier_tower_demon_pit.update(this, store, script)
	local brk, stam

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts
	this.nav_rally.center = nil
	this.nav_rally.pos = V.vclone(this.pos)

	local tower = store.entities[this.source_id]
	local damage_factor = 1
	local pow_master_exploders

	if tower and tower.powers and tower.powers.master_exploders.level > 0 then
		local level = tower.powers.master_exploders.level

		damage_factor = tower.powers.master_exploders.explosion_damage_factor[level]
		pow_master_exploders = tower.powers.master_exploders
	end

	local function explosion(r, damage_min, damage_max, dty)
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, r, 0, bit.bor(F_FLYING, F_CLIFF))

		if targets then
			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				damage_min = damage_min * damage_factor
				damage_max = damage_max * damage_factor
				d.value = math.random(damage_min, damage_max)
				d.damage_type = dty
				d.target_id = target.id
				d.source_id = this.id

				queue_damage(store, d)

				local m = E:create_entity(this.explosion_mod_stun)

				m.modifier.source_id = this.id
				m.modifier.target_id = target.id
				m.modifier.duration = this.explosion_mod_stun_duration[this.level]

				queue_insert(store, m)

				if pow_master_exploders then
					m = E:create_entity(pow_master_exploders.mod)
					m.modifier.source_id = this.id
					m.modifier.target_id = target.id
					m.modifier.duration = pow_master_exploders.burning_duration[pow_master_exploders.level]
					m.dps.damage_min = pow_master_exploders.burning_damage_min[pow_master_exploders.level]
					m.dps.damage_max = pow_master_exploders.burning_damage_max[pow_master_exploders.level]

					queue_insert(store, m)
				end
			end
		end
	end

	local function check_tower_damage_factor()
		if store.entities[this.source_id] then
			for _, a in ipairs(this.melee.attacks) do
				if not a._original_damage_min then
					a._original_damage_min = a.damage_min
				end

				if not a._original_damage_max then
					a._original_damage_max = a.damage_max
				end

				a.damage_min = a._original_damage_min * store.entities[this.source_id].tower.damage_factor
				a.damage_max = a._original_damage_max * store.entities[this.source_id].tower.damage_factor
			end
		end
	end

	if this.sound_events and this.sound_events.raise then
		S:queue(this.sound_events.raise)
	end

	this.health_bar.hidden = true

	U.y_animation_play(this, "landing", nil, store.tick_ts, 1)

	if not this.health.dead then
		this.health_bar.hidden = nil
	end

	local starting_pos = V.vclone(this.pos)

	this.nav_rally.pos = starting_pos

	local patrol_pos = V.vclone(this.pos)

	patrol_pos.x, patrol_pos.y = patrol_pos.x + this.patrol_pos_offset.x, patrol_pos.y + this.patrol_pos_offset.y

	local nearest_node = P:nearest_nodes(patrol_pos.x, patrol_pos.y, nil, nil, false)[1]
	local pi, spi, ni = unpack(nearest_node)
	local npos = P:node_pos(pi, spi, ni)
	local patrol_pos_2 = V.vclone(this.pos)

	patrol_pos_2.x, patrol_pos_2.y = patrol_pos_2.x - this.patrol_pos_offset.x, patrol_pos_2.y - this.patrol_pos_offset.y

	local nearest_node = P:nearest_nodes(patrol_pos_2.x, patrol_pos_2.y, nil, nil, false)[1]
	local pi, spi, ni = unpack(nearest_node)
	local npos_2 = P:node_pos(pi, spi, ni)

	if V.dist2(patrol_pos.x, patrol_pos.y, npos.x, npos.y) > V.dist2(patrol_pos_2.x, patrol_pos_2.y, npos_2.x, npos_2.y) then
		patrol_pos = V.vclone(patrol_pos_2)
	end

	local idle_ts = store.tick_ts
	local patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			U.animation_start(this, "the_expendables", nil, store.tick_ts, false, 1)
			U.unblock_target(store, this)
			U.y_wait(store, fts(20))
			S:queue(this.explosion_sound)
			explosion(this.explosion_range[this.level], this.explosion_damage_min[this.level], this.explosion_damage_max[this.level], this.explosion_damage_type)

			local decal = E:create_entity(this.decal_on_explosion)

			decal.pos = V.vclone(this.pos)
			decal.tween.ts = store.tick_ts

			queue_insert(store, decal)
			U.y_animation_wait(this, 1)
			queue_remove(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)

			idle_ts = store.tick_ts
			patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)
		else
			check_tower_damage_factor()

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					idle_ts = store.tick_ts
					patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)

					goto label_568_0
				end
			end

			if SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)

				if patrol_cd < store.tick_ts - idle_ts then
					if this.nav_rally.pos == starting_pos then
						this.nav_rally.pos = patrol_pos
					else
						this.nav_rally.pos = starting_pos
					end

					idle_ts = store.tick_ts
					patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)
				end
			end
		end

		::label_568_0::

		coroutine.yield()
	end
end

scripts.projecticle_big_guy_tower_demon_pit = {}

function scripts.projecticle_big_guy_tower_demon_pit.update(this, store, script)
	local jumping = true
	local b = this.bullet
	local bullet_fly = true
	local last_y = this.pos.y
	local flip_x = b.to.x - b.from.x < 0

	U.animation_start(this, "idle_1", flip_x, store.tick_ts, 40)

	local target = store.entities[b.target_id]

	b.ts = store.tick_ts
	b.speed = SU.initial_parabola_speed(b.from, b.to, b.flight_time, b.g)

	while bullet_fly do
		coroutine.yield()

		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if jumping and last_y > this.pos.y then
			U.animation_start(this, "idle_2", flip_x, store.tick_ts, false, 1)

			b.g = b.g * 0.95
			jumping = false
		end

		last_y = this.pos.y

		if b.flight_time < store.tick_ts - b.ts then
			bullet_fly = false
		end
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
		else
			hp = b.hit_payload
		end

		hp.pos.x, hp.pos.y = b.to.x, b.to.y
		hp.level = b.level

		if hp.aura then
			hp.aura.level = this.bullet.level
		end

		queue_insert(store, hp)
	end

	queue_remove(store, this)
end

scripts.big_guy_tower_demon_pit = {}

function scripts.big_guy_tower_demon_pit.update(this, store, script)
	this.health.hp_max = this.health_level[this.level]
	this.health.hp = this.health.hp_max

	local brk, stam

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts
	this.melee.attacks[1].damage_max = this.damage_max[this.level]
	this.melee.attacks[1].damage_min = this.damage_min[this.level]
	this.nav_rally.center = nil
	this.nav_rally.pos = V.vclone(this.pos)

	if this.sound_events and this.sound_events.raise then
		S:queue(this.sound_events.raise)
	end

	this.health_bar.hidden = true

	U.y_animation_play(this, "landing", nil, store.tick_ts, 1)

	if not this.health.dead then
		this.health_bar.hidden = nil
	end

	local function explosion(r, damage, dty)
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, r, 0, bit.bor(F_FLYING, F_CLIFF))

		if targets then
			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				d.value = damage
				d.damage_type = dty
				d.target_id = target.id
				d.source_id = this.id

				queue_damage(store, d)
			end
		end
	end

	local path_ni = 1
	local path_spi = 1
	local path_pi = 1
	local node_pos
	local available_paths = {}

	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end

	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, function(k, v)
			return not table.contains(store.level.ignore_walk_backwards_paths, v)
		end)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, available_paths)

	if #nearest > 0 then
		path_pi, path_spi, path_ni = unpack(nearest[1])
	end

	path_spi = 1
	path_ni = path_ni - 3

	local distance = 0

	while true do
		if this.health.dead or band(GR:cell_type(this.pos.x, this.pos.y, TERRAIN_TYPES_MASK), TERRAIN_WATER) ~= 0 then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			U.animation_start(this, "death", nil, store.tick_ts, false, 1)
			U.y_wait(store, fts(20))
			S:queue(this.explosion_sound)
			explosion(this.explosion_range[this.level], this.explosion_damage[this.level], this.explosion_damage_type)
			U.y_animation_wait(this, 1)
			queue_remove(store, this)

			return
		end

		if path_ni <= 0 then
			SU.y_soldier_death(store, this)
			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_572_0
				end
			end

			node_pos = this.nav_rally.pos
			distance = V.dist2(node_pos.x, node_pos.y, this.pos.x, this.pos.y)

			if distance < 25 then
				path_ni = path_ni - 3
				this.nav_rally.pos = P:node_pos(path_pi, path_spi, path_ni)
			end

			if SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_regen(store, this)
			end
		end

		::label_572_0::

		coroutine.yield()
	end
end

scripts.mod_track_fx = {}

function scripts.mod_track_fx.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	if this.tween then
		this.tween.ts = store.tick_ts
		this.tween.disabled = false

		U.animation_start(this, this.animation_loop, nil, store.tick_ts, true)
		U.y_wait(store, this.tween.props[1].keys[2][1])
	else
		U.y_animation_play(this, this.animation_start, nil, store.tick_ts, 1)
	end

	if this.sound_events.insert then
		S:queue(this.sound_events.insert)
	end

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			if this.tween then
				this.tween.ts = store.tick_ts
				this.tween.reverse = true
				this.tween.disabled = false

				U.y_wait(store, this.tween.props[1].keys[2][1])
			else
				U.y_animation_play(this, this.animation_end, nil, store.tick_ts, 1)
			end

			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		U.animation_start(this, this.animation_loop, nil, store.tick_ts, true)
		coroutine.yield()
	end
end

scripts.tower_arborean_emissary = {}

function scripts.tower_arborean_emissary.insert(this, store, script)
	if not this.tower_upgrade_persistent_data.current_mode then
		this.tower_upgrade_persistent_data.current_mode = 0
	elseif this.tower_upgrade_persistent_data.current_mode == 1 and this.barrack then
		local soldier_type = this.barrack.soldier_type
		this.barrack.soldier_type = this.barrack.standby_soldier_type
		this.barrack.standby_soldier_type = soldier_type
		local sound = this.sound_events.change_rally_point
		this.sound_events.change_rally_point = this.sound_events.standby_soldiers_change_rally_point
		this.sound_events.standby_soldiers_change_rally_point = sound
		for i = 1, #this.barrack.soldiers do
			local soldier = this.barrack.soldiers[i]
			this.barrack.soldiers[i] = nil
			queue_remove(store, soldier)
		end
	end
	this.change_mode = false
	this.tower_upgrade_persistent_data.preparing = false
	this.tower_upgrade_persistent_data.preparing_ts = 0
	return scripts.tower_barrack.insert(this, store, script)
end

function scripts.tower_arborean_emissary.update(this, store, script)
	local tower_sid = this.render.sid_tower
	local a = this.attacks
	local ab = this.attacks.list[1]
	local ag = this.attacks.list[2]
	local aw = this.attacks.list[3]
	local pow_g = this.powers and this.powers.gift_of_nature or nil
	local pow_w = this.powers and this.powers.wave_of_roots or nil
	local doing_animated_idle = false
	local last_idle = store.tick_ts

	this.tower.long_idle_cooldown = math.random(this.tower.long_idle_cooldown_min, this.tower.long_idle_cooldown_max)
	ab.ts = store.tick_ts - ab.cooldown + a.attack_delay_on_spawn

	local last_ts = store.tick_ts - a.min_cooldown + a.attack_delay_on_spawn
	local attacks = {}
	local pows = {}

	if ag then
		table.insert(attacks, ag)
		table.insert(pows, pow_g)
	end

	if aw then
		table.insert(attacks, aw)
		table.insert(pows, pow_w)
	end

	if ab then
		table.insert(attacks, ab)
		table.insert(pows, nil)
	end

	local function find_target(aa)
		local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, aa.node_prediction, aa.vis_flags, aa.vis_bans)

		return target, pred_pos
	end

	local function find_unmodded_target(aa)
		local modded_enemies = {}

		for _, v in pairs(store.entities) do
			if v.template_name == "mod_tower_arborean_emissary_basic_attack" then
				table.insert(modded_enemies, v.modifier.target_id)
			end
		end

		local target, targets, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, aa.node_prediction, aa.vis_flags, aa.vis_bans, function(e, _)
			return not table.contains(modded_enemies, e.id)
		end)

		return target, pred_pos
	end

	local function find_ally_damaged(aa, vis_flags, vis_bans)
		local soldiers = U.find_soldiers_in_range(store.entities, tpos(this), 0, aa.max_range, vis_flags, vis_bans, function(e)
			return e.health and e.health.hp < e.health.hp_max
		end)

		if soldiers and #soldiers > 0 then
			local _, surrounded_soldiers = U.find_entity_most_surrounded(soldiers)

			for _, soldier in ipairs(surrounded_soldiers) do
				local enemies_melee = U.find_enemies_in_range(store.entities, soldier.pos, 0, aa.check_melee_range, vis_flags, vis_bans)

				if enemies_melee and #enemies_melee > 0 then
					return soldier
				end
			end

			return surrounded_soldiers[1]
		end

		return nil
	end

	local function check_change_mode(barrack)
		if this.change_mode then
			this.change_mode = false
			this.tower_upgrade_persistent_data.preparing = true
			this.tower_upgrade_persistent_data.preparing_ts = store.tick_ts

			if this.tower_upgrade_persistent_data.current_mode == 1 then
				this.tower_upgrade_persistent_data.current_mode = 0
			else
				this.tower_upgrade_persistent_data.current_mode = 1
			end

			local soldier_type = barrack.soldier_type
			barrack.soldier_type = barrack.standby_soldier_type
			barrack.standby_soldier_type = soldier_type
			local sound = this.sound_events.change_rally_point
			this.sound_events.change_rally_point = this.sound_events.standby_soldiers_change_rally_point
			this.sound_events.standby_soldiers_change_rally_point = sound
			for i = 1, #barrack.soldiers do
				local soldier = barrack.soldiers[i]
				barrack.soldiers[i] = nil
				queue_remove(store, soldier)
			end
		elseif this.tower_upgrade_persistent_data.preparing and store.tick_ts - this.tower_upgrade_persistent_data.preparing_ts > barrack.change_interval then
			this.tower_upgrade_persistent_data.preparing = false
		end
	end

	local roots = {}

	::label_576_0::

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.powers then
				for _, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == pow_g then
							if pow.level == 1 then
								ag.ts = store.tick_ts
							end

							ag.cooldown = pow.cooldown[pow.level]
							ag.ts = store.tick_ts - ag.cooldown
						end

						if pow == pow_w then
							if pow.level == 1 then
								aw.ts = store.tick_ts
							end

							aw.cooldown = pow.cooldown[pow.level]
							aw.damage_min = pow.damage_min[pow.level]
							aw.damage_max = pow.damage_max[pow.level]
							aw.ts = store.tick_ts - aw.cooldown
						end
					end
				end
			end

			SU.towers_swaped(store, this, this.attacks.list)

			for i, aa in pairs(attacks) do
				do
					local pow = pows[i]

					if (not pow or pow.level > 0) and store.tick_ts - aa.ts > aa.cooldown and store.tick_ts - last_ts > a.min_cooldown then
						if aa == ag and this.tower.can_do_magic then
							local ally_damaged = find_ally_damaged(aa, aa.vis_flags_soldier, aa.vis_bans_soldier)

							if not ally_damaged then
								SU.delay_attack(store, aa, fts(10))
							else
								last_ts = store.tick_ts

								local center_pos = V.vclone(ally_damaged.pos)

								U.animation_start_group(this, aa.animation, nil, store.tick_ts, false, "layers")

								if U.y_wait(store, aa.shoot_time, false) then
									goto label_576_0
								end

								S:queue(aa.sound)

								ally_damaged = find_ally_damaged(aa, aa.vis_flags_soldier, aa.vis_bans_soldier)
								aa.ts = last_ts

								if ally_damaged then
									center_pos = V.vclone(ally_damaged.pos)
								end

								local nodes = P:nearest_nodes(center_pos.x, center_pos.y, nil, {
									1
								}, false)
								local pi, spi, ni = unpack(nodes[1])

								center_pos = P:node_pos(pi, spi, ni)

								local e = E:create_entity(aa.entity)

								e.pos = center_pos
								e.duration = pow.aura_duration[pow.level]
								e.tower_pos = V.vclone(this.pos)
								e.power_level = this.powers.gift_of_nature.level

								queue_insert(store, e)
								U.y_animation_wait_group(this, "layers")
							end
						elseif aa == aw and this.tower.can_do_magic then
							local _, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.trigger_range, aa.node_prediction, aa.vis_flags, aa.vis_bans)

							if not enemies or #enemies < aa.min_targets then
								SU.delay_attack(store, aa, fts(10))
							else
								last_ts = store.tick_ts

								U.animation_start_group(this, aa.animation, nil, store.tick_ts, false, "layers")

								if U.y_wait(store, aa.shoot_time, false) then
									goto label_576_0
								end

								aa.ts = last_ts

								local _, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, aa.effect_range, aa.node_prediction, aa.vis_flags, aa.vis_bans)

								if enemies and #enemies > 0 then
									enemies = table.random_order(enemies)
									enemies = table.slice(enemies, 1, aa.max_targets[pow.level])
								else
									goto label_576_1
								end

								S:queue(aa.sound)

								for _, e in ipairs(enemies) do
									if not e.health.death then
										local m = E:create_entity(aa.mod)

										m.modifier.target_id = e.id
										m.modifier.source_id = this.id
										m.modifier.level = pow.level
										m.wave_of_roots = aa.wave_of_roots_balance
										m.render.sprites[1].ts = store.tick_ts

										queue_insert(store, m)

										local d = E:create_entity("damage")

										d.value = math.random(aa.damage_min, aa.damage_max)
										d.source_id = this.id
										d.target_id = e.id
										d.damage_type = aa.damage_type

										queue_damage(store, d)
									end
								end

								U.y_animation_wait_group(this, "layers")
							end
						elseif aa == ab then
							local base_node_prediction = aa.node_prediction

							aa.node_prediction = aa.node_prediction + aa.shoot_time

							local enemy, pred_pos = find_unmodded_target(aa)

							if not enemy or not pred_pos then
								enemy, pred_pos = find_target(aa)
							end

							aa.node_prediction = base_node_prediction

							if not enemy then
								SU.delay_attack(store, aa, fts(10))
							else
								local enemy_id = enemy.id
								local shoot_pos = pred_pos

								last_ts = store.tick_ts

								U.animation_start_group(this, aa.animation, nil, store.tick_ts, false, "layers")
								U.y_wait(store, aa.shoot_time, false)
								S:queue(aa.sound)

								enemy, __ = find_unmodded_target(aa)

								if not enemy or not pred_pos then
									enemy, __ = find_target(aa)
								end

								if enemy then
									enemy_id = enemy.id
									shoot_pos = V.vclone(enemy.pos)
								end

								local b = E:create_entity(aa.bullet)

								b.pos.x, b.pos.y = this.pos.x + aa.bullet_start_offset.x, this.pos.y + aa.bullet_start_offset.y
								b.bullet.from = V.vclone(b.pos)
								b.bullet.to = shoot_pos
								b.bullet.target_id = enemy_id
								b.bullet.source_id = this.id
								b.bullet.level = this.tower.level
								b.bullet.damage_factor = this.tower.damage_factor

								queue_insert(store, b)

								aa.ts = last_ts

								U.y_animation_wait_group(this, "layers")
							end
						end
					end
				end

				::label_576_1::
			end

			if doing_animated_idle and U.animation_finished_group(this, "layers", 1) then
				doing_animated_idle = false
				last_idle = store.tick_ts
				this.tower.long_idle_cooldown = math.random(this.tower.long_idle_cooldown_min, this.tower.long_idle_cooldown_max)
			end

			if not doing_animated_idle and store.tick_ts - last_ts > this.tower.long_idle_cooldown and store.tick_ts - last_idle > this.tower.long_idle_cooldown then
				U.animation_start_group(this, this.animation_idles[math.random(#this.animation_idles)], nil, store.tick_ts, false, "layers")

				doing_animated_idle = true
			end

			local b = this.barrack

			if b then
				check_change_mode(b)
				for i = 1, b.max_soldiers do
					local s = b.soldiers[i]

					if not s or s.health.dead and not store.entities[s.id] then
						s = E:create_entity(b.soldier_type)
						s.soldier.tower_id = this.id
						s.soldier.tower_soldier_idx = i
						s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
						s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers)
						s.nav_rally.new = true

						queue_insert(store, s)

						b.soldiers[i] = s

						signal.emit("tower-spawn", this, s)
					end
				end

				if b.rally_new then
					b.rally_new = false

					signal.emit("rally-point-changed", this)

					local all_dead = true

					for i, s in ipairs(b.soldiers) do
						s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers,
							b.rally_angle_offset)
						s.nav_rally.new = true
						all_dead = all_dead and s.health.dead
					end

					if not all_dead then
						S:queue(this.sound_events.change_rally_point)
					end
				end
			end

			coroutine.yield()
		end
	end
end

scripts.decal_tower_arborean_emissary_gift_of_nature_wisp = {}

function scripts.decal_tower_arborean_emissary_gift_of_nature_wisp.update(this, store)
	local fm = this.force_motion
	local ps
	local start_ts = store.tick_ts
	local patrol_ts
	local sf = this.render.sprites[1]
	local patrol_start = V.vclone(this.to)
	local starting_pos = V.vclone(this.initial_pos)

	this.tween.props[1].disabled = true
	this.tween.props[2].disabled = true
	this.reach_target = false

	local function current_phase(phase)
		local last_i = 1

		for i, value in ipairs(this.positions[this.wisp_order]) do
			if phase < value[1] then
				if i > 1 then
					last_i = i - 1
				end

				break
			end
		end

		return last_i
	end

	local function get_patrol_pos()
		local phase = (store.tick_ts - patrol_ts) / this.duration
		local current_phase_i = current_phase(phase)
		local patrol_next_pos = V.vclone(this.positions[this.wisp_order][current_phase_i][2])

		patrol_next_pos.x = patrol_next_pos.x + patrol_start.x
		patrol_next_pos.y = patrol_next_pos.y + patrol_start.y

		local easing = "quad-inout"
		local new_pos_x = U.ease_value(this.pos.x, patrol_next_pos.x, phase, easing)
		local new_pos_y = U.ease_value(this.pos.y, patrol_next_pos.y, phase, easing)

		return new_pos_x, new_pos_y
	end

	local function move_start(dest)
		local speed_multiplier = 4
		local max_a = fm.max_a * speed_multiplier
		local a_step = fm.a_step * speed_multiplier
		local max_v = fm.max_v * speed_multiplier
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(max_a, V.mul(a_step, dx, dy)))
		fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
		fm.v.x, fm.v.y = V.trim(max_v, fm.v.x, fm.v.y)
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = V.mul(-1 * fm.fr / store.tick_length, fm.v.x, fm.v.y)
	end

	local function move_patrol(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, dx, dy)))
		fm.v.x, fm.v.y = V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y))
		fm.v.x, fm.v.y = V.trim(fm.max_v, fm.v.x, fm.v.y)
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = V.mul(-1 * fm.fr / store.tick_length, fm.v.x, fm.v.y)
	end

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	sf.hidden = true

	U.y_wait(store, fts(this.wisp_order) * 3)

	sf.hidden = false
	this.tween.disabled = false
	this.tween.reverse = true
	this.tween.props[2].disabled = false
	this.tween.props[2].ts = store.tick_ts

	while true do
		if store.tick_ts - start_ts >= this.standing_duration then
			break
		end

		move_start(this.initial_pos)

		sf.flip_x = fm.v.x < 0

		coroutine.yield()
	end

	start_ts = store.tick_ts

	if this.particles_name then
		ps = E:create_entity(this.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while true do
		if patrol_ts and store.tick_ts - patrol_ts >= this.duration then
			break
		end

		if this.reach_target then
			local patrol_dest = {}

			patrol_dest.x, patrol_dest.y = get_patrol_pos()
			fm.ramp_radius = 1
			fm.max_a = 300
			fm.max_v = 150

			move_patrol(patrol_dest)

			goto label_582_0
		end

		if this.initial_impulse and store.tick_ts - start_ts < this.initial_impulse_duration then
			local initial_destination = this.initial_destination[this.wisp_order]
			local init = {}

			init.x, init.y = V.add(starting_pos.x, starting_pos.y, initial_destination.x, initial_destination.y)

			move_step(init)

			goto label_582_0
		end

		this.reach_target = move_step(this.to)

		if this.reach_target then
			patrol_ts = store.tick_ts
			this.tween.disabled = false
			this.tween.props[1].ts = store.tick_ts - this.wisp_order * fts(15)
		end

		::label_582_0::

		sf.flip_x = fm.v.x < 0

		coroutine.yield()
	end

	this.tween.props[2].disabled = false
	this.tween.props[2].ts = store.tick_ts
	this.tween.reverse = false

	local out_ts = store.tick_ts
	local last_pos = V.vclone(this.pos)
	local going_right = fm.v.x < 0
	local out_pos = {}
	local out_x = 100

	while true do
		if store.tick_ts - out_ts >= this.tween.props[2].keys[2][1] then
			break
		end

		if going_right then
			out_x = -100
		end

		out_pos.x = last_pos.x + out_x
		out_pos.y = last_pos.y

		move_step(out_pos)
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.tower_arborean_emissary_bolt = {}

function scripts.tower_arborean_emissary_bolt.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local pred_pos

	if target then
		pred_pos = P:predict_enemy_pos(target, fts(5))
	else
		pred_pos = b.to
	end

	local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			local d = math.max(math.abs(target.pos.x + hit_offset.x - b.to.x), math.abs(target.pos.y + hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.level = b.level

				queue_insert(store, m)
			end
		end
	elseif b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	this.render.sprites[1].hidden = true

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.mod_arborean_emissary_weak = {}

function scripts.mod_arborean_emissary_weak.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]
	local target_id = this.modifier.target_id
	local template_name = this.template_name
	local modifiers = table.filter(store.entities, function(k, v)
		return v.modifier and v.modifier.target_id == target_id and v.template_name == template_name
	end)

	if #modifiers > 0 then
		local base_modifier = modifiers[1]

		base_modifier.modifier.ts = store.tick_ts
		this.render = nil

		if base_modifier.render then
			for i = 1, #base_modifier.render.sprites do
				base_modifier.render.sprites[i].ts = store.tick_ts
			end
		end

		if base_modifier.tween then
			base_modifier.tween.ts = store.tick_ts
		end
	end

	if not target or target.health.dead or not target.unit then
		return false
	end

	if this.received_damage_factor_config then
		this.received_damage_factor = this.received_damage_factor_config[this.modifier.level]
	end

	if this.inflicted_damage_factor_config then
		this.inflicted_damage_factor = this.inflicted_damage_factor_config[this.modifier.level]
	end

	this.modifier.duration = this.modifier_duration[this.modifier.level]

	if this.received_damage_factor then
		target.health.damage_factor = target.health.damage_factor * this.received_damage_factor
	end

	if this.inflicted_damage_factor then
		target.unit.damage_factor = target.unit.damage_factor * this.inflicted_damage_factor
	end

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts

			if s.size_names then
				s.name = s.size_names[target.unit.size]
			end

			if s.size_scales then
				s.scale = s.size_scales[target.unit.size]
			end
		end
	end

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_arborean_emissary_weak.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if target and target.health and target.unit then
		if this.received_damage_factor then
			target.health.damage_factor = target.health.damage_factor / this.received_damage_factor
		end

		if this.inflicted_damage_factor then
			target.unit.damage_factor = target.unit.damage_factor / this.inflicted_damage_factor
		end
	end

	return true
end

scripts.controller_upgrade_heroes_nimble_physique = {}

function scripts.controller_upgrade_heroes_nimble_physique.update(this, store, script)
	local trigger_cards = this.trigger_cards
	local total_cards = this.total_cards

	for _, v in pairs(store.entities) do
		if v.hero then
			function v.health.on_damage(hero, store, damage)
				if U.flag_has(damage.damage_type, bit.bor(DAMAGE_INSTAKILL, DAMAGE_DISINTEGRATE, DAMAGE_EAT, DAMAGE_IGNORE_SHIELD, DAMAGE_NO_DODGE, DAMAGE_POISON, DAMAGE_MODIFIER, DAMAGE_EXPLOSION)) then
					return true
				end

				if not hero._nimble_physique_deck then
					hero._nimble_physique_deck = SU.deck_new(trigger_cards, total_cards)
				end

				local dodge = SU.deck_draw(hero._nimble_physique_deck)

				if dodge then
					local e = E:create_entity("pop_miss")

					e.pos = V.v(hero.pos.x, hero.pos.y)

					if hero.unit and hero.unit.pop_offset then
						e.pos.y = e.pos.y + hero.unit.pop_offset.y
					end

					e.pos.y = e.pos.y + e.pop_y_offset
					e.render.sprites[1].r = math.random(-21, 21) * math.pi / 180
					e.render.sprites[1].ts = store.tick_ts

					simulation:queue_insert_entity(e)
				end

				return not dodge
			end
		end
	end

	return true
end

scripts.controller_upgrades_alliance = {}

function scripts.controller_upgrades_alliance.insert(this, store, script)
	store.player_gold = store.player_gold + this.extra_gold

	if this.seal then
		for _, e in pairs(store.entities) do
			if e.template_name == "decal_defend_point5" then
				local seal = E:create_entity(this.seal)

				seal.pos = V.vclone(e.pos)

				queue_insert(store, seal)

				e.render.sprites[1].hidden = true
			end
		end
	end

	if this.coil then
		for _, e in pairs(store.entities) do
			if e.template_name == "decal_defense_flag5" then
				local coil = E:create_entity(this.coil)

				coil.pos = V.vclone(e.pos)

				queue_insert(store, coil)

				e.render.sprites[1].hidden = true
			end
		end
	end

	return true
end

function scripts.controller_upgrades_alliance.update(this, store, script)
	return true
end

scripts.controller_tower_arborean_emissary_gift_of_nature = {}

function scripts.controller_tower_arborean_emissary_gift_of_nature.update(this, store, script)
	local wisps = {}

	for i = 1, 3 do
		local e = E:create_entity(this.entity)

		e.pos.x, e.pos.y = this.tower_pos.x, this.tower_pos.y + 70
		e.initial_pos = V.v(this.tower_pos.x + this.start_offset[i].x, this.tower_pos.y + this.start_offset[i].y)
		e.from = V.vclone(e.pos)
		e.to = V.v(this.pos.x + this.end_offset[i].x, this.pos.y + this.end_offset[i].y)
		e.duration = this.duration
		e.wisp_order = i

		queue_insert(store, e)
		table.insert(wisps, e)
	end

	while true do
		for _, w in ipairs(wisps) do
			if w.reach_target then
				goto label_597_0
			end
		end

		coroutine.yield()
	end

	::label_597_0::

	local a = E:create_entity(this.aura)

	a.pos = this.pos
	a.aura.duration = this.duration
	a.aura.level = this.power_level

	queue_insert(store, a)

	local aura_ts = store.tick_ts

	while true do
		if store.tick_ts - aura_ts > this.duration then
			break
		end

		coroutine.yield()
	end

	queue_remove(store, a)
	queue_remove(store, this)
end

scripts.aura_tower_arborean_emissary_gift_of_nature = {}

function scripts.aura_tower_arborean_emissary_gift_of_nature.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.aura.duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_598_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_598_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_598_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_598_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_598_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
end

scripts.tower_arborean_emissary_gift_of_nature_heal_mod = {}

function scripts.tower_arborean_emissary_gift_of_nature_heal_mod.insert(this, store)
	this.hps.heal_min = this.heal_min[this.modifier.level]
	this.hps.heal_max = this.heal_max[this.modifier.level]
	this.modifier.duration = this.duration[this.modifier.level]

	return scripts.mod_track_target.insert(this, store)
end

scripts.tower_arborean_emissary_gift_of_nature_damage_mod = {}

function scripts.tower_arborean_emissary_gift_of_nature_damage_mod.insert(this, store)
	this.dps.damage_min = this.damage_min[this.modifier.level]
	this.dps.damage_max = this.damage_max[this.modifier.level]
	this.modifier.duration = this.duration[this.modifier.level]

	return scripts.mod_dps.insert(this, store)
end

scripts.tower_arborean_emissary_gift_of_nature_heal_mod_decal = {}

function scripts.tower_arborean_emissary_gift_of_nature_heal_mod_decal.insert(this, store)
	this.modifier.duration = this.duration[this.modifier.level]

	return scripts.mod_track_target.insert(this, store)
end

scripts.tower_arborean_emissary_root_stun_mod = {}

function scripts.tower_arborean_emissary_root_stun_mod.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	U.y_animation_play(this, this.animation_start, nil, store.tick_ts, 1)
	U.animation_start(this, this.animation_idle, nil, store.tick_ts, false)

	while store.tick_ts - m.ts < m.duration - this.out_before and target and not target.health.dead do
		if this.render and m.use_mod_offset and target.unit.mod_offset and not m.custom_offsets then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	U.y_animation_play(this, this.animation_end, nil, store.tick_ts, 1)
	queue_remove(store, this)
end

scripts.tower_rocket_gunners = {}

function scripts.tower_rocket_gunners.get_info(this)
	local s = E:create_entity(this.barrack.soldier_type)

	if this.powers then
		for pn, p in pairs(this.powers) do
			for i = 1, p.level do
				SU.soldier_power_upgrade(s, pn)
			end
		end
	end

	local s_info = s.info.fn(s)
	local attacks

	if s.melee and s.melee.attacks then
		attacks = s.melee.attacks
	elseif s.ranged and s.ranged.attacks then
		attacks = s.ranged.attacks
	end

	local min, max

	for _, a in pairs(attacks) do
		if a.damage_min then
			local damage_factor = this.tower.damage_factor

			min, max = a.damage_min * damage_factor, a.damage_max * damage_factor

			break
		end
	end

	if min and max then
		min, max = math.ceil(min), math.ceil(max)
	end

	return {
		type = STATS_TYPE_TOWER_BARRACK,
		hp_max = s.health.hp_max,
		damage_min = min,
		damage_max = max,
		armor = s.health.armor,
		respawn = s.health.dead_lifetime
	}
end

function scripts.tower_rocket_gunners.update(this, store, script)
	local tower_sid = 2
	local b = this.barrack
	local formation_offset = 0
	local MODE_FLY = 0
	local MODE_GROUND = 1
	local sting_missiles_ts = store.tick_ts
	local sting_missiles_ready = false
	local sting_missiles_soldier

	if this.tower_upgrade_persistent_data.swaped then
		this.tower_upgrade_persistent_data = E:clone_c("tower_upgrade_persistent_data")
		this.tower_upgrade_persistent_data.current_mode = MODE_FLY
		this.tower_upgrade_persistent_data.is_taking_off = {
			true,
			true
		}
		this.tower_upgrade_persistent_data.swaped = nil
	else
		if not this.tower_upgrade_persistent_data.current_mode then
			this.tower_upgrade_persistent_data.current_mode = MODE_FLY
		end

		if not this.tower_upgrade_persistent_data.is_taking_off then
			this.tower_upgrade_persistent_data.is_taking_off = {
				true,
				true
			}
		end
	end

	local function check_change_rally()
		if b.rally_new then
			b.rally_new = false

			signal.emit("rally-point-changed", this)

			local all_dead = true

			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, 3, formation_offset)
				s.nav_rally.new = true
				all_dead = all_dead and s.health.dead
			end

			if not all_dead then
				S:queue(this.sound_events.change_rally_point)
			end
		end
	end

	local function check_change_mode()
		if this.change_mode then
			this.change_mode = false

			if this.tower_upgrade_persistent_data.current_mode == MODE_GROUND then
				this.tower_upgrade_persistent_data.current_mode = MODE_FLY
			else
				this.tower_upgrade_persistent_data.current_mode = MODE_GROUND
			end

			for _, soldier in ipairs(b.soldiers) do
				soldier.change_mode = true
			end
		end
	end

	while true do
		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					for _, s in pairs(b.soldiers) do
						s.powers[pn].level = p.level
						s.powers[pn].changed = true

						if p == this.powers.sting_missiles then
							sting_missiles_ready = true
						end
					end
				end
			end
		end

		if this.powers and this.powers.sting_missiles and this.powers.sting_missiles.level > 0 then
			if sting_missiles_ready then
				if (not sting_missiles_soldier or sting_missiles_soldier.health.dead) and #b.soldiers > 0 then
					sting_missiles_soldier = b.soldiers[math.random(#b.soldiers)]
					sting_missiles_soldier.ranged.attacks[3].disabled = false
				end

				if sting_missiles_soldier and sting_missiles_soldier.ranged.attacks[3].disabled then
					sting_missiles_ready = false
					sting_missiles_ts = store.tick_ts
					sting_missiles_soldier = nil
				end
			else
				sting_missiles_ready = store.tick_ts - sting_missiles_ts > this.powers.sting_missiles.cooldown[this.powers.sting_missiles.level]
			end
		end

		check_change_mode()

		if not this.tower.blocked then
			for i = 1, b.max_soldiers do
				local s = b.soldiers[i]

				if not s or s.health.dead and not store.entities[s.id] then
					U.animation_start(this, "spawn", nil, store.tick_ts, 1, tower_sid)

					local spawn_ts = store.tick_ts

					S:queue(this.spawn_sound)

					while store.tick_ts - spawn_ts < fts(this.spawn_time) do
						check_change_rally()
						check_change_mode()
						coroutine.yield()
					end

					s = E:create_entity(b.soldier_type)
					s.soldier.tower_id = this.id
					s.soldier.tower_soldier_idx = i
					s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
					s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, 3, formation_offset)
					s.nav_rally.new = true
					s.render.sprites[1].flip_x = true

					if this.powers then
						for pn, p in pairs(this.powers) do
							s.powers[pn].level = p.level
						end
					end

					s.spawned_from_tower = true

					queue_insert(store, s)

					b.soldiers[i] = s

					U.y_animation_wait(this, tower_sid)
					U.y_wait(store, fts(this.spawn_delay))
				end
			end
		end

		check_change_rally()
		coroutine.yield()
	end
end

scripts.soldier_tower_rocket_gunners = {}

function scripts.soldier_tower_rocket_gunners.insert(this, store, script)
	local tower = store.entities[this.soldier.tower_id]
	local has_phosphoric = false

	if tower.powers then
		for ptn, p_tower in pairs(tower.powers) do
			if p_tower.level > 0 then
				for pn, p_soldier in pairs(this.powers) do
					if ptn == pn then
						p_soldier.level = p_tower.level

						SU.soldier_power_upgrade(this, pn)

						if pn == "phosphoric" then
							this.melee.attacks[2].level = p_soldier.level
							this.ranged.attacks[2].level = p_soldier.level
							this.unit.damage_factor = p_soldier.damage_factor[p_soldier.level]
							has_phosphoric = true
						end

						if pn == "sting_missiles" then
							this.ranged.attacks[3].max_range = p_soldier.max_range[p_soldier.level]
							this.ranged.attacks[3].min_range = p_soldier.min_range[p_soldier.level]
							this.ranged.attacks[3].filter_fn = function(e, o)
								return e.health and e.health.hp_max <= p_soldier.hp_max_target[p_soldier.level]
							end
						end
					end
				end
			end
		end

		this.melee.attacks[1].disabled = has_phosphoric
		this.melee.attacks[2].disabled = not has_phosphoric
		this.ranged.attacks[1].disabled = has_phosphoric
		this.ranged.attacks[2].disabled = not has_phosphoric
	end

	return scripts.soldier_barrack.insert(this, store, script)
end

function tower_rocket_gunners_phosphoric_area_damage(soldier, store, target)
	local attack = soldier.melee.attacks[2]
	local dradius = attack.damage_radius
	local enemies = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, attack.vis_bans) == 0 and band(v.vis.bans, attack.vis_flags) == 0 and U.is_inside_ellipse(v.pos, target.pos, dradius)
	end)

	for _, enemy in pairs(enemies) do
		local d = E:create_entity("damage")

		d.damage_type = attack.damage_type

		local dmax = attack.damage_area_max[soldier.powers.phosphoric.level]
		local dmin = attack.damage_area_min[soldier.powers.phosphoric.level]
		local upg = UP:get_upgrade("towers_improved_formulas")

		if upg then
			d.value = dmax
		else
			local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, target.pos, dradius)

			d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
		end

		d.source_id = soldier.id
		d.target_id = enemy.id

		queue_damage(store, d)

		if enemy.health.armor and enemy.health.armor > 0 and target.id ~= enemy.id then
			SU.armor_dec(enemy, soldier.powers.phosphoric.armor_reduction[soldier.powers.phosphoric.level])
		end
	end
end

function scripts.soldier_tower_rocket_gunners.update(this, store, script)
	local brk, sta
	local tower = store.entities[this.soldier.tower_id]
	local is_taking_off = tower.tower_upgrade_persistent_data.is_taking_off[this.soldier.tower_soldier_idx]
	local last_target_pos

	this.melee.attacks[1].level = this.unit.level
	this.ranged.attacks[1].level = this.unit.level
	this.vis.flags = bor(this.vis.flags, F_FLYING)
	this._max_speed = this.motion.max_speed

	if this.vis._bans then
		this.vis.bans = this.vis._bans
		this.vis._bans = nil
	end

	local MODE_FLY = 0
	local MODE_GROUND = 1

	local function adjust_position_reference(mode)
		mode = mode or this.current_mode
		this.ui.click_rect.pos.y = this.render.sprites[1].offset.y + this.ui.click_rect_offset_y
		this.unit.hit_offset.y = this.render.sprites[1].offset.y + 12
		this.unit.mod_offset.y = this.render.sprites[1].offset.y + 13

		if this.ranged.attacks[3] then
			this.ranged.attacks[3].bullet_start_offset = {
				v(this.ranged.attacks[3].bullet_start_offset_relative.x, this.render.sprites[1].offset.y + this.ranged.attacks[3].bullet_start_offset_relative.y)
			}
		end

		if mode == MODE_GROUND then
			local new_height = U.ease_value(this.health_bar.offset.y, this.health_bar.y_offset, store.tick_length * 10, "linear")

			this.health_bar.offset.y = new_height
		else
			local new_height = U.ease_value(this.health_bar.offset.y, this.flight_height + this.health_bar.y_offset, store.tick_length * 10, "linear")

			this.health_bar.offset.y = new_height
		end
	end

	local function adjust_height(mode, strength_down)
		mode = mode or this.current_mode

		local height_dest = this.flight_height
		local easing = "quart-in"
		local strength = 1.5

		if mode == MODE_GROUND then
			height_dest = 0
			easing = "expo-in"
			strength = strength_down or 2
		end

		local new_height = U.ease_value(this.render.sprites[1].offset.y, height_dest, store.tick_length * strength, easing)

		this.render.sprites[1].offset.y = km.clamp(0, this.flight_height, new_height)

		adjust_position_reference(mode)

		this.drag_line_origin_offset.y = height_dest
	end

	local function check_tower_damage_factor()
		if store.entities[this.soldier.tower_id] then
			for _, a in ipairs(this.melee.attacks) do
				if not a._original_damage_min then
					a._original_damage_min = a.damage_min
				end

				if not a._original_damage_max then
					a._original_damage_max = a.damage_max
				end

				a.damage_min = a._original_damage_min * store.entities[this.soldier.tower_id].tower.damage_factor
				a.damage_max = a._original_damage_max * store.entities[this.soldier.tower_id].tower.damage_factor
			end
		end
	end

	local function y_soldier_new_rally_custom(store, this)
		local r = this.nav_rally
		local out = false
		local prev_immune = this.health.immune_to

		this.health.immune_to = r.immune_to

		if r.new then
			r.new = false

			U.unblock_target(store, this)
			U.set_destination(this, r.pos)

			if r.delay_max then
				U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop)

				local index = this.soldier.tower_soldier_idx or 0
				local tower = store.entities[this.soldier.tower_id]
				local total = tower and tower.barrack.max_soldiers or 1

				if SU.y_soldier_wait(store, this, index / total * r.delay_max) then
					goto label_615_0
				end
			end

			local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

			U.animation_start(this, an, af, store.tick_ts, -1)

			local start_ts = store.tick_ts

			if is_taking_off then
				this.vis.bans = this.vis_bans_before_take_off
				this.shadow_decal = E:create_entity(this.shadow_decal_t)
				this.shadow_decal.pos = this.pos
				this.shadow_decal.soldier_height = this.flight_height
				this.shadow_decal.entity = this

				queue_insert(store, this.shadow_decal)

				local dest = V.vclone(r.pos)

				this.render.sprites[1].sort_y_offset = this.spawn_sort_y_offset
				this.tween.disabled = true
				this.tween.props[1].disabled = true
				this.render.sprites[1].scale = v(0.9, 0.9)

				U.y_animation_play(this, "take_off", nil, store.tick_ts, 1)

				this.render.sprites[1].scale = v(1, 1)

				U.animation_start(this, "idle_air", nil, store.tick_ts, true)

				this.idle_flip.last_animation = "idle_air"

				local fx = E:create_entity(this.spawn_fx)

				fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)

				while not this.motion.arrived do
					adjust_height()

					local easing = "quart-inout"

					this.pos.x = U.ease_value(this.pos.x, dest.x, (store.tick_ts - start_ts) / 30, easing)
					this.pos.y = U.ease_value(this.pos.y, dest.y, (store.tick_ts - start_ts) / 30, easing)

					local vx, vy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
					local v_len = V.len(vx, vy)

					if v_len <= this.arrive_epsilon then
						this.motion.arrived = true
					end

					if tower and tower.tower.upgrade_to then
						is_taking_off = false

						break
					end

					coroutine.yield()
				end

				is_taking_off = false
				tower.tower_upgrade_persistent_data.is_taking_off[this.soldier.tower_soldier_idx] = false
				this.tween.disabled = false
				this.tween.props[1].disabled = false
				this.tween.props[1].ts = store.tick_ts
				this.render.sprites[1].sort_y_offset = 0
				this.motion.max_speed = this.speed_flight
				this.melee.attacks[1].disabled = true
				this.current_mode = MODE_FLY
			elseif this.current_mode == MODE_FLY or V.dist2(r.pos.x, r.pos.y, this.pos.x, this.pos.y) < this.max_dist_walk * this.max_dist_walk then
				local start_ts = store.tick_ts
				local time_to_accel = 0.7
				local dist_to_break = 50
				local vx, vy = V.sub(r.pos.x, r.pos.y, this.pos.x, this.pos.y)
				local dist2 = V.len2(vx, vy)

				while not this.motion.arrived do
					if this.health.dead or this.unit.is_stunned then
						out = true

						break
					end

					if r.new and not is_taking_off then
						out = false

						break
					end

					if this.change_mode and this.current_mode == MODE_GROUND and dist2 > this.max_dist_walk * this.max_dist_walk then
						out = false

						break
					end

					if this.current_mode == MODE_FLY then
						local vx, vy = V.sub(r.pos.x, r.pos.y, this.pos.x, this.pos.y)
						local dist = V.len(vx, vy)

						if dist_to_break < dist then
							local ease_step = (store.tick_ts - start_ts) / time_to_accel

							this.motion.max_speed = U.ease_value(0, this._max_speed, ease_step, "quad-in")
						else
							local ease_step = dist / dist_to_break

							this.motion.max_speed = U.ease_value(20, this._max_speed, ease_step, "quad-in")
						end
					else
						this.motion.max_speed = this.speed_ground
					end

					U.walk(this, store.tick_length)

					this.motion.speed.x, this.motion.speed.y = 0, 0

					coroutine.yield()
				end
				this.motion.max_speed = this.speed_ground
			else
				local start_ts = store.tick_ts
				local time_to_accel = 0.7
				local dist_to_break = 60
				local breaking = false

				U.animation_start(this, "take_off", nil, store.tick_ts, false)

				while not this.motion.arrived do
					if this.health.dead or this.unit.is_stunned then
						out = true

						break
					end

					if this.change_mode then
						out = false

						break
					end

					adjust_height(breaking and MODE_GROUND or MODE_FLY, 1)

					if U.animation_finished(this) and this.render.sprites[1].name == "take_off" then
						U.animation_start(this, "idle_air", nil, store.tick_ts, true)
					end

					local vx, vy = V.sub(r.pos.x, r.pos.y, this.pos.x, this.pos.y)
					local dist = V.len(vx, vy)

					if dist_to_break < dist then
						local ease_step = (store.tick_ts - start_ts) / time_to_accel

						this.motion.max_speed = U.ease_value(0, this._max_speed, ease_step, "quad-in")
					else
						breaking = true

						local ease_step = dist / dist_to_break

						this.motion.max_speed = U.ease_value(20, this._max_speed, ease_step, "quad-in")

						if this.current_mode == MODE_GROUND and this.render.sprites[1].name == "idle_air" then
							U.animation_start(this, "take_off", nil, store.tick_ts, false)
						end
					end

					U.walk(this, store.tick_length)

					this.motion.speed.x, this.motion.speed.y = 0, 0

					coroutine.yield()
				end
				this.motion.max_speed = this.speed_ground
			end
		end

		::label_615_0::

		this.vis.bans = this.vis_bans_after_take_off
		this.health.immune_to = prev_immune

		return out
	end

	local function change_mode_fly()
		this.motion.max_speed = this.speed_flight
		this.ranged.attacks[1].animation = "attack_air"
		this.melee.attacks[1].disabled = true

		if this.melee.attacks[2] then
			this.melee.attacks[2].disabled = true
		end

		if this.ranged.attacks[2] then
			this.ranged.attacks[2].animation = "phosphoric_coating_air"
		end

		if this.ranged.attacks[3] then
			this.ranged.attacks[3].animation = "sting_missiles_air"
		end

		this.unit.death_animation = "death_air"
		this.unit.hide_after_death = true

		local land_fx = E:create_entity(this.land_fx)

		land_fx.render.sprites[1].ts = store.tick_ts
		land_fx.pos = this.pos

		queue_insert(store, land_fx)
		S:queue(this.sound_take_off)
		U.y_animation_play(this, "take_off", nil, store.tick_ts, 1)
		U.animation_start(this, "idle_air", nil, store.tick_ts, true)

		this.idle_flip.last_animation = "idle_air"

		while this.render.sprites[1].offset.y < this.flight_height - this.arrive_epsilon do
			adjust_height()
			coroutine.yield()
		end

		U.y_wait(store, 0.2 * this.soldier.tower_soldier_idx)

		this.tween.props[1].disabled = false
		this.tween.disabled = false
		this.tween.props[1].ts = store.tick_ts
		this.render.sprites[1].angles.walk = {
			"idle_air"
		}
		this.vis.flags = bor(this.vis.flags, F_FLYING)
	end

	local function change_mode_ground()
		this.motion.max_speed = this.speed_ground
		this.ranged.attacks[1].animation = "attack_floor"
		this.unit.death_animation = "death_floor"
		this.unit.hide_after_death = false

		if this.powers and this.powers.phosphoric.level > 0 then
			this.melee.attacks[1].disabled = true
			this.melee.attacks[2].disabled = false
		else
			this.melee.attacks[1].disabled = false
		end

		if this.ranged.attacks[2] then
			this.ranged.attacks[2].animation = "phosphoric_coating_floor"
		end

		if this.ranged.attacks[3] then
			this.ranged.attacks[3].animation = "sting_missiles_floor"
		end

		this.tween.props[1].disabled = true
		this.tween.disabled = true

		local land_fx_ready = false

		while this.render.sprites[1].offset.y > this.arrive_epsilon do
			adjust_height()

			if not land_fx_ready and this.render.sprites[1].offset.y < this.distance_to_land_fx then
				land_fx_ready = true

				local land_fx = E:create_entity(this.land_fx)

				land_fx.render.sprites[1].ts = store.tick_ts
				land_fx.pos = this.pos

				queue_insert(store, land_fx)
			end

			coroutine.yield()
		end

		U.y_animation_play(this, "landing", nil, store.tick_ts, 1)
		U.animation_start(this, "idle_floor", nil, store.tick_ts, 1)

		this.idle_flip.last_animation = "idle_floor"
		this.render.sprites[1].angles.walk = {
			"walk"
		}
		this.vis.flags = U.flag_clear(this.vis.flags, F_FLYING)
	end

	local function soldier_idle(store, this)
		local idle_animation = "idle_floor"

		if this.current_mode == MODE_FLY then
			idle_animation = "idle_air"
		end

		local idle_pos = this.pos

		if this.soldier.target_id then
			local target = store.entities[this.soldier.target_id]

			if target then
				idle_pos = target.pos

				local an, af = U.animation_name_facing_point(this, idle_animation, idle_pos)

				U.animation_start(this, an, af, store.tick_ts, true)
			end
		elseif last_target_pos then
			idle_pos = last_target_pos

			local an, af = U.animation_name_facing_point(this, idle_animation, idle_pos)

			U.animation_start(this, an, af, store.tick_ts, true)
		else
			U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop, nil, force_ts)
		end

		if store.tick_ts - this.idle_flip.ts > 2 * store.tick_length then
			this.idle_flip.ts_counter = 0
		end

		this.idle_flip.ts = store.tick_ts
		this.idle_flip.ts_counter = this.idle_flip.ts_counter + store.tick_length

		if this.idle_flip.ts_counter > this.idle_flip.cooldown then
			this.idle_flip.ts_counter = 0

			if math.random() < this.idle_flip.chance then
				this.render.sprites[1].flip_x = not this.render.sprites[1].flip_x
			end

			if this.idle_flip.animations then
				this.idle_flip.last_animation = table.random(this.idle_flip.animations)
			end
		end
	end

	local function y_soldier_ranged_attacks(store, this)
		local target, attack, pred_pos = SU.soldier_pick_ranged_target_and_attack(store, this)

		if not target then
			last_target_pos = nil

			return false, A_NO_TARGET
		end

		if not attack then
			return false, A_IN_COOLDOWN
		end

		local start_ts = store.tick_ts
		local attack_done

		U.set_destination(this, this.pos)

		if this.current_mode == MODE_FLY and attack ~= this.ranged.attacks[3] then
			pred_pos.y = pred_pos.y - this.flight_height
		end

		if attack == this.ranged.attacks[3] then
			local mark = E:create_entity(attack.mark_mod)

			mark.modifier.target_id = target.id
			mark.modifier.source_id = this.id
			mark.modifier.duration = 9e+99

			queue_insert(store, mark)
		end

		attack_done = SU.y_soldier_do_ranged_attack(store, this, target, attack, pred_pos)

		if attack_done then
			last_target_pos = pred_pos
			attack.ts = start_ts

			if attack.shared_cooldown then
				for _, aa in pairs(this.ranged.attacks) do
					if aa ~= attack and aa.shared_cooldown then
						aa.ts = attack.ts
					end
				end
			end

			if this.ranged.forced_cooldown then
				this.ranged.forced_ts = start_ts
			end
		end

		if attack_done then
			return false, A_DONE
		else
			return true
		end
	end

	if not this.spawned_from_tower then
		this.current_mode = tower.tower_upgrade_persistent_data.current_mode
		this.change_mode = false
		this.vis.bans = this.vis_bans_after_take_off
		this.shadow_decal = E:create_entity(this.shadow_decal_t)
		this.shadow_decal.pos = this.pos
		this.shadow_decal.soldier_height = this.flight_height
		this.shadow_decal.entity = this

		queue_insert(store, this.shadow_decal)

		if this.current_mode == MODE_FLY then
			U.animation_start(this, "idle_air", nil, store.tick_ts, true)

			this.idle_flip.last_animation = "idle_air"

			if this.ranged.attacks[2] then
				this.ranged.attacks[2].animation = "phosphoric_coating_air"
			end

			if this.ranged.attacks[3] then
				this.ranged.attacks[3].animation = "sting_missiles_air"
			end

			this.tween.disabled = false
			this.tween.props[1].disabled = false
			this.tween.props[1].ts = store.tick_ts
			this.motion.max_speed = this.speed_flight
			this.melee.attacks[1].disabled = true
			this.vis.flags = bor(this.vis.flags, F_FLYING)
		else
			this.motion.max_speed = this.speed_ground
			this.melee.attacks[1].disabled = false
			this.ranged.attacks[1].animation = "attack_floor"

			if this.ranged.attacks[2] then
				this.ranged.attacks[2].animation = "phosphoric_coating_floor"
			end

			if this.ranged.attacks[3] then
				this.ranged.attacks[3].animation = "sting_missiles_floor"
			end

			this.unit.death_animation = "death_floor"
			this.unit.hide_after_death = false
			this.tween.props[1].disabled = true
			this.tween.disabled = true

			U.animation_start(this, "idle_floor", nil, store.tick_ts, true)

			this.idle_flip.last_animation = "idle_floor"
			this.render.sprites[1].angles.walk = {
				"walk"
			}
			this.vis.flags = U.flag_clear(this.vis.flags, F_FLYING)
		end

		adjust_height()
	end

	while true do
		while this.nav_rally.new do
			if y_soldier_new_rally_custom(store, this) then
				goto label_611_1
			end
		end

		if this.change_mode or this.current_mode ~= tower.tower_upgrade_persistent_data.current_mode then
			this.change_mode = false

			U.unblock_target(store, this)

			if this.current_mode == MODE_GROUND then
				this.current_mode = MODE_FLY

				change_mode_fly()
			else
				this.current_mode = MODE_GROUND

				change_mode_ground()
			end
		end

		adjust_position_reference()

		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					SU.soldier_power_upgrade(this, pn)

					if p == this.powers.phosphoric then
						this.melee.attacks[1].disabled = true
						this.melee.attacks[2].disabled = false
						this.melee.attacks[2].level = p.level
						this.ranged.attacks[1].disabled = true
						this.ranged.attacks[2].disabled = false
						this.ranged.attacks[2].level = p.level
						this.unit.damage_factor = p.damage_factor[p.level]
					end

					if p == this.powers.sting_missiles then
						this.ranged.attacks[3].max_range = p.max_range[p.level]
						this.ranged.attacks[3].min_range = p.min_range[p.level]
						this.ranged.attacks[3].filter_fn = function(e, o)
							return e.health and e.health.hp_max <= p.hp_max_target[p.level]
						end
					end
				end
			end
		end

		check_tower_damage_factor()

		if this.health.dead then
			tower.tower_upgrade_persistent_data.is_taking_off[this.soldier.tower_soldier_idx] = true

			if this.current_mode == MODE_FLY then
				this.unit.fade_time_after_death = false

				U.unblock_target(store, this)
				SU.y_enemy_death(store, this)
			else
				this.tween = nil

				SU.y_soldier_death(store, this)
			end

			return
		end

		if this.unit.is_stunned then
			this.tween.props[1].disabled = true

			SU.soldier_idle(store, this)

			goto label_611_1
		else
			this.tween.props[1].disabled = false
		end

		if this.current_mode == MODE_GROUND then
			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if sta == A_DONE and this.powers and this.powers.phosphoric.level > 0 then
				local target = store.entities[this.soldier.target_id]

				if target then
					if target.health.armor and target.health.armor > 0 then
						SU.armor_dec(target, this.powers.phosphoric.armor_reduction[this.powers.phosphoric.level])
					end

					tower_rocket_gunners_phosphoric_area_damage(this, store, target)
				end
			end

			if brk or sta ~= A_NO_TARGET then
				goto label_611_1
			end
		end

		if this.ranged and not this.ranged.range_while_blocking then
			if this.ranged.attacks[2] and this.ranged.attacks[2].bullet_start_offset then
				for _, start_offset in ipairs(this.ranged.attacks[2].bullet_start_offset) do
					start_offset.y = this.render.sprites[1].offset.y + this.ranged.attacks[2].bullet_start_offset_relative.y
					start_offset.x = this.ranged.attacks[2].bullet_start_offset_relative.x
				end
			end

			brk, sta = y_soldier_ranged_attacks(store, this)

			if brk or sta == A_DONE then
				goto label_611_1
			elseif sta == A_IN_COOLDOWN and not this.ranged.go_back_during_cooldown then
				goto label_611_0
			end
		end

		if SU.soldier_go_back_step(store, this) then
			goto label_611_1
		end

		::label_611_0::

		soldier_idle(store, this)
		SU.soldier_regen(store, this)

		::label_611_1::

		coroutine.yield()
	end
end

scripts.bullet_soldier_tower_rocket_gunners = {}

function scripts.bullet_soldier_tower_rocket_gunners.update(this, store)
	local b = this.bullet
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]

	b.damage_min = b.damage_min_config[b.level]
	b.damage_max = b.damage_max_config[b.level]

	local tower = source and store.entities[source.soldier.tower_id]

	U.y_wait(store, b.flight_time)

	if target then
		if tower then
			local tower_damage_factor = tower.tower.damage_factor

			b.damage_factor = tower_damage_factor
		end

		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if band(target.vis.flags, F_FLYING) ~= 0 then
			local fx = E:create_entity(b.hit_fx)

			fx.pos.x, fx.pos.y = target.pos.x, target.pos.y + target.flight_height
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		else
			local fx = E:create_entity(b.hit_fx)

			fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			if band(target.vis.flags, F_CLIFF) == 0 then
				local fx = E:create_entity(b.floor_fx)

				fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end
		end
	end

	queue_remove(store, this)
end

scripts.bullet_soldier_tower_rocket_gunners_phosphoric = {}

function scripts.bullet_soldier_tower_rocket_gunners_phosphoric.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local dest = V.vclone(b.to)

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle
		s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	if this.ray_duration then
		while store.tick_ts - s.ts < this.ray_duration do
			if this.track_target then
				update_sprite()
			end

			if tower and not store.entities[tower.id] then
				queue_remove(store, this)

				if fx then
					queue_remove(store, fx)
				end

				for key, value in pairs(mods_added) do
					queue_remove(store, value)
				end

				break
			end

			coroutine.yield()

			s.hidden = false
		end
	else
		while not U.animation_finished(this, 1) do
			if tower and not store.entities[tower.id] then
				queue_remove(store, this)

				break
			end

			coroutine.yield()
		end
	end

	if target and source then
		b.damage_factor = source.unit.damage_factor

		local tower_id = source.soldier.tower_id

		if tower_id and store.entities[tower_id] then
			local tower_damage_factor = store.entities[tower_id].tower.damage_factor

			b.damage_factor = tower_damage_factor
		end

		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if target.health.armor and target.health.armor > 0 and source.powers and source.powers.phosphoric then
			SU.armor_dec(target, source.powers.phosphoric.armor_reduction[b.level])
		end

		if band(target.vis.flags, F_FLYING) ~= 0 then
			local fx = E:create_entity(b.hit_fx)

			if target.flight_height then
				fx.pos.x, fx.pos.y = target.pos.x, target.pos.y + target.flight_height
			else
				fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
			end

			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
		else
			local fx = E:create_entity(b.hit_fx)

			fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			if band(target.vis.flags, F_CLIFF) == 0 then
				local fx = E:create_entity(b.floor_fx)

				fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end
		end

		if band(target.vis.flags, F_FLYING) == 0 then
			tower_rocket_gunners_phosphoric_area_damage(source, store, target)
		end
	end

	queue_remove(store, this)
end

scripts.bullet_soldier_tower_rocket_gunners_sting_missiles = {}

function scripts.bullet_soldier_tower_rocket_gunners_sting_missiles.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local ps

	if not source then
		queue_remove(store, this)

		return
	end

	source.ranged.attacks[3].disabled = true

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 8 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	local function fly_to_pos(target_pos)
		local start_ts = store.tick_ts
		local last_pos = V.vclone(this.pos)
		local dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)

		while V.len(dx, dy) > 20 do
			last_pos.x, last_pos.y = this.pos.x, this.pos.y

			move_step(target_pos)

			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			ps.particle_system.emit_offset.x, ps.particle_system.emit_offset.y = V.rotate(this.render.sprites[1].r, ps.emit_offset_relative.x, ps.emit_offset_relative.y)
			dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
			dist = V.len(dx, dy)

			coroutine.yield()
		end
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if target then
		local m = E:create_entity(this.mod)

		m.modifier.target_id = target.id

		queue_insert(store, m)
	end

	local soldier_pos = v(source.pos.x, source.pos.y + source.render.sprites[1].offset.y)
	local soldier_floor_pos = v(source.pos.x, source.pos.y)
	local attack = table.deepclone(source.ranged.attacks[3])

	fm.a.x, fm.a.y = 0, 80

	local target_pos = v(soldier_pos.x, soldier_pos.y + 130)

	fly_to_pos(target_pos)

	local side_flip = 1

	if target and target.pos.x < soldier_pos.x then
		side_flip = -1
	end

	fm.a.x, fm.a.y = 100, 0

	local target_pos = v(soldier_pos.x + 70 * side_flip, soldier_pos.y + 130)

	fly_to_pos(target_pos)

	target_pos = v(soldier_pos.x + 35 * side_flip, soldier_pos.y + 100)

	fly_to_pos(target_pos)

	-- target_pos = v(soldier_pos.x, soldier_pos.y + 130)

	-- fly_to_pos(target_pos)

	-- target_pos = v(soldier_pos.x, soldier_pos.y + 180)

	-- fly_to_pos(target_pos)

	-- if target then
	-- 	target_pos = v(target.pos.x, soldier_pos.y + 180)

	-- 	fly_to_pos(target_pos)
	-- end

	fm.a_step = 5
	fm.max_a = 2700
	fm.max_v = 900
	ps.particle_system.emission_rate = 90

	if not target or target.health.dead then
		local new_target, targets = U.find_foremost_enemy(store.entities, soldier_floor_pos, 0, attack.max_range, false, attack.vis_flags, attack.vis_bans, attack.filter_fn)

		if new_target then
			b.target_id = new_target.id

			local m = E:create_entity(this.mod)

			m.modifier.target_id = new_target.id

			queue_insert(store, m)
		end
	end

	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	if target and band(target.vis.flags, F_FLYING) ~= 0 then
		b.ignore_hit_offset = false
	end

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			ps.particle_system.emit_offset.x, ps.particle_system.emit_offset.y = V.rotate(this.render.sprites[1].r, ps.emit_offset_relative.x, ps.emit_offset_relative.y)
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.damage_type = bor(DAMAGE_INSTAKILL, DAMAGE_NO_SPAWNS)
		d.value = 10

		queue_damage(store, d)

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.level = b.level

				queue_insert(store, m)
			end
		end
	elseif b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	S:queue(this.sound_events.hit)

	this.render.sprites[1].hidden = true

	if target and band(target.vis.flags, F_FLYING) ~= 0 then
		if b.hit_fx_air then
			local decal = E:create_entity(b.hit_fx_air)

			decal.pos = V.vclone(b.to)
			decal.render.sprites[1].ts = store.tick_ts

			queue_insert(store, decal)
		end
	else
		if b.hit_fx then
			local fx = E:create_entity(b.hit_fx)

			fx.pos.x, fx.pos.y = b.to.x, b.to.y
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].runs = 0

			queue_insert(store, fx)
		end

		if target and target.unit.can_explode then
			target.unit.show_blood_pool = false

			if b.hit_decal then
				local decal = E:create_entity(b.hit_decal)

				decal.pos = V.vclone(b.to)
				decal.render.sprites[1].ts = store.tick_ts

				queue_insert(store, decal)
			end

			if b.hit_decal_fx then
				local decal = E:create_entity(b.hit_decal_fx)

				decal.pos = V.vclone(b.to)
				decal.render.sprites[1].ts = store.tick_ts

				queue_insert(store, decal)
			end
		end
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.decal_soldier_shadow = {}

function scripts.decal_soldier_shadow.update(this, store, script)
	while true do
		if this.entity.health.dead then
			if not this.entity.health.last_damage_types == 0 then
				U.y_wait(store, fts(this.dissapear_time))
			end

			queue_remove(store, this)

			return
		end

		local offset_y = this.entity.render.sprites[1].offset.y
		local shadow_scale = 1 - this.shadow_shrink * offset_y / this.max_height

		this.render.sprites[1].scale = v(shadow_scale, shadow_scale)

		coroutine.yield()
	end
end

scripts.mod_soldier_tower_rocket_gunners_sting_missiles_target = {}

function scripts.mod_soldier_tower_rocket_gunners_sting_missiles_target.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	U.animation_start(this, "start", nil, store.tick_ts)

	local is_idle = false

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		if U.animation_finished(this, 1) and not is_idle then
			is_idle = true

			U.animation_start(this, "idle", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.tower_necromancer = {}

function scripts.tower_necromancer.update(this, store)
	local tower_sid = this.render.sid_tower
	local last_ts = store.tick_ts - this.attacks.list[1].cooldown
	local last_ts_shared = store.tick_ts - this.attacks.min_cooldown

	this.attacks._last_target_pos = this.attacks._last_target_pos or v(REF_W, 0)
	this.attacks.list[1].ts = store.tick_ts - this.attacks.list[1].cooldown + this.attacks.attack_delay_on_spawn

	local max_skulls = #this.attacks.list[1].bullet_spawn_offset

	if this.tower_upgrade_persistent_data.swaped then
		this.tower_upgrade_persistent_data = E:clone_c("tower_upgrade_persistent_data")
		this.tower_upgrade_persistent_data.swaped = true

		SU.towers_swaped(store, this, this.attacks.list)
	end

	if not this.tower_upgrade_persistent_data.current_skulls then
		this.tower_upgrade_persistent_data.current_skulls = 0
		this.tower_upgrade_persistent_data.skulls_ref = {}
		last_ts = this.tower_upgrade_persistent_data.last_ts
		this.tower_upgrade_persistent_data.current_skeletons = 0
		this.tower_upgrade_persistent_data.current_golems = 0
		this.tower_upgrade_persistent_data.fire_skulls = false
		this.tower_upgrade_persistent_data.skeletons_ref = {}
	end

	for index, skull in pairs(this.tower_upgrade_persistent_data.skulls_ref) do
		if skull then
			local start_offset = table.safe_index(this.attacks.list[1].bullet_spawn_offset, index)

			skull.pos.x, skull.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
			skull.bullet.source_id = this.id
			skull.bullet.level = this.tower.level
		end
	end

	for index, skeleton in pairs(this.tower_upgrade_persistent_data.skeletons_ref) do
		skeleton.source_necromancer = this
	end

	local function find_target(attack)
		local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, this.attacks.range, attack.node_prediction, attack.vis_flags, attack.vis_bans)

		return target, pred_pos
	end

	local function is_pos_below(pos)
		return not pos or pos.y < this.pos.y + 50
	end

	local function check_skill_debuff()
		if this.powers then
			local power = this.powers.skill_debuff
			local attack = this.attacks.list[2]

			if power and power.level and power.level > 0 and attack and attack.cooldown and attack.ts and store.tick_ts - attack.ts > attack.cooldown and
			(not attack.min_cooldown or store.tick_ts - last_ts_shared > attack.min_cooldown) and this.tower.can_do_magic then
				local enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, attack.max_range, attack.node_prediction + attack.cast_time, attack.vis_flags, attack.vis_bans, function(e, o)
					local node_offset = P:predict_enemy_node_advance(e, attack.node_prediction + attack.cast_time)
					local e_ni = e.nav_path.ni + node_offset
					local n_pos = P:node_pos(e.nav_path.pi, e.nav_path.spi, e_ni)

					return band(GR:cell_type(n_pos.x, n_pos.y), bor(TERRAIN_CLIFF, TERRAIN_WATER)) == 0
				end)

				if not enemy or #enemies < attack.min_targets then
					SU.delay_attack(store, attack, fts(10))

					return
				end

				local start_ts = store.tick_ts

				U.animation_start(this, attack.animation, nil, store.tick_ts, false, this.render.sid_mage)
				U.animation_start(this, "mark_of_silence", nil, store.tick_ts, false, this.render.sid_glow_fx)

				while store.tick_ts - start_ts < attack.cast_time do
					coroutine.yield()
				end

				local debuff_aura = E:create_entity(attack.entity)
				local ni = enemy.nav_path.ni + P:predict_enemy_node_advance(enemy, attack.node_prediction)

				debuff_aura.pos = P:node_pos(enemy.nav_path.pi, 1, ni)
				debuff_aura.aura.duration = power.aura_duration[power.level]
				debuff_aura.aura.level = power.level
				debuff_aura.aura.source_id = this.id

				queue_insert(store, debuff_aura)
				U.y_animation_wait(this, this.render.sid_mage)

				attack.ts = start_ts
				last_ts_shared = start_ts
			end
		end
	end

	local function check_skill_rider()
		if not this.powers then
			return
		end

		local power = this.powers.skill_rider
		local attack = this.attacks.list[3]

		if not power or power.level <= 0 or not attack or not attack.cooldown or store.tick_ts - attack.ts < attack.cooldown or
		(attack.min_cooldown and store.tick_ts - last_ts_shared < attack.min_cooldown) or not this.tower.can_do_magic then
			return
		end

		local enemy, enemies = U.find_foremost_enemy(store.entities, tpos(this), 0, attack.max_range, attack.node_prediction, attack.vis_flags, attack.vis_bans)

		if not enemy or #enemies < attack.min_targets then
			SU.delay_attack(store, attack, fts(10))

			return
		end

		local start_ts = store.tick_ts

		U.animation_start(this, attack.animation, nil, store.tick_ts, false, this.render.sid_mage)
		U.animation_start(this, "call_death_rider", nil, store.tick_ts, false, this.render.sid_glow_fx)

		while store.tick_ts - start_ts < attack.cast_time do
			coroutine.yield()
		end

		local rider = E:create_entity(attack.entity)
		local ni = enemy.nav_path.ni + P:predict_enemy_node_advance(enemy, attack.node_prediction)

		rider.pos = P:node_pos(enemy.nav_path.pi, 1, ni)
		rider.aura.level = power.level
		rider.path_id = enemy.nav_path.pi

		queue_insert(store, rider)
		U.y_animation_wait(this, this.render.sid_mage)

		attack.ts = start_ts
		last_ts_shared = start_ts
	end

	local target, pred_pos = find_target(this.attacks.list[1])

	if is_pos_below(pred_pos) then
		U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_mage)
	else
		U.animation_start(this, "idle_back", nil, store.tick_ts, true, this.render.sid_mage)
	end

	local had_target = false

	if this.tower.level == 4 then
		U.animation_start(this, "smoke", nil, store.tick_ts, true, 6)
	end

	::label_629_0::

	while true do
		if U.animation_finished(this, this.render.sid_mage) then
			if this.render.sprites[this.render.sid_mage].name == "attack" then
				U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_mage, true)
			elseif this.render.sprites[this.render.sid_mage].name == "attack_back" then
				U.animation_start(this, "idle_back", nil, store.tick_ts, true, this.render.sid_mage)
			end
		end

		if this.tower.blocked then
			coroutine.yield()
		else
			if target and not had_target then
				this.tween.reverse = false
				this.tween.disabled = false
				this.tween.ts = store.tick_ts

				U.animation_start(this, "attack", nil, store.tick_ts, true, this.render.sid_smoke_fx)
			end

			if not target and had_target then
				this.tween.reverse = true
				this.tween.ts = store.tick_ts
			end

			had_target = target ~= nil

			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == this.powers.skill_debuff then
							this.attacks.list[2].cooldown = pow.cooldown[pow.level]
							this.attacks.list[2].ts = store.tick_ts - this.attacks.list[2].cooldown
						elseif pow == this.powers.skill_rider then
							this.attacks.list[3].cooldown = pow.cooldown[pow.level]
							this.attacks.list[3].ts = store.tick_ts - this.attacks.list[3].cooldown
						end
					end
				end
			end

			if this.tower_upgrade_persistent_data.current_skulls == 0 then
				this.tower_upgrade_persistent_data.fire_skulls = false
			end

			local attack = this.attacks.list[1]

			if store.tick_ts - attack.ts > attack.cooldown and store.tick_ts - last_ts_shared > this.attacks.min_cooldown then
				target, pred_pos = find_target(attack)

				if not target and max_skulls <= this.tower_upgrade_persistent_data.current_skulls then
					SU.delay_attack(store, attack, fts(10))
				else
					local start_ts = store.tick_ts

					if this.tower.level > 1 then
						U.animation_start(this, "skull_spawn", nil, store.tick_ts, 1, this.render.sid_glow_fx)
					end

					if is_pos_below(pred_pos) then
						U.animation_start(this, "attack", nil, store.tick_ts, nil, this.render.sid_mage)
					else
						U.animation_start(this, "attack_back", nil, store.tick_ts, nil, this.render.sid_mage)
					end

					local b = E:create_entity(attack.bullet)

					U.y_wait(store, attack.shoot_time)

					target, pred_pos = find_target(this.attacks.list[1])

					if target and this.tower_upgrade_persistent_data.current_skulls > 0 then
						this.tower_upgrade_persistent_data.fire_skulls = true
						attack.ts = start_ts
						last_ts = start_ts

						goto label_629_0
					end

					local start_offset
					local fire_directly = this.tower_upgrade_persistent_data.current_skulls == 0 and target

					if fire_directly then
						start_offset = V.vclone(attack.bullet_start_offset)

						if this.render.sprites[this.render.sid_mage].name == "attack_back" then
							start_offset.x = -start_offset.x
						end
					else
						start_offset = table.safe_index(attack.bullet_spawn_offset, this.tower_upgrade_persistent_data.current_skulls + 1)
					end

					attack.ts = start_ts
					last_ts = start_ts
					b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = V.vclone(b.pos)
					b.bullet.source_id = this.id
					b.bullet.level = this.tower.level
					b.bullet.damage_factor = this.tower.damage_factor
					b.tower_ref = this
					b.render.sprites[1].flip_x = this.tower_upgrade_persistent_data.current_skulls > 0 and this.tower_upgrade_persistent_data.current_skulls < 3
					b.fire_directly = fire_directly

					if this.tower_upgrade_persistent_data.current_skulls < 2 then
						b.render.sprites[1].z = Z_OBJECTS
						b.render.sprites[1].sort_y_offset = -40 - 10 * this.tower.level
					else
						b.render.sprites[1].z = Z_OBJECTS
						b.render.sprites[1].sort_y_offset = -40 * this.tower.level
						b.render.sprites[1].draw_order = 2
					end

					queue_insert(store, b)

					this.tower_upgrade_persistent_data.current_skulls = this.tower_upgrade_persistent_data.current_skulls + 1
					this.tower_upgrade_persistent_data.skulls_ref[this.tower_upgrade_persistent_data.current_skulls] = b
				end
			end

			check_skill_debuff()
			check_skill_rider()

			this.tower_upgrade_persistent_data.last_ts = last_ts

			coroutine.yield()
		end
	end
end

function scripts.tower_necromancer.remove(this, store)
	if this.tower_upgrade_persistent_data.skulls_ref and not this.tower.upgrade_to then
		for _, skull in pairs(this.tower_upgrade_persistent_data.skulls_ref) do
			if skull then
				queue_remove(store, skull)
			end
		end
	end

	return true
end

scripts.bullet_tower_necromancer = {}

function scripts.bullet_tower_necromancer.insert(this, store, script)
	local b = this.bullet

	if b.target_id then
		local target = store.entities[b.target_id]

		if not target or band(target.vis.bans, F_RANGED) ~= 0 then
			return false
		end
	end

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	local s = this.render.sprites[1]

	if not b.ignore_rotation then
		s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
	end

	this.source = store.entities[b.source_id]

	if not this.source then
		return false
	end

	U.animation_start(this, "flying", nil, store.tick_ts, s.loop)

	return true
end

function scripts.bullet_tower_necromancer.update(this, store)
	local b = this.bullet
	local target
	local fm = this.force_motion

	local function find_target()
		local attack = this.source.attacks.list[1]
		local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this.source), 0, this.source.attacks.range, attack.node_prediction, attack.vis_flags, attack.vis_bans)

		return target, pred_pos
	end

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	U.animation_start(this, "idle", nil, store.tick_ts, false, 1)

	local recalculate_spawn_pos = false

	if not this.source then
		queue_remove(store, this)

		return
	end

	if this.source.tower.is_blocked then
		this.fire_directly = false
		recalculate_spawn_pos = true
	end

	local enemy, pred_pos = find_target()

	if this.fire_directly and enemy then
		if enemy then
			goto label_636_0
		else
			recalculate_spawn_pos = true
		end
	else
		S:queue(this.summon_sound)
	end

	if recalculate_spawn_pos then
		local start_offset = table.safe_index(this.source.attacks.list[1].bullet_spawn_offset, this.source.tower_upgrade_persistent_data.current_skulls + 1)

		this.pos.x, this.pos.y = this.source.pos.x + start_offset.x, this.source.pos.y + start_offset.y
	end

	U.animation_start(this, "idle", nil, store.tick_ts, false, 2)
	U.y_wait(store, fts(math.random(0, 10)))
	U.animation_start(this, "idle", nil, store.tick_ts, true, 1)

	while not U.animation_finished(this, 2) do
		coroutine.yield()
	end

	this.render.sprites[2].hidden = true

	while not this.source or not this.source.tower_upgrade_persistent_data.fire_skulls or not enemy or not pred_pos do
		if b.source_id ~= this.source.id and store.entities[b.source_id] ~= nil then
			this.source = store.entities[b.source_id]
		end

		if this.source and not this.source.tower.is_blocked then
			enemy, pred_pos = find_target()
		else
			enemy = nil
		end

		this.render.sprites[1].hidden = this.source.render.sprites[2].hidden

		coroutine.yield()
	end

	::label_636_0::

	if b.source_id ~= this.source.id and store.entities[b.source_id] ~= nil then
		this.source = store.entities[b.source_id]
	end

	this.render.sprites[1].z = Z_BULLETS
	this.source.tower_upgrade_persistent_data.skulls_ref[this.source.tower_upgrade_persistent_data.current_skulls] = nil
	this.source.tower_upgrade_persistent_data.current_skulls = this.source.tower_upgrade_persistent_data.current_skulls - 1
	b.to = V.v(pred_pos.x + enemy.unit.hit_offset.x, pred_pos.y + enemy.unit.hit_offset.y)
	b.target_id = enemy.id
	target = store.entities[enemy.id]

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local iix, iiy = V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts
	this.render.sprites[1].flip_x = pred_pos.x < this.source.pos.x

	S:queue(this.shoot_sound)

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local d = math.max(math.abs(target.pos.x + target.unit.hit_offset.x - b.to.x), math.abs(target.pos.y + target.unit.hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.info("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = pred_pos.x + target.unit.hit_offset.x, pred_pos.y + target.unit.hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(0, iix, iiy))
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local mod = E:create_entity(b.mod)

		mod.modifier.target_id = target.id
		mod.modifier.source_id = this.source.id

		queue_insert(store, mod)

		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)
		S:queue(this.hit_sound)
	end

	U.animation_start(this, "hit_FX_idle", nil, store.tick_ts, 1, 1)

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false
	end

	while not U.animation_finished(this, 1) do
		coroutine.yield()
	end

	this.render.sprites[1].hidden = true

	queue_remove(store, this)
	coroutine.yield()
end

scripts.mod_tower_necromancer_curse = {}

function scripts.mod_tower_necromancer_curse.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target or not source then
		return false
	end

	if target.health.dead then
		-- block empty
	else
		if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
			log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

			return false
		end

		if target.unit and this.render then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.flip_x = target.render.sprites[1].flip_x
				s.ts = store.tick_ts

				if s.size_names then
					s.name = s.size_names[target.unit.size]
				end
			end

			if band(target.vis.flags, F_FLYING) ~= 0 then
				this.render.sprites[2].hidden = true
			end
		end
	end

	if band(target.vis.flags, F_FLYING) ~= 0 or band(target.vis.flags, F_NIGHTMARE) ~= 0 then
		return true
	end

	for _, et in pairs(this.excluded_templates) do
		if et == target.template_name then
			return true
		end
	end

	local entity_name = this.skeleton_prefix .. source.tower.level

	this.render.sprites[1].name = this.sprite_small
	this.render.sprites[2].name = this.decal_small

	if (target.unit.size == UNIT_SIZE_MEDIUM or target.unit.size == UNIT_SIZE_LARGE) and not table.contains(this.excluded_templates_golem, target.template_name) then
		entity_name = this.skeleton_golem_prefix .. source.tower.level
		this.render.sprites[1].name = this.sprite_big
		this.render.sprites[2].name = this.decal_big
	end

	target._necromancer_entity_name = entity_name
	target.old_death_spawns = target.death_spawns

	if not target.death_spawns or target.death_spawns.name ~= entity_name then
		target.death_spawns = nil
	end

	return true
end

function scripts.mod_tower_necromancer_curse.remove(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		local can_spawn = target.health.dead and target._necromancer_entity_name and band(target.health.last_damage_types, bor(DAMAGE_EAT, DAMAGE_NO_SPAWNS)) == 0

		if can_spawn then
			target.death_spawns = nil

			local s = E:create_entity(target._necromancer_entity_name)

			s.pos = V.vclone(target.pos)
			s.source = target

			if s.render and s.render.sprites[1] and target.render and target.render.sprites[1] then
				s.render.sprites[1].flip_x = target.render.sprites[1].flip_x
			end

			if s.nav_path then
				s.nav_path.pi = this.nav_path.pi
				s.nav_path.spi = this.nav_path.spi
				s.nav_path.ni = this.nav_path.ni + 2
			end

			queue_insert(store, s)
		else
			target._necromancer_entity_name = nil
			
			if target.old_death_spawns then
				target.death_spawns = target.old_death_spawns
				target.old_death_spawns = nil
			end
		end
	end

	return true
end

scripts.soldier_tower_necromancer_skeleton = {}

function scripts.soldier_tower_necromancer_skeleton.update(this, store, script)
	local brk, stam, star
	local source = this.source

	this.reinforcement.ts = store.tick_ts
	this.nav_rally.pos = V.vclone(this.pos)
	this.nav_rally.center = V.vclone(this.pos)
	this.render.sprites[1].hidden = true
	this._vis_bans = this.vis.bans
	this.vis.bans = F_ALL
	this.ui.can_click = false

	if source and source.health and source.health.dead_lifetime then
		if source.unit and source.unit.fade_time_after_death then
			U.y_wait(store, source.health.dead_lifetime + source.unit.fade_time_after_death)
		else
			U.y_wait(store, source.health.dead_lifetime)
		end
	else
		U.y_wait(store, math.random(this.spawn_delay_min, this.spawn_delay_max))
	end

	this.vis.bans = this._vis_bans
	this.ui.can_click = true
	this.source_necromancer = nil

	local targets = table.filter(store.entities, function(k, v)
		return not v.pending_removal and (v.template_name == "tower_necromancer_lvl1" or v.template_name == "tower_necromancer_lvl2" or v.template_name == "tower_necromancer_lvl3" or v.template_name == "tower_necromancer_lvl4") and U.is_inside_ellipse(v.pos, this.pos, v.attacks.range * 1.1)
	end)
	local kill_oldest_skeleton = false
	local kill_oldest_golem = false
	local kill_from_any_tower = false

	if targets and #targets > 0 then
		if this.is_golem then
			table.sort(targets, function(e1, e2)
				return e1.tower_upgrade_persistent_data.current_golems < e2.tower_upgrade_persistent_data.current_golems
			end)
		else
			table.sort(targets, function(e1, e2)
				return e1.tower_upgrade_persistent_data.current_skeletons < e2.tower_upgrade_persistent_data.current_skeletons
			end)
		end

		this.source_necromancer = targets[1]

		if this.is_golem then
			kill_oldest_golem = this.source_necromancer.tower_upgrade_persistent_data.current_golems >= this.source_necromancer.max_golems
			this.source_necromancer.tower_upgrade_persistent_data.current_golems = this.source_necromancer.tower_upgrade_persistent_data.current_golems + 1
		else
			kill_oldest_skeleton = this.source_necromancer.tower_upgrade_persistent_data.current_skeletons >= this.source_necromancer.max_skeletons
			this.source_necromancer.tower_upgrade_persistent_data.current_skeletons = this.source_necromancer.tower_upgrade_persistent_data.current_skeletons + 1
		end
	else
		queue_remove(store, this)

		return
	end

	if not kill_oldest_golem and not kill_oldest_skeleton then
		local cg = store.count_groups[this.count_group_type]

		if cg[this.count_group.name] and cg[this.count_group.name] > this.count_group_max then
			kill_oldest_skeleton = true
			kill_from_any_tower = true
		end
	end

	if kill_oldest_skeleton or kill_oldest_golem then
		local targets

		if this.is_golem then
			targets = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.source_necromancer and (this.source_necromancer == v.source_necromancer or kill_from_any_tower and not v.is_golem) and v.is_golem and v.health and not v.health.dead and v.soldier and not v.soldier.target_id and this.id ~= v.id
			end)
		else
			targets = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.source_necromancer and (this.source_necromancer == v.source_necromancer or kill_from_any_tower and not v.is_golem) and v.health and not v.health.dead and v.soldier and not v.soldier.target_id and this.id ~= v.id
			end)
		end

		if targets and #targets > 0 then
			table.sort(targets, function(e1, e2)
				return e1.id < e2.id
			end)

			targets[1].health.dead = true
			targets[1].health_bar.hidden = true
		else
			if this.is_golem then
				this.source_necromancer.tower_upgrade_persistent_data.current_golems = this.source_necromancer.tower_upgrade_persistent_data.current_golems - 1
			else
				this.source_necromancer.tower_upgrade_persistent_data.current_skeletons = this.source_necromancer.tower_upgrade_persistent_data.current_skeletons - 1
			end

			queue_remove(store, this)

			return
		end
	end

	table.insert(this.source_necromancer.tower_upgrade_persistent_data.skeletons_ref, this)

	this.render.sprites[1].ts = store.tick_ts
	this.render.sprites[1].hidden = false

	local spawn_fx = E:create_entity(this.spawn_fx)

	spawn_fx.pos = V.vclone(this.pos)
	spawn_fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, spawn_fx)
	U.y_wait(store, fts(this.spawn_fx_delay))
	S:queue(this.spawn_sound)
	U.y_animation_play(this, "spawn", nil, store.tick_ts, 1)

	local starting_pos = V.vclone(this.pos)

	this.nav_rally.pos = starting_pos

	local patrol_pos = V.vclone(this.pos)

	patrol_pos.x, patrol_pos.y = patrol_pos.x + this.patrol_pos_offset.x, patrol_pos.y + this.patrol_pos_offset.y

	local nearest_node = P:nearest_nodes(patrol_pos.x, patrol_pos.y, nil, nil, false)[1]
	local pi, spi, ni = unpack(nearest_node)
	local npos = P:node_pos(pi, spi, ni)
	local patrol_pos_2 = V.vclone(this.pos)

	patrol_pos_2.x, patrol_pos_2.y = patrol_pos_2.x - this.patrol_pos_offset.x, patrol_pos_2.y - this.patrol_pos_offset.y

	local nearest_node = P:nearest_nodes(patrol_pos_2.x, patrol_pos_2.y, nil, nil, false)[1]
	local pi, spi, ni = unpack(nearest_node)
	local npos_2 = P:node_pos(pi, spi, ni)

	if V.dist2(patrol_pos.x, patrol_pos.y, npos.x, npos.y) > V.dist2(patrol_pos_2.x, patrol_pos_2.y, npos_2.x, npos_2.y) then
		patrol_pos = V.vclone(patrol_pos_2)
	end

	local idle_ts = store.tick_ts
	local patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)

	while true do
		if this.health.dead then
			SU.y_soldier_death(store, this)

			if this.is_golem then
				this.source_necromancer.tower_upgrade_persistent_data.current_golems = this.source_necromancer.tower_upgrade_persistent_data.current_golems - 1
			else
				this.source_necromancer.tower_upgrade_persistent_data.current_skeletons = this.source_necromancer.tower_upgrade_persistent_data.current_skeletons - 1
			end

			table.removeobject(this.source_necromancer.tower_upgrade_persistent_data.skeletons_ref, this)
			queue_remove(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)

			idle_ts = store.tick_ts
			patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)
		else
			SU.soldier_courage_upgrade(store, this)

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					idle_ts = store.tick_ts
					patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)

					goto label_641_0
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				-- block empty
			elseif SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)

				if patrol_cd < store.tick_ts - idle_ts then
					if this.nav_rally.pos == starting_pos then
						this.nav_rally.pos = patrol_pos
					else
						this.nav_rally.pos = starting_pos
					end

					idle_ts = store.tick_ts
					patrol_cd = math.random(this.patrol_min_cd, this.patrol_max_cd)
				end
			end
		end

		::label_641_0::

		coroutine.yield()
	end
end

scripts.aura_tower_necromancer_skill_debuff = {}

function scripts.aura_tower_necromancer_skill_debuff.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0
	local sid_totem = 1
	local sid_fx = 2

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	this.render.sprites[sid_fx].hidden = true

	U.y_animation_play(this, "start", nil, store.tick_ts, 1, sid_totem)

	this.render.sprites[sid_fx].hidden = false
	this.tween.props[1].disabled = false
	this.tween.props[1].ts = store.tick_ts

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_648_0
			end
		end

		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			if this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
				goto label_648_0
			end

			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.enemy_vis_bans) == 0 and band(v.vis.bans, this.aura.enemy_vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.enemy_allowed_templates or table.contains(this.aura.enemy_allowed_templates, v.template_name)) and (not this.aura.enemy_excluded_templates or not table.contains(this.aura.enemy_excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				for _, mod_name in pairs(this.aura.enemy_mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.aura.source_id
					new_mod.modifier.duration = this.modifier_duration_config[this.aura.level]
					new_mod.inflicted_damage_factor = this.modifier_inflicted_damage_factor[this.aura.level]

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)
				end
			end

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.soldier_vis_bans) == 0 and band(v.vis.bans, this.aura.soldier_vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.soldier_allowed_templates or table.contains(this.aura.soldier_allowed_templates, v.template_name)) and (not this.aura.soldier_excluded_templates or not table.contains(this.aura.soldier_excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				for _, mod_name in pairs(this.aura.soldier_mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.aura.source_id
					new_mod.modifier.duration = this.modifier_duration_config[this.aura.level]
					new_mod.inflicted_damage_factor = this.modifier_inflicted_damage_factor[this.aura.level]

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)
				end
			end
		end

		U.animation_start(this, "idle", nil, store.tick_ts, 1, sid_totem)

		::label_648_0::

		coroutine.yield()
	end

	this.tween.reverse = true
	this.tween.props[1].ts = store.tick_ts

	U.y_animation_play(this, "end", nil, store.tick_ts, 1, sid_totem)
	queue_remove(store, this)
end

scripts.aura_tower_necromancer_skill_rider = {}

function scripts.aura_tower_necromancer_skill_rider.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local sid_rider = 1
	local sid_fx = 2
	local target_pos = this.pos
	local fading = false
	local spawned_fx = false
	local path_ni = 1
	local path_spi = 1
	local path_pi = 1
	local available_paths = {}

	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end

	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, function(k, v)
			return not table.contains(store.level.ignore_walk_backwards_paths, v)
		end)
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, available_paths)

	if #nearest > 0 then
		path_pi, path_spi, path_ni = unpack(nearest[1])

		for _, n in pairs(nearest) do
			local _path_pi, _path_spi, _path_ni = unpack(n)

			if _path_pi == this.path_id then
				path_pi, path_spi, path_ni = _path_pi, _path_spi, _path_ni

				break
			end
		end
	end

	path_spi = 1
	path_ni = path_ni - 3

	local distance = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	local function hit_enemies()
		local targets = table.filter(store.entities, function(k, v)
			return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
		end)

		for i, target in ipairs(targets) do
			local already_hit_target = false
			local has_mod, mods = U.has_modifiers(store, target, this.aura.mod)

			if has_mod then
				for _, mod in pairs(mods) do
					if mod.modifier.source_id == this.id then
						already_hit_target = true

						break
					end
				end
			end

			if already_hit_target then
				-- block empty
			else
				this.damage_max = this.damage_max_config[this.aura.level]
				this.damage_min = this.damage_min_config[this.aura.level]

				if target and not target.health.dead and target.enemy then
					queue_damage(store, SU.create_attack_damage(this, target.id, this.id))

					local hit_fx = E:create_entity(this.hit_fx)

					hit_fx.pos = V.vclone(target.pos)
					hit_fx.pos.x, hit_fx.pos.y = hit_fx.pos.x + target.unit.hit_offset.x, hit_fx.pos.y + target.unit.hit_offset.y
					hit_fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, hit_fx)

					local new_mod = E:create_entity(this.aura.mod)

					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)
				end
			end
		end
	end

	path_ni = path_ni - 3
	target_pos = P:node_pos(path_pi, path_spi, path_ni)

	local flip_x = target_pos.x < this.pos.x

	U.animation_start(this, "spawn", flip_x, store.tick_ts, 1, sid_rider)
	U.y_wait(store, fts(10))
	hit_enemies()
	U.y_wait(store, fts(10))

	this.tween.props[1].disabled = true
	this.tween.props[1].ts = store.tick_ts

	local psA = E:create_entity(this.particles_name_A)

	psA.particle_system.track_id = this.id
	psA.particle_system.emit = true

	queue_insert(store, psA)

	local psB = E:create_entity(this.particles_name_B)

	psB.particle_system.track_id = this.id
	psB.particle_system.emit = true

	queue_insert(store, psB)

	local function rider_go_back_step()
		if V.veq(this.pos, target_pos) then
			this.motion.arrived = true

			return false
		else
			U.set_destination(this, target_pos)

			if U.walk(this, store.tick_length) then
				return false
			else
				local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

				U.animation_start(this, an, af, store.tick_ts, -1)

				return true
			end
		end
	end

	local function run_backwards()
		local last_pos = this.pos

		distance = V.dist2(target_pos.x, target_pos.y, this.pos.x, this.pos.y)

		if distance < 25 then
			path_ni = path_ni - 3
			target_pos = P:node_pos(path_pi, path_spi, path_ni)
		end

		rider_go_back_step()

		if not spawned_fx then
			local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)
			local hit_fx

			if an == "walk_side" then
				hit_fx = E:create_entity(this.spawn_side_fx)
			elseif an == "walk_front" then
				hit_fx = E:create_entity(this.spawn_front_fx)
			else
				hit_fx = E:create_entity(this.spawn_back_fx)
			end

			hit_fx.pos = V.vclone(this.pos)
			hit_fx.render.sprites[1].ts = store.tick_ts
			hit_fx.render.sprites[1].flip_x = af

			queue_insert(store, hit_fx)

			spawned_fx = true
		end

		local r = V.angleTo(target_pos.x - last_pos.x, target_pos.y - last_pos.y)

		psA.particle_system.emit_offset.x, psA.particle_system.emit_offset.y = V.rotate(r, psA.emit_offset_relative.x, psA.emit_offset_relative.y)
		psB.particle_system.emit_offset.x, psB.particle_system.emit_offset.y = V.rotate(r, psB.emit_offset_relative.x, psB.emit_offset_relative.y)
	end

	local function check_start_fade()
		if fading then
			return false
		end

		local fade_duration = this.tween.props[1].keys[2][1]
		local n_pos = P:node_pos(path_pi, path_spi, path_ni - 5)

		if band(GR:cell_type(n_pos.x, n_pos.y), bor(TERRAIN_CLIFF, TERRAIN_WATER)) ~= 0 then
			this.tween.props[1].keys[2][1] = 0.25

			return true
		end

		if this.aura.duration >= 0 and store.tick_ts - this.aura.ts + fade_duration > this.actual_duration then
			return true
		end

		local nearest = P:nearest_nodes(this.pos.x, this.pos.y, available_paths)

		if #nearest > 0 then
			path_pi, path_spi, path_ni = unpack(nearest[1])

			return path_ni < 10
		end

		return false
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration or fading and this.render.sprites[1].alpha <= 0 then
			break
		end

		if check_start_fade() then
			fading = true
			this.tween.props[1].disabled = false
			this.tween.reverse = true
			this.tween.props[1].ts = store.tick_ts
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_651_0
			end
		end

		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			if this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
				goto label_651_0
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts

			hit_enemies()
		end

		run_backwards()

		::label_651_0::

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.mod_tower_necromancer_skill_debuff = {}

function scripts.mod_tower_necromancer_skill_debuff.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]
	local source = store.entities[this.modifier.source_id]

	if target and not target.health.dead and target.enemy then
		target.enemy._prev_can_do_magic = target.enemy.can_do_magic
		target.enemy.can_do_magic = false

		return true
	end

	return false
end

function scripts.mod_tower_necromancer_skill_debuff.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos
	m.duration = m.duration_config[m.level]

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			break
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

function scripts.mod_tower_necromancer_skill_debuff.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if target and not target.health.dead then
		target.enemy.can_do_magic = target.enemy._prev_can_do_magic
	end

	return true
end

scripts.tower_ballista = {}

function scripts.tower_ballista.update(this, store)
	local last_ts = store.tick_ts - this.attacks.list[1].cooldown

	this.attacks.list[1].ts = store.tick_ts - this.attacks.list[1].cooldown + this.attacks.attack_delay_on_spawn

	local arrive_epsilon = 0.5
	local last_ts_idle = store.tick_ts
	local idle_cooldown = math.random(4, 8)
	local a_name, a_flip, angle_idx

	if not this.tower_upgrade_persistent_data.current_angle then
		this.tower_upgrade_persistent_data.current_angle = 235
	end

	local function find_target(attack)
		local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, this.attacks.range, attack.node_prediction, attack.vis_flags, attack.vis_bans)

		return target, pred_pos
	end

	local function animation_name_facing_angle_ballista(group, angle_deg)
		local a = this.render.sprites[this.render.sid_tower_top]
		local o_name, o_flip, o_idx
		local a1, a2, a3, a4, a5, a6, a7, a8 = 22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5
		local quadrant = a._last_quadrant
		local angles = a.angles[group]

		if a1 <= angle_deg and angle_deg < a2 then
			o_name, o_flip, o_idx = angles[3], true, 3
			quadrant = 1
		elseif a2 <= angle_deg and angle_deg < a3 then
			o_name, o_flip, o_idx = angles[4], false, 4
			quadrant = 2
		elseif a3 <= angle_deg and angle_deg < a4 then
			o_name, o_flip, o_idx = angles[3], false, 3
			quadrant = 3
		elseif a4 <= angle_deg and angle_deg < a5 then
			o_name, o_flip, o_idx = angles[2], false, 2
			quadrant = 4
		elseif a5 <= angle_deg and angle_deg < a6 then
			o_name, o_flip, o_idx = angles[1], false, 1
			quadrant = 5
		elseif a6 <= angle_deg and angle_deg < a7 then
			o_name, o_flip, o_idx = angles[5], false, 5
			quadrant = 6
		elseif a7 <= angle_deg and angle_deg < a8 then
			o_name, o_flip, o_idx = angles[1], true, 1
			quadrant = 7
		else
			o_name, o_flip, o_idx = angles[2], true, 2
			quadrant = 8
		end

		return o_name, o_flip, o_idx
	end

	local function animation_name_facing_point_ballista(group, point, offset)
		local fx, fy = this.pos.x, this.pos.y

		if offset then
			fx, fy = fx + offset.x, fy + offset.y
		end

		local vx, vy = V.sub(point.x, point.y, fx, fy)
		local v_angle = V.angleTo(vx, vy)
		local angle = km.unroll(v_angle)
		local angle_deg = angle * 180 / math.pi

		this.tower_upgrade_persistent_data.current_angle = angle_deg

		return animation_name_facing_angle_ballista(group, angle_deg)
	end

	local function rotate_towards_angle(target_angle_deg)
		local current_angle = this.tower_upgrade_persistent_data.current_angle
		local angle_dist = km.short_angle_deg(current_angle, target_angle_deg)

		current_angle = km.unroll_deg(current_angle + math.min(this.turn_speed, math.abs(angle_dist)) * km.sign(angle_dist))
		a_name, a_flip, angle_idx = animation_name_facing_angle_ballista("idle", current_angle)

		U.animation_start(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)

		this.tower_upgrade_persistent_data.current_angle = current_angle

		return km.short_angle_deg(current_angle, target_angle_deg)
	end

	local function rotate_towards_pos(pos)
		local vx, vy = V.sub(pos.x, pos.y, this.pos.x + this.tower_top_offset.x, this.pos.y + this.tower_top_offset.y)
		local v_angle = V.angleTo(vx, vy)
		local angle_to_target = km.unroll(v_angle)

		angle_to_target = angle_to_target * 180 / math.pi

		return rotate_towards_angle(angle_to_target)
	end

	local function shoot_bomb(attack, enemy, dest)
		local b = E:create_entity(attack.bullet)

		b.pos.x, b.pos.y = this.pos.x + attack.bullet_start_offset.x, this.pos.y + attack.bullet_start_offset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = dest
		b.bullet.level = this.powers.skill_bomb.level
		b.bullet.target_id = enemy and enemy.id
		b.bullet.source_id = this.id
		b.bullet.damage_min = attack.damage_min[this.powers.skill_bomb.level]
		b.bullet.damage_max = attack.damage_max[this.powers.skill_bomb.level]

		queue_insert(store, b)
	end

	local function check_skill_bomb()
		if not this.powers then
			return
		end

		local power = this.powers.skill_bomb
		local attack = this.attacks.list[2]

		if not power or power.level <= 0 or not attack or store.tick_ts - attack.ts < attack.cooldown or not this.tower.can_do_magic then
			return
		end

		local enemy, enemies, pred_pos = U.find_foremost_enemy(store.entities, this.pos, attack.min_range, attack.max_range, attack.node_prediction, attack.vis_flags, attack.vis_bans)

		if not enemy or not pred_pos or attack.min_targets and #enemies < attack.min_targets then
			return
		end

		local available_paths = {
			enemy.nav_path.pi
		}
		local nearest = P:nearest_nodes(pred_pos.x, pred_pos.y, available_paths)

		if #nearest > 0 then
			local path_pi, path_spi, path_ni = unpack(nearest[1])

			path_spi = 1
			pred_pos = P:node_pos(path_pi, path_spi, path_ni)
		end

		local start_ts = store.tick_ts

		U.animation_start(this, "ability1", nil, store.tick_ts, false, this.render.sid_goblin)

		while store.tick_ts - start_ts < attack.shoot_time do
			coroutine.yield()
		end

		shoot_bomb(attack, nil, pred_pos)

		attack.ts = start_ts
	end

	a_name, a_flip, angle_idx = animation_name_facing_angle_ballista("idle", this.tower_upgrade_persistent_data.current_angle)

	U.animation_start(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)

	local attack = this.attacks.list[1]
	local target, pred_pos = find_target(attack)

	::label_661_0::

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == this.powers.skill_final_shot then
							pow.damage_factor = pow.damage_factor_config[pow.level]
						elseif pow == this.powers.skill_bomb then
							this.attacks.list[2].cooldown = pow.cooldown[pow.level]
							this.attacks.list[2].ts = store.tick_ts - this.attacks.list[2].cooldown
						end
					end
				end
			end

			SU.towers_swaped(store, this, this.attacks.list)

			if idle_cooldown < store.tick_ts - last_ts_idle and (not target or not pred_pos) then
				local new_angle

				if this.tower_upgrade_persistent_data.current_angle > 270 then
					new_angle = math.random(180, 235)
				else
					new_angle = math.random(305, 360)
				end

				repeat
					local angle_dist
					local end_rotation = false

					angle_dist = rotate_towards_angle(new_angle)
					target, pred_pos = find_target(attack)
					end_rotation = arrive_epsilon >= math.abs(angle_dist) or target and pred_pos

					if not end_rotation then
						coroutine.yield()
					end
				until end_rotation

				last_ts_idle = store.tick_ts
				idle_cooldown = math.random(4, 8)
			end

			if target and pred_pos then
				local angle_dist = rotate_towards_pos(pred_pos)
			end

			if store.tick_ts - attack.ts > attack.cooldown then
				target, pred_pos = find_target(attack)

				if not target then
					SU.delay_attack(store, attack, fts(10))

					goto label_661_0
				end

				local a_name, a_flip, angle_idx
				local start_ts = store.tick_ts

				repeat
					local angle_dist
					local reached_target = false

					if target and pred_pos then
						angle_dist = rotate_towards_pos(pred_pos)
						target, pred_pos = find_target(attack)
						reached_target = arrive_epsilon >= math.abs(angle_dist) and target and pred_pos
					end

					if not target or not pred_pos then
						goto label_661_1
					end

					if not reached_target then
						coroutine.yield()
					end
				until reached_target

				local last_target_pos = V.vclone(pred_pos)
				local missed_shot = false
				local shoot_final_shot = false

				for i = 1, attack.burst_count do
					a_name, a_flip, angle_idx = animation_name_facing_point_ballista("idle", pred_pos, this.tower_top_offset)

					local b

					if this.powers and this.powers.skill_final_shot.level > 0 and i == attack.burst_count then
						shoot_final_shot = true
						a_name, a_flip, angle_idx = animation_name_facing_point_ballista("final_shot", pred_pos, this.tower_top_offset)

						U.animation_start(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)
						U.y_wait(store, fts(6))

						b = E:create_entity(this.powers.skill_final_shot.bullet)
					else
						b = E:create_entity(attack.bullet)
					end

					missed_shot = false
					target, pred_pos = find_target(this.attacks.list[1])

					if not target or not pred_pos then
						pred_pos = V.vclone(last_target_pos)

						local offset = {}

						offset.x, offset.y = math.random(5, 10), math.random(5, 10)

						local angle = math.random() * math.pi * 2

						offset.x, offset.y = V.rotate(angle, offset.x, offset.y)
						pred_pos.x, pred_pos.y = V.add(pred_pos.x, pred_pos.y, offset.x, offset.y)
						missed_shot = true
					else
						local dist = V.dist(last_target_pos.x, last_target_pos.y, pred_pos.x, pred_pos.y)
						local max_dist = attack.max_dist_between_shots

						if shoot_final_shot then
							max_dist = max_dist * 1.5
						end

						if max_dist < dist then
							local enemies = U.find_enemies_in_range(store.entities, last_target_pos, 0, max_dist, attack.vis_flags, attack.vis_bans)

							if not enemies or #enemies == 0 then
								local enemies = U.find_enemies_in_range(store.entities, tpos(this), 0, this.attacks.range, attack.vis_flags, attack.vis_bans)

								table.sort(enemies, function(e1, e2)
									return V.dist(e1.pos.x, e1.pos.y, pred_pos.x, pred_pos.y) < V.dist(e2.pos.x, e2.pos.y, pred_pos.x, pred_pos.y)
								end)

								local dir = {}

								dir.x, dir.y = V.sub(enemies[1].pos.x, enemies[1].pos.y, last_target_pos.x, last_target_pos.y)
								dir.x, dir.y = V.normalize(dir.x, dir.y)
								dir.x, dir.y = V.mul(max_dist, dir.x, dir.y)
								pred_pos.x, pred_pos.y = V.add(last_target_pos.x, last_target_pos.y, dir.x, dir.y)
								missed_shot = true
							else
								table.sort(enemies, function(e1, e2)
									return V.dist(e1.pos.x, e1.pos.y, last_target_pos.x, last_target_pos.y) < V.dist(e2.pos.x, e2.pos.y, last_target_pos.x, last_target_pos.y)
								end)

								pred_pos = V.vclone(enemies[1].pos)
								target = enemies[1]
							end
						end
					end

					last_target_pos = V.vclone(pred_pos)

					local start_offset = V.vclone(attack.bullet_start_offset[angle_idx])

					if not a_flip then
						start_offset.x = -start_offset.x
					end

					b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = V.vclone(pred_pos)

					if not missed_shot and target and not attack.ignore_hit_offset then
						b.bullet.to.x = b.bullet.to.x + target.unit.hit_offset.x
						b.bullet.to.y = b.bullet.to.y + target.unit.hit_offset.y
					end

					if not missed_shot and target then
						b.bullet.target_id = target.id
					end

					b.bullet.source_id = this.id
					-- b.bullet.level = this.tower.level
					b.bullet.damage_factor = this.tower.damage_factor * b.bullet.damage_factor

					if shoot_final_shot then
						b.bullet.damage_factor = b.bullet.damage_factor * this.powers.skill_final_shot.damage_factor
						b.bullet.level = this.powers.skill_final_shot.level

						local fx = E:create_entity(this.final_shot_fx)

						fx.pos = V.vclone(b.bullet.from)

						local s = fx.render.sprites[1]

						s.ts = store.tick_ts

						queue_insert(store, fx)
					end

					if missed_shot then
						b.missed_shot = true
					end

					queue_insert(store, b)

					local fx = E:create_entity(this.shot_fx)

					fx.pos = V.vclone(b.bullet.from)

					local s = fx.render.sprites[1]

					s.ts = store.tick_ts

					local angle = V.angleTo(b.bullet.to.x - fx.pos.x, b.bullet.to.y - fx.pos.y)

					s.r = angle

					if angle_idx == 3 or angle_idx == 4 then
						s.z = this.render.sprites[this.render.sid_tower_top].z
					else
						s.z = this.render.sprites[this.render.sid_tower_top].z + 1
					end

					queue_insert(store, fx)

					if i < 5 then
						U.animation_start_group(this, "ability" .. i, false, store.tick_ts, false, "layers_base")
					end

					if shoot_final_shot then
						U.y_animation_wait(this, this.render.sid_tower_top)
					else
						a_name, a_flip, angle_idx = animation_name_facing_point_ballista("shot", pred_pos, this.tower_top_offset)

						U.y_animation_play(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)
					end
				end

				shoot_final_shot = false
				attack.ts = store.tick_ts
				last_ts = start_ts

				U.y_wait(store, fts(15))

				if this.tower.level < 4 then
					U.animation_start(this, "ability1", false, store.tick_ts, true, this.render.sid_goblin)
				end

				U.y_animation_play_group(this, "ability5", false, store.tick_ts, false, "layers_base")

				if this.tower.level < 4 then
					U.animation_start(this, "idle_1_1", false, store.tick_ts, true, this.render.sid_goblin)
				end

				a_name, a_flip, angle_idx = animation_name_facing_angle_ballista("reload", this.tower_upgrade_persistent_data.current_angle)

				U.y_animation_play(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)
				U.y_wait(store, fts(4))

				last_ts_idle = store.tick_ts
				idle_cooldown = math.random(4, 8)
			end

			check_skill_bomb()

			::label_661_1::

			this.tower_upgrade_persistent_data.last_ts = last_ts

			coroutine.yield()
		end
	end
end

scripts.bullet_tower_ballista = {}

function scripts.bullet_tower_ballista.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local dest = V.vclone(b.to)

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle
		s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width
	end

	local function hit_target()
		if target then
			if b.mod then
				local mod = E:create_entity(b.mod)

				mod.modifier.target_id = target.id
				mod.modifier.source_id = source.id
				mod.modifier.duration = mod.stun_time[b.level]

				queue_insert(store, mod)
			end

			local d = SU.create_bullet_damage(b, target.id, this.id)

			queue_damage(store, d)

			local fx = E:create_entity(b.hit_fx)

			fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			if this.is_final_shot then
				local angle = V.angleTo(b.from.x - b.to.x, b.from.y - b.to.y)

				fx.render.sprites[1].r = angle
			end
		elseif this.missed_shot and GR:cell_is_only(this.pos.x, this.pos.y, TERRAIN_LAND) then
			local fx = E:create_entity(this.missed_arrow_decal)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local fx = E:create_entity(this.missed_arrow_dust)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local fx = E:create_entity(this.missed_arrow)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].flip_x = b.to.x > b.from.x

			queue_insert(store, fx)
		end
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	local already_hit_target = false

	if this.ray_duration then
		while store.tick_ts - s.ts < this.ray_duration do
			if this.track_target then
				update_sprite()
			end

			if source and not store.entities[source.id] then
				queue_remove(store, this)

				break
			end

			if not already_hit_target and store.tick_ts - s.ts > this.hit_delay then
				hit_target()

				already_hit_target = true
			end

			coroutine.yield()

			s.hidden = false
		end
	else
		while not U.animation_finished(this, 1) do
			if source and not store.entities[source.id] then
				queue_remove(store, this)

				break
			end

			if not already_hit_target and store.tick_ts - s.ts > this.hit_delay then
				hit_target(b, target)

				already_hit_target = true
			end

			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.bullet_tower_ballista_skill_bomb = {}

function scripts.bullet_tower_ballista_skill_bomb.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius
	local ps

	if b.particles_name then
		if #b.particles_name > 1 then
			for _, pn in ipairs(b.particles_name) do
				ps = E:create_entity(pn)
				ps.particle_system.track_id = this.id

				queue_insert(store, ps)
			end
		else
			ps = E:create_entity(b.particles_name)
			ps.particle_system.track_id = this.id

			queue_insert(store, ps)
		end
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	local enemies = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, b.damage_bans) == 0 and band(v.vis.bans, b.damage_flags) == 0 and U.is_inside_ellipse(v.pos, b.to, dradius)
	end)

	for _, enemy in pairs(enemies) do
		local d = E:create_entity("damage")

		d.damage_type = b.damage_type
		d.reduce_armor = b.reduce_armor
		d.reduce_magic_armor = b.reduce_magic_armor

		if b.damage_decay_random then
			d.value = U.frandom(dmin, dmax)
		else
			local upg = UP:get_upgrade("towers_improved_formulas")

			if upg then
				d.value = dmax
			else
				local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, b.to, dradius)

				d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
			end
		end

		d.value = math.ceil(b.damage_factor * d.value)
		d.source_id = this.id
		d.target_id = enemy.id

		queue_damage(store, d)
		log.paranoid("bomb id:%s, radius:%s, enemy id:%s, dist:%s, damage:%s damage_type:%x", this.id, dradius, enemy.id, V.dist(enemy.pos.x, enemy.pos.y, b.to.x, b.to.y), d.value, d.damage_type)
	end

	local p = SU.create_bullet_pop(store, this)

	queue_insert(store, p)

	local cell_type = GR:cell_type(b.to.x, b.to.y)

	if b.hit_fx then
		S:queue(this.sound_events.hit)

		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, sfx)
	end

	if b.hit_decal and band(cell_type, TERRAIN_WATER) == 0 then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	queue_remove(store, this)
end

function scripts.bullet_tower_ballista_skill_bomb.remove(this, store)
	local b = this.bullet
	local angle_aux = 2 * math.pi / 3

	for i = 1, 3 do
		pos = U.point_on_ellipse(b.to, 30, angle_aux * (i - 1))

		local scraps = E:create_entity(this.scraps)

		scraps.pos = V.vclone(pos)
		scraps.aura.duration = this.duration_config[b.level]
		scraps.tween.props[1].keys = {
			{
				0,
				255
			},
			{
				scraps.aura.duration - 0.5,
				255
			},
			{
				scraps.aura.duration,
				0
			}
		}

		queue_insert(store, scraps)
	end

	return true
end

scripts.aura_bullet_tower_ballista_skill_bomb = {}

function scripts.aura_bullet_tower_ballista_skill_bomb.update(this, store)
	local first_hit_ts
	local last_hit_ts = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time
	this.tween.ts = store.tick_ts

	U.animation_start(this, "in", false, store.tick_ts, false, 1)

	while true do
		if U.animation_finished(this, 1) and this.render.sprites[1].name ~= "idle" then
			U.animation_start(this, "idle", false, store.tick_ts, true, 1)
		end

		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name))
			end)

			if #targets > 0 and this.render.sprites[1].name == "idle" then
				local moving_targets = table.filter(targets, function(k, v)
					return v.motion.speed.x > 0 or v.motion.speed.y > 0
				end)

				if #moving_targets > 0 then
					U.animation_start(this, "ability1", false, store.tick_ts, false, 1)

					local junk_fx = E:create_entity(this.junk_fx)

					junk_fx.pos = V.vclone(this.pos)
					junk_fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, junk_fx)
				end
			end

			for i, target in ipairs(targets) do
				local new_mod = E:create_entity(this.aura.mod)

				new_mod.modifier.level = this.aura.level
				new_mod.modifier.target_id = target.id
				new_mod.modifier.source_id = this.id

				queue_insert(store, new_mod)
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.tower_flamespitter = {}

function scripts.tower_flamespitter.get_info(this)
	local a = E:get_template(this.attacks.list[1].aura)
	local o = scripts.tower_common.get_info(this)

	o.type = STATS_TYPE_TOWER

	local min = math.ceil(a.damage_min_config[this.tower.level] * this.tower.damage_factor)
	local max = math.ceil(a.damage_max_config[this.tower.level] * this.tower.damage_factor)
	local ticks_count = math.ceil(a.aura.duration / a.aura.cycle_time)

	min = min * ticks_count
	max = max * ticks_count
	o.damage_min = min
	o.damage_max = max

	return o
end

function scripts.tower_flamespitter.update(this, store)
	local attack_basic, attack_bomb, attack_columns = this.attacks.list[1], this.attacks.list[2], this.attacks.list[3]
	local last_ts = store.tick_ts - attack_basic.cooldown

	attack_basic.ts = store.tick_ts - attack_basic.cooldown + this.attacks.attack_delay_on_spawn

	local attack_bomb_ts = store.tick_ts
	local attack_columns_ts = store.tick_ts
	local last_ts_idle = store.tick_ts
	local arrive_epsilon = 0.5
	local idle_cooldown = math.random(4, 8)
	local a_name, a_flip, angle_idx

	if not this.tower_upgrade_persistent_data.current_angle then
		this.tower_upgrade_persistent_data.current_angle = 235
	end

	local function find_target(attack)
		local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, this.attacks.range, attack.node_prediction, attack.vis_flags, attack.vis_bans)

		return target, pred_pos
	end

	local function animation_name_facing_angle_flamespitter(group, angle_deg)
		local a = this.render.sprites[this.render.sid_tower_top]
		local o_name, o_flip, o_idx
		local a1, a2, a3, a4, a5, a6, a7, a8 = 22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5
		local quadrant = a._last_quadrant
		local angles = a.angles[group]

		if a1 <= angle_deg and angle_deg < a2 then
			o_name, o_flip, o_idx = angles[3], true, 3
			quadrant = 1
		elseif a2 <= angle_deg and angle_deg < a3 then
			o_name, o_flip, o_idx = angles[4], false, 4
			quadrant = 2
		elseif a3 <= angle_deg and angle_deg < a4 then
			o_name, o_flip, o_idx = angles[3], false, 3
			quadrant = 3
		elseif a4 <= angle_deg and angle_deg < a5 then
			o_name, o_flip, o_idx = angles[2], false, 2
			quadrant = 4
		elseif a5 <= angle_deg and angle_deg < a6 then
			o_name, o_flip, o_idx = angles[1], false, 1
			quadrant = 5
		elseif a6 <= angle_deg and angle_deg < a7 then
			o_name, o_flip, o_idx = angles[5], false, 5
			quadrant = 6
		elseif a7 <= angle_deg and angle_deg < a8 then
			o_name, o_flip, o_idx = angles[1], true, 1
			quadrant = 7
		else
			o_name, o_flip, o_idx = angles[2], true, 2
			quadrant = 8
		end

		return o_name, o_flip, o_idx
	end

	local function animation_name_facing_point_flamespitter(group, point, offset)
		local fx, fy = this.pos.x, this.pos.y

		if offset then
			fx, fy = fx + offset.x, fy + offset.y
		end

		local vx, vy = V.sub(point.x, point.y, fx, fy)
		local v_angle = V.angleTo(vx, vy)
		local angle = km.unroll(v_angle)
		local angle_deg = km.rad2deg(angle)

		this.tower_upgrade_persistent_data.current_angle = angle_deg

		return animation_name_facing_angle_flamespitter(group, angle_deg)
	end

	local function rotate_towards_angle(target_angle_deg)
		local current_angle = this.tower_upgrade_persistent_data.current_angle
		local angle_dist = km.short_angle_deg(current_angle, target_angle_deg)

		current_angle = km.unroll_deg(current_angle + math.min(this.turn_speed, math.abs(angle_dist)) * km.sign(angle_dist))
		a_name, a_flip, angle_idx = animation_name_facing_angle_flamespitter("idle", current_angle)

		U.animation_start(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)

		this.tower_upgrade_persistent_data.current_angle = current_angle

		return km.short_angle_deg(current_angle, target_angle_deg)
	end

	local function rotate_towards_pos(pos)
		local vx, vy = V.sub(pos.x, pos.y, this.pos.x + this.tower_top_offset.x, this.pos.y + this.tower_top_offset.y)
		local v_angle = V.angleTo(vx, vy)
		local angle_to_target = km.unroll(v_angle)

		angle_to_target = km.rad2deg(angle_to_target)

		return rotate_towards_angle(angle_to_target)
	end

	local function shoot_bomb(enemy, dest)
		local b = E:create_entity(attack_bomb.bullet)

		b.pos.x, b.pos.y = this.pos.x + attack_bomb.bullet_start_offset.x, this.pos.y + attack_bomb.bullet_start_offset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = dest
		b.bullet.level = this.powers.skill_bomb.level
		b.bullet.target_id = enemy and enemy.id
		b.bullet.source_id = this.id
		b.bullet.damage_min = attack_bomb.damage_min[this.powers.skill_bomb.level]
		b.bullet.damage_max = attack_bomb.damage_max[this.powers.skill_bomb.level]

		queue_insert(store, b)
	end

	local function spawn_column(origin, dest)
		local power = this.powers.skill_columns
		local column = E:create_entity(power.column_template)

		column.origin = V.vclone(origin)
		column.dest = V.vclone(dest)
		column.source_id = this.id
		column.damage_in_min = power.damage_in_min[power.level]
		column.damage_in_max = power.damage_in_max[power.level]
		column.damage_out_min = power.damage_out_min[power.level]
		column.damage_out_max = power.damage_out_max[power.level]

		queue_insert(store, column)
	end

	local function check_skill_bomb()
		if not this.powers or not this.tower.can_do_magic then
			return
		end

		local power = this.powers.skill_bomb
		local a = attack_bomb

		if not power or power.level <= 0 or not a or store.tick_ts - a.ts < power.cooldown[power.level] then
			return
		end

		local enemy, enemies, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)

		if not enemy or not pred_pos or a.min_targets and #enemies < a.min_targets then
			return
		end

		local available_paths = {
			enemy.nav_path.pi
		}
		local nearest = P:nearest_nodes(pred_pos.x, pred_pos.y, available_paths)

		if #nearest > 0 then
			local path_pi, path_spi, path_ni = unpack(nearest[1])

			path_spi = 1
			pred_pos = P:node_pos(path_pi, path_spi, path_ni)
		end

		local start_ts = store.tick_ts

		U.animation_start(this, "blazing_trail", nil, store.tick_ts, false, this.render.sid_dwarf)
		U.animation_start(this, "blazing_trail", nil, store.tick_ts, false, this.render.sid_skill_2)
		U.y_wait(store, fts(16))

		this.render.sprites[this.render.sid_stove_fire].hidden = false

		U.animation_start(this, "blazing_trail", nil, store.tick_ts, false, this.render.sid_stove_fire)
		U.y_wait(store, fts(34))
		S:queue(a.sound)
		shoot_bomb(nil, pred_pos)

		a.ts = start_ts
	end

	local function check_skill_columns()
		if not this.powers or not this.tower.can_do_magic then
			return
		end

		local power = this.powers.skill_columns
		local a = attack_columns

		if not power or power.level <= 0 or store.tick_ts - a.ts < power.cooldown[power.level] then
			return
		end

		local enemy, enemies, pred_pos = U.find_foremost_enemy(store.entities, this.pos, a.min_range, a.max_range, a.node_prediction, a.vis_flags, a.vis_bans)

		if not enemy or not pred_pos or a.min_targets and #enemies < a.min_targets then
			return
		end

		local mod = E:get_template("mod_tower_flamesplitter_skill_columns")
		mod.modifier.duration = mod.duration_config[power.level]

		local start_ts = store.tick_ts
		local path = enemy.nav_path.pi
		local nearest = P:nearest_nodes(pred_pos.x, pred_pos.y, {
			path
		}, {
			1,
			2,
			3
		}, true)

		if #nearest == 0 then
			return
		end

		local positions = {}
		local pi, spi, ni = unpack(nearest[1])
		local nodes_between_columns = 6
		local last_spi = enemy.nav_path.spi

		positions[1] = P:node_pos(pi, spi, ni)

		for i = 2, power.columns[power.level] do
			local ni_aux = ni - (i - 1) * nodes_between_columns

			if P:is_node_valid(pi, ni_aux) then
				local spi = math.random(1, 3)

				if spi == last_spi then
					spi = spi + 1

					if spi > 3 then
						spi = 1
					end
				end

				last_spi = spi
				positions[i] = P:node_pos(pi, spi, ni_aux)
			end
		end

		U.animation_start(this, "scorching_torches", nil, store.tick_ts, false, this.render.sid_dwarf)
		U.animation_start(this, "scorching_torches", nil, store.tick_ts, false, this.render.sid_skill_1)

		this.render.sprites[this.render.sid_stove_fire].hidden = false

		U.animation_start(this, "scorching_torches", nil, store.tick_ts, false, this.render.sid_stove_fire)
		U.y_wait(store, fts(16))
		S:queue(a.sound)

		local origin = V.vclone(this.pos)

		origin.x = origin.x + power.decal_start_offset.x
		origin.y = origin.y + power.decal_start_offset.y

		for i = 1, #positions do
			spawn_column(origin, positions[i])
			U.y_wait(store, fts(8))
		end

		U.y_animation_wait(this, this.render.sid_dwarf)

		a.ts = start_ts
	end

	a_name, a_flip, angle_idx = animation_name_facing_angle_flamespitter("idle", this.tower_upgrade_persistent_data.current_angle)

	U.animation_start(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)

	local target, pred_pos = find_target(attack_basic)

	::label_681_0::

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.tower.level == 4 and not this.render.sprites[this.render.sid_stove_fire].hidden and U.animation_finished(this, this.render.sid_stove_fire) then
				this.render.sprites[this.render.sid_stove_fire].hidden = true
			end

			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						local a = this.attacks.list[pow.attack_idx]

						a.cooldown = pow.cooldown[pow.level]
						a.ts = store.tick_ts - a.cooldown
					end
				end
			end

			SU.towers_swaped(store, this, this.attacks.list)

			if idle_cooldown < store.tick_ts - last_ts_idle and (not target or not pred_pos) then
				local new_angle

				if this.tower_upgrade_persistent_data.current_angle > 270 then
					new_angle = math.random(180, 235)
				else
					new_angle = math.random(305, 360)
				end

				repeat
					local angle_dist
					local end_rotation = false

					angle_dist = rotate_towards_angle(new_angle)
					target, pred_pos = find_target(attack_basic)
					end_rotation = arrive_epsilon >= math.abs(angle_dist) or target and pred_pos

					if not end_rotation then
						coroutine.yield()
					end
				until end_rotation

				last_ts_idle = store.tick_ts
				idle_cooldown = math.random(4, 8)
			end

			if target and pred_pos then
				local angle_dist = rotate_towards_pos(pred_pos)
			end

			if store.tick_ts - attack_basic.ts > attack_basic.cooldown then
				target, pred_pos = find_target(attack_basic)

				if not target then
					SU.delay_attack(store, attack_basic, fts(10))

					goto label_681_0
				end

				local a_name, a_flip, angle_idx
				local start_ts = store.tick_ts

				repeat
					local angle_dist
					local reached_target = false

					if target and pred_pos then
						angle_dist = rotate_towards_pos(pred_pos)
						target, pred_pos = find_target(attack_basic)
						reached_target = arrive_epsilon >= math.abs(angle_dist) and target and pred_pos
					end

					if not target or not pred_pos then
						goto label_681_1
					end

					if not reached_target then
						coroutine.yield()
					end
				until reached_target

				attack_basic.ts = store.tick_ts
				last_ts = start_ts

				local nearest = P:nearest_nodes(pred_pos.x, pred_pos.y)
				local pi, spi, ni = unpack(nearest[1])
				local aura_pos = P:node_pos(pi, 1, ni)

				U.animation_start(this, "attack", a_flip, store.tick_ts, false, this.render.sid_dwarf)
				U.y_wait(store, fts(14))

				a_name, a_flip, angle_idx = animation_name_facing_point_flamespitter("attack", pred_pos, this.tower_top_offset)

				U.animation_start(this, a_name, a_flip, store.tick_ts, false, this.render.sid_tower_top)
				S:queue(attack_basic.sound, {
					delay = fts(9)
				})
				U.y_wait(store, fts(21))

				a_name, a_flip, angle_idx = animation_name_facing_point_flamespitter("idle", pred_pos, this.tower_top_offset)

				local offset = V.vclone(attack_basic.bullet_start_offset[angle_idx])

				if not a_flip then
					offset.x = -offset.x
				end

				this.flame_fx = E:create_entity(attack_basic.flame_fx)
				this.flame_fx.render.sprites[1].ts = store.tick_ts
				this.flame_fx.pos.x = this.pos.x + offset.x
				this.flame_fx.pos.y = this.pos.y + offset.y
				this.flame_fx.render.sprites[1].r = V.angleTo(this.pos.x + this.tower_top_offset.x - pred_pos.x, this.pos.y + this.tower_top_offset.y - pred_pos.y)
				this.flame_fx.render.sprites[1].scale = v(1, 1)
				this.flame_fx.render.sprites[1].scale.x = attack_basic.flame_fx_scale_x[angle_idx]

				queue_insert(store, this.flame_fx)
				U.y_animation_play(this.flame_fx, "in", false, store.tick_ts)

				local flame_id = this.flame_fx.id

				U.animation_start(this.flame_fx, "loop", false, store.tick_ts, true)

				local aura_delay = 0

				U.y_wait(store, aura_delay)

				local aura_offset = V.vclone(attack_basic.aura_offset[angle_idx])

				if not a_flip then
					aura_offset.x = -aura_offset.x
				end

				local aura = E:create_entity(attack_basic.aura)

				aura.pos = V.vclone(aura_pos)
				aura.aura.source_id = this.id
				aura.aura.ts = store.tick_ts
				aura.aura.level = this.tower.level
				aura.aura.damage_min = math.ceil(aura.damage_min_config[this.tower.level] * this.tower.damage_factor)
				aura.aura.damage_max = math.ceil(aura.damage_max_config[this.tower.level] * this.tower.damage_factor)

				queue_insert(store, aura)
				U.y_wait(store, attack_basic.duration - aura_delay)
				U.y_animation_play(this.flame_fx, "out", false, store.tick_ts)
				queue_remove(store, this.flame_fx)

				last_ts_idle = store.tick_ts
				idle_cooldown = math.random(4, 8)
			end

			check_skill_bomb()
			check_skill_columns()

			::label_681_1::

			this.tower_upgrade_persistent_data.last_ts = last_ts

			coroutine.yield()
		end
	end
end

function scripts.tower_flamespitter.remove(this, store)
	if this.flame_fx then
		this.flame_fx.render.sprites[1].hidden = true

		queue_remove(store, this.flame_fx)
	end

	return true
end

scripts.aura_tower_flamespitter = {}

function scripts.aura_tower_flamespitter.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_692_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local tower = store.entities[this.aura.source_id]

			if not tower then
				goto label_692_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				local new_mod = E:create_entity(this.aura.mod)

				new_mod.modifier.level = this.aura.level
				new_mod.modifier.target_id = target.id
				new_mod.modifier.source_id = this.id
				new_mod.dps.damage_min = new_mod.damage[this.aura.level]
				new_mod.dps.damage_max = new_mod.damage[this.aura.level]
				new_mod.dps.damage_inc = 0

				if this.aura.hide_source_fx and target.id == this.aura.source_id then
					new_mod.render = nil
				end

				queue_insert(store, new_mod)

				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id

				local dmin, dmax = this.aura.damage_min, this.aura.damage_max

				d.value = math.random(dmin, dmax)

				local tower = store.entities[this.aura.source_id]

				d.damage_type = this.aura.damage_type
				d.track_damage = this.aura.track_damage
				d.xp_dest_id = this.aura.xp_dest_id
				d.xp_gain_factor = this.aura.xp_gain_factor

				queue_damage(store, d)
			end
		end

		::label_692_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.bullet_tower_flamespitter_skill_bomb_payload = {}

function scripts.bullet_tower_flamespitter_skill_bomb_payload.update(this, store, script)
	local function spawn_burn_fx(pi, spi, ni, burn_fx_id)
		local pos = P:node_pos(pi, spi, ni)
		local s = E:create_entity(this.burn_fx)

		s.pos = V.vclone(pos)
		s.render.sprites[1].ts = store.tick_ts

		queue_insert(store, s)

		local enemies = U.find_enemies_in_range(store.entities, pos, 0, this.burn_radius, this.vis_flags, this.vis_bans)

		if enemies and #enemies > 0 then
			for i = 1, #enemies do
				local mod = E:create_entity(this.mod_burn)

				mod.modifier.target_id = enemies[i].id

				queue_insert(store, mod)
			end
		end
	end

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y)

	if #nearest > 0 then
		local pi, spi, ni = unpack(nearest[1])
		local initial_offset = 3
		local ni1 = ni - initial_offset
		local ni2 = ni + initial_offset
		local steps = 3
		local ni_aux
		local nodes_between_flames = 4

		for i = 1, steps do
			ni_aux = ni1 - i * (nodes_between_flames + 1)

			if P:is_node_valid(pi, ni_aux) then
				spawn_burn_fx(pi, 1, ni_aux)
			end

			ni_aux = ni1 - i * nodes_between_flames

			if P:is_node_valid(pi, ni_aux) then
				spawn_burn_fx(pi, 2, ni_aux)
				spawn_burn_fx(pi, 3, ni_aux)
			end

			ni_aux = ni2 + i * (nodes_between_flames + 1)

			if P:is_node_valid(pi, ni_aux) then
				spawn_burn_fx(pi, 1, ni_aux)
			end

			ni_aux = ni2 + i * nodes_between_flames

			if P:is_node_valid(pi, ni_aux) then
				spawn_burn_fx(pi, 2, ni_aux)
				spawn_burn_fx(pi, 3, ni_aux)
			end

			U.y_wait(store, fts(3))
		end
	end

	queue_remove(store, this)
end

scripts.controller_tower_flamespitter_column = {}

function scripts.controller_tower_flamespitter_column.update(this, store, script)
	local count_decals = 6
	local dist_v = V.vv(0)

	dist_v.x, dist_v.y = V.sub(this.dest.x, this.dest.y, this.origin.x, this.origin.y)

	for i = 1, count_decals do
		local dist_v_trunc = V.vv(0)

		dist_v_trunc.x, dist_v_trunc.y = V.mul(i / count_decals, dist_v.x, dist_v.y)

		local pos = V.vv(0)

		pos.x, pos.y = V.add(this.origin.x, this.origin.y, dist_v_trunc.x, dist_v_trunc.y)

		local decal = E:create_entity(this.decal)

		decal.pos.x, decal.pos.y = pos.x, pos.y
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
		U.y_wait(store, fts(2))
	end

	local fx = E:create_entity(this.column_fx)

	fx.pos.x, fx.pos.y = this.dest.x, this.dest.y
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)
	U.y_wait(store, fts(12))
	S:queue(this.sound)

	local enemies = U.find_enemies_in_range(store.entities, this.dest, 0, this.radius_in, this.vis_flags, this.vis_bans)

	if enemies and #enemies > 0 then
		for _, enemy in pairs(enemies) do
			local d = E:create_entity("damage")

			d.damage_type = this.damage_in_type
			d.value = math.random(this.damage_in_min, this.damage_in_max)
			d.source_id = this.source_id
			d.target_id = enemy.id

			queue_damage(store, d)

			local mod = E:create_entity(this.mod)

			mod.modifier.target_id = enemy.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)
		end
	end

	local enemies = U.find_enemies_in_range(store.entities, this.dest, this.radius_in, this.radius_out, this.vis_flags, this.vis_bans)

	if enemies and #enemies > 0 then
		for _, enemy in pairs(enemies) do
			local d = E:create_entity("damage")

			d.damage_type = this.damage_out_type
			d.value = math.random(this.damage_out_min, this.damage_out_max)
			d.source_id = this.source_id
			d.target_id = enemy.id

			queue_damage(store, d)
		end
	end

	U.y_animation_wait(fx)

	fx.render.sprites[1].hidden = true

	queue_remove(store, this)
end

scripts.tower_barrel = {}

function scripts.tower_barrel.insert(this, store, script)
	if this.barrack and not this.barrack.rally_pos and this.tower.default_rally_pos then
		this.barrack.rally_pos = V.vclone(this.tower.default_rally_pos)
	end

	return true
end

function scripts.tower_barrel.update(this, store, script)
	local a = this.attacks
	local ba = a.list[1]

	ba.ts = store.tick_ts - ba.cooldown + a.attack_delay_on_spawn

	local bba = a.list[2]
	local wa = a.list[3]
	local idle_flip_cd = math.random(4, 8)
	local idle_flip_last_ts = store.tick_ts
	local b = this.barrack
	local spawn_controller

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if idle_flip_cd < store.tick_ts - idle_flip_last_ts then
				U.animation_start(this, "idle", not this.render.sprites[this.sid_viking].flip_x, store.tick_ts, true, this.sid_viking)

				idle_flip_last_ts = store.tick_ts
				idle_flip_cd = math.random(4, 8)
			end

			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow.attack_idx then
							local attack = this.attacks.list[pow.attack_idx]

							attack.cooldown = pow.cooldown[pow.level]
							attack.ts = store.tick_ts - attack.cooldown
							attack.disabled = false
						end
					end
				end
			end

			if this.tower_upgrade_persistent_data.swaped then
				this.tower_upgrade_persistent_data = E:clone_c("tower_upgrade_persistent_data")
			end

			SU.towers_swaped(store, this, this.attacks.list)

			if bba and not bba.disabled and store.tick_ts - bba.ts > bba.cooldown and this.tower.can_do_magic then
				local targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.range, bba.vis_flags, bba.vis_bans)

				if not targets or #targets < bba.min_targets then
					SU.delay_attack(store, bba, fts(10))
				else
					local pred_pos = P:predict_enemy_pos(targets[1], bba.shoot_time + fts(25))

					bba.ts = store.tick_ts

					local flip_x = pred_pos.x > this.pos.x

					U.animation_start(this, bba.animation, flip_x, store.tick_ts, false, this.sid_viking)
					U.y_wait(store, bba.shoot_time)

					local trigger_pos = pred_pos
					local enemy = targets[1]
					local enemies

					enemy, enemies, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, bba.node_prediction, bba.vis_flags, bba.vis_bans)

					local offset_x = bba.bullet_start_offset.x

					if flip_x then
						offset_x = offset_x * -1
					end

					offset_x = offset_x + this.render.sprites[this.sid_viking].offset.x

					local b = E:create_entity(bba.bullet)

					b.bullet.damage_factor = this.tower.damage_factor
					b.pos.x, b.pos.y = this.pos.x + offset_x, this.pos.y + bba.bullet_start_offset.y
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = enemy and pred_pos or trigger_pos

					local nearest = P:nearest_nodes(b.bullet.to.x, b.bullet.to.y)
					local pi, spi, ni = unpack(nearest[1])

					b.bullet.to = P:node_pos(pi, 1, ni)
					b.bullet.source_id = this.id
					b.bullet.level = this.powers.skill_barrel.level
					b.render.sprites[1].r = 0

					queue_insert(store, b)
					S:queue(bba.sound)
					U.y_animation_wait(this, this.sid_viking)
					U.animation_start(this, "idle", nil, store.tick_ts, true, this.sid_viking)

					idle_flip_last_ts = store.tick_ts

					goto label_698_0
				end
			end

			if wa and not wa.disabled and store.tick_ts - wa.ts > wa.cooldown and not this.tower.blocked then
				for i = 1, b.max_soldiers do
					local s = b.soldiers[i]

					if not s or s.health.dead and not store.entities[s.id] then
						S:queue(this.powers.skill_warrior.sound_evict)
						S:queue(this.powers.skill_warrior.sound_drink)
						U.animation_start(this, wa.animation, false, store.tick_ts, false, this.sid_tower)
						U.y_wait(store, wa.drunk_man_spawn_delay)

						s = E:create_entity(b.soldier_type)
						s.soldier.tower_id = this.id
						s.soldier.tower_soldier_idx = i
						s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
						s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers)
						s.dest_pos = s.nav_rally.center
						s.source_id = this.id
						s.nav_rally.new = true
						b.soldiers[i] = s

						signal.emit("tower-spawn", this, s)

						local spawn_fx = E:create_entity(this.powers.skill_warrior.spawn_fx)

						spawn_fx.render.sprites[1].ts = store.tick_ts
						spawn_fx.pos = V.vclone(this.pos)
						spawn_fx.soldier_ref = s
						spawn_fx.tower_ref = this

						queue_insert(store, spawn_fx)
						U.y_animation_wait(this, this.sid_tower)
						U.animation_start(this, "idle", false, store.tick_ts, false, this.sid_tower)

						goto label_698_0
					end
				end
			end

			if store.tick_ts - ba.ts > ba.cooldown then
				local enemy, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, ba.node_prediction, ba.vis_flags, ba.vis_bans)

				if not enemy or not pred_pos then
					SU.delay_attack(store, ba, fts(10))
				else
					ba.ts = store.tick_ts

					local flip_x = pred_pos.x > this.pos.x

					U.animation_start(this, ba.animation, flip_x, store.tick_ts, false, this.sid_viking)
					U.y_wait(store, ba.shoot_time)

					local trigger_pos = pred_pos

					enemy, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, ba.node_prediction, ba.vis_flags, ba.vis_bans)

					local offset_x = ba.bullet_start_offset.x

					if flip_x then
						offset_x = offset_x * -1
					end

					offset_x = offset_x + this.render.sprites[this.sid_viking].offset.x

					local b = E:create_entity(ba.bullet)

					b.bullet.damage_factor = this.tower.damage_factor
					b.pos.x, b.pos.y = this.pos.x + offset_x, this.pos.y + ba.bullet_start_offset.y
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = enemy and pred_pos or trigger_pos
					b.bullet.source_id = this.id

					queue_insert(store, b)
					S:queue(ba.sound)
					U.y_animation_wait(this, this.sid_viking)
					U.animation_start(this, "idle", nil, store.tick_ts, true, this.sid_viking)

					idle_flip_last_ts = store.tick_ts
				end
			end
		end

		::label_698_0::

		if b and b.rally_new then
			b.rally_new = false

			signal.emit("rally-point-changed", this)

			local all_dead = true

			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers, b.rally_angle_offset)
				s.nav_rally.new = true
				all_dead = all_dead and s.health.dead
			end

			if not all_dead then
				S:queue(this.sound_events.change_rally_point)
			end
		end

		coroutine.yield()
	end
end

scripts.mod_bullet_tower_barrel = {}

function scripts.mod_bullet_tower_barrel.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]
	local template_name = this.template_name

	if not target or target.health.dead or not target.unit then
		return false
	end

	target.unit.damage_factor = target.unit.damage_factor * (1 - this.damage_reduction)
	if this.speed_factor and target.motion then
		target.motion.max_speed = target.motion.max_speed * this.speed_factor
	end

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts

			if s.size_names then
				s.prefix = s.size_names[target.unit.size]
			end

			if s.size_scales then
				s.scale = s.size_scales[target.unit.size]
			end
		end
	end

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_bullet_tower_barrel.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if target and target.health and target.unit then
		target.unit.damage_factor = target.unit.damage_factor / (1 - this.damage_reduction)
		if this.speed_factor and target.motion then
			target.motion.max_speed = target.motion.max_speed / this.speed_factor
		end
	end

	return true
end

scripts.aura_bullet_tower_barrel_skill_barrel = {}

function scripts.aura_bullet_tower_barrel_skill_barrel.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.render.sprites[this.sid_barrel].name == "start" and U.animation_finished(this, this.sid_barrel) then
			U.animation_start(this, "loop", nil, store.tick_ts, true, this.sid_barrel)
		end

		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.aura.radius, this.aura.vis_flags, this.aura.vis_bans)

			if targets then
				for i, target in ipairs(targets) do
					local mods = this.aura.mods or {
						this.aura.mod
					}

					for _, mod_name in pairs(mods) do
						local new_mod = E:create_entity(mod_name)

						new_mod.modifier.level = this.aura.level
						new_mod.modifier.target_id = target.id
						new_mod.modifier.source_id = this.id

						if this.aura.hide_source_fx and target.id == this.aura.source_id then
							new_mod.render = nil
						end

						queue_insert(store, new_mod)

						victims_count = victims_count + 1
					end
				end
			end
		end

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)

	local decal = E:create_entity(this.explosion_decal)

	decal.render.sprites[1].ts = store.tick_ts
	decal.tween.ts = store.tick_ts

	queue_insert(store, decal)

	local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.explosion_damage_radius, this.explosion_vis_flags, this.explosion_vis_bans)

	if targets then
		for i, target in pairs(targets) do
			local d = E:create_entity("damage")

			d.damage_type = this.explosion_damage_type

			local dmin, dmax = this.explosion_damage_min[this.aura.level], this.explosion_damage_max[this.aura.level]
			local upg = UP:get_upgrade("towers_improved_formulas")

			if upg then
				d.value = dmax
			else
				local dist_factor = U.dist_factor_inside_ellipse(target.pos, this.pos, this.explosion_damage_radius)

				d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
			end

			d.value = math.ceil(d.value)
			d.source_id = this.id
			d.target_id = target.id

			queue_damage(store, d)
		end
	end

	this.tween.ts = store.tick_ts
	this.tween.disabled = false

	S:queue(this.explosion_sfx)
	U.y_animation_play(this, "explosion", nil, store.tick_ts, 1, this.sid_barrel)
	queue_remove(store, this)
end

scripts.controller_soldier_tower_barrel_skill_warrior_spawn = {}

function scripts.controller_soldier_tower_barrel_skill_warrior_spawn.update(this, store, script)
	U.animation_start(this, "idle", false, store.tick_ts, false, this.sid_drunk_man)
	U.y_wait(store, this.berzerker_spawn_delay)

	local warrior_pos = v(this.pos.x + this.berzerker_spawn_offset.x, this.pos.y + this.berzerker_spawn_offset.y)
	local spawn_fx = E:create_entity(this.spawn_fx)

	spawn_fx.render.sprites[1].ts = store.tick_ts
	spawn_fx.pos = V.vclone(this.pos)

	queue_insert(store, spawn_fx)
	U.y_animation_wait(this, this.sid_drunk_man)

	local w = this.soldier_ref

	w.pos = V.vclone(warrior_pos)
	w.level = this.tower_ref.powers.skill_warrior.level
	w.health.hp_max = this.tower_ref.powers.skill_warrior.hp_max[w.level]

	if w.war_rations_hp_factor then
		w.health.hp_max = math.ceil(w.health.hp_max * w.war_rations_hp_factor)
	end

	w.health.armor = this.tower_ref.powers.skill_warrior.armor[w.level]

	queue_insert(store, w)
	queue_remove(store, this)
end

scripts.soldier_tower_barrel_skill_warrior = {}

function scripts.soldier_tower_barrel_skill_warrior.insert(this, store, script)
	if this.melee then
		this.melee.order = U.attack_order(this.melee.attacks)
	end

	local floor_decal = E:create_entity(this.floor_decal)

	floor_decal.render.sprites[1].ts = store.tick_ts
	floor_decal.pos = this.pos

	queue_insert(store, floor_decal)

	this.decal_floor_ref = floor_decal

	return true
end

function scripts.soldier_tower_barrel_skill_warrior.update(this, store, script)
	local brk, stam

	this.render.sprites[1].ts = store.tick_ts

	local a1 = this.melee.attacks[1]

	a1.damage_min = a1.damage_min_config[this.level]
	a1.damage_max = a1.damage_max_config[this.level]
	a1.ts = store.tick_ts

	local a2 = this.melee.attacks[2]

	a2.damage_min = a2.damage_min_config[this.level]
	a2.damage_max = a2.damage_max_config[this.level]
	a2.ts = store.tick_ts

	local tower = store.entities[this.source_id]

	if not tower then
		this.decal_floor_ref.tween.disabled = false
		this.decal_floor_ref.tween.ts = store.tick_ts

		queue_remove(store, this)

		return
	end

	local current_level = tower.powers.skill_warrior.level

	local function y_soldier_new_rally_break_attack(store, this, break_fn)
		local r = this.nav_rally
		local out = false
		local vis_bans = this.vis.bans
		local prev_immune = this.health.immune_to

		this.health.immune_to = r.immune_to
		this.vis.bans = F_ALL

		if r.new then
			r.new = false

			U.unblock_target(store, this)
			U.set_destination(this, r.pos)

			if r.delay_max then
				U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop)

				local index = this.soldier.tower_soldier_idx or 0
				local tower = store.entities[this.soldier.tower_id]
				local total = tower and tower.barrack.max_soldiers or 1

				if SU.y_soldier_wait(store, this, index / total * r.delay_max) then
					goto label_705_0
				end
			end

			local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

			U.animation_start(this, an, af, store.tick_ts, -1)

			while not this.motion.arrived do
				if this.health.dead or this.unit.is_stunned then
					out = true

					break
				end

				if r.new then
					out = false

					U.set_destination(this, r.pos)

					local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

					U.animation_start(this, an, af, store.tick_ts, -1)

					r.new = false
				end

				if break_fn() then
					out = false

					break
				end

				if r._first_time then
					r._first_time = false

					local target = U.find_foremost_enemy(store.entities, r.center, 0, this.melee.range, false, F_BLOCK, bit.bor(F_CLIFF), function(e)
						return (not e.enemy.max_blockers or #e.enemy.blockers == 0) and band(GR:cell_type(e.pos.x, e.pos.y), TERRAIN_NOWALK) == 0 and (not this.melee.fn_can_pick or this.melee.fn_can_pick(this, e))
					end)

					if target then
						out = false

						break
					end
				end

				U.walk(this, store.tick_length)
				coroutine.yield()

				this.motion.speed.x, this.motion.speed.y = 0, 0
			end
		end

		::label_705_0::

		this.vis.bans = vis_bans
		this.health.immune_to = prev_immune

		return out
	end

	local function walk_break_fn()
		return this.nav_rally.new
	end

	local function check_tower_damage_factor()
		if store.entities[this.soldier.tower_id] then
			for _, a in ipairs(this.melee.attacks) do
				if not a._original_damage_min then
					a._original_damage_min = a.damage_min
				end

				if not a._original_damage_max then
					a._original_damage_max = a.damage_max
				end

				a.damage_min = a._original_damage_min * store.entities[this.soldier.tower_id].tower.damage_factor
				a.damage_max = a._original_damage_max * store.entities[this.soldier.tower_id].tower.damage_factor
			end
		end
	end

	local function check_tower_skill_upgrade()
		if tower and tower.powers then
			local warrior_level = tower.powers.skill_warrior.level

			if current_level ~= warrior_level then
				this.level = warrior_level
				a1.damage_min = a1.damage_min_config[this.level]
				a1.damage_max = a1.damage_max_config[this.level]
				a2.damage_min = a2.damage_min_config[this.level]
				a2.damage_max = a2.damage_max_config[this.level]
				a1._original_damage_min = a1.damage_min
				a1._original_damage_max = a1.damage_max
				a2._original_damage_min = a2.damage_min
				a2._original_damage_max = a2.damage_max
				this.health.hp_max = tower.powers.skill_warrior.hp_max[this.level]
				this.health.armor = tower.powers.skill_warrior.armor[this.level]

				if this.war_rations_hp_factor then
					this.health.hp_max = math.ceil(this.health.hp_max * this.war_rations_hp_factor)
				end

				this.health.hp = this.health.hp_max
				current_level = warrior_level
			end
		end
	end

	while true do
		if this.health.dead or not tower or not store.entities[this.source_id] then
			this.decal_floor_ref.tween.disabled = false
			this.decal_floor_ref.tween.ts = store.tick_ts
			tower = store.entities[this.source_id]

			if tower then
				tower.attacks.list[tower.powers.skill_warrior.attack_idx].ts = store.tick_ts
			end

			this.health.hp = 0

			SU.remove_modifiers(store, this)

			this.ui.can_click = false

			if tower then
				tower.attacks.list[3].ts = store.tick_ts
			end

			U.unblock_target(store, this)

			local h = this.health

			if band(h.last_damage_types, bor(DAMAGE_DISINTEGRATE, DAMAGE_DISINTEGRATE_BOSS)) ~= 0 then
				this.unit.hide_during_death = true

				local fx = E:create_entity("fx_soldier_desintegrate")

				fx.pos.x, fx.pos.y = this.pos.x, this.pos.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			elseif band(h.last_damage_types, bor(DAMAGE_EAT)) ~= 0 then
				this.unit.hide_during_death = true
			else
				SU.y_reinforcement_fade_out(store, this)

				return
			end

			this.health.death_finished_ts = store.tick_ts

			if this.ui then
				if IS_TRILOGY then
					this.ui.can_click = not this.unit.hide_after_death
				else
					this.ui.can_click = this.ui.can_click and not this.unit.hide_after_death
				end

				this.ui.z = -1
			end

			if this.unit.hide_during_death or this.unit.hide_after_death then
				for _, s in pairs(this.render.sprites) do
					s.hidden = true
				end
			end

			if this.unit.fade_time_after_death then
				local delay = this.unit.fade_time_after_death
				local duration = this.unit.fade_duration_after_death

				if this.health and this.health.delete_after and duration then
					delay = this.health.delete_after - store.tick_ts - duration
				end

				SU.fade_out_entity(store, this, delay, duration)
			end

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)
			check_tower_skill_upgrade()
			check_tower_damage_factor()

			while this.nav_rally.new do
				if y_soldier_new_rally_break_attack(store, this, walk_break_fn) then
					goto label_704_0
				end
			end

			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if sta == A_IN_COOLDOWN then
				-- block empty
			else
				if brk or sta ~= A_NO_TARGET then
					goto label_704_0
				end

				if SU.soldier_go_back_step(store, this) then
					goto label_704_0
				end
			end

			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_704_0::

		coroutine.yield()
	end
end

scripts.tower_sand = {}

function scripts.tower_sand.update(this, store, script)
	local a = this.attacks
	local ba = a.list[1]

	ba.ts = store.tick_ts - ba.cooldown + a.attack_delay_on_spawn

	local ga = a.list[2]
	local bba = a.list[3]
	local shooter_sids = {
		3,
		4
	}
	local shooter_idx = 1

	if not a._last_target_pos then
		a._last_target_pos = {}

		for i = 1, #shooter_sids do
			a._last_target_pos[i] = v(REF_W, 0)
		end
	end

	local function shoot_animation(attack, shooter_idx, pos)
		local ssid = shooter_sids[shooter_idx]
		local soffset = this.render.sprites[ssid].offset
		local s = this.render.sprites[ssid]
		local an, af = U.animation_name_facing_point(this, attack.animation, pos, ssid, soffset)

		if attack == ga then
			af = not af
		end

		U.animation_start(this, an, af, store.tick_ts, 1, ssid)
	end

	local function shoot_bullet(attack, shooter_idx, enemy, level)
		local ssid = shooter_sids[shooter_idx]
		local shooting_up = this.render.sprites[ssid].name == this.render.sprites[ssid].angles.shoot[1]
		local shooting_right = not this.render.sprites[ssid].flip_x
		local soffset = this.render.sprites[ssid].offset
		local boffset = attack.bullet_start_offset[shooting_up and 1 or 2]
		local b = E:create_entity(attack.bullet)

		if attack == ga then
			b.bullet.damage_min = b.bullet.damage_min_config[this.powers.skill_gold.level]
			b.bullet.damage_max = b.bullet.damage_max_config[this.powers.skill_gold.level]
		end

		b.pos.x = this.pos.x + soffset.x + boffset.x * (shooting_right and 1 or -1)
		b.pos.y = this.pos.y + soffset.y + boffset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		b.bullet.target_id = enemy.id
		b.bullet.source_id = this.id
		b.bullet.level = level
		b.bullet.damage_factor = this.tower.damage_factor
		b.bounces = 0

		queue_insert(store, b)
	end

	local function check_upgrades_purchase()
		if this.powers then
			for _, pow in pairs(this.powers) do
				if pow.changed then
					pow.changed = nil

					local pa = this.attacks.list[pow.attack_idx]

					pa.cooldown = pow.cooldown[pow.level]
					pa.ts = store.tick_ts - pa.cooldown
				end
			end
		end
	end

	for idx, ssid in ipairs(shooter_sids) do
		local soffset = this.render.sprites[ssid].offset
		local s = this.render.sprites[ssid]
		local an, af = U.animation_name_facing_point(this, "idle", a._last_target_pos[idx], ssid, soffset)

		U.animation_start(this, an, af, store.tick_ts, 1, ssid)
	end

	while true do
		local at

		if this.tower.blocked then
			coroutine.yield()
		else
			check_upgrades_purchase()
			SU.towers_swaped(store, this, this.attacks.list)

			if bba and bba.cooldown and store.tick_ts - bba.ts > bba.cooldown and this.tower.can_do_magic then
				local _, enemies, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, bba.range, bba.shoot_time[1] + fts(20), bba.vis_flags, bba.vis_bans)

				if not enemies or #enemies < bba.min_targets then
					SU.delay_attack(store, bba, fts(10))
				else
					local nearest_nodes = P:nearest_nodes(pred_pos.x, pred_pos.y, {
						enemies[1].nav_path.pi
					})

					if #nearest_nodes == 0 then
						SU.delay_attack(store, bba, fts(10))
					else
						bba.ts = store.tick_ts

						U.animation_start(this, bba.animation, nil, store.tick_ts, false, this.tower_sid)
						S:queue(bba.sound)

						local c = E:create_entity(this.powers.skill_big_blade.controller)

						c.target_node = nearest_nodes[1]
						c.tower_ref = this

						queue_insert(store, c)
					end
				end
			end

			if ga and ga.cooldown and store.tick_ts - ga.ts > ga.cooldown and this.tower.can_do_magic then
				at = ga
			elseif store.tick_ts - ba.ts > ba.cooldown then
				at = ba
			end

			if at then
				local trigger_enemy, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, at.vis_flags, at.vis_bans)

				if not trigger_enemy then
					SU.delay_attack(store, at, fts(10))
				else
					at.ts = store.tick_ts
					shooter_idx = km.zmod(shooter_idx + 1, #shooter_sids)

					shoot_animation(at, shooter_idx, trigger_enemy.pos)
					S:queue(at.sound)

					while store.tick_ts - at.ts < at.shoot_time do
						check_upgrades_purchase()
						coroutine.yield()
					end

					local enemy, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, at.vis_flags, at.vis_bans)

					enemy = enemy or trigger_enemy

					shoot_bullet(at, shooter_idx, enemy, 0)

					a._last_target_pos[shooter_idx].x, a._last_target_pos[shooter_idx].y = enemy.pos.x, enemy.pos.y

					U.y_animation_wait(this, shooter_sids[shooter_idx])
				end
			end

			if store.tick_ts - ba.ts > this.tower.long_idle_cooldown then
				for _, sid in pairs(shooter_sids) do
					local an, af = U.animation_name_facing_point(this, "idle", this.tower.long_idle_pos, sid)

					U.animation_start(this, an, af, store.tick_ts, -1, sid)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.bullet_tower_sand = {}

function scripts.bullet_tower_sand.update(this, store)
	local b = this.bullet
	local target, ps

	this.bounces = 0

	local already_hit = {}
	local tower = store.entities[b.source_id]
	local skill_level

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if b.damage_min_config then
		skill_level = tower.powers.skill_gold.level
		b.damage_min = b.damage_min_config[skill_level]
		b.damage_max = b.damage_max_config[skill_level]
	end

	::label_714_0::

	while V.dist2(this.pos.x, this.pos.y, b.to.x, b.to.y) > b.fixed_speed * store.tick_length * (b.fixed_speed * store.tick_length) do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead then
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
		end

		b.speed.x, b.speed.y = V.mul(b.fixed_speed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length
		this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)

		coroutine.yield()
	end

	local will_kill

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		will_kill = U.predict_damage(target, d) >= target.health.hp

		table.insert(already_hit, target.id)
		S:queue(this.sound_hit)
	end

	if this.gold_chance and will_kill then
		local stole_gold = math.random(0, 100) <= this.gold_chance * 100

		if stole_gold then
			local sfx = E:create_entity(b.hit_fx_coins)

			sfx.pos = V.vclone(b.to)
			sfx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, sfx)

			local gold_pos = V.v(sfx.pos.x, sfx.pos.y)

			signal.emit("got-gold", gold_pos, this.gold_extra[skill_level])
		end
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, sfx)
	end

	S:queue(this.sound)

	if this.bounces < this.max_bounces then
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.bounce_range, b.vis_flags, b.vis_bans, function(v)
			return not table.contains(already_hit, v.id)
		end)

		if not targets then
			if target and not target.health.dead then
				already_hit = {
					target.id
				}
			else
				already_hit = {}
			end

			targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.bounce_range, b.vis_flags, b.vis_bans, function(v)
				return not table.contains(already_hit, v.id)
			end)
		end

		if targets then
			table.sort(targets, function(e1, e2)
				return V.dist2(this.pos.x, this.pos.y, e1.pos.x, e1.pos.y) < V.dist2(this.pos.x, this.pos.y, e2.pos.x, e2.pos.y)
			end)

			local target = targets[1]

			this.bounces = this.bounces + 1
			b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			b.target_id = target.id
			b.fixed_speed = b.fixed_speed * this.bounce_speed_mult
			b.damage_min = math.floor(b.damage_min * this.bounce_damage_mult)

			if b.damage_min < 1 then
				b.damage_min = 1
			end

			b.damage_max = math.floor(b.damage_max * this.bounce_damage_mult)

			if b.damage_max < 1 then
				b.damage_max = 1
			end

			goto label_714_0
		end
	end

	queue_remove(store, this)
end

scripts.controller_tower_sand_lvl4_skill_big_blade = {}

function scripts.controller_tower_sand_lvl4_skill_big_blade.update(this, store)
	local bba = this.tower_ref.attacks.list[3]

	local function shoot_big_blade(idx, dest)
		local boffset = bba.bullet_start_offset[idx]
		local b = E:create_entity(bba.bullet)

		b.pos.x = this.tower_ref.pos.x + boffset.x
		b.pos.y = this.tower_ref.pos.y + boffset.y
		b.origin_pos = V.vclone(b.pos)
		b.dest_pos = V.vclone(dest)
		b.aura.source_id = this.tower_ref.id
		b.aura.level = this.tower_ref.powers.skill_big_blade.level
		b.aura.damage_factor = this.tower_ref.tower.damage_factor
		b.aura.damage_min = this.tower_ref.powers.skill_big_blade.damage_min[b.aura.level]
		b.aura.damage_max = this.tower_ref.powers.skill_big_blade.damage_max[b.aura.level]
		b.aura.duration = this.tower_ref.powers.skill_big_blade.duration[b.aura.level]

		queue_insert(store, b)
	end

	local pi, spi, ni = unpack(this.target_node)
	local pos1 = P:node_pos(pi, 2, ni + 3)
	local pos2 = P:node_pos(pi, 3, ni - 3)

	U.y_wait(store, bba.shoot_time[1])
	shoot_big_blade(1, pos1)
	U.y_wait(store, bba.shoot_time[2] - bba.shoot_time[1])
	shoot_big_blade(2, pos2)
	queue_remove(store, this)
end

scripts.aura_tower_sand_skill_big_blade = {}

function scripts.aura_tower_sand_skill_big_blade.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0
	local reached_dest = false
	local source_tower = store.entities[this.aura.source_id]

	this.speed = V.vv(0)
	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	local ps = E:create_entity(this.particles_name)

	ps.particle_system.track_id = this.id

	queue_insert(store, ps)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		local d = this.dest_pos
		local s = this.speed
		local p = this.pos

		if reached_dest then
			-- block empty
		elseif V.dist2(p.x, p.y, d.x, d.y) > this.fixed_speed * store.tick_length * (this.fixed_speed * store.tick_length) then
			s.x, s.y = V.mul(this.fixed_speed, V.normalize(d.x - p.x, d.y - p.y))
			p.x, p.y = p.x + s.x * store.tick_length, p.y + s.y * store.tick_length
		else
			reached_dest = true
			this.render.sprites[1].prefix = "tower_sand_lvl4_skill_2_decal"

			U.y_animation_play(this, "in", nil, store.tick_ts)
			U.animation_start(this, "loop", nil, store.tick_ts, true)

			this.render.sprites[1].z = Z_DECALS
			ps.particle_system.emit = false
		end

		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration or not source_tower then
			break
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.aura.radius, this.aura.vis_flags, this.aura.vis_bans)

			if targets then
				for i, target in ipairs(targets) do
					local d = E:create_entity("damage")

					d.source_id = this.id
					d.target_id = target.id

					local dmin, dmax = this.aura.damage_min, this.aura.damage_max

					d.value = math.random(dmin, dmax)
					d.damage_type = this.aura.damage_type
					d.track_damage = this.aura.track_damage
					d.xp_dest_id = this.aura.xp_dest_id
					d.xp_gain_factor = this.aura.xp_gain_factor

					queue_damage(store, d)

					local fx = E:create_entity(this.hit_fx)

					fx.pos = V.vclone(target.pos)
					fx.pos.x, fx.pos.y = fx.pos.x + target.unit.hit_offset.x, fx.pos.y + target.unit.hit_offset.y
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)

					local mods = this.aura.mods or {
						this.aura.mod
					}

					for _, mod_name in pairs(mods) do
						local new_mod = E:create_entity(mod_name)

						new_mod.modifier.level = this.aura.level
						new_mod.modifier.target_id = target.id
						new_mod.modifier.source_id = this.id

						if this.aura.hide_source_fx and target.id == this.aura.source_id then
							new_mod.render = nil
						end

						queue_insert(store, new_mod)

						victims_count = victims_count + 1
					end
				end
			end
		end

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)

	this.render.sprites[1].prefix = "tower_sand_lvl4_skill_2_decal"

	U.y_animation_play(this, "out", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.tower_ray = {}

function scripts.tower_ray.get_info(this)
	local b = E:get_template(this.attacks.list[1].bullet)

	if not b.bullet.damage_min or not b.bullet.damage_max then
		b.bullet.damage_min = b.bullet.damage_min_config[this.tower.level]
		b.bullet.damage_max = b.bullet.damage_max_config[this.tower.level]
	end

	local o = scripts.tower_common.get_info(this)

	o.type = STATS_TYPE_TOWER_MAGE

	local min = math.ceil(b.bullet.damage_min * this.tower.damage_factor)
	local max = math.ceil(b.bullet.damage_max * this.tower.damage_factor)

	o.damage_min = min
	o.damage_max = max

	return o
end

function scripts.tower_ray.update(this, store)
	local a = this.attacks
	local ab = this.attacks.list[1]
	local ac = this.attacks.list[2]
	local as = this.attacks.list[3]
	local pow_c = this.powers and this.powers.chain or nil
	local pow_s = this.powers and this.powers.sheep or nil
	local last_ts = store.tick_ts - ab.cooldown

	a._last_target_pos = a._last_target_pos or v(REF_W, 0)
	ab.ts = store.tick_ts - ab.cooldown + a.attack_delay_on_spawn

	local idle_ts = store.tick_ts
	local attacks = {}
	local pows = {}

	if as then
		table.insert(attacks, as)
		table.insert(pows, pow_s)
	end

	if ac then
		table.insert(attacks, ac)
		table.insert(pows, pow_c)
	end

	if ab then
		table.insert(attacks, ab)
		table.insert(pows, nil)
	end

	for i = 1, #this.crystals_ids do
		local crystal_sid = this.render.sid_crystals + i - 1
		local start_offset = this.render.sprites[crystal_sid].offset
		local end_offset = V.v(start_offset.x, start_offset.y + 2.5)
		local frec = 3

		this.tween.props[i] = E:clone_c("tween_prop")
		this.tween.props[i].name = "offset"

		if this.tower.level <= 3 then
			if i == 3 or i == 4 then
				end_offset.x = -3
			elseif i == 5 or i == 6 then
				end_offset.x = 3
			end
		elseif i == 3 or i == 4 then
			end_offset.x = -3
		elseif i == 5 or i == 6 then
			end_offset.x = 3
		elseif i == 7 or i == 8 then
			end_offset.x = 3
		end

		this.tween.props[i].keys = {
			{
				0,
				start_offset
			},
			{
				frec / 2,
				end_offset
			},
			{
				frec,
				start_offset
			}
		}
		this.tween.props[i].sprite_id = crystal_sid
		this.tween.props[i].loop = true
		this.tween.props[i].interp = "sine"
		this.tween.props[i].ts = store.tick_ts
	end

	if this.stones_ids then
		for i = 1, #this.stones_ids do
			local stone_sid = this.render.sid_stones + i - 1
			local prop_id = #this.crystals_ids + i
			local start_offset = V.vclone(this.render.sprites[2].offset)
			local end_offset = V.vclone(this.render.sprites[2].offset)
			local frec = 3

			this.tween.props[prop_id] = E:clone_c("tween_prop")
			this.tween.props[prop_id].name = "offset"

			if this.tower.level == 2 then
				if i == 1 then
					end_offset = v(-5, start_offset.y + 3)
				elseif i == 2 or i == 3 then
					end_offset = v(-5, start_offset.y - 1)
				elseif i == 4 then
					end_offset = v(5, start_offset.y + 3)
				else
					end_offset = v(5, start_offset.y)
				end
			elseif this.tower.level == 3 then
				if i == 1 then
					end_offset = v(-5, start_offset.y + 3)
				elseif i == 2 then
					end_offset = v(-5, start_offset.y + 1)
				elseif i == 3 then
					end_offset = v(-4, start_offset.y - 3)
				elseif i == 4 then
					end_offset = v(5, start_offset.y + 2)
				elseif i == 5 then
					end_offset = v(3, start_offset.y + 2)
				else
					end_offset = v(4, start_offset.y - 5)
				end
			elseif this.tower.level == 4 then
				if i == 1 then
					end_offset = v(-3, start_offset.y + 2)
				elseif i == 2 then
					end_offset = v(-2, start_offset.y + 4)
				elseif i == 3 then
					end_offset = v(-4, start_offset.y + 2)
				elseif i == 4 or i == 5 then
					end_offset = v(3, start_offset.y + 3)
				elseif i == 6 then
					end_offset = v(4, start_offset.y + 1)
				elseif i == 7 then
					end_offset = v(-3, start_offset.y - 1)
				elseif i == 8 then
					end_offset = v(2, start_offset.y - 2)
				elseif i == 9 or i == 10 then
					end_offset = v(2, start_offset.y)
				else
					end_offset = v(-1, start_offset.y - 3)
				end
			end

			this.tween.props[prop_id].keys = {
				{
					0,
					start_offset
				},
				{
					frec / 2,
					end_offset
				},
				{
					frec,
					start_offset
				}
			}
			this.tween.props[prop_id].sprite_id = stone_sid
			this.tween.props[prop_id].loop = true
			this.tween.props[prop_id].interp = "sine"
		end
	end

	if this.tower.level == 4 then
		for i = 1, #this.rocks_ids + #this.back_rocks_ids do
			local rock_sid = this.render.sid_rocks + i - 1
			local prop_id = #this.crystals_ids + #this.stones_ids + i
			local start_offset = V.vclone(this.render.sprites[2].offset)
			local end_offset = V.v(start_offset.x, start_offset.y + 5)
			local frec = 4

			this.tween.props[prop_id] = E:clone_c("tween_prop")
			this.tween.props[prop_id].name = "offset"
			this.tween.props[prop_id].keys = {
				{
					0,
					start_offset
				},
				{
					frec / 2,
					end_offset
				},
				{
					frec,
					start_offset
				}
			}
			this.tween.props[prop_id].sprite_id = rock_sid
			this.tween.props[prop_id].loop = true
			this.tween.props[prop_id].interp = "sine"
			this.tween.props[prop_id].ts = store.tick_ts - i
		end

		local core_rock_sid = 2
		local prop_id = #this.crystals_ids + #this.stones_ids + #this.rocks_ids + #this.back_rocks_ids + 1
		local start_offset = V.vclone(this.render.sprites[2].offset)
		local end_offset = V.v(start_offset.x, start_offset.y + 4)
		local frec = 5

		this.tween.props[prop_id] = E:clone_c("tween_prop")
		this.tween.props[prop_id].name = "offset"
		this.tween.props[prop_id].keys = {
			{
				0,
				start_offset
			},
			{
				frec / 2,
				end_offset
			},
			{
				frec,
				start_offset
			}
		}
		this.tween.props[prop_id].sprite_id = core_rock_sid
		this.tween.props[prop_id].loop = true
		this.tween.props[prop_id].interp = "sine"
		this.tween.props[prop_id].ts = store.tick_ts
		prop_id = prop_id + 1
		this.tween.props[prop_id] = E:clone_c("tween_prop")
		this.tween.props[prop_id].name = "scale"
		this.tween.props[prop_id].keys = {
			{
				0,
				V.vv(1)
			},
			{
				frec / 2,
				V.vv(0.9)
			},
			{
				frec,
				V.vv(1)
			}
		}
		this.tween.props[prop_id].sprite_id = this.render.sid_core_rock_shadow
		this.tween.props[prop_id].loop = true
		this.tween.props[prop_id].interp = "sine"
		this.tween.props[prop_id].ts = this.tween.props[prop_id - 1].ts
	end

	local function find_target(aa)
		local target, _, pred_pos = U.find_strongest_enemy_in_range(store.entities, tpos(this), 0, a.range, aa.node_prediction, aa.vis_flags, aa.vis_bans, function(e, o)
			return not aa.excluded_templates or not table.contains(aa.excluded_templates, e.template_name)
		end)

		return target, pred_pos
	end

	do
		local soffset = this.shooter_offset
		local an, af, ai = U.animation_name_facing_point(this, "idle", a._last_target_pos, this.render.sid_mage, soffset)

		U.animation_start(this, an, false, store.tick_ts, true, this.render.sid_mage)
	end

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			if this.powers then
				for k, pow in pairs(this.powers) do
					if pow.changed then
						pow.changed = nil

						if pow == pow_c then
							if pow.level >= 1 then
								ab.disabled = true
								ac.disabled = false
							end

							ac.ts = store.tick_ts - ac.cooldown

							if pow.level == 1 then
								for i = 1, #this.shocks_ids do
									local shock_fx = E:create_entity(this.shock_fx)

									shock_fx.pos = tpos(this)
									shock_fx.render.sprites[1].prefix = shock_fx.render.sprites[1].prefix .. this.shocks_ids[i]
									shock_fx.render.sprites[1].ts = store.tick_ts
									shock_fx.tower_id = this.id

									queue_insert(store, shock_fx)
									U.animation_start(shock_fx, "idle", nil, store.tick_ts, true)
								end
							end
						end

						if pow == pow_s then
							as.disabled = false
							as.cooldown = pow.cooldown[1]
							as.ts = store.tick_ts - as.cooldown
						end
					end
				end
			end

			SU.towers_swaped(store, this, this.attacks.list)

			for i, aa in pairs(attacks) do
				if aa and not aa.disabled and store.tick_ts - aa.ts > aa.cooldown and store.tick_ts - last_ts > a.min_cooldown then
					if aa == as then
						if not this.tower.can_do_magic then
							goto label_continue
						end
						local enemy, pred_pos = find_target(aa)

						if not enemy then
							SU.delay_attack(store, aa, fts(10))
						else
							local enemy_id = enemy.id
							local enemy_pos = enemy.pos

							last_ts = store.tick_ts

							S:queue(aa.sound)

							local an, af, ai = U.animation_name_facing_point(this, aa.animation_start, enemy.pos, this.render.sid_mage, this.mage_offset)

							a._last_target_pos.x, a._last_target_pos.y = enemy.pos.x, enemy.pos.y

							U.animation_start(this, an, nil, store.tick_ts, false, this.render.sid_mage)
							U.animation_start_group(this, "glow_start", nil, store.tick_ts, false, "rocks")

							local b = E:create_entity(aa.bullet)
							local start_offset = aa.bullet_start_offset

							U.y_wait(store, fts(4))
							U.animation_start_group(this, "idle_2", nil, store.tick_ts, true, "rocks")
							U.y_wait(store, aa.shoot_time - fts(4))

							local an, af, ai = U.animation_name_facing_point(this, aa.animation_loop, enemy.pos, this.render.sid_mage, this.mage_offset)

							a._last_target_pos.x, a._last_target_pos.y = enemy.pos.x, enemy.pos.y

							U.animation_start(this, an, nil, store.tick_ts, true, this.render.sid_mage)

							if aa.start_fx then
								local fx = E:create_entity(aa.start_fx)

								fx.pos.x, fx.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
								fx.render.sprites[1].ts = store.tick_ts

								queue_insert(store, fx)
							end

							U.y_wait(store, fts(1))

							enemy, pred_pos = find_target(aa)

							if enemy then
								enemy_id = enemy.id
								enemy_pos = enemy.pos
							else
								goto label_722_0
							end

							aa.ts = last_ts
							b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.v(pred_pos.x + enemy.unit.hit_offset.x, pred_pos.y + enemy.unit.hit_offset.y)
							b.bullet.target_id = enemy_id
							b.bullet.source_id = this.id
							b.bullet.level = this.tower.level
							b.tower_ref = this
							b.pred_pos = V.vclone(pred_pos)

							queue_insert(store, b)

							::label_722_0::

							local an, af, ai = U.animation_name_facing_point(this, aa.animation_end, a._last_target_pos, this.render.sid_mage, this.mage_offset)

							U.animation_start(this, an, nil, store.tick_ts, false, this.render.sid_mage)
							U.y_animation_play_group(this, "glow_end", nil, store.tick_ts, 1, "rocks")
							U.animation_start_group(this, "idle", nil, store.tick_ts, true, "rocks")
							U.y_animation_wait(this, this.render.sid_mage)

							local soffset = this.shooter_offset
							local an, af, ai = U.animation_name_facing_point(this, "idle", a._last_target_pos, this.render.sid_mage, soffset)

							U.animation_start(this, an, false, store.tick_ts, true, this.render.sid_mage)

							idle_ts = store.tick_ts
						end
					else
						local enemy, pred_pos = find_target(aa)

						if not enemy then
							SU.delay_attack(store, aa, fts(10))
						else
							local enemy_id = enemy.id
							local enemy_pos = enemy.pos

							last_ts = store.tick_ts

							S:queue(aa.sound)

							local an, af, ai = U.animation_name_facing_point(this, aa.animation_start, enemy.pos, this.render.sid_mage, this.mage_offset)

							a._last_target_pos.x, a._last_target_pos.y = enemy.pos.x, enemy.pos.y

							U.animation_start(this, an, nil, store.tick_ts, false, this.render.sid_mage)
							U.animation_start_group(this, "union", nil, store.tick_ts, false, "crystals")

							if this.tower.level < 4 then
								this.render.sprites[this.render.sid_glow].hidden = false

								U.animation_start(this, "glow_start", nil, store.tick_ts, false, this.render.sid_glow)
							else
								U.animation_start_group(this, "glow_start", nil, store.tick_ts, false, "rocks")
							end

							if aa.start_fx then
								local fx = E:create_entity(aa.start_fx)

								fx.pos = V.vclone(tpos(this))
								fx.render.sprites[1].ts = store.tick_ts

								queue_insert(store, fx)
							end

							local b = E:create_entity(aa.bullet)
							local start_offset = aa.bullet_start_offset

							U.y_wait(store, fts(4))

							if this.tower.level < 4 then
								this.render.sprites[this.render.sid_glow].hidden = false

								U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_glow)
							else
								U.animation_start_group(this, "idle_2", nil, store.tick_ts, true, "rocks")
							end

							U.y_wait(store, aa.shoot_time - fts(4))

							local an, af, ai = U.animation_name_facing_point(this, aa.animation_loop, enemy.pos, this.render.sid_mage, this.mage_offset)

							a._last_target_pos.x, a._last_target_pos.y = enemy.pos.x, enemy.pos.y

							U.animation_start(this, an, nil, store.tick_ts, true, this.render.sid_mage)

							if b.bullet.out_start_fx then
								local fx = E:create_entity(b.bullet.out_start_fx)

								fx.pos.x, fx.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
								fx.render.sprites[1].ts = store.tick_ts

								queue_insert(store, fx)
							end

							if b.bullet.out_fx then
								local fx = E:create_entity(b.bullet.out_fx)

								fx.pos.x, fx.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
								fx.render.sprites[1].ts = store.tick_ts

								queue_insert(store, fx)

								this.ray_fx_start = fx
							end

							U.y_wait(store, fts(1))

							local last_fx = store.tick_ts + fts(3)

							this.render.sprites[this.render.sid_crystal_union].hidden = false

							for i = this.render.sid_crystals, this.render.sid_crystals + #this.crystals_ids - 1 do
								this.render.sprites[i].hidden = true
							end

							local range_to_stay = a.range + a.extra_range

							enemy, pred_pos = find_target(aa)

							if enemy then
								enemy_id = enemy.id
								enemy_pos = enemy.pos
							else
								goto label_722_1
							end

							this.chain_targets = {
								enemy.id
							}
							b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
							b.bullet.from = V.vclone(b.pos)
							b.bullet.to = V.vclone(enemy_pos)
							b.bullet.target_id = enemy_id
							b.bullet.source_id = this.id
							b.bullet.level = this.tower.level
							b.bullet.damage_factor = this.tower.damage_factor
							b.tower_ref = this

							queue_insert(store, b)

							while store.tick_ts - last_ts < aa.duration + aa.shoot_time and enemy and enemy.enemy and not enemy.health.dead and b and not b.force_stop_ray and not this.tower.blocked and V.dist2(tpos(this).x, tpos(this).y, enemy.pos.x, enemy.pos.y) <= range_to_stay * range_to_stay do
								if store.tick_ts - last_fx > 1 and store.tick_ts - last_ts < aa.duration + aa.shoot_time - 0.75 and b.bullet.out_start_fx then
									local fx = E:create_entity(b.bullet.out_start_fx)

									fx.pos.x, fx.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
									fx.render.sprites[1].ts = store.tick_ts

									queue_insert(store, fx)

									last_fx = store.tick_ts
								end

								coroutine.yield()
							end

							b.force_stop_ray = true

							::label_722_1::

							aa.ts = last_ts

							queue_remove(store, this.ray_fx_start)

							this.render.sprites[this.render.sid_crystal_union].hidden = true

							for i = this.render.sid_crystals, this.render.sid_crystals + #this.crystals_ids - 1 do
								this.render.sprites[i].hidden = false
							end

							U.animation_start_group(this, "break", nil, store.tick_ts, false, "crystals")

							local an, af, ai = U.animation_name_facing_point(this, aa.animation_end, a._last_target_pos, this.render.sid_mage, this.mage_offset)

							U.animation_start(this, an, nil, store.tick_ts, false, this.render.sid_mage)

							if this.tower.level < 4 then
								U.y_animation_play(this, "glow_end", nil, store.tick_ts, 1, this.render.sid_glow)

								this.render.sprites[this.render.sid_glow].hidden = true
							else
								U.y_animation_play_group(this, "glow_end", nil, store.tick_ts, 1, "rocks")
								U.animation_start_group(this, "idle", nil, store.tick_ts, true, "rocks")
							end

							U.y_animation_wait(this, this.render.sid_mage)

							local soffset = this.shooter_offset
							local an, af, ai = U.animation_name_facing_point(this, "idle", a._last_target_pos, this.render.sid_mage, soffset)

							U.animation_start(this, an, false, store.tick_ts, true, this.render.sid_mage)

							idle_ts = store.tick_ts
						end
					end
				end
				::label_continue::
			end

			if store.tick_ts - idle_ts > this.tower.long_idle_cooldown then
				local an, af, ai = U.animation_name_facing_point(this, "idle", this.tower.long_idle_pos, this.render.sprites.sid_mage, this.mage_offset)

				U.animation_start(this, "idle", false, store.tick_ts, true, this.render.sprites.sid_mage)
			end

			coroutine.yield()
		end
	end
end

function scripts.tower_ray.remove(this, store)
	if this.ray_fx_start then
		queue_remove(store, this.ray_fx_start)
	end

	if this.tower.level == 1 then
		return true
	end

	return true
end

scripts.tower_dark_elf = {}

function scripts.tower_dark_elf.get_info(this)
	local min, max, d_type

	if this.attacks and this.attacks.list[1].damage_min then
		min, max = this.attacks.list[1].damage_min, this.attacks.list[1].damage_max
	elseif this.attacks and this.attacks.list[1].bullet then
		local b = E:get_template(this.attacks.list[1].bullet)

		min, max = b.bullet.damage_min, b.bullet.damage_max
		d_type = b.bullet.damage_type
	end

	local pow_buff = this.powers and this.powers.skill_buff or nil

	if pow_buff and pow_buff.level > 0 then
		local soulsDamageMin = this.tower_upgrade_persistent_data.souls_extra_damage_min or 0
		local soulsDamageMax = this.tower_upgrade_persistent_data.souls_extra_damage_max or 0

		min = min + soulsDamageMin
		max = max + soulsDamageMax
	end

	min, max = math.ceil(min * this.tower.damage_factor), math.ceil(max * this.tower.damage_factor)

	local cooldown

	if this.attacks and this.attacks.list[1].cooldown then
		cooldown = this.attacks.list[1].cooldown
	end

	return {
		type = STATS_TYPE_TOWER,
		damage_min = min,
		damage_max = max,
		damage_type = d_type,
		range = this.attacks.range,
		cooldown = cooldown
	}
end

function scripts.tower_dark_elf.insert(this, store)
	log.info(tostring(this.barrack))

	if this.barrack and not this.barrack.rally_pos and this.tower.default_rally_pos then
		this.barrack.rally_pos = V.vclone(this.tower.default_rally_pos)
	end

	if this.tower_upgrade_persistent_data.fps then
		this.render.sprites[this.render.sid_archer].fps = this.tower_upgrade_persistent_data.fps
		if not this.attacks.list[1]._original_shoot_time then
			this.attacks.list[1]._original_shoot_time = this.attacks.list[1].shoot_time
			this.attacks.list[1]._original_cooldown = this.attacks.list[1].cooldown
		end
		this.attacks.list[1].shoot_time = this.attacks.list[1]._original_shoot_time * FPS / this.tower_upgrade_persistent_data.fps
		this.attacks.list[1].cooldown = math.max(this.attacks.list[1]._original_cooldown * FPS / this.tower_upgrade_persistent_data.fps, 1)
	end

	return true
end

function scripts.tower_dark_elf.update(this, store)
	local last_ts = store.tick_ts
	local a_name, a_flip, angle_idx, target, pred_pos
	local attack = this.attacks.list[1]
	local attack_soldiers = this.attacks.list[2]
	local b = this.barrack
	local pow_soldiers = this.powers and this.powers.skill_soldiers or nil
	local pow_buff = this.powers and this.powers.skill_buff or nil
	local MODE_FOREMOST = 0
	local MODE_MAXHP = 1

	local function find_maxhp_enemy(entities, origin, min_range, max_range, prediction_time, flags, bans, filter_func, min_override_flags)
		flags = flags or 0
		bans = bans or 0
		min_override_flags = min_override_flags or 0

		local enemies = {}

		for _, e in pairs(entities) do
			if e.pending_removal or not e.enemy or not e.nav_path or not e.vis or e.health and e.health.dead or band(e.vis.flags, bans) ~= 0 or band(e.vis.bans, flags) ~= 0 or filter_func and not filter_func(e, origin) then
				-- block empty
			else
				local e_pos, e_ni

				if prediction_time and e.motion and e.motion.speed then
					if e.motion.forced_waypoint then
						local dt = prediction_time == true and 1 or prediction_time

						e_pos = V.v(e.pos.x + dt * e.motion.speed.x, e.pos.y + dt * e.motion.speed.y)
						e_ni = e.nav_path.ni
					else
						local node_offset = P:predict_enemy_node_advance(e, prediction_time)

						e_ni = e.nav_path.ni + node_offset
						e_pos = P:node_pos(e.nav_path.pi, e.nav_path.spi, e_ni)
					end
				else
					e_pos = e.pos
					e_ni = e.nav_path.ni
				end

				if U.is_inside_ellipse(e_pos, origin, max_range) and P:is_node_valid(e.nav_path.pi, e_ni) and (min_range == 0 or band(e.vis.flags, min_override_flags) ~= 0 or not U.is_inside_ellipse(e_pos, origin, min_range)) then
					e.__ffe_pos = V.vclone(e_pos)

					table.insert(enemies, e)
				end
			end
		end

		if not enemies or #enemies == 0 then
			return nil, nil
		else
			table.sort(enemies, function(e1, e2)
				return e1.health.hp_max > e2.health.hp_max
			end)

			return enemies[1], enemies, enemies[1].__ffe_pos
		end
	end

	local function find_target(attack, node_prediction)
		if this.tower_upgrade_persistent_data.current_mode == MODE_FOREMOST then
			local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, this.attacks.range, node_prediction, attack.vis_flags, attack.vis_bans)

			return target, pred_pos
		else
			local target, _, pred_pos = find_maxhp_enemy(store.entities, tpos(this), 0, this.attacks.range, node_prediction, attack.vis_flags, attack.vis_bans)

			return target, pred_pos
		end
	end

	local function animation_name_facing_angle_dark_elf(group, source_pos, dest_pos)
		local vx, vy = V.sub(dest_pos.x, dest_pos.y, source_pos.x, source_pos.y)
		local v_angle = V.angleTo(vx, vy)
		local angle = km.unroll(v_angle)
		local angle_deg = km.rad2deg(angle)
		local a = this.render.sprites[this.render.sid_archer]
		local o_name, o_flip, o_idx
		local a1, a2, a3, a4, a5, a6, a7, a8 = 0, 20, 90, 160, 180, 200, 270, 340
		local angles = a.angles[group]

		if a1 <= angle_deg and angle_deg < a2 then
			o_name, o_flip, o_idx = angles[1], false, 1
			quadrant = 1
		elseif a2 <= angle_deg and angle_deg < a3 then
			o_name, o_flip, o_idx = angles[2], false, 2
			quadrant = 2
		elseif a3 <= angle_deg and angle_deg < a4 then
			o_name, o_flip, o_idx = angles[2], true, 2
			quadrant = 3
		elseif a4 <= angle_deg and angle_deg < a5 then
			o_name, o_flip, o_idx = angles[1], true, 1
			quadrant = 4
		elseif a5 <= angle_deg and angle_deg < a6 then
			o_name, o_flip, o_idx = angles[4], true, 4
			quadrant = 5
		elseif a6 <= angle_deg and angle_deg < a7 then
			o_name, o_flip, o_idx = angles[3], true, 3
			quadrant = 6
		elseif a7 <= angle_deg and angle_deg < a8 then
			o_name, o_flip, o_idx = angles[3], false, 3
			quadrant = 7
		else
			o_name, o_flip, o_idx = angles[4], false, 4
			quadrant = 8
		end

		return o_name, o_flip, o_idx
	end

	local function check_change_mode()
		if this.change_mode then
			this.change_mode = false

			if this.tower_upgrade_persistent_data.current_mode == MODE_FOREMOST then
				this.tower_upgrade_persistent_data.current_mode = MODE_MAXHP
			else
				this.tower_upgrade_persistent_data.current_mode = MODE_FOREMOST
			end

			return true
		end

		return false
	end

	local function check_upgrades_purchase()
		if this.powers then
			for k, pow in pairs(this.powers) do
				if pow.changed then
					pow.changed = nil

					if pow == pow_soldiers then
						if not this.controller_soldiers then
							this.controller_soldiers = E:create_entity(this.controller_soldiers_template)
							this.controller_soldiers.tower_ref = this
							this.controller_soldiers.pos = this.pos

							queue_insert(store, this.controller_soldiers)
						end

						this.controller_soldiers.pow_level = pow.level
					end
				end
			end
		end
	end

	local function retarget(node_prediction)
		local retarget, new_pos = find_target(attack)

		if retarget then
			this.attacks._last_target_pos = pred_pos

			if this.mod_target then
				this.mod_target.modifier.target_id = retarget.id
			end

			return retarget, new_pos
		else
			target = nil

			if this.mod_target then
				queue_remove(store, this.mod_target)
			end

			return nil, nil
		end
	end

	if not this.attacks._last_target_pos then
		this.attacks._last_target_pos = {}
		this.attacks._last_target_pos = v(REF_W, 0)
	end

	local an, af = U.animation_name_facing_point(this, "idle", this.attacks._last_target_pos, this.render.sid_archer)

	U.animation_start(this, an, af, store.tick_ts, 1, this.render.sid_archer)

	if this.tower_upgrade_persistent_data.last_ts then
		last_ts = this.tower_upgrade_persistent_data.last_ts
		attack.ts = this.tower_upgrade_persistent_data.last_ts
	else
		attack.ts = store.tick_ts - attack.cooldown + attack.first_cooldown
	end

	::label_728_0::

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			check_upgrades_purchase()
			check_change_mode()
			SU.towers_swaped(store, this, this.attacks.list)

			if store.tick_ts - attack.ts > attack.cooldown then
				target, pred_pos = find_target(attack, attack.node_prediction_prepare + attack.node_prediction)

				if not target then
					SU.delay_attack(store, attack, fts(10))

					goto label_728_0
				end

				this.mod_target = E:create_entity(attack.mod_target)
				this.mod_target.modifier.target_id = target.id
				this.mod_target.modifier.source_id = this.id
				this.mod_target.render.sprites[1].hidden = this.tower_upgrade_persistent_data.current_mode ==
				MODE_FOREMOST

				queue_insert(store, this.mod_target)

				local a_name, a_flip, angle_idx
				local start_ts = store.tick_ts

				this.attacks._last_target_pos = pred_pos

				local an, af = U.animation_name_facing_point(this, "shot_prepare", pred_pos, this.render.sid_archer)

				U.animation_start(this, an, af, store.tick_ts, false, this.render.sid_archer)

				while not U.animation_finished(this, this.render.sid_archer, 1) do
					check_upgrades_purchase()
					check_change_mode()

					if this.tower.blocked then
						local an, af = U.animation_name_facing_point(this, "idle", pred_pos, this.render.sid_archer)

						U.animation_start(this, an, af, store.tick_ts, false, this.render.sid_archer)

						if this.mod_target then
							queue_remove(store, this.mod_target)
						end

						goto label_728_0
					end

					coroutine.yield()
				end

				local old_target = target

				target, pred_pos = retarget(attack.node_prediction)

				if not pred_pos then
					if not old_target.health.dead then
						local node_offset = P:predict_enemy_node_advance(old_target, attack.shoot_time)
						local e_ni = old_target.nav_path.ni + node_offset
						local e_pos = P:node_pos(old_target.nav_path.pi, old_target.nav_path.spi, e_ni)

						if V.dist2(e_pos.x, e_pos.y, this.pos.x, this.pos.y) < this.attacks.range * this.attacks.range * 1.3 then
							target = old_target
						end
					end

					pred_pos = this.attacks._last_target_pos
				end

				an, af, angle_idx = animation_name_facing_angle_dark_elf("shot", this.pos, pred_pos)

				U.animation_start(this, an, af, store.tick_ts, false, this.render.sid_archer)
				U.y_wait(store, attack.shoot_time)

				local bullet = E:create_entity(attack.bullet)

				bullet.pos = V.vclone(this.pos)

				local offset_x = af and -attack.bullet_start_offset[angle_idx].x or
				attack.bullet_start_offset[angle_idx].x
				local offset_y = attack.bullet_start_offset[angle_idx].y

				bullet.pos = V.v(this.pos.x + offset_x, this.pos.y + offset_y)
				bullet.bullet.from = V.vclone(bullet.pos)
				bullet.bullet.to = V.vclone(pred_pos)

				if target then
					bullet.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x,
						target.pos.y + target.unit.hit_offset.y)
				end

				bullet.bullet.target_id = target and target.id or nil
				bullet.bullet.source_id = this.id
				bullet.bullet.damage_factor = this.tower.damage_factor

				if pow_buff and pow_buff.level > 0 then
					local soulsDamageMin = this.tower_upgrade_persistent_data.souls_extra_damage_min or 0
					local soulsDamageMax = this.tower_upgrade_persistent_data.souls_extra_damage_max or 0
					local soulsArmorReduction = this.tower_upgrade_persistent_data.souls_armor_reduction or 0

					bullet.bullet.damage_min = bullet.bullet.damage_min + soulsDamageMin
					bullet.bullet.damage_max = bullet.bullet.damage_max + soulsDamageMax
					bullet.bullet.reduce_armor = soulsArmorReduction
				end

				queue_insert(store, bullet)

				while not U.animation_finished(this, this.render.sid_archer, 1) do
					check_upgrades_purchase()
					check_change_mode()
					coroutine.yield()
				end

				local an, af = U.animation_name_facing_point(this, "shot_end", pred_pos, this.render.sid_archer)

				U.y_animation_play(this, an, af, store.tick_ts, false, this.render.sid_archer)

				attack.ts = start_ts
				last_ts = start_ts
				this.tower.long_idle_pos = V.vclone(pred_pos)
			end

			this.tower_upgrade_persistent_data.last_ts = last_ts

			if store.tick_ts - last_ts > this.tower.long_idle_cooldown then
				U.animation_start(this, "idle", false, store.tick_ts, -1, this.render.sid_archer)

				this.attacks._last_target_pos = v(REF_W, 0)
			end

			coroutine.yield()
		end
	end
end

function scripts.tower_dark_elf.remove(this, store)
	if this.controller_soldiers then
		queue_remove(store, this.controller_soldiers)
	end

	return true
end

scripts.mod_tower_dark_elf_big_target = {}

function scripts.mod_tower_dark_elf_big_target.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local source = store.entities[m.source_id]
	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	U.animation_start(this, "run", nil, store.tick_ts)

	local t_id = m.target_id

	while true do
		target = store.entities[m.target_id]

		if target and t_id ~= m.target_id then
			this.pos = target.pos
			t_id = m.target_id
		end

		this.render.sprites[1].hidden = not target or target.health.dead or
		source.tower_upgrade_persistent_data.current_mode == 0

		if m.duration >= 0 and store.tick_ts - m.ts > m.duration then
			queue_remove(store, this)

			return
		end

		if this.render and target and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end
end

scripts.bullet_tower_dark_elf = {}

function scripts.bullet_tower_dark_elf.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local dest = V.vclone(b.to)

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle
		s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width
	end

	local function hit_target()
		if target and source then
			if b.mod then
				local mod = E:create_entity(b.mod)

				mod.modifier.target_id = target.id
				mod.modifier.source_id = source.id

				queue_insert(store, mod)
			end

			local d = SU.create_bullet_damage(b, target.id, this.id)

			queue_damage(store, d)

			local fx = E:create_entity(b.hit_fx)

			fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].r = this.render.sprites[1].r

			queue_insert(store, fx)

			if target.health and not target.health.dead and store.entities[source.id] then
				local tower = store.entities[source.id]

				if tower.powers then
					for _, pow in pairs(tower.powers) do
						if pow == tower.powers.skill_buff and pow.level > 0 then
							local will_kill = U.predict_damage(target, d) >= target.health.hp

							if will_kill then
								local soul_mod = E:create_entity(this.skill_buff_mod)

								soul_mod.pos = V.v(target.pos.x + target.unit.hit_offset.x,
									target.pos.y + target.unit.hit_offset.y)
								soul_mod.modifier.source_id = this.id
								soul_mod.modifier.target_id = target.id
								soul_mod.tower_id = tower.id

								queue_insert(store, soul_mod)
							end
						end
					end
				end
			end
		elseif this.missed_shot and GR:cell_is_only(this.pos.x, this.pos.y, TERRAIN_LAND) then
			local fx = E:create_entity(this.missed_arrow_decal)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local fx = E:create_entity(this.missed_arrow_dust)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local fx = E:create_entity(this.missed_arrow)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].flip_x = b.to.x > b.from.x

			queue_insert(store, fx)
		end
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	local already_hit_target = false

	if this.ray_duration then
		while store.tick_ts - s.ts < this.ray_duration do
			if this.track_target then
				update_sprite()
			end

			if source and not store.entities[source.id] then
				queue_remove(store, this)

				break
			end

			if not already_hit_target and store.tick_ts - s.ts > this.hit_delay then
				hit_target()

				already_hit_target = true
			end

			coroutine.yield()

			s.hidden = false
		end
	else
		while not U.animation_finished(this, 1) do
			if source and not store.entities[source.id] then
				queue_remove(store, this)

				break
			end

			if not already_hit_target and store.tick_ts - s.ts > this.hit_delay then
				hit_target(b, target)

				already_hit_target = true
			end

			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.controller_tower_dark_elf_soldiers = {}

function scripts.controller_tower_dark_elf_soldiers.update(this, store)
	local b = this.tower_ref.barrack
	local check_soldiers_ts = store.tick_ts
	local tower_id = this.tower_ref.id
	local last_pow_level = 1
	local power_data = this.tower_ref.powers.skill_soldiers

	while true do
		if this.pow_level ~= last_pow_level then
			last_pow_level = this.pow_level

			for i = 1, b.max_soldiers do
				local s = b.soldiers[i]

				if s and store.entities[s.id] then
					s.health.hp_max = power_data.hp[this.pow_level]

					if s.war_rations_hp_factor then
						s.health.hp_max = math.ceil(s.health.hp_max * s.war_rations_hp_factor)
					end

					s.health.hp = s.health.hp_max
					s.melee.attacks[1].damage_min = power_data.damage_min[this.pow_level]
					s.melee.attacks[1].damage_max = power_data.damage_max[this.pow_level]
					s.dodge.chance = power_data.dodge_chance[this.pow_level]
				end
			end
		end

		if store.tick_ts - check_soldiers_ts > this.check_soldiers_cooldown and not this.tower_ref.blocked then
			for i = 1, b.max_soldiers do
				local s = b.soldiers[i]

				if not s or s.health.dead and not store.entities[s.id] then
					S:queue(this.sound_open)

					this.render.sprites[1].hidden = false

					U.y_animation_play(this, "open", nil, store.tick_ts)
					U.animation_start(this, "idle", false, store.tick_ts)

					s = E:create_entity(b.soldier_type)
					s.soldier.tower_id = this.tower_ref.id
					s.soldier.tower_soldier_idx = i
					s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
					s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers)
					s.dest_pos = s.nav_rally.center
					s.source_id = this.tower_ref.id
					s.nav_rally.new = true
					s.health.hp_max = power_data.hp[this.pow_level]

					if s.war_rations_hp_factor then
						s.health.hp_max = math.ceil(s.health.hp_max * s.war_rations_hp_factor)
					end

					s.melee.attacks[1].damage_min = power_data.damage_min[this.pow_level]
					s.melee.attacks[1].damage_max = power_data.damage_max[this.pow_level]
					s.dodge.chance = power_data.dodge_chance[this.pow_level]

					queue_insert(store, s)

					b.soldiers[i] = s
					check_soldiers_ts = store.tick_ts

					U.y_wait(store, this.spawn_delay)
					U.y_animation_play(this, "close", nil, store.tick_ts)

					this.render.sprites[1].hidden = true

					goto label_741_0
				end
			end
		end

		if b.rally_new then
			b.rally_new = false

			signal.emit("rally-point-changed", this)

			local all_dead = true

			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers, math.pi * 0.25)
				s.nav_rally.new = true
				all_dead = all_dead and s.health.dead
			end

			if not all_dead then
				S:queue(this.tower_ref.sound_events.change_rally_point)
			end
		end

		::label_741_0::

		coroutine.yield()
	end

	queue_remove(store, this)
end

function scripts.controller_tower_dark_elf_soldiers.remove(this, store)
	if this.tower_ref then
		local b = this.tower_ref.barrack

		for i = 1, b.max_soldiers do
			local s = b.soldiers[i]

			if s then
				queue_remove(store, s)
			end
		end
	end

	return true
end

scripts.mod_tower_dark_elf_skill_buff = {}

function scripts.mod_tower_dark_elf_skill_buff.remove(this, store)
	local tower = store.entities[this.tower_id]

	if not tower then
		return true
	end

	local target = store.entities[this.modifier.target_id]

	if not target or not target.health.dead then
		return true
	end

	local bullet = E:create_entity(this.skill_buff_bullet)

	bullet.pos = V.vclone(this.pos)
	bullet.bullet.to = V.v(tower.pos.x + this.tower_offset.x, tower.pos.y + this.tower_offset.y)
	bullet.bullet.from = V.vclone(bullet.pos)
	bullet.bullet.target_id = this.tower_id
	bullet.bullet.source_id = this.modifier.source_id

	queue_insert(store, bullet)

	return true
end

scripts.bullet_tower_dark_elf_skill_buff = {}

function scripts.bullet_tower_dark_elf_skill_buff.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	U.y_animation_play(this, "soul_start", nil, store.tick_ts, 1)

	local tower = store.entities[b.target_id]

	if not tower and this.tween.disabled then
		this.tween.disabled = false
		this.tween.ts = store.tick_ts
	end

	S:queue(this.sound_start)
	U.y_animation_play(this, "soul_travelstart", nil, store.tick_ts, 1)

	::label_744_0::

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		U.animation_start(this, "soul_travel", nil, store.tick_ts, s.loop)

		if ps then
			ps.particle_system.emit = true
		end
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		if target and target.health and not target.health.dead then
			if b.ignore_hit_offset then
				b.to.x, b.to.y = target.pos.x, target.pos.y
			else
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end

			new_target = false
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end

		local tower = store.entities[b.target_id]

		if not tower and this.tween.disabled then
			this.tween.disabled = false
			this.tween.ts = store.tick_ts
		end
	end

	while b.store and not b.target_id do
		coroutine.yield()

		if b.target_id then
			mspeed = b.min_speed
			new_target = true

			goto label_744_0
		end
	end

	local tower = store.entities[b.target_id]

	if not tower then
		queue_remove(store, this)

		return
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y

	if target then
		if tower and tower.powers and tower.powers.skill_buff then
			if not tower.tower_upgrade_persistent_data.souls_extra_damage_min then
				tower.tower_upgrade_persistent_data.souls_extra_damage_min = 0
				
			end

			if not tower.tower_upgrade_persistent_data.souls_extra_damage_max then
				tower.tower_upgrade_persistent_data.souls_extra_damage_max = 0
			end

			if not tower.tower_upgrade_persistent_data.souls_armor_reduction then
				tower.tower_upgrade_persistent_data.souls_armor_reduction = 0
			end

			if not tower.tower_upgrade_persistent_data.fps then
				tower.tower_upgrade_persistent_data.fps = FPS
			end

			if not tower.attacks.list[1]._original_shoot_time then
				tower.attacks.list[1]._original_shoot_time = tower.attacks.list[1].shoot_time
				tower.attacks.list[1]._original_cooldown = tower.attacks.list[1].cooldown
			end

			local increaseDamageMin = tower.powers.skill_buff.damage_min[tower.powers.skill_buff.level]
			local increaseDamageMax = tower.powers.skill_buff.damage_max[tower.powers.skill_buff.level]
			local increaseArmorReduction = tower.powers.skill_buff.armor_reduction[tower.powers.skill_buff.level] / 100
			local fpsIncrement = tower.powers.skill_buff.fps_increment[tower.powers.skill_buff.level]

			tower.tower_upgrade_persistent_data.souls_extra_damage_min = tower.tower_upgrade_persistent_data.souls_extra_damage_min + increaseDamageMin
			tower.tower_upgrade_persistent_data.souls_extra_damage_max = tower.tower_upgrade_persistent_data.souls_extra_damage_max + increaseDamageMax
			tower.tower_upgrade_persistent_data.souls_armor_reduction = math.min(tower.tower_upgrade_persistent_data.souls_armor_reduction + increaseArmorReduction, 
			tower.powers.skill_buff.max_armor_reduction)
			tower.tower_upgrade_persistent_data.fps = math.min(tower.tower_upgrade_persistent_data.fps + fpsIncrement, tower.powers.skill_buff.max_fps)
			tower.render.sprites[tower.render.sid_archer].fps = tower.tower_upgrade_persistent_data.fps
			tower.attacks.list[1].shoot_time = tower.attacks.list[1]._original_shoot_time * FPS / tower.tower_upgrade_persistent_data.fps
			tower.attacks.list[1].cooldown = math.max(tower.attacks.list[1]._original_cooldown * FPS / tower.tower_upgrade_persistent_data.fps, 1)
		end

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id
				m.modifier.level = b.level

				queue_insert(store, m)
			end
		end

		if b.hit_payload then
			local hp = b.hit_payload

			hp.pos.x, hp.pos.y = this.pos.x, this.pos.y

			queue_insert(store, hp)
		end
	end

	if b.payload then
		local hp = b.payload

		hp.pos.x, hp.pos.y = b.to.x, b.to.y

		queue_insert(store, hp)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.tower_hermit_toad = {}

function scripts.tower_hermit_toad.get_info(this)
	local index = 1
	local type = STATS_TYPE_TOWER

	if this.tower.kind == TOWER_KIND_MAGE then
		index = 2
		type = STATS_TYPE_TOWER_MAGE
	end

	if this.changing_to_new_mode then
		if this.changing_to_new_mode == 0 then
			index = 1
			type = STATS_TYPE_TOWER
		else
			index = 2
			type = STATS_TYPE_TOWER_MAGE
		end
	end

	local min, max, d_type

	if this.attacks and this.attacks.list[index].damage_min then
		min, max = this.attacks.list[index].damage_min, this.attacks.list[index].damage_max
	elseif this.attacks and this.attacks.list[index].bullet then
		local b = E:get_template(this.attacks.list[index].bullet)

		min, max = b.bullet.damage_min, b.bullet.damage_max
		d_type = b.bullet.damage_type
	end

	min, max = math.ceil(min * this.tower.damage_factor), math.ceil(max * this.tower.damage_factor)

	local cooldown

	if this.attacks and this.attacks.list[index].cooldown then
		cooldown = this.attacks.list[index].cooldown
	end

	return {
		type = type,
		damage_min = min,
		damage_max = max,
		damage_type = d_type,
		range = this.attacks.range,
		cooldown = cooldown
	}
end

function scripts.tower_hermit_toad.update(this, store)
	local last_ts = store.tick_ts
	local a_name, a_flip, angle_idx, target, targets, pred_pos
	local attack_engineer = this.attacks.list[1]
	local attack_mage = this.attacks.list[2]
	local attack_instakill = this.attacks.list[3]
	local attack_jump = this.attacks.list[4]
	local attack
	local pow_instakill = this.powers and this.powers.instakill or nil
	local pow_jump = this.powers and this.powers.jump or nil
	local last_idle_ts = store.tick_ts
	local MODE_ENGINEER = 0
	local MODE_MAGE = 1

	if this.tower_upgrade_persistent_data.bubbles_mage_area_id and not store.entities[this.tower_upgrade_persistent_data.bubbles_mage_area_id] then
		this.tower_upgrade_persistent_data.bubbles_mage_area_id = nil
	end

	if this.tower_upgrade_persistent_data.bubbles_mage_id and not store.entities[this.tower_upgrade_persistent_data.bubbles_mage_id] then
		this.tower_upgrade_persistent_data.bubbles_mage_id = nil
	end

	if this.tower_upgrade_persistent_data.bubbles_engineer_id and not store.entities[this.tower_upgrade_persistent_data.bubbles_engineer_id] then
		this.tower_upgrade_persistent_data.bubbles_engineer_id = nil
	end

	if not this.tower_upgrade_persistent_data.bubbles_mage_area_id then
		local ps = E:create_entity(this.ps_bubbles_mage_area)

		ps.particle_system.track_id = this.id
		ps.particle_system.track_offset = this.ps_bubbles_mage_area_offset
		ps.particle_system.emit_speed = this.ps_bubbles_mage_area_emit_speed
		ps.particle_system.scale_var = this.ps_bubbles_mage_area_scale_var
		ps.particle_system.emission_rate = this.ps_bubbles_mage_area_emission_rate

		queue_insert(store, ps)

		this.tower_upgrade_persistent_data.bubbles_mage_area_id = ps.id

		if this.tower_upgrade_persistent_data.current_mode == MODE_ENGINEER then
			ps.particle_system.emit = false
		end
	else
		local ps = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_area_id]

		ps.particle_system.track_id = this.id
		ps.particle_system.track_offset = this.ps_bubbles_mage_area_offset
		ps.particle_system.emit_speed = this.ps_bubbles_mage_area_emit_speed
		ps.particle_system.scale_var = this.ps_bubbles_mage_area_scale_var
		ps.particle_system.emission_rate = this.ps_bubbles_mage_area_emission_rate
	end

	if not this.tower_upgrade_persistent_data.bubbles_mage_id then
		local ps = E:create_entity(this.ps_bubbles_mage)

		ps.particle_system.track_id = this.id
		ps.particle_system.track_offset = this.ps_bubbles_mage_offset
		ps.particle_system.emit_speed = this.ps_bubbles_mage_emit_speed
		ps.particle_system.scale_var = this.ps_bubbles_mage_scale_var
		ps.particle_system.emission_rate = this.ps_bubbles_mage_emission_rate

		queue_insert(store, ps)

		this.tower_upgrade_persistent_data.bubbles_mage_id = ps.id

		if this.tower_upgrade_persistent_data.current_mode == MODE_ENGINEER then
			ps.particle_system.emit = false
		end
	else
		local ps = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_id]

		ps.particle_system.track_id = this.id
		ps.particle_system.track_offset = this.ps_bubbles_mage_offset
		ps.particle_system.emit_speed = this.ps_bubbles_mage_emit_speed
		ps.particle_system.scale_var = this.ps_bubbles_mage_scale_var
		ps.particle_system.emission_rate = this.ps_bubbles_mage_emission_rate
	end

	if not this.tower_upgrade_persistent_data.bubbles_engineer_id then
		local ps = E:create_entity(this.ps_bubbles_engineer)

		ps.particle_system.track_id = this.id
		ps.particle_system.track_offset = this.ps_bubbles_engineer_offset
		ps.particle_system.emit_speed = this.ps_bubbles_engineer_emit_speed
		ps.particle_system.scale_var = this.ps_bubbles_engineer_scale_var
		ps.particle_system.emission_rate = this.ps_bubbles_engineer_emission_rate

		queue_insert(store, ps)

		this.tower_upgrade_persistent_data.bubbles_engineer_id = ps.id

		if this.tower_upgrade_persistent_data.current_mode == MODE_MAGE then
			ps.particle_system.emit = false
		end
	else
		local ps = store.entities[this.tower_upgrade_persistent_data.bubbles_engineer_id]

		ps.particle_system.track_id = this.id
		ps.particle_system.track_offset = this.ps_bubbles_engineer_offset
		ps.particle_system.emit_speed = this.ps_bubbles_engineer_emit_speed
		ps.particle_system.scale_var = this.ps_bubbles_engineer_scale_var
		ps.particle_system.emission_rate = this.ps_bubbles_engineer_emission_rate
	end

	local function pause_area_ps()
		local ps_bubbles_mage_area = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_area_id]

		if ps_bubbles_mage_area then
			ps_bubbles_mage_area.particle_system.emit = false
		end
	end

	local function resume_area_ps()
		if this.tower_upgrade_persistent_data.current_mode == MODE_MAGE then
			local ps_bubbles_mage_area = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_area_id]

			if ps_bubbles_mage_area then
				ps_bubbles_mage_area.particle_system.emit = true
			end
		end
	end

	local function pause_pipe_ps()
		local ps_bubbles_mage = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_id]
		local ps_bubbles_engineer = store.entities[this.tower_upgrade_persistent_data.bubbles_engineer_id]

		if ps_bubbles_mage then
			ps_bubbles_mage.particle_system.emit = false
		end

		if ps_bubbles_engineer then
			ps_bubbles_engineer.particle_system.emit = false
		end
	end

	local function resume_pipe_ps()
		if this.tower_upgrade_persistent_data.current_mode == MODE_ENGINEER then
			local ps_bubbles_engineer = store.entities[this.tower_upgrade_persistent_data.bubbles_engineer_id]

			if ps_bubbles_engineer then
				ps_bubbles_engineer.particle_system.emit = true
			end
		else
			local ps_bubbles_mage = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_id]

			if ps_bubbles_mage then
				ps_bubbles_mage.particle_system.emit = true
			end
		end
	end

	local function create_splash_fx()
		local fx = E:create_entity(this.fx_splash)

		fx.pos = V.v(this.pos.x + this.fx_splash_offset.x, this.pos.y + this.fx_splash_offset.y)
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].color = this.tower_upgrade_persistent_data.current_mode == MODE_MAGE and {
			239,
			156,
			255
		} or {
			41,
			226,
			219
		}

		queue_insert(store, fx)
	end

	local function get_mode_anim(anim_table, mode)
		return anim_table[(mode and mode or this.tower_upgrade_persistent_data.current_mode) + 1]
	end

	local function change_mode(new_mode, with_animation)
		this.changing_to_new_mode = new_mode

		pause_pipe_ps()
		pause_area_ps()

		if with_animation == nil or with_animation then
			local anim_name = new_mode == MODE_MAGE and "changetower2" or "changetower"

			U.animation_start(this, anim_name, nil, store.tick_ts, false, this.render.sid_toad)

			if this.render.sid_leaf then
				U.animation_start(this, "changetower", nil, store.tick_ts, false, this.render.sid_leaf)
			end

			U.y_wait(store, fts(9))
			create_splash_fx()
			U.y_wait(store, fts(24))
		else
			U.animation_start(this, get_mode_anim(this.render.bubbles_anims, new_mode), nil, this.render.sprites[this.render.sid_bubbles].ts, true, this.render.sid_bubbles)
		end

		this.tower_upgrade_persistent_data.current_mode = new_mode
		this.render.sprites[2].name = this.idle_modes[new_mode + 1]

		if new_mode == MODE_ENGINEER then
			this.tower.kind = TOWER_KIND_ENGINEER
			this.attacks.range = attack_engineer.range[this.tower.level]
		else
			this.tower.kind = TOWER_KIND_MAGE
			this.attacks.range = attack_mage.range[this.tower.level]
		end

		local mods_list = table.filter(store.entities, function(k, v)
			return v.modifier and v.modifier.target_id == this.id
		end)

		if mods_list and #mods_list > 0 then
			for _, v in pairs(mods_list) do
				if v.range_factor then
					this.attacks.range = this.attacks.range * v.range_factor
				end
			end
		end

		if with_animation == nil or with_animation then
			create_splash_fx()
			U.animation_start(this, get_mode_anim(this.render.bubbles_anims, new_mode), nil, this.render.sprites[this.render.sid_bubbles].ts, true, this.render.sid_bubbles)
			U.y_animation_wait(this, this.render.sid_toad)
		end

		resume_pipe_ps()
		resume_area_ps()

		this.changing_to_new_mode = nil
	end

	change_mode(this.tower_upgrade_persistent_data.current_mode, false)

	if this.tower.level > 1 then
		create_splash_fx()
	end

	local function check_change_mode()
		if this.change_mode then
			this.change_mode = false

			if this.tower_upgrade_persistent_data.current_mode == MODE_ENGINEER then
				change_mode(MODE_MAGE)
			else
				change_mode(MODE_ENGINEER)
			end
		end
	end

	local function customEaseFastEndsSlowMiddle(t)
		if t < 0.5 then
			return (t / 0.5)^1.2 / 2
		else
			return 1 - ((1 - t) / 0.5)^1.5 / 2
		end
	end

	local function parabola_position(p1, p2, t, height_factor)
		local eased_t = customEaseFastEndsSlowMiddle(t)
		local mid_x = (p1.x + p2.x) / 2
		local mid_y = math.min(p1.y, p2.y) - height_factor
		local x = (1 - eased_t)^2 * p1.x + 2 * (1 - eased_t) * eased_t * mid_x + eased_t^2 * p2.x
		local y = (1 - eased_t)^2 * p1.y + 2 * (1 - eased_t) * eased_t * mid_y + eased_t^2 * p2.y

		return {
			x = x,
			y = y
		}
	end

	local function linear_position(p1, p2, t)
		local x = p1.x + (p2.x - p1.x) * t
		local y = p1.y + (p2.y - p1.y) * t

		return {
			x = x,
			y = y
		}
	end

	local function y_toad_flip(af)
		if this.render.sprites[this.render.sid_toad].flip_x == af or af == nil then
			return
		end

		pause_pipe_ps()

		local an = get_mode_anim(this.toad_flip_anims)

		U.y_animation_play(this, get_mode_anim(this.toad_flip_anims), nil, store.tick_ts, 1, this.render.sid_toad)
		resume_pipe_ps()

		local ps_bubbles_engineer = store.entities[this.tower_upgrade_persistent_data.bubbles_engineer_id]

		if ps_bubbles_engineer then
			ps_bubbles_engineer.particle_system.track_offset.x = -ps_bubbles_engineer.particle_system.track_offset.x
		end

		local ps_bubbles_mage = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_id]

		if ps_bubbles_mage then
			ps_bubbles_mage.particle_system.track_offset.x = -ps_bubbles_mage.particle_system.track_offset.x
		end

		U.animation_start(this, get_mode_anim(this.idle_modes), af, store.tick_ts, true, this.render.sid_toad)
	end

	local function find_target(a, range)
		local target, targets, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, range, a.node_prediction + this.toad_flip_duration / 2, a.vis_flags, a.vis_bans)

		return target, targets, pred_pos
	end

	local function y_toad_animation_finished_check_change_mode()
		while not U.animation_finished(this, this.render.sid_toad, 1) do
			coroutine.yield()
		end
	end

	local function y_toad_wait_time_check_change_mode(wait_time)
		local wait_ts_start = store.tick_ts

		while wait_time > store.tick_ts - wait_ts_start do
			coroutine.yield()
		end
	end

	local function check_upgrades_purchase()
		if this.powers then
			for _, pow in pairs(this.powers) do
				if pow.changed then
					pow.changed = nil

					local pa = this.attacks.list[pow.attack_idx]

					pa.cooldown = pow.cooldown[pow.level]

					if pow.level == 1 then
						pa.ts = store.tick_ts - pa.cooldown
					end

					if pow.damage_min then
						pa.damage_min = pow.damage_min[pow.level]
					end

					if pow.damage_max then
						pa.damage_max = pow.damage_max[pow.level]
					end
				end
			end
		end
	end

	if not this.attacks._last_target_pos then
		this.attacks._last_target_pos = {}
		this.attacks._last_target_pos = v(REF_W, 0)
	end

	local an, af = U.animation_name_facing_point(this, get_mode_anim(this.idle_modes), this.attacks._last_target_pos, this.render.sid_toad)

	U.animation_start(this, an, af, store.tick_ts, 1, this.render.sid_toad)

	if this.tower_upgrade_persistent_data.last_ts then
		last_ts = this.tower_upgrade_persistent_data.last_ts
		attack_engineer.ts = this.tower_upgrade_persistent_data.last_ts
		attack_mage.ts = this.tower_upgrade_persistent_data.last_ts
	else
		attack_engineer.ts = store.tick_ts - attack_engineer.cooldown + attack_engineer.first_cooldown
		attack_mage.ts = store.tick_ts - attack_mage.cooldown + attack_mage.first_cooldown
	end

	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			check_change_mode()
			SU.towers_swaped(store, this, this.attacks.list)
			check_upgrades_purchase()

			if pow_instakill and pow_instakill.level > 0 and this.tower.can_do_magic then
				attack = attack_instakill

				if store.tick_ts - attack.ts > attack.cooldown then
					target, targets, pred_pos = find_target(attack, attack.range)

					if not target then
						SU.delay_attack(store, attack, fts(10))
					elseif U.has_modifiers(store, target, attack.mark_mod) then
						SU.delay_attack(store, attack, fts(10))
					else
						local mark_mod = E:create_entity(attack.mark_mod)

						mark_mod.modifier.level = attack.level
						mark_mod.modifier.target_id = target.id
						mark_mod.modifier.source_id = this.id

						queue_insert(store, mark_mod)

						local pushed_bans = U.push_bans(target.vis, F_EAT)
						local a_name, a_flip, angle_idx
						local start_ts = store.tick_ts

						this.attacks._last_target_pos = pred_pos

						local an, af, angle_idx = U.animation_name_facing_point(this, get_mode_anim(attack.animation), pred_pos, this.render.sid_toad)

						y_toad_flip(af)
						pause_pipe_ps()
						U.animation_start(this, an, af, store.tick_ts, false, this.render.sid_toad)
						coroutine.yield()
						U.pop_bans(target.vis, pushed_bans)
						coroutine.yield()
						y_toad_wait_time_check_change_mode(attack.shoot_time)
						S:queue(attack.sound)

						local retarget, targets, new_pos = find_target(attack, attack.range)
						local target_pos

						if retarget then
							target_pos = V.vclone(target.pos)
							pred_pos = new_pos
							target = retarget
							this.attacks._last_target_pos = pred_pos
						else
							target = nil
							target_pos = pred_pos
						end

						local bullet = E:create_entity(attack.bullet)

						bullet.pos = V.vclone(this.pos)

						local offset_x = af and -attack.bullet_start_offset[angle_idx].x or attack.bullet_start_offset[angle_idx].x
						local offset_y = attack.bullet_start_offset[angle_idx].y

						bullet.pos = V.v(this.pos.x + offset_x, this.pos.y + offset_y)
						bullet.bullet.from = V.vclone(bullet.pos)
						bullet.bullet.to = target and V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y) or pred_pos
						bullet.bullet.target_id = target and target.id or nil
						bullet.bullet.source_id = this.id

						queue_insert(store, bullet)

						local bullet_from = V.vclone(bullet.bullet.from)
						local bullet_to = V.vclone(bullet.bullet.to)

						U.y_wait(store, fts(1))

						if target then
							local is_exo = false

							for k, v in pairs(target.render.sprites) do
								if v.exo then
									is_exo = true

									break
								end
							end

							local es = E:create_entity("decal")

							es.pos = V.vclone(bullet_to)

							local diff = V.v(bullet_from.x - bullet_to.x, bullet_from.y - bullet_to.y)
							local length = V.len(diff.x, diff.y)
							local normal_x, normal_y = V.normalize(diff.x, diff.y)
							local angle = V.angleTo(normal_x, normal_y)
							local entity_frame_names = {}

							for _, es in pairs(target.render.sprites) do
								if es.animated then
									table.insert(entity_frame_names, es.frame_name)
								else
									table.insert(entity_frame_names, es.name)
								end
							end

							local sprites_offset = {}

							sprites_offset.x, sprites_offset.y = V.sub(target.pos.x, target.pos.y, es.pos.x, es.pos.y)

							if not is_exo then
								es.render.sprites[1] = table.deepclone(target.render.sprites[1])
								local sprite1 = es.render.sprites[1]
								sprite1.shader = es.shader
								sprite1.shader_args = es.shader_args
								sprite1.animated = false
								sprite1.prefix = nil
								sprite1.name = entity_frame_names[1]
								if not sprite1.offset then
									sprite1.offset = V.vv(0)
								end
								sprite1.offset.x, sprite1.offset.y = V.add(sprite1.offset.x, sprite1.offset.y, sprites_offset.x, sprites_offset.y)

								queue_insert(store, es)
								coroutine.yield()
								U.sprites_hide(target, nil, nil, true)
							end

							es.render.sprites[1].z = Z_BULLETS + 1
							es.r = angle

							if not es.render.sprites[1].scale then
								es.render.sprites[1].scale = V.vv(1)
							end

							local orig_scale = V.vclone(es.render.sprites[1].scale)
							local eaten = false

							while not eaten do
								if bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0001" or bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0002" then
									-- block empty
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0003" then
									es.pos = V.v(bullet_to.x + normal_x * length * -0.01, bullet_to.y + normal_y * length * -0.01)
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0004" then
									es.pos = V.v(bullet_to.x + normal_x * length * -0.005, bullet_to.y + normal_y * length * -0.005)
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0005" then
									es.pos = V.v(bullet_to.x + normal_x * length * -0, bullet_to.y + normal_y * length * -0)
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0006" then
									es.pos = V.v(bullet_to.x + normal_x * length * 0.005, bullet_to.y + normal_y * length * 0.005)
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0007" then
									es.pos = V.v(bullet_to.x + normal_x * length * 0.05, bullet_to.y + normal_y * length * 0.05)
									es.render.sprites[1].scale = V.v(orig_scale.x * 0.95, orig_scale.y * 0.95)
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0008" then
									es.pos = V.v(bullet_to.x + normal_x * length * 0.08, bullet_to.y + normal_y * length * 0.08)
									es.render.sprites[1].scale = V.v(orig_scale.x * 0.93, orig_scale.y * 0.93)
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0009" then
									es.pos = V.v(bullet_to.x + normal_x * length * 0.45, bullet_to.y + normal_y * length * 0.45)
									es.render.sprites[1].scale = V.v(orig_scale.x * 0.9, orig_scale.y * 0.9)
									es.render.sprites[1].alpha = 225
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0010" then
									es.pos = V.v(bullet_to.x + normal_x * length * 0.49, bullet_to.y + normal_y * length * 0.49)
									es.render.sprites[1].scale = V.v(orig_scale.x * 0.88, orig_scale.y * 0.88)
									es.render.sprites[1].alpha = 200
								elseif bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0011" or bullet.render.sprites[1].frame_name == "hermit_toad_tower_tongue_0012" then
									es.pos = V.v(bullet_to.x + normal_x * length * 0.8, bullet_to.y + normal_y * length * 0.8)
									es.render.sprites[1].scale = V.v(orig_scale.x * 0.65, orig_scale.y * 0.65)
									es.render.sprites[1].alpha = 150

									coroutine.yield()
									queue_remove(store, es)

									eaten = true
								end

								coroutine.yield()
							end
						end

						y_toad_animation_finished_check_change_mode()
						resume_pipe_ps()

						attack.ts = start_ts
						last_ts = start_ts
						last_idle_ts = store.tick_ts

						goto label_885_0
					end
				end
			end

			if pow_jump and pow_jump.level > 0 and this.tower.can_do_magic then
				attack = attack_jump

				if store.tick_ts - attack.ts > attack.cooldown then
					target, targets, pred_pos = find_target(attack, attack.range)

					if not targets or #targets < attack.min_targets or not pred_pos then
						SU.delay_attack(store, attack, fts(10))
					else
						local a_name, a_flip, angle_idx
						local start_ts = store.tick_ts

						this.attacks._last_target_pos = pred_pos

						local an, af, angle_idx = U.animation_name_facing_point(this, get_mode_anim(attack.animation_start), pred_pos, this.render.sid_toad)

						y_toad_flip(af)
						pause_pipe_ps()
						U.animation_start(this, an, af, store.tick_ts, false, this.render.sid_toad)
						U.animation_start(this, "pathjumpbgin", nil, store.tick_ts, false, this.render.sid_leaf)
						y_toad_animation_finished_check_change_mode()
						U.animation_start(this, get_mode_anim(attack.animation_disappear), af, store.tick_ts, true, this.render.sid_toad)
						y_toad_wait_time_check_change_mode(attack.jump_in_delay)

						local retarget, targets, new_pos = find_target(attack, attack.range)

						if retarget then
							pred_pos = new_pos
							target = retarget
							this.attacks._last_target_pos = pred_pos
						else
							target = nil
						end

						this.render.sprites[this.render.sid_toad_jump].hidden = false
						this.render.sprites[this.render.sid_toad_jump].flip_x = this.render.sprites[this.render.sid_toad].flip_x
						this.render.sprites[this.render.sid_toad_jump].pos = V.vclone(pred_pos)

						U.animation_start(this, get_mode_anim(attack.animation_path_landing), nil, store.tick_ts, false, this.render.sid_toad_jump)
						y_toad_wait_time_check_change_mode(attack.path_landing_action_time)
						S:queue(attack.sound_fall)

						local t_mod = E:get_template(attack.mod)
						local enemies = table.filter(store.entities, function(k, v)
							return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, t_mod.modifier.vis_bans) == 0 and band(v.vis.flags, attack.vis_bans) == 0 and band(v.vis.bans, t_mod.modifier.vis_flags) == 0 and band(v.vis.bans, attack.vis_flags) == 0 and U.is_inside_ellipse(v.pos, pred_pos, attack.radius)
						end)

						for _, enemy in pairs(enemies) do
							local mod = E:create_entity(attack.mod)

							mod.modifier.level = attack.level
							mod.modifier.target_id = enemy.id
							mod.modifier.source_id = this.id

							queue_insert(store, mod)
						end

						local targets = U.find_enemies_in_range(store.entities, pred_pos, 0, attack.radius, attack.damage_flags, attack.damage_bans)

						if targets then
							for _, t in pairs(targets) do
								local d = E:create_entity("damage")

								d.damage_type = attack.damage_type

								local dist_factor = U.dist_factor_inside_ellipse(t.pos, pred_pos, attack.radius)

								d.value = math.floor(attack.damage_max - (attack.damage_max - attack.damage_min) * dist_factor)
								d.value = math.ceil(this.tower.damage_factor * d.value)
								d.source_id = this.id
								d.target_id = t.id

								queue_damage(store, d)
							end
						end

						local decal = E:create_entity(attack.jump_decal)

						decal.pos = V.vclone(pred_pos)
						decal.render.sprites[1].ts = store.tick_ts

						queue_insert(store, decal)

						while not U.animation_finished(this, this.render.sid_toad_jump, 1) do
							coroutine.yield()
						end

						y_toad_wait_time_check_change_mode(attack.jump_back_delay)

						local toad_jump_o_z = this.render.sprites[this.render.sid_toad_jump].z

						this.render.sprites[this.render.sid_toad_jump].z = Z_BULLETS

						S:queue(attack.sound_jump)
						U.animation_start(this, get_mode_anim(attack.animation_back_up), nil, store.tick_ts, false, this.render.sid_toad_jump)

						local orig_jump_pos = V.vclone(this.render.sprites[this.render.sid_toad_jump].pos)
						local jump_back_ts = store.tick_ts
						local elapsed_time = 0
						local doing_down_anim = false
						local decal_shadow = E:create_entity(attack.jump_back_shadow)

						decal_shadow.render.sprites[1].pos = V.vclone(this.pos)
						decal_shadow.render.sprites[1].ts = store.tick_ts

						queue_insert(store, decal_shadow)

						while elapsed_time < attack.jump_back_duration do
							local elapsed_percentage = elapsed_time / attack.jump_back_duration

							if elapsed_percentage > 0.5 and not doing_down_anim then
								U.animation_start(this, get_mode_anim(attack.animation_back_down), af, store.tick_ts, true, this.render.sid_toad_jump)

								doing_down_anim = true
							end

							this.render.sprites[this.render.sid_toad_jump].pos = parabola_position(orig_jump_pos, this.pos, elapsed_percentage, attack.jump_back_height)
							decal_shadow.render.sprites[1].pos = linear_position(orig_jump_pos, this.pos, elapsed_percentage)
							elapsed_time = store.tick_ts - jump_back_ts

							coroutine.yield()
						end

						queue_remove(store, decal_shadow)

						this.render.sprites[this.render.sid_toad_jump].hidden = true

						create_splash_fx()
						S:queue(attack.sound_back_to_pond)
						U.animation_start(this, "pathjumpbgout", nil, store.tick_ts, false, this.render.sid_leaf)
						U.animation_start(this, get_mode_anim(attack.animation_end), nil, store.tick_ts, false, this.render.sid_toad)

						this.render.sprites[this.render.sid_toad_jump].z = toad_jump_o_z

						y_toad_animation_finished_check_change_mode()
						resume_pipe_ps()

						attack.ts = start_ts
						last_ts = start_ts
						last_idle_ts = store.tick_ts

						goto label_885_0
					end
				end
			end

			if this.tower_upgrade_persistent_data.current_mode == MODE_ENGINEER then
				attack = attack_engineer
			else
				attack = attack_mage
			end

			if store.tick_ts - attack.ts > attack.cooldown then
				target, targets, pred_pos = find_target(attack, this.attacks.range)

				if not target then
					SU.delay_attack(store, attack, fts(10))

					goto label_885_0
				end

				local a_name, a_flip
				local start_ts = store.tick_ts

				this.attacks._last_target_pos = pred_pos

				local an, af = U.animation_name_facing_point(this, attack.animation, pred_pos, this.render.sid_toad)

				y_toad_flip(af)
				pause_pipe_ps()
				U.animation_start(this, an, af, store.tick_ts, false, this.render.sid_toad)
				y_toad_wait_time_check_change_mode(attack.shoot_time)
				S:queue(attack.sound)

				local retarget, targets, new_pos = find_target(attack, this.attacks.range * 1.1)

				if retarget then
					pred_pos = new_pos
					target = retarget
					this.attacks._last_target_pos = pred_pos
				else
					target = nil
				end

				local bullet = E:create_entity(attack.bullet)

				bullet.pos = V.vclone(this.pos)

				local offset_x = af and -attack.bullet_start_offset.x or attack.bullet_start_offset.x
				local offset_y = attack.bullet_start_offset.y

				bullet.pos = V.v(this.pos.x + offset_x, this.pos.y + offset_y)
				bullet.bullet.from = V.vclone(bullet.pos)
				bullet.bullet.to = V.vclone(pred_pos)
				bullet.bullet.target_id = target and target.id or nil
				bullet.bullet.source_id = this.id
				bullet.bullet.damage_factor = this.tower.damage_factor

				queue_insert(store, bullet)
				y_toad_animation_finished_check_change_mode()
				resume_pipe_ps()

				attack_engineer.ts = start_ts
				attack_mage.ts = start_ts
				last_ts = start_ts

				U.animation_start(this, get_mode_anim(this.idle_modes), nil, store.tick_ts, false, this.render.sid_toad)

				last_idle_ts = store.tick_ts

				goto label_885_0
			end

			this.tower_upgrade_persistent_data.last_ts = last_ts

			if store.tick_ts - last_idle_ts > this.idle_flip.cooldown then
				if math.random() < this.idle_flip.chance then
					local anims_table = {
						"flip",
						"idleanim",
						"blink",
						"blink"
					}
					local selected_anim = table.random(anims_table)

					if selected_anim == "flip" then
						y_toad_flip(not this.render.sprites[this.render.sid_toad].flip_x)
					elseif selected_anim == "idleanim" then
						U.y_animation_play(this, get_mode_anim(this.toad_idle_anims), nil, store.tick_ts, 1, this.render.sid_toad)
					elseif selected_anim == "blink" then
						U.y_animation_play(this, get_mode_anim(this.toad_blink_anims), nil, store.tick_ts, 1, this.render.sid_toad)
					end
				end

				last_idle_ts = store.tick_ts
			end
		end

		::label_885_0::

		coroutine.yield()
	end
end

function scripts.tower_hermit_toad.remove(this, store)
	if this.tower_upgrade_persistent_data.bubbles_engineer_id then
		local ps = store.entities[this.tower_upgrade_persistent_data.bubbles_engineer_id]

		if ps then
			queue_remove(store, ps)
		end

		this.tower_upgrade_persistent_data.bubbles_engineer_id = nil
	end

	if this.tower_upgrade_persistent_data.bubbles_mage_id then
		local ps = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_id]

		if ps then
			queue_remove(store, ps)
		end

		this.tower_upgrade_persistent_data.bubbles_mage_id = nil
	end

	if this.tower_upgrade_persistent_data.bubbles_mage_area_id then
		local ps = store.entities[this.tower_upgrade_persistent_data.bubbles_mage_area_id]

		if ps then
			queue_remove(store, ps)
		end

		this.tower_upgrade_persistent_data.bubbles_mage_area_id = nil
	end

	return true
end

scripts.bullet_tower_hermit_toad_engineer_basic = {}

function scripts.bullet_tower_hermit_toad_engineer_basic.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius

	if b.level and b.level > 0 then
		if b.damage_radius_inc then
			dradius = dradius + b.level * b.damage_radius_inc
		end

		if b.damage_min_inc then
			dmin = dmin + b.level * b.damage_min_inc
		end

		if b.damage_max_inc then
			dmax = dmax + b.level * b.damage_max_inc
		end
	end

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	local enemies = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, b.damage_bans) == 0 and band(v.vis.bans, b.damage_flags) == 0 and U.is_inside_ellipse(v.pos, b.to, dradius)
	end)

	for _, enemy in pairs(enemies) do
		local d = E:create_entity("damage")

		d.damage_type = b.damage_type
		d.reduce_armor = b.reduce_armor
		d.reduce_magic_armor = b.reduce_magic_armor

		if b.damage_decay_random then
			d.value = U.frandom(dmin, dmax)
		else
			local upg = UP:get_upgrade("towers_improved_formulas")
			local source = store.entities[b.source_id]

			if upg and source and source.tower then
				d.value = dmax
			else
				local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, b.to, dradius)

				d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
			end
		end

		d.value = math.ceil(b.damage_factor * d.value)
		d.source_id = this.id
		d.target_id = enemy.id

		if b.xp_gain_factor and b.xp_dest_id then
			d.xp_gain_factor = b.xp_gain_factor
			d.xp_dest_id = b.source_id
		end

		queue_damage(store, d)
		log.paranoid("bomb id:%s, radius:%s, enemy id:%s, dist:%s, damage:%s damage_type:%x", this.id, dradius, enemy.id, V.dist(enemy.pos.x, enemy.pos.y, b.to.x, b.to.y), d.value, d.damage_type)

		if this.up_shock_and_awe_chance and band(enemy.vis.bans, F_STUN) == 0 and band(enemy.vis.flags, bor(F_BOSS, F_CLIFF, F_FLYING)) == 0 and math.random() < this.up_shock_and_awe_chance then
			local mod = E:create_entity("mod_shock_and_awe")

			mod.modifier.target_id = enemy.id

			queue_insert(store, mod)
		end

		if b.mod then
			local mod = E:create_entity(b.mod)

			mod.modifier.target_id = enemy.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)
		end
	end

	local p = SU.create_bullet_pop(store, this)

	queue_insert(store, p)

	local cell_type = GR:cell_type(b.to.x, b.to.y)

	if b.hit_fx_water and band(cell_type, TERRAIN_WATER) ~= 0 then
		S:queue(this.sound_events.hit_water)

		local water_fx = E:create_entity(b.hit_fx_water)

		water_fx.pos.x, water_fx.pos.y = b.to.x, b.to.y
		water_fx.render.sprites[1].ts = store.tick_ts
		water_fx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, water_fx)
	elseif b.hit_fx then
		S:queue(this.sound_events.hit)

		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, sfx)
	end

	if b.hit_decal and band(cell_type, TERRAIN_WATER) == 0 then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
		else
			hp = b.hit_payload
		end

		hp.pos.x, hp.pos.y = b.to.x, b.to.y
		hp.source_id = b.source_id

		if hp.aura then
			hp.aura.level = this.bullet.level
			hp.aura.duration = this.aura_duration[this.bullet.level]
			hp.tween.props[1].keys = {
				{
					0,
					255
				},
				{
					hp.aura.duration - 0.5,
					255
				},
				{
					hp.aura.duration,
					0
				}
			}
		end

		queue_insert(store, hp)
	end

	queue_remove(store, this)
end

scripts.bullet_tower_hermit_toad_instakill_tongue = {}

function scripts.bullet_tower_hermit_toad_instakill_tongue.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local dest = V.vclone(b.to)

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle
		s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width
	end

	local function hit_target()
		if target then
			if b.mod then
				local mod = E:create_entity(b.mod)

				mod.modifier.target_id = target.id
				mod.modifier.source_id = source.id

				queue_insert(store, mod)
			end

			local d = SU.create_bullet_damage(b, target.id, this.id)

			queue_damage(store, d)

			if b.hit_fx then
				local fx = E:create_entity(b.hit_fx)

				fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
				fx.render.sprites[1].ts = store.tick_ts
				fx.render.sprites[1].flip_x = b.to.x > b.from.x

				queue_insert(store, fx)
			end

			target.unit.can_explode = false
			target.unit.death_animation = nil
			target.unit.hide_during_death = true
		elseif this.missed_shot and GR:cell_is_only(this.pos.x, this.pos.y, TERRAIN_LAND) then
			local fx = E:create_entity(this.missed_arrow_decal)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local fx = E:create_entity(this.missed_arrow_dust)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local fx = E:create_entity(this.missed_arrow)

			fx.pos = V.v(b.to.x, b.to.y)
			fx.render.sprites[1].ts = store.tick_ts
			fx.render.sprites[1].flip_x = b.to.x > b.from.x

			queue_insert(store, fx)
		end
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	local already_hit_target = false

	if this.ray_duration then
		while store.tick_ts - s.ts < this.ray_duration do
			if this.track_target then
				update_sprite()
			end

			if source and not store.entities[source.id] then
				queue_remove(store, this)

				break
			end

			if not already_hit_target and store.tick_ts - s.ts > this.hit_delay then
				hit_target()

				already_hit_target = true
			end

			coroutine.yield()

			s.hidden = false
		end
	else
		while not U.animation_finished(this, 1) do
			if source and not store.entities[source.id] then
				queue_remove(store, this)

				break
			end

			if not already_hit_target and store.tick_ts - s.ts > this.hit_delay then
				hit_target(b, target)

				already_hit_target = true
			end

			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.tower_dwarf = {}

function scripts.tower_dwarf.update(this, store, script)
	local tower_sid = 2
	local door_sid = 3
	local base_max_soldiers = 2
	local formation_angles = {
		math.pi * 0.25,
		math.pi,
		math.pi * 0.25
	}
	local angle_offset = math.pi * 0.25
	local mute_spawn = false

	while true do
		local b = this.barrack

		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					if p == this.powers.incendiary_ammo then
						for _, s in pairs(b.soldiers) do
							s.powers[pn].level = p.level
							s.powers[pn].changed = true
						end
					end

					if p == this.powers.formation then
						b.max_soldiers = base_max_soldiers + p.level
						b.rally_new = true
						angle_offset = formation_angles[p]
						mute_spawn = true
					end
				end
			end
		end

		if not this.tower.blocked then
			for i = 1, b.max_soldiers do
				local s = b.soldiers[i]

				if not s or s.health.dead and not store.entities[s.id] then
					if not b.door_open then
						S:queue("GUITowerOpenDoor")
						U.animation_start(this, "open", nil, store.tick_ts, 1, door_sid)

						while not U.animation_finished(this, door_sid) do
							coroutine.yield()
						end

						b.door_open = true
						b.door_open_ts = store.tick_ts
					end

					s = E:create_entity(b.soldier_type)
					s.soldier.tower_id = this.id
					s.soldier.tower_soldier_idx = i
					s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
					s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers, angle_offset)
					s.nav_rally.new = true

					if this.powers then
						for pn, p in pairs(this.powers) do
							if p == this.powers.incendiary_ammo and p.level > 0 then
								s.powers[pn].level = p.level
								s.powers[pn].changed = true
							end
						end
					end

					queue_insert(store, s)

					b.soldiers[i] = s

					signal.emit("tower-spawn", this, s)
				end
			end
		end

		if b.door_open and store.tick_ts - b.door_open_ts > b.door_hold_time then
			U.animation_start(this, "close", nil, store.tick_ts, 1, door_sid)

			while not U.animation_finished(this, door_sid) do
				coroutine.yield()
			end

			b.door_open = false
		end

		if b.rally_new then
			b.rally_new = false

			signal.emit("rally-point-changed", this)

			local all_dead = true

			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, b.max_soldiers, angle_offset)
				s.nav_rally.new = true
				s.nav_rally.group_index = i - 1
				s.nav_rally.group_total = #b.soldiers
				all_dead = all_dead and s.health.dead
			end

			if not all_dead and not mute_spawn then
				S:queue(this.sound_events.change_rally_point)
			end

			mute_spawn = false
		end

		coroutine.yield()
	end
end

scripts.soldier_tower_dwarf = {}

function scripts.soldier_tower_dwarf.insert(this, store)
	if scripts.soldier_barrack.insert(this, store) then
		local pow_h = this.powers and this.powers.healing_prayer or nil
		local pow_l = this.powers and this.powers.lead or nil
		local a_h = this.timed_attacks and this.timed_attacks.list[1] or nil
		local a_l = this.timed_attacks and this.timed_attacks.list[2] or nil

		return true
	end

	return false
end

function scripts.soldier_tower_dwarf.update(this, store, script)
	local brk, sta
	local pow_i = this.powers and this.powers.incendiary_ammo or nil
	local a_i = this.ranged.attacks[2] or nil
	local damage_factor_prev = this.health.damage_factor
	local mods = {}
	local first_walk = true

	if this.vis._bans then
		this.vis.bans = this.vis._bans
		this.vis._bans = nil
	end

	this.nav_rally._first_time = true

	local function y_soldier_new_rally_break_attack(store, this, break_fn, first_walk)
		local r = this.nav_rally
		local out = false
		local vis_bans = this.vis.bans
		local prev_immune = this.health.immune_to

		this.health.immune_to = r.immune_to
		this.vis.bans = F_ALL

		if r.new then
			r.new = false

			U.unblock_target(store, this)
			U.set_destination(this, r.pos)

			if r.delay_max then
				U.animation_start(this, this.idle_flip.last_animation, nil, store.tick_ts, this.idle_flip.loop)

				local index = this.soldier.tower_soldier_idx or 0
				local tower = store.entities[this.soldier.tower_id]
				local total = tower and tower.barrack.max_soldiers or 1

				if SU.y_soldier_wait(store, this, index / total * r.delay_max) then
					goto label_975_0
				end
			end

			local offset = V.v(r.pos.x - r.center.x, r.pos.y - r.center.y)
			local old_center = V.v(this.pos.x - offset.x, this.pos.y - offset.y)

			if V.dist2(r.center.x, r.center.y, old_center.x, old_center.y) < this.max_dist_walk * this.max_dist_walk or first_walk then
				local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

				U.animation_start(this, an, af, store.tick_ts, -1)

				while not this.motion.arrived do
					if this.health.dead or this.unit.is_stunned then
						out = true

						break
					end

					if r.new then
						out = false

						break
					end

					if break_fn() then
						out = false

						break
					end

					if r._first_time then
						r._first_time = false

						local target = U.find_foremost_enemy(store.entities, r.center, 0, this.melee.range, false, F_BLOCK, bit.bor(F_CLIFF), function(e)
							return (not e.enemy.max_blockers or #e.enemy.blockers == 0) and band(GR:cell_type(e.pos.x, e.pos.y), TERRAIN_NOWALK) == 0 and (not this.melee.fn_can_pick or this.melee.fn_can_pick(this, e))
						end)

						if target then
							out = false

							break
						end
					end

					U.walk(this, store.tick_length)
					coroutine.yield()

					this.motion.speed.x, this.motion.speed.y = 0, 0
				end
			else
				S:queue(this.sound_jump)

				local an, af = U.animation_name_facing_point(this, "jump_in", this.motion.dest)

				U.y_animation_play(this, "jump_in", not af, store.tick_ts, 1)

				local d = E:create_entity(this._jump_explosion)

				d.pos = V.v(this.pos.x, this.pos.y)
				d.render.sprites[1].ts = store.tick_ts

				queue_insert(store, d)

				local prefix = this.render.sprites[1].prefix

				this.render.sprites[1].prefix = "name"
				this.render.sprites[1].name = this._jump_asset_name
				this.render.sprites[1].animated = false

				local g = -0.7 / (fts(1) * fts(1))
				local flight_time = 1
				local speed = SU.initial_parabola_speed(this.pos, this.nav_rally.pos, flight_time, g)
				local from = V.vclone(this.pos)
				local flying = true
				local ts = store.tick_ts
				local fpos = V.vclone(this.nav_rally.pos)
				local rotation_dir = this.nav_rally.pos.x - this.pos.x > 0 and -1 or 1
				local dist = V.dist(fpos.x, fpos.y, from.x, from.y)
				local dir = V.v((fpos.x - from.x) / dist, (fpos.y - from.y) / dist)

				this.motion.speed.x, this.motion.speed.y = 0, 0

				local shadow = this.render.sprites[2]

				while flying do
					coroutine.yield()

					this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - ts, from, speed, g)
					this.render.sprites[1].r = store.tick_ts * 50 * rotation_dir

					local dis_floor = (this.pos.x - from.x) / dir.x
					local height = this.pos.y - (dir.y * dis_floor + from.y)

					this.render.sprites[1].sort_y_offset = -height
					shadow.hidden = false
					shadow.offset.y = -height

					local s = km.clamp(0.5, 1, 40 / height)

					shadow.scale.x = s
					shadow.scale.y = s

					if flight_time - 0.05 < store.tick_ts - ts then
						shadow.hidden = true
						this.pos.x = fpos.x
						this.pos.y = fpos.y
						flying = false
						this.render.sprites[1].sort_y_offset = 0
					end
				end

				this.render.sprites[1].r = 0
				this.render.sprites[1].prefix = prefix
				this.render.sprites[1].animated = true

				U.y_animation_play(this, "jump_out", nil, store.tick_ts, 1)
				U.animation_start(this, "idle", nil, store.tick_ts, 1)
			end
		end

		::label_975_0::

		this.vis.bans = vis_bans
		this.health.immune_to = prev_immune

		return out
	end

	local function check_tower_damage_factor()
		if store.entities[this.soldier.tower_id] then
			for _, a in ipairs(this.melee.attacks) do
				if not a._original_damage_min then
					a._original_damage_min = a.damage_min
				end

				if not a._original_damage_max then
					a._original_damage_max = a.damage_max
				end

				a.damage_min = a._original_damage_min * store.entities[this.soldier.tower_id].tower.damage_factor
				a.damage_max = a._original_damage_max * store.entities[this.soldier.tower_id].tower.damage_factor
			end
		end
	end

	local function walk_break_fn()
		return pow_l and pow_l.changed
	end

	while true do
		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					SU.soldier_power_upgrade(this, pn)

					if p == pow_i then
						a_i.disabled = nil
						a_i.cooldown = p.cooldown
						a_i.level = p.level

						if p.level == 1 then
							a_i.ts = store.tick_ts - a_i.cooldown
						end
					end
				end
			end
		end

		if this.health.dead then
			this.ui.can_click = false

			SU.y_soldier_death(store, this)

			while true do
				if pow_l and pow_l.changed then
					queue_remove(store, this)
				end

				coroutine.yield()
			end
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if y_soldier_new_rally_break_attack(store, this, walk_break_fn, first_walk) then
					goto label_974_1
				end

				first_walk = false
			end

			check_tower_damage_factor()

			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			else
				brk, sta = SU.y_soldier_ranged_attacks(store, this)

				if brk or sta == A_DONE then
					goto label_974_1
				elseif sta == A_IN_COOLDOWN and not this.ranged.go_back_during_cooldown then
					goto label_974_0
				end

				if SU.soldier_go_back_step(store, this) then
					goto label_974_1
				end

				::label_974_0::

				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_974_1::

		coroutine.yield()
	end
end

scripts.bullet_soldier_tower_dwarf = {}

function scripts.bullet_soldier_tower_dwarf.update(this, store)
	local b = this.bullet
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]

	b.damage_min = b.damage_min_config[b.level]
	b.damage_max = b.damage_max_config[b.level]

	local tower = source and store.entities[source.soldier.tower_id]

	U.y_wait(store, b.flight_time)

	if target then
		if tower then
			local tower_damage_factor = tower.tower.damage_factor

			b.damage_factor = tower_damage_factor
		end

		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		local fx = E:create_entity(b.hit_fx)

		fx.pos = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	queue_remove(store, this)
end

scripts.tower_sparking_geode = {}

function scripts.tower_sparking_geode.get_info(this)
	local b = E:get_template(this.attacks.list[1].bullet)
	local o = scripts.tower_common.get_info(this)

	o.type = STATS_TYPE_TOWER
	o.damage_min = math.ceil(b.bullet.damage_min * this.tower.damage_factor)
	o.damage_max = math.ceil(b.bullet.damage_max * this.tower.damage_factor)
	o.cooldown = (this.attacks.list[1].ray_timing_min + this.attacks.list[1].ray_timing_max) / 2

	return o
end

function scripts.tower_sparking_geode.update(this, store, script)
	local last_target_pos
	local a = this.attacks
	local a_basic = this.attacks.list[1]
	local a_crystalize = this.attacks.list[2]
	local a_burst = this.attacks.list[3]
	local shots = 5
	local pow_crystalize = this.powers and this.powers.crystalize or nil
	local pow_burst = this.powers and this.powers.spike_burst or nil
	local last_ts = store.tick_ts - a_basic.cooldown

	a._last_target_pos = a._last_target_pos or v(REF_W, 0)
	a_basic.ts = store.tick_ts - a_basic.cooldown + a.attack_delay_on_spawn

	local sid_geode = this.render.sid_geode
	local sid_base = this.render.sid_base_electricity
	local sid_attack_fx = this.render.sid_attack_fx

	local function update_powers()
		if this.powers then
			for k, pow in pairs(this.powers) do
				if pow.changed then
					pow.changed = nil

					if pow == pow_crystalize then
						a_crystalize.cooldown = pow.cooldown[pow.level]

						if pow.level == 1 then
							a_crystalize.ts = store.tick_ts - a_crystalize.cooldown
						end
					end

					if pow == pow_burst then
						a_burst.cooldown = pow.cooldown[pow.level]

						if pow.level == 1 then
							a_burst.ts = store.tick_ts - a_burst.cooldown
						end
					end
				end
			end
		end
	end

	local function create_evolve_fx()
		local fx = E:create_entity(this.fx_evolve)

		fx.pos = V.v(this.pos.x + this.fx_evolve_offset.x, this.pos.y + this.fx_evolve_offset.y)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	local function can_crystalize()
		if not this.tower.can_do_magic then
			return false
		end

		if not a_crystalize then
			return false
		end

		if not pow_crystalize then
			return false
		end

		if pow_crystalize.level < 1 then
			return false
		end

		if not (store.tick_ts - a_crystalize.ts > a_crystalize.cooldown) then
			return false
		end

		if not (store.tick_ts - last_ts > a.min_cooldown) then
			return false
		end

		local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.range, a_crystalize.vis_flags, a_crystalize.vis_bans)

		if not enemies then
			SU.delay_attack(store, a_crystalize, fts(10))

			return false
		end

		return true
	end

	local function can_spike_burst()
		if not this.tower.can_do_magic then
			return false
		end

		if not a_burst then
			return false
		end

		if not pow_burst then
			return false
		end

		if pow_burst.level < 1 then
			return false
		end

		if not (store.tick_ts - a_burst.ts > a_burst.cooldown) then
			return false
		end

		if not (store.tick_ts - last_ts > a.min_cooldown) then
			return false
		end

		local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a_burst.range, a_burst.vis_flags, a_burst.vis_bans)

		if not enemies then
			SU.delay_attack(store, a_burst, fts(10))

			return false
		end

		return true
	end

	local function a_basic_break()
		update_powers()

		if this.tower.blocked then
			return true
		end

		if this.tower_upgrade_persistent_data.swaped then
			return true
		end

		if can_crystalize() then
			return true
		end

		if can_spike_burst() then
			return true
		end

		return false
	end

	if this.tower.level > 1 then
		create_evolve_fx()
	end

	U.animation_start(this, "idleup", nil, store.tick_ts, true, sid_geode, true)
	U.animation_start(this, "on_loop", nil, store.tick_ts, true, sid_base, true)

	while true do
		update_powers()
		SU.towers_swaped(store, this, this.attacks.list)

		if this.tower.blocked then
			-- block empty
		else
			if can_crystalize() then
				local start_ts = store.tick_ts

				S:queue(a_crystalize.sound_cast)
				U.animation_start(this, a_crystalize.animation, nil, store.tick_ts, false, sid_geode)
				U.y_wait(store, a_crystalize.cast_time)

				local fx = E:create_entity(a_crystalize.up_ray_fx)

				fx.pos = V.v(this.pos.x, this.pos.y + 70)
				fx.render.sprites[1].ts = store.tick_ts
				fx.render.sprites[2].ts = store.tick_ts

				queue_insert(store, fx)
				U.y_wait(store, fts(11))

				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.range, a_crystalize.vis_flags, a_crystalize.vis_bans)

				if not enemies then
					a_crystalize.ts = store.tick_ts + a_crystalize.cooldown * 0.2
				else
					enemies = table.random_order(enemies)
					enemies = table.slice(enemies, 1, a_crystalize.max_targets[pow_crystalize.level])

					for _, enemy in pairs(enemies) do
						local mod = E:create_entity(a_crystalize.mod)

						mod.modifier.source_id = this.id
						mod.modifier.target_id = enemy.id
						mod.modifier.duration = a_crystalize.duration[pow_crystalize.level]
						mod.received_damage_factor = a_crystalize.received_damage_factor[pow_crystalize.level]

						queue_insert(store, mod)
						U.y_wait(store, fts(2))
					end

					a_crystalize.ts = start_ts
				end

				U.y_animation_wait(this, sid_geode)
				U.animation_start(this, "idleup", nil, store.tick_ts, true, sid_geode)

				goto label_1047_0
			end

			if can_spike_burst() then
				local start_ts = store.tick_ts

				S:queue(a_burst.sound_cast)
				U.animation_start(this, a_burst.animation, nil, store.tick_ts, false, sid_geode)
				U.y_wait(store, a_burst.cast_time)
				S:queue(a_burst.sound_loop)

				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a_burst.range, a_burst.vis_flags, a_burst.vis_bans)

				if not enemies then
					a_burst.ts = store.tick_ts + a_burst.cooldown * 0.2
				else
					do
						local spike_burst_aura = E:create_entity(a_burst.aura)

						spike_burst_aura.pos = V.vclone(this.pos)
						spike_burst_aura.aura.source_id = this.id
						spike_burst_aura.aura.ts = store.tick_ts
						spike_burst_aura.aura.duration = a_burst.duration[pow_burst.level]
						spike_burst_aura.aura.level = pow_burst.level

						queue_insert(store, spike_burst_aura)
					end

					a_burst.ts = start_ts
				end

				U.y_animation_wait(this, sid_geode)
				S:stop(a_burst.sound_loop)
				U.animation_start(this, "idleup", nil, store.tick_ts, true, sid_geode)

				goto label_1047_0
			end

			if store.tick_ts - a_basic.ts > a_basic.cooldown and store.tick_ts - last_ts > a.min_cooldown and not a_basic_break() then
				local ignore_out_of_range_check = true
				local target_pred_pos
				local enemy, enemies, _ = U.find_rearmost_enemy(store.entities, tpos(this), 0, a.range, a_basic.prediction_time, a_basic.vis_flags, a_basic.vis_bans)

				if not enemies or not enemy then
					SU.delay_attack(store, a_basic, fts(3))
				else
					local start_ts = store.tick_ts

					this.render.sprites[sid_attack_fx].hidden = false

					U.animation_start(this, a_basic.animation_start, nil, store.tick_ts, false, sid_geode)
					U.y_animation_play(this, "in", nil, store.tick_ts, false, sid_attack_fx)
					U.animation_start(this, a_basic.animation_loop, nil, store.tick_ts, true, sid_geode)
					U.animation_start(this, "loop", nil, store.tick_ts, true, sid_attack_fx)

					local _, new_enemies = U.find_rearmost_enemy(store.entities, tpos(this), 0, a.range, fts(9), a_basic.vis_flags, a_basic.vis_bans)

					if new_enemies then
						enemies = new_enemies
					end

					local shot_i = 1
					local zmod_target = 1

					while not a_basic_break() do
						if a_basic.targeting_style == 1 then
							enemy = table.random(enemies)
						else
							enemy = enemies[km.zmod(zmod_target, #enemies)]

							if zmod_target > #enemies then
								zmod_target = 1
							end
						end

						local in_range = ignore_out_of_range_check or U.is_inside_ellipse(tpos(this), enemy.pos, a.range * 1.1)
						local bullet = E:create_entity(a_basic.bullet)

						bullet.bullet.shot_index = shot_i
						bullet.bullet.damage_factor = this.tower.damage_factor
						bullet.bullet.source_id = this.id

						local node_offset = P:predict_enemy_node_advance(enemy, fts(9))
						local e_ni = enemy.nav_path.ni + node_offset

						target_pred_pos = P:node_pos(enemy.nav_path.pi, enemy.nav_path.spi, e_ni)

						if in_range then
							if enemy.health and not enemy.health.dead then
								bullet.bullet.to = V.v(target_pred_pos.x + enemy.unit.hit_offset.x, target_pred_pos.y + enemy.unit.hit_offset.y)
								bullet.bullet.target_id = enemy.id
							else
								bullet.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x + math.random(-20, 20), enemy.pos.y + enemy.unit.hit_offset.y + math.random(-20, 20))
								bullet.bullet.target_id = nil
							end
						else
							bullet.bullet.to = V.v(last_target_pos.x + math.random(-20, 20), last_target_pos.y + math.random(-20, 20))
							bullet.bullet.target_id = nil
						end

						local start_offset = table.random(a_basic.bullet_start_offset)

						bullet.bullet.from = V.v(this.pos.x + start_offset.x, this.pos.y + start_offset.y)

						local min_distance = 4900
						local curr_distance = V.dist2(bullet.bullet.from.x, bullet.bullet.from.y, bullet.bullet.to.x, bullet.bullet.to.y)

						if curr_distance < min_distance then
							for _, new_offset in pairs(a_basic.bullet_start_offset_safe) do
								local new_from = V.v(this.pos.x + new_offset.x, this.pos.y + new_offset.y)
								local new_distance = V.dist2(new_from.x, new_from.y, bullet.bullet.to.x, bullet.bullet.to.y)

								if curr_distance < new_distance then
									bullet.bullet.from = V.vclone(new_from)
									curr_distance = new_distance

									if min_distance <= curr_distance then
										break
									end
								end
							end
						end

						bullet.pos = V.vclone(bullet.bullet.from)

						queue_insert(store, bullet)

						this.tower_upgrade_persistent_data.last_fight_ts = store.tick_ts

						local ray_timing = a_basic.ray_timing_min + (a_basic.ray_timing_max - a_basic.ray_timing_min) * math.random()

						U.y_wait(store, ray_timing)

						enemy, enemies = U.find_rearmost_enemy(store.entities, tpos(this), 0, a.range, bullet.bullet.hit_time, a_basic.vis_flags, a_basic.vis_bans)

						if not enemy then
							break
						end

						shot_i = shot_i + 1
						if a_basic.targeting_style ~= 0 then
							zmod_target = zmod_target + 1
						end
					end

					U.animation_start(this, "out", nil, store.tick_ts, false, sid_attack_fx)
					U.y_animation_play(this, a_basic.animation_end, nil, store.tick_ts, false, sid_geode)

					this.render.sprites[sid_attack_fx].hidden = true

					U.animation_start(this, "idleup", nil, store.tick_ts, true, sid_geode)

					a_basic.ts = start_ts
				end
			end
		end

		::label_1047_0::

		coroutine.yield()
	end
end

scripts.tower_sparking_geode_ray = {}

function scripts.tower_sparking_geode_ray.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)
	local tower = this.tower_ref

	if this.bounces == nil then
		this.bounces = math.random(this.bounces_min, this.bounces_max)
	end

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
		s.scale.y = s.scale.y * this.bounce_scale_y

		if this.bounce_scale_y < 1 and s.scale.x < 1 then
			s.scale.y = s.scale.y * (s.scale.x + 1) / 2
		end
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	if target and b.damage_type ~= DAMAGE_NONE then
		local d = SU.create_bullet_damage(b, target.id, b.source_id)

		queue_damage(store, d)
	end

	local mods_added = {}

	if target then
		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = b.target_id

				if m.damage_from_bullet then
					if m.dps then
						m.dps.damage_min = b.damage_min * b.damage_factor
						m.dps.damage_max = b.damage_max * b.damage_factor
					else
						m.modifier.damage_min = b.damage_min * b.damage_factor
						m.modifier.damage_max = b.damage_max * b.damage_factor
					end
				else
					local level

					if not tower then
						level = this.bullet.level
					else
						level = tower.level
						level = level or this.bullet.level
					end

					m.modifier.level = level
				end

				table.insert(mods_added, m)
				queue_insert(store, m)
			end
		end

		table.insert(this.seen_targets, target.id)

		if this.bounces > 0 then
			U.y_wait(store, this.bounce_delay)

			local bounce_target = U.find_nearest_enemy(store.entities, dest, 0, this.bounce_range, this.bounce_vis_flags, this.bounce_vis_bans, function(v)
				return not table.contains(this.seen_targets, v.id)
			end)

			if bounce_target then
				log.paranoid("ray_tesla bounce from %s to %s dist:%s", target.id, bounce_target.id, V.dist(dest.x, dest.y, bounce_target.pos.x, bounce_target.pos.y))

				local r = E:create_entity(this.template_name)

				r.sound_events.insert = nil

				local node_offset = P:predict_enemy_node_advance(bounce_target, fts(5))
				local e_ni = bounce_target.nav_path.ni + node_offset
				local pred_pos = P:node_pos(bounce_target.nav_path.pi, bounce_target.nav_path.spi, e_ni)
				local dir_nx, dir_ny = V.normalize(pred_pos.x - dest.x, pred_pos.y - dest.y)
				local offset_dir = 10

				r.pos = V.v(dest.x - dir_nx * offset_dir, dest.y - dir_ny * offset_dir)
				r.bullet.to = V.v(pred_pos.x + bounce_target.unit.hit_offset.x + dir_nx * offset_dir, pred_pos.y + bounce_target.unit.hit_offset.y + dir_ny * offset_dir)
				r.bullet.target_id = bounce_target.id
				r.bullet.source_id = target.id
				r.bounces = this.bounces - 1
				r.bounce_scale_y = r.bounce_scale_y * r.bounce_scale_y_factor
				r.seen_targets = this.seen_targets
				r.bullet.damage_min = this.bullet.damage_min * this.bounce_damage_factor
				r.bullet.damage_max = this.bullet.damage_max * this.bounce_damage_factor
				r.render.sprites[1].name = this.bounce_sprite_name
				r.ray_duration = this.bounce_ray_duration
				r.image_width = this.bounce_image_width
				r.bullet.hit_fx = nil

				queue_insert(store, r)
			end
		end
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
		else
			hp = b.hit_payload
		end

		if hp.aura then
			hp.aura.level = this.bullet.level
			hp.aura.source_id = this.id

			if target then
				hp.pos.x, hp.pos.y = target.pos.x, target.pos.y
			else
				hp.pos.x, hp.pos.y = dest.x, dest.y
			end
		else
			hp.pos.x, hp.pos.y = dest.x, dest.y
		end

		queue_insert(store, hp)
	end

	local disable_hit = false

	if this.hit_fx_only_no_target then
		disable_hit = target ~= nil and not target.health.dead
	end

	local fx

	if b.hit_fx and not disable_hit then
		local is_air = target and band(target.vis.flags, F_FLYING) ~= 0

		fx = E:create_entity(b.hit_fx)

		if b.hit_fx_ignore_hit_offset and target and not is_air then
			fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
		else
			fx.pos.x, fx.pos.y = dest.x, dest.y
		end

		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].r = s.r + math.rad(90)
		fx.render.sprites[1].sort_y_offset = this.pos.y - fx.pos.y - 10

		queue_insert(store, fx)
	end

	if this.ray_duration then
		while store.tick_ts - s.ts < this.ray_duration do
			if this.track_target then
				update_sprite()
			end

			if tower and not store.entities[tower.id] then
				queue_remove(store, this)

				if fx then
					queue_remove(store, fx)
				end

				for key, value in pairs(mods_added) do
					queue_remove(store, value)
				end

				break
			end

			coroutine.yield()

			s.hidden = false
		end
	else
		while not U.animation_finished(this, 1) do
			if tower and not store.entities[tower.id] then
				queue_remove(store, this)

				break
			end

			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.mod_tower_sparking_geode_stun = {}

function scripts.mod_tower_sparking_geode_stun.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or not target.unit then
		return false
	end

	if IS_KR5 and (band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0) then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	if this.received_damage_factor then
		target.health.damage_factor = target.health.damage_factor * this.received_damage_factor
	end

	if this.inflicted_damage_factor then
		target.unit.damage_factor = target.unit.damage_factor * this.inflicted_damage_factor
	end

	if this.health_bar_offset then
		this._target_health_bar_offset = V.vclone(target.health_bar.offset)
		target.health_bar.offset = V.vclone(this.health_bar_offset[target.unit.size])
	end

	U.sprites_hide(target, nil, nil, true)
	SU.hide_modifiers(store, target, true, this)
	SU.hide_auras(store, target, true)

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts

			if s.size_names then
				s.name = s.size_names[target.unit.size]
			end

			if s.size_prefixes then
				s.prefix = s.prefix .. s.size_prefixes[target.unit.size]
			end

			if s.size_scales then
				s.scale = s.size_scales[target.unit.size]
			end

			if not s.keep_flip_x then
				s.flip_x = target.render.sprites[1].flip_x
			end

			if s.size_anchors then
				s.anchor = s.size_anchors[target.unit.size]
			end

			if m.custom_scales then
				s.scale = V.vclone(m.custom_scales[target.template_name] or m.custom_scales.default)
			end

			if m.custom_offsets then
				s.offset = V.vclone(m.custom_offsets[target.template_name] or m.custom_offsets.default)
				s.offset.x = s.offset.x * (s.flip_x and -1 or 1)
			elseif m.health_bar_offset then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end
	end

	m.ts = store.tick_ts
	this._pushed_bans = U.push_bans(target.vis, F_CUSTOM)

	SU.stun_inc(target)
	log.paranoid("mod_stun.insert (%s)-%s for target (%s)-%s", this.id, this.template_name, target.id, target.template_name)
	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_tower_sparking_geode_stun.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	S:queue(this.mod_sound)
	U.animation_start(this, "down", nil, store.tick_ts, false, this.render.sid_ray)
	U.animation_start(this, "run", nil, store.tick_ts, false, this.render.sid_decal)

	start_ts = store.tick_ts

	if m.animation_phases then
		U.animation_start(this, "in", nil, store.tick_ts, false, this.render.sid_crystal)
		U.animation_start(this, "in", nil, store.tick_ts, false, this.render.sid_fx)

		while not U.animation_finished(this, this.render.sid_crystal) do
			if not target_hidden and m.hide_target_delay and store.tick_ts - start_ts > m.hide_target_delay then
				target_hidden = true

				if target.ui then
					target.ui.can_click = false
				end

				if target.health_bar then
					target.health_bar.hidden = true
				end

				U.sprites_hide(target, nil, nil, true)
				SU.hide_modifiers(store, target, true, this)
				SU.hide_auras(store, target, true)
			end

			if U.animation_finished(this, this.render.sid_ray) then
				U.sprites_hide(this, this.render.sid_ray, this.render.sid_ray, false)
			end

			if U.animation_finished(this, this.render.sid_decal) then
				U.sprites_hide(this, this.render.sid_decal, this.render.sid_decal, false)
			end

			coroutine.yield()
		end
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_crystal)
	U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_fx)

	while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
		if this.render and m.use_mod_offset and target.unit.mod_offset and not m.custom_offsets then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end

		if U.animation_finished(this, this.render.sid_ray) then
			U.sprites_hide(this, this.render.sid_ray, this.render.sid_ray, false)
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

function scripts.mod_tower_sparking_geode_stun.remove(this, store, script)
	local fx = E:create_entity(this.out_fx)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	local target = store.entities[this.modifier.target_id]

	if not target then
		return true
	end

	local fx_scales = {
		V.vv(0.8),
		V.vv(0.9),
		V.vv(1)
	}

	fx.render.sprites[1].scale = fx_scales[target.unit.size]

	if target.health and target.unit then
		if this.received_damage_factor then
			target.health.damage_factor = target.health.damage_factor / this.received_damage_factor
		end

		if this.inflicted_damage_factor then
			target.unit.damage_factor = target.unit.damage_factor / this.inflicted_damage_factor
		end
	end

	if this._target_health_bar_offset then
		target.health_bar.offset = V.vclone(this._target_health_bar_offset)
	end

	U.sprites_show(target, nil, nil, true)
	SU.show_modifiers(store, target, true, this)
	SU.show_auras(store, target, true)

	if this._pushed_bans then
		U.pop_bans(target.vis, this._pushed_bans)

		this._pushed_bans = nil
	end

	SU.stun_dec(target)
	log.paranoid("mod_stun.remove (%s)-%s for target (%s)-%s", this.id, this.template_name, target.id, target.template_name)

	return true
end

scripts.aura_tower_sparking_geode_spike_burst = {}

function scripts.aura_tower_sparking_geode_spike_burst.insert(this, store, script)
	this.aura.ts = store.tick_ts

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts
		end
	end

	if this.aura.source_id then
		local target = store.entities[this.aura.source_id]

		if target and this.render and this.aura.use_mod_offset and target.unit and target.unit.mod_offset then
			this.render.sprites[1].offset.x, this.render.sprites[1].offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
		end
	end

	this.actual_duration = this.aura.duration

	if this.aura.duration_inc then
		this.actual_duration = this.actual_duration + this.aura.level * this.aura.duration_inc
	end

	return true
end

function scripts.aura_tower_sparking_geode_spike_burst.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	for _, ps_n in pairs(this.ps_names) do
		local ps = E:create_entity(ps_n)

		ps.particle_system.emit_area_spread = V.vv(this.aura.radius)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_1060_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_1060_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_1060_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_1060_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_1060_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.decal_tower_sparking_geode_burst_crystal = {}

function scripts.decal_tower_sparking_geode_burst_crystal.update(this, store)
	local start_ts = store.tick_ts

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while not this.finish do
		coroutine.yield()
	end

	U.y_animation_play(this, "death", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.tower_stage_17_weirdwood = {}

function scripts.tower_stage_17_weirdwood.update(this, store)
	local a = this.attacks
	local aa = this.attacks.list[1]
	local blink_ts = store.tick_ts
	local blink_cooldown = math.random(3, 8)

	this.loaded = false
	this.phases = {
		"a",
		"b",
		"c"
	}
	this.current_phase = 1

	U.y_wait(store, fts(math.random(0, 30)))

	local function do_attack(at)
		SU.delay_attack(store, at, 0.25)

		local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), at.min_range, a.range,
			at.node_prediction, at.vis_flags, at.vis_bans)

		if target then
			at.ts = store.tick_ts
			blink_ts = store.tick_ts
			this.loaded = false

			local cp = this.phases[this.current_phase]

			U.animation_start(this, cp .. "_" .. at.animation, nil, store.tick_ts, false, this.tower_sid)
			U.y_wait(store, at.shoot_time)

			local nt, _, nt_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, at.node_prediction,
				at.vis_flags, at.vis_bans)

			if nt then
				target = nt
				pred_pos = nt_pos
			end

			local bo = at.bullet_start_offset
			local b = E:create_entity(at.bullet)

			b.pos = V.v(this.pos.x + bo.x, this.pos.y + bo.y)
			b.bullet.from = V.vclone(b.pos)
			b.bullet.to = V.vclone(pred_pos)
			b.bullet.source_id = this.id
			b.bullet.damage_factor = this.tower.damage_factor

			queue_insert(store, b)
			U.y_animation_wait(this, this.tower_sid)

			return true
		end

		return false
	end

	aa.ts = store.tick_ts

	while true do
		if this.tower.sell then
			coroutine.yield()
		elseif this.tower.blocked then
			coroutine.yield()
		else
			if not this.loaded then
				if store.tick_ts - aa.ts > aa.cooldown - a.load_time then
					local cp = this.phases[this.current_phase]

					U.y_animation_play(this, cp .. "_attack_load", nil, store.tick_ts, 1, this.tower_sid)

					this.loaded = true
				end

				if this.tower.blocked then
					goto label_745_0
				end
			end

			if this.loaded and store.tick_ts - aa.ts > aa.cooldown and do_attack(aa) then
				-- block empty
			else
				if blink_cooldown < store.tick_ts - blink_ts then
					blink_ts = store.tick_ts
					blink_cooldown = math.random(3, 8)

					local cp = this.phases[this.current_phase]
					local idle_anim = math.random(2, 3)

					if this.loaded then
						U.animation_start(this, cp .. "_" .. "idle_" .. idle_anim .. "_attack", nil, store.tick_ts, false,
							this.tower_sid)
					else
						U.animation_start(this, cp .. "_" .. "idle_" .. idle_anim, nil, store.tick_ts, false,
							this.tower_sid)
					end
				end

				if this.corruption_kr5.count >= this.corruption_kr5.limit then
					local nodes = P:nearest_nodes(this.pos.x, this.pos.y, {
						this.corruption_kr5.spawn_path
					}, nil, false)
					local pi, spi, ni = unpack(nodes[1])
					local n_pos = P:node_pos(pi, spi, ni)

					S:queue(this.sound_transform)

					local fx = E:create_entity(this.transformation_fx)

					fx.pos = V.vclone(this.pos)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
					U.y_animation_play(this, "transformation", nil, store.tick_ts, 1, this.tower_sid)

					local e = E:create_entity(this.corruption_kr5.spawn)

					e.pos.x, e.pos.y = this.pos.x, this.pos.y
					e.started_in_holder = true
					e.activate_holder = this.tower.holder_id
					e.walk_pos = V.vclone(n_pos)
					e.selected_path = pi

					queue_insert(store, e)
					signal.emit("wave-notification", "icon", "enemy_deathwood")

					local mods = table.filter(store.entities, function(_, ee)
						return ee.modifier and ee.modifier.target_id == e.id
					end)

					for _, mod in pairs(mods) do
						queue_remove(store, mod)
					end

					local th = E:create_entity("tower_holder_blocked_terrain_4")

					th.pos = V.vclone(this.pos)
					th.tower.holder_id = this.tower.holder_id
					th.tower.flip_x = this.tower.flip_x
					th.tower_holder.unblock_price = this.holder_cost

					if this.tower.default_rally_pos then
						th.tower.default_rally_pos = this.tower.default_rally_pos
					end

					if this.tower.terrain_style then
						th.tower.terrain_style = this.tower.terrain_style
					end

					if th.ui and this.ui then
						th.ui.nav_mesh_id = this.ui.nav_mesh_id
					end

					queue_insert(store, th)
					queue_remove(store, this)
					signal.emit("tower-removed", this, th)

					return
				end

				if this.corruption_kr5.count >= this.corruption_kr5.corruption_phases[this.current_phase] then
					this.current_phase = this.current_phase + 1

					S:queue(this.sound_corruption)

					local fx = E:create_entity(this.leafless_fx)

					fx.pos = V.vclone(this.pos)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
					U.y_wait(store, fts(6))

					local cp = this.phases[this.current_phase]

					if this.loaded then
						U.animation_start(this, cp .. "_" .. "idle_1_attack", nil, store.tick_ts, true, this.tower_sid)
					else
						U.animation_start(this, cp .. "_" .. "idle", nil, store.tick_ts, true, this.tower_sid)
					end
				end
			end
		end

		::label_745_0::

		coroutine.yield()
	end
end

function scripts.tower_stage_17_weirdwood.on_corrupt(this, store)
	this.corruption_kr5.count = this.corruption_kr5.count + 1
end

scripts.tower_stage_18_elven_barrack = {}

function scripts.tower_stage_18_elven_barrack.update(this, store, script)
	local b = this.barrack
	local door_sid = this.render.door_sid or 2
	local formation_offset = 0

	local function check_change_rally()
		if b.rally_new then
			b.rally_new = false

			signal.emit("rally-point-changed", this)

			local sounds = {}
			local all_dead = true

			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, 3, formation_offset)
				s.nav_rally.new = true

				if s.sound_events.change_rally_point then
					table.insert(sounds, s.sound_events.change_rally_point)
				end

				all_dead = all_dead and s.health.dead
			end

			if not all_dead then
				if #sounds > 0 then
					S:queue(sounds[math.random(1, #sounds)])
				else
					S:queue(this.sound_events.change_rally_point)
				end
			end
		end
	end

	while true do
		local old_count = #b.soldiers

		b.soldiers = table.filter(b.soldiers, function(_, s)
			return store.entities[s.id] ~= nil
		end)

		if #b.soldiers > 0 and #b.soldiers ~= old_count then
			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, 3, formation_offset)
			end
		end

		if b.unit_bought then
			this.barrack.max_soldiers = this.barrack.max_soldiers + 1

			for i, ss in ipairs(b.soldiers) do
				ss.nav_rally.pos, ss.nav_rally.center = U.rally_formation_position(i, b, 3, formation_offset)
			end

			b.unit_bought = nil

			local price = E:get_template(b.soldier_type).unit.price[this.barrack.max_soldiers]

			store.player_gold = store.player_gold - price
		end

		check_change_rally()

		if not this.tower.blocked then
			for i = 1, this.barrack.max_soldiers do
				local s = b.soldiers[i]

				if not s or s.health.dead and not store.entities[s.id] then
					if b.has_door and not b.door_open then
						U.animation_start(this, "open", nil, store.tick_ts, false, door_sid)
						U.y_animation_wait(this, door_sid)

						b.door_open = true
						b.door_open_ts = store.tick_ts
					end

					local spawn_ts = store.tick_ts

					S:queue(this.spawn_sound)

					s = E:create_entity(b.soldier_type)
					s.soldier.tower_id = this.id
					s.soldier.tower_soldier_idx = i
					s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
					s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, 3, formation_offset)
					s.nav_rally.new = true
					s.render.sprites[1].flip_x = true

					if this.powers then
						for pn, p in pairs(this.powers) do
							s.powers[pn].level = p.level
						end
					end

					s.spawned_from_tower = true

					queue_insert(store, s)

					b.soldiers[i] = s
				end
			end
		end

		if b.has_door and b.door_open and store.tick_ts - b.door_open_ts > b.door_hold_time then
			U.animation_start(this, "close", nil, store.tick_ts, false, door_sid)
			U.y_animation_wait(this, door_sid)

			b.door_open = false
		end

		if this.corruption_kr5.count >= this.corruption_kr5.corruption_phases[this.current_phase] then
			this.current_phase = this.current_phase + 1

			if this.current_phase > #this.corruption_kr5.corruption_phases then
				local fx = E:create_entity(this.state_change_fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
				U.y_wait(store, fts(20))

				local fx = E:create_entity(this.transformation_fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
				U.y_wait(store, fts(10))

				local spawner = E:create_entity(this.corruption_kr5.spawn)

				spawner.pos = V.vclone(this.pos)
				spawner.holder_id = this.tower.holder_id

				queue_insert(store, spawner)

				this.tower.sell = true
				this.trigger_deselect = true

				return
			else
				local fx = E:create_entity(this.state_change_fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
				U.y_wait(store, fts(10))

				this.render.sprites[2].name = "elven_barracks_tower" .. this.phases[this.current_phase]
			end
		end

		coroutine.yield()
	end
end

function scripts.tower_stage_18_elven_barrack.remove(this, store, script)
	for _, s in pairs(this.barrack.soldiers) do
		if s.health then
			s.health.hp = 0
			s.health.dead = true
			s.health_bar.hidden = true
			s.regen = nil
		end
	end

	return true
end

function scripts.tower_stage_18_elven_barrack.on_corrupt(this, store)
	this.corruption_kr5.count = this.corruption_kr5.count + 1
end

scripts.spawner_stage_18_elven_barrack = {}

function scripts.spawner_stage_18_elven_barrack.update(this, store)
	local holder = table.filter(store.entities, function(_, v)
		return v.tower and v.tower.holder_id == this.holder_id
	end)

	if #holder > 0 then
		holder = holder[1]
		holder.render.sprites[1].z = Z_BACKGROUND + 1
		holder.render.sprites[2].z = Z_BACKGROUND + 2
		holder.ui.can_click = false
		holder.tower.can_hover = false
	end

	while true do
		if not this.corruption_kr5.enabled then
			local s1, s2, s3 = this.render.sprites[5], this.render.sprites[6], this.render.sprites[7]

			U.y_ease_keys(store, {
				s1,
				s2,
				s3
			}, {
				"alpha",
				"alpha",
				"alpha"
			}, {
				0,
				0,
				0
			}, {
				255,
				255,
				255
			}, 0.5, {
				"linear",
				"linear",
				"linear"
			})
			U.y_wait(store, fts(30))

			local e = E:create_entity(this.corruption_kr5.spawn)

			e.pos.x, e.pos.y = this.pos.x, this.pos.y

			local nearest_nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil)
			local pi, spi, ni = unpack(nearest_nodes[1])

			e.nav_path.pi = pi
			e.nav_path.spi = spi
			e.nav_path.ni = ni + 8
			e.spawned_from_tower = true
			e.motion.forced_waypoint = P:node_pos(pi, spi, ni + 8)
			e.enemy.gold = 0

			queue_insert(store, e)
			signal.emit("wave-notification", "icon", "enemy_animated_armor")
			U.y_ease_keys(store, {
				s1,
				s2,
				s3
			}, {
				"alpha",
				"alpha",
				"alpha"
			}, {
				255,
				255,
				255
			}, {
				0,
				0,
				0
			}, 0.25, {
				"linear",
				"linear",
				"linear"
			})
			U.y_wait(store, this.spawn_cd)

			this.corruption_kr5.enabled = true
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

function scripts.spawner_stage_18_elven_barrack.on_corrupt(this, store)
	this.corruption_kr5.enabled = false
end

scripts.fx_tower_ray_lvl4_shock = {}

function scripts.fx_tower_ray_lvl4_shock.update(this, store)
	local cds = {
		1,
		2,
		2,
		1,
		2,
		1
	}
	local cd_id = 1

	local function hide_if_necessary()
		local t = store.entities[this.tower_id]

		if t then
			this.render.sprites[1].hidden = t.render.sprites[1].hidden
		end
	end

	local function y_wait_and_hide(time)
		local start_ts = store.tick_ts

		while time > store.tick_ts - start_ts do
			hide_if_necessary()
			coroutine.yield()
		end
	end

	while store.entities[this.tower_id] do
		this.render.sprites[1].hidden = false

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		while not U.animation_finished(this, 1, cds[cd_id]) do
			hide_if_necessary()
			coroutine.yield()
		end

		this.render.sprites[1].hidden = true

		y_wait_and_hide(1)

		cd_id = cd_id + 1

		if cd_id > #cds then
			cd_id = 1
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_stage_17_tree = {}

function scripts.decal_stage_17_tree.update(this, store, script)
	while true do
		if this.ui.clicked then
			S:queue(this.sound_tap)

			this.ui.clicked = nil
			this.ui.can_click = false

			U.y_animation_play(this, "action", nil, store.tick_ts, 1)
			U.animation_start(this, "idle", nil, store.tick_ts, true)

			this.ui.can_click = true
		end

		coroutine.yield()
	end
end

scripts.decal_stage_18_streetlight = {}

function scripts.decal_stage_18_streetlight.update(this, store, script)
	while true do
		if this.ui.clicked then
			S:queue(this.sound_in)

			this.ui.clicked = nil
			this.ui.can_click = false

			S:queue(this.sound_break)
			U.y_animation_play(this, "action", nil, store.tick_ts, 1)
			U.animation_start(this, "idle_broken", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_18_cuckoo = {}

function scripts.decal_stage_18_cuckoo.update(this, store, script)
	local touch_times = 0

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			touch_times = touch_times + 1

			if touch_times == this.touches_needed then
				S:queue(this.sound_in)
				U.y_animation_play(this, "action_2_in", nil, store.tick_ts, 1)
				U.animation_start(this, "action_2_idle", nil, store.tick_ts, true)
				U.y_wait(store, this.duration)
				S:queue(this.sound_out)
				U.y_animation_play(this, "action_2_out", nil, store.tick_ts, 1)

				this.ui.can_click = true

				if this.reset_touches then
					touch_times = 0
				end
			elseif touch_times < this.touches_needed or touch_times > this.touches_needed and this.touchable_after_anim then
				U.y_animation_play(this, "action_1", nil, store.tick_ts, 1)

				this.ui.can_click = true
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_19_statue = {}

function scripts.decal_stage_19_statue.update(this, store, script)
	local current_step = 1

	if store.level_mode == GAME_MODE_CAMPAIGN then
		this.ui.can_click = false
	end

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false

			if current_step < 3 then
				S:queue(this.sound_12)
			else
				S:queue(this.sound_3)
			end

			local action_name = "action_" .. current_step
			local idle_name = "idle_" .. current_step + 1

			U.y_animation_play(this, action_name, nil, store.tick_ts, 1)
			U.animation_start(this, idle_name, nil, store.tick_ts, true)

			current_step = current_step + 1

			if current_step < 4 then
				this.ui.can_click = true
			else
				signal.emit("rock-paper-scissors-stage19", this)
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_19_navira_cape = {}

function scripts.decal_stage_19_navira_cape.update(this, store, script)
	local start_ts = store.tick_ts

	while store.tick_ts - start_ts < fts(38) do
		coroutine.yield()
	end

	while true do
		this.render.sprites[1].hidden = true

		U.y_wait(store, fts(2))

		this.render.sprites[1].hidden = false

		U.y_wait(store, fts(2))
	end
end

scripts.stage20_arborean_house = {}

function scripts.stage20_arborean_house.get_info(this)
	return {
		type = STATS_TYPE_SOLDIER,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		armor = this.health.armor
	}
end

function scripts.stage20_arborean_house.update(this, store)
	local current_health_th = 0

	local function spawn_fx(fx_template)
		local fx = E:create_entity(fx_template)

		fx.pos = V.v(this.pos.x + this.unit.hit_offset.x, this.pos.y + this.unit.hit_offset.y)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	local function destroy_house()
		this.ui.can_select = false
		this.health.hp = 0
		this.health.dead = true
		this.health.death_finished_ts = store.tick_ts
		this.vis.flags = 0
		this.render.sprites[1].name = "idle" .. #this.life_thresholds + 1
	end

	if store.level_mode == GAME_MODE_HEROIC then
		destroy_house()

		this.health_bar.hidden = true

		return
	end

	while true do
		if this.health.dead then
			destroy_house()
			spawn_fx(this.threshold_fx_last)

			return
		end

		if current_health_th <= #this.life_thresholds then
			local hp_percent = this.health.hp / this.health.hp_max

			if hp_percent < this.life_thresholds[current_health_th + 1] then
				current_health_th = current_health_th + 1
				this.render.sprites[1].name = "idle" .. current_health_th + 1

				spawn_fx(this.threshold_fx)
			end
		end

		coroutine.yield()
	end
end

scripts.decal_achievement_stage_21_croc_boat = {}

function scripts.decal_achievement_stage_21_croc_boat.update(this, store, script)
	local touch_times = 0

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			touch_times = touch_times + 1

			if touch_times == this.touches_needed then
				S:queue(this.sound_engine_success)
				U.animation_start(this, "tap2", nil, store.tick_ts, false, this.render.sid_croc)
				U.y_wait(store, fts(73))
				signal.emit("boat-croc-stage21")
				U.y_animation_wait(this, this.render.sid_croc, 1)
				U.animation_start(this, "idle2", nil, store.tick_ts, true, this.render.sid_croc)
			else
				S:queue(this.sound_engine_fail)
				U.y_animation_play(this, "tap1", nil, store.tick_ts, 1, this.render.sid_croc)
				U.animation_start(this, "idle1", nil, store.tick_ts, true, this.render.sid_croc)

				this.ui.can_click = true
			end
		end

		coroutine.yield()
	end
end

scripts.decal_achievement_stage_22_croc_king = {}

function scripts.decal_achievement_stage_22_croc_king.update(this, store, script)
	local touch_times = 0
	local flying = false

	while not flying do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			touch_times = touch_times + 1

			if touch_times == 1 then
				U.y_animation_play(this, "tap1", nil, store.tick_ts)
				U.animation_start(this, "idle2", nil, store.tick_ts, true)

				this.ui.can_click = true
			elseif touch_times == 2 then
				U.y_animation_play(this, "tap2", nil, store.tick_ts)
				U.animation_start(this, "idle2", nil, store.tick_ts, true)

				this.ui.can_click = true
			elseif touch_times == 3 then
				U.y_animation_play(this, "tap3", nil, store.tick_ts)
				U.animation_start(this, "loop", nil, store.tick_ts, true)

				this.pos.y = this.pos.y - 5
				flying = true
				this.render.sprites[1].z = Z_OBJECTS_SKY
			end
		end

		coroutine.yield()
	end

	local speedX = -0.05
	local max_speedX = -4

	while flying do
		this.pos.x = this.pos.x + speedX
		this.pos.y = this.pos.y + 5
		speedX = math.max(max_speedX, speedX * 1.1)

		if this.pos.y > 900 then
			signal.emit("flying-king-croc-stage22")
			queue_remove(store, this)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_22_easteregg_sheepy = {}

function scripts.decal_stage_22_easteregg_sheepy.update(this, store, script)
	local touch_times = 0
	local speed = 30
	local start_pos = V.vclone(this.pos)

	local function y_sheepy_walk(dest)
		U.animation_start(this, "running", nil, store.tick_ts, true)

		this.render.sprites[1].flip_x = dest.x > this.pos.x

		local distance = 1000

		while distance > 5 do
			local vx, vy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
			local v_angle = V.angleTo(vx, vy)
			local v_len = V.len(vx, vy)

			distance = v_len

			if distance > 5 then
				local step = speed * store.tick_length
				local nx, ny = V.normalize(V.rotate(v_angle, 1, 0))
				local sx, sy = V.mul(step, nx, ny)

				this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, sx, sy)
			else
				U.animation_start(this, "idle", nil, store.tick_ts, true)

				return
			end

			coroutine.yield()
		end
	end

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			touch_times = touch_times + 1

			if touch_times == 1 then
				y_sheepy_walk(V.v(start_pos.x - 65, start_pos.y))
				U.y_wait(store, 0.4)
				y_sheepy_walk(V.v(start_pos.x, start_pos.y))
				U.y_wait(store, 0.4)
				y_sheepy_walk(V.v(start_pos.x - 20, start_pos.y + 10))

				this.ui.can_click = true
			elseif touch_times == 2 then
				U.y_animation_play(this, "action1", nil, store.tick_ts)

				this.ui.can_click = true
			elseif touch_times == 3 then
				y_sheepy_walk(V.v(start_pos.x - 20, start_pos.y - 23))
				U.y_animation_play(this, "death", nil, store.tick_ts)
				queue_remove(store, this)

				return
			end
		end

		coroutine.yield()
	end
end

scripts.decal_achievement_into_the_ogreverse = {}

function scripts.decal_achievement_into_the_ogreverse.update(this, store, script)
	local touch_times = 0

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			touch_times = touch_times + 1

			if touch_times == 1 then
				U.y_animation_play(this, "cultist_transform", nil, store.tick_ts, 1, 2)
				U.animation_start(this, "spider_idle", nil, store.tick_ts, true, 2)

				this.ui.can_click = true
			elseif touch_times == 2 then
				U.y_animation_play(this, "spider_transform", nil, store.tick_ts, 1, 2)
				U.animation_start(this, "pig_idle", nil, store.tick_ts, true, 2)

				this.ui.can_click = true
			elseif touch_times == 3 then
				U.y_animation_play(this, "pig_transform", nil, store.tick_ts, 1, 2)
				U.animation_start(this, "ogre_idle", nil, store.tick_ts, true, 2)

				this.ui.can_click = true
			elseif touch_times == 4 then
				U.y_animation_play(this, "ogre_transform", nil, store.tick_ts, 1, 2)

				this.render.sprites[2].z = Z_TOWER_BASES - 1
				this.render.sprites[1].z = Z_TOWER_BASES - 2

				U.y_animation_play(this, "ogre_fall", nil, store.tick_ts, 1, 2)

				this.render.sprites[1].z = Z_OBJECTS
				this.render.sprites[2].hidden = true

				U.y_wait(store, 1)
				signal.emit("spiders-into-the-ogreverse")
			end
		end

		coroutine.yield()
	end
end

scripts.decal_achievement_a_coon_of_surprises = {}

function scripts.decal_achievement_a_coon_of_surprises.update(this, store, script)
	local touch_times = 0

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			touch_times = touch_times + 1

			if touch_times < this.required_touches then
				U.y_animation_play(this, "clicked", nil, store.tick_ts, 1, this.render.sid_animated)
				U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_animated)

				this.ui.can_click = true
			else
				U.animation_start(this, "broken", nil, store.tick_ts, false, this.render.sid_animated)
				U.y_wait(store, this.change_z_time)

				this.render.sprites[this.render.sid_animated].z = Z_OBJECTS
				this.render.sprites[this.render.sid_animated].sort_y_offset = this.change_y_sort_offset

				U.y_animation_wait(this, this.render.sid_animated, 1)
				U.animation_start(this, "idle_2", nil, store.tick_ts, true, this.render.sid_animated)

				if this.give_achievement then
					signal.emit("spiders-a-coon-of-surprises")
				end
			end
		end

		coroutine.yield()
	end
end

scripts.decal_achievement_lucas_spider = {}

function scripts.decal_achievement_lucas_spider.update(this, store, script)
	local touch_times = 0

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			touch_times = touch_times + 1

			if touch_times == 1 then
				U.y_animation_play(this, "tap_1", nil, store.tick_ts)
				U.animation_start(this, "idle_2", nil, store.tick_ts, true)

				this.ui.can_click = true
			elseif touch_times == 2 then
				U.y_animation_play(this, "tap_2", nil, store.tick_ts)
				U.animation_start(this, "idle_2", nil, store.tick_ts, true)

				this.ui.can_click = true
			elseif touch_times == 3 then
				U.y_animation_play(this, "tap_3", nil, store.tick_ts)
				U.animation_start(this, "idle_3", nil, store.tick_ts, true)
				signal.emit("spiders-lucas-spider")
			end
		end

		coroutine.yield()
	end
end

scripts.mod_tower_ray_damage = {}

function scripts.mod_tower_ray_damage.update(this, store)
	local cycles, total_damage = 0, 0
	local m = this.modifier
	local dps = this.dps
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		queue_remove(store, this)

		return
	end

	local source = store.entities[m.source_id]

	local function apply_damage(value)
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = dps.damage_type
		d.pop = dps.pop
		d.pop_chance = dps.pop_chance
		d.pop_conds = dps.pop_conds

		queue_damage(store, d)

		local effective_dmg = U.predict_damage(target, d)

		total_damage = total_damage + effective_dmg
	end

	local function apply_true_damage(value, add_to_total)
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = DAMAGE_TRUE
		d.pop = dps.pop
		d.pop_chance = 0

		queue_damage(store, d)

		local effective_dmg = U.predict_damage(target, d)

		if add_to_total then
			total_damage = total_damage + effective_dmg
		end
	end

	local raw_damage = math.random(this.dps.damage_min, this.dps.damage_max)
	local raw_damage_tiers = {}

	for _, v in pairs(this.damage_tiers) do
		table.insert(raw_damage_tiers, raw_damage * v)
	end

	local total_cycles = m.duration / dps.damage_every
	local dps_damage

	local function calculate_dps_damage(tier)
		local current_tier = km.clamp(0, #raw_damage_tiers, tier)
		local cycles_in_tier = m.duration / (#raw_damage_tiers * dps.damage_every)

		dps_damage = math.floor(raw_damage_tiers[current_tier] / cycles_in_tier)
	end

	local function get_expected_true_damage(value)
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = dps.damage_type

		return U.predict_damage(target, d)
	end

	local function get_expected_true_damage_after_tier(tier)
		local total_acc_dmg = 0

		for i = 1, tier do
			total_acc_dmg = total_acc_dmg + raw_damage_tiers[i]
		end

		return get_expected_true_damage(math.floor(total_acc_dmg))
	end

	this.pos = target.pos
	dps.ts = store.tick_ts
	m.ts = store.tick_ts

	if this.forced_start_ts then
		m.ts = this.forced_start_ts
	end

	while true do
		target = store.entities[m.target_id]
		source = store.entities[m.source_id]

		if not target or target.health.dead then
			break
		end

		if this.render and m.use_mod_offset and target.unit.hit_offset then
			for _, s in ipairs(this.render.sprites) do
				s.offset.x, s.offset.y = target.unit.hit_offset.x, target.unit.hit_offset.y
			end
		end

		if dps.damage_every and store.tick_ts - dps.ts >= dps.damage_every then
			cycles = cycles + 1
			dps.ts = dps.ts + dps.damage_every

			local last_damage_tier = math.ceil((cycles - 1) * dps.damage_every)
			local new_damage_tier = math.ceil(cycles * dps.damage_every)

			if last_damage_tier ~= new_damage_tier then
				calculate_dps_damage(new_damage_tier)
			end

			apply_damage(dps_damage)

			local cycles_in_tier = m.duration / (#raw_damage_tiers * dps.damage_every)

			if math.fmod(cycles, cycles_in_tier) == 0 then
				local expected_true_dmg = get_expected_true_damage_after_tier(last_damage_tier)
				local pending_true_dmg = expected_true_dmg - total_damage

				if pending_true_dmg > 0 then
					apply_true_damage(math.floor(pending_true_dmg), true)
				elseif get_expected_true_damage(raw_damage_tiers[last_damage_tier]) == 0 then
					apply_true_damage(1, false)
				end
			end

			if total_cycles <= cycles then
				log.paranoid(">>>>> id:%s - mod_tower_ray_damage cycles:%s raw_damage:%s dps_damage:%s total_damage:%s", this.id, cycles, raw_damage, dps_damage, total_damage)

				break
			end

			this.render.sprites[1].scale = V.vv(0.4 + new_damage_tier / 5)
		end

		if not source or source.force_stop_ray then
			break
		end

		coroutine.yield()
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts
end

scripts.mod_tower_ray_slow = {}

function scripts.mod_tower_ray_slow.insert(this, store, script)
	this.slow.factor = this.slowConfig[this.modifier.level]

	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or not target.motion or target.motion.invulnerable then
		return false
	end

	if this.modifier.excluded_templates and table.contains(this.modifier.excluded_templates, target.template_name) then
		return false
	end

	target.motion.max_speed = target.motion.max_speed * this.slow.factor
	this.modifier.ts = store.tick_ts

	signal.emit("mod-applied", this, target)

	this.modifier_inserted = true

	return true
end

function scripts.mod_tower_ray_slow.remove(this, store, script)
	if not this.modifier_inserted then
		return true
	end

	local target = store.entities[this.modifier.target_id]

	if target and target.health and target.motion then
		target.motion.max_speed = target.motion.max_speed / this.slow.factor
	end

	this.modifier_inserted = false

	return true
end

scripts.bullet_tower_ray = {}

function scripts.bullet_tower_ray.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)
	local tower = this.tower_ref
	local pow
	if tower.powers then
		pow = tower.powers.chain
	end

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
				this.force_stop_ray = true
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end

			if target then
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.vv(1)

	U.animation_start(this, "loop", nil, store.tick_ts, true)
	update_sprite()

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	local mods_added = {}

	if target and (b.mod or b.mods) then
		local mods = b.mods or {
			b.mod
		}

		for _, mod_name in pairs(mods) do
			local m = E:create_entity(mod_name)

			m.modifier.target_id = b.target_id
			m.modifier.source_id = this.id
			m.modifier.level = b.level

			if m.damage_from_bullet then
				local d_mult = 1 * b.damage_factor

				if pow and this.chain_pos and this.chain_pos > 1 then
					d_mult = pow.damage_mult[pow.level] * b.damage_factor
				end

				if m.dps then
					m.dps.damage_min = math.ceil(b.damage_min * d_mult)
					m.dps.damage_max = math.ceil(b.damage_max * d_mult)
				end
			end

			table.insert(mods_added, m)
			queue_insert(store, m)

			if this.mod_start_ts then
				m.forced_start_ts = this.mod_start_ts
			end
		end
	end

	local disable_hit = false

	if this.hit_fx_only_no_target then
		disable_hit = target ~= nil and not target.health.dead
	end

	local fx

	if b.hit_fx and not disable_hit then
		local is_air = target and band(target.vis.flags, F_FLYING) ~= 0

		fx = E:create_entity(b.hit_fx)

		if b.hit_fx_ignore_hit_offset and target and not is_air then
			fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
		else
			fx.pos.x, fx.pos.y = dest.x, dest.y
		end

		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	local start_ts = store.tick_ts
	local pending_chain = pow and pow.level > 0 and this.chain_pos and this.chain_pos < this.max_enemies[pow.level]
	local chained_next_ray = false
	local start_chain_delay = this.chain_delay
	local source = store.entities[b.source_id]

	if this.ray_duration then
		while store.tick_ts - start_ts < this.ray_duration and target and not target.health.dead and not this.force_stop_ray and source do
			if pending_chain and store.tick_ts - start_ts > this.chain_delay then
				local chain_target, _, _ = U.find_nearest_enemy(store.entities, target.pos, 0, this.chain_range, this.vis_flags, this.vis_bans, function(e, o)
					return not table.contains(tower.chain_targets, e.id)
				end)

				if chain_target then
					local chain = E:create_entity(this.template_name)
					local start_offset = target.unit.hit_offset

					chain.pos.x, chain.pos.y = target.pos.x + start_offset.x, target.pos.y + start_offset.y
					chain.bullet.from = V.vclone(chain.pos)

					local end_offset = chain_target.unit.hit_offset

					chain.bullet.to = V.vclone(chain_target.pos)
					chain.bullet.to.x, chain.bullet.to.y = chain.bullet.to.x + end_offset.x, chain.bullet.to.y + end_offset.y
					chain.bullet.target_id = chain_target.id
					chain.bullet.source_id = b.target_id
					chain.bullet.level = b.level
					chain.tower_ref = tower
					chain.chain_pos = this.chain_pos + 1
					chain.mod_start_ts = start_ts

					queue_insert(store, chain)

					this.next_in_chain = chain

					table.insert(tower.chain_targets, chain_target.id, chain_target.id)

					pending_chain = false
					chained_next_ray = true
				else
					this.chain_delay = this.chain_delay + 0.25
				end
			end

			if chained_next_ray and (not this.next_in_chain or this.next_in_chain.render.sprites[1].hidden) then
				pending_chain = true
				chained_next_ray = false
			end

			if this.chain_pos and this.chain_pos > 1 then
				local start_offset = source.unit.hit_offset

				this.pos.x, this.pos.y = source.pos.x + start_offset.x, source.pos.y + start_offset.y
				b.from = V.vclone(this.pos)
			end

			if store.tick_ts - start_ts > this.ray_duration - fts(7) and this.render.sprites[1].name ~= "fade" then
				U.animation_start(this, "fade", nil, store.tick_ts)
			end

			if this.track_target then
				update_sprite()
			end

			if tower and not store.entities[tower.id] then
				break
			end

			target = store.entities[b.target_id]

			if target and this.chain_pos and this.chain_pos > 1 and V.dist2(this.pos.x, this.pos.y, target.pos.x, target.pos.y) > this.chain_range_to_stay * this.chain_range_to_stay then
				break
			end

			if target and band(target.vis.bans, this.vis_flags) ~= 0 then
				this.force_stop_ray = true

				break
			end

			coroutine.yield()

			s.hidden = false
			source = store.entities[b.source_id]
		end
	end

	if not target or target.health.dead or this.force_stop_ray or not source then
		S:stop(this.sound_events.insert)
		S:queue(this.sound_events.interrupt)
	end

	if fx then
		queue_remove(store, fx)
	end

	for key, value in pairs(mods_added) do
		if not value.dps or not tower or this.force_stop_ray then
			queue_remove(store, value)
		end
	end

	for k, v in pairs(tower.chain_targets) do
		if v == b.target_id then
			tower.chain_targets[k] = nil
		end
	end

	if this.next_in_chain then
		this.chain_delay = start_chain_delay

		U.y_wait(store, this.chain_delay + fts(4))

		this.next_in_chain.force_stop_ray = true
	end

	if this.render.sprites[1].name == "fade" then
		U.y_animation_wait(this)
	else
		U.y_animation_play(this, "fade", nil, store.tick_ts)
	end

	this.render.sprites[1].hidden = true

	queue_remove(store, this)
end

scripts.bullet_tower_ray_sheep = {}

function scripts.bullet_tower_ray_sheep.update(this, store)
	local b = this.bullet
	local target
	local fm = this.force_motion

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	target = store.entities[b.target_id]

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local iix, iiy = V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	S:queue(this.shoot_sound)

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local d = math.max(math.abs(target.pos.x + target.unit.hit_offset.x - b.to.x), math.abs(target.pos.y + target.unit.hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.info("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = this.pred_pos.x + target.unit.hit_offset.x, this.pred_pos.y + target.unit.hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(0, iix, iiy))
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local sheep_t = this.sheep_t

		if band(target.vis.flags, F_FLYING) ~= 0 then
			sheep_t = this.sheep_flying_t
		end

		local sheep = E:create_entity(sheep_t)

		sheep.pos = V.vclone(target.pos)
		sheep.nav_path.pi = target.nav_path.pi
		sheep.nav_path.spi = target.nav_path.spi
		sheep.nav_path.ni = target.nav_path.ni
		sheep.source_id = b.source_id
		sheep.enemy.gold = target.enemy.gold
		sheep.health.hp_max = target.health.hp_max * this.sheep_hp_mult
		sheep.health.hp = target.health.hp * this.sheep_hp_mult
		sheep._original_unit_name = target.template_name

		queue_insert(store, sheep)

		target.trigger_deselect = true
		target.gold = 0

		queue_remove(store, target)
		S:queue(this.hit_sound)
	end

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos = V.vclone(this.pos)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false
	end

	queue_remove(store, this)
	coroutine.yield()
end

scripts.enemy_tower_ray_sheep = {}

function scripts.enemy_tower_ray_sheep.update(this, store)
	local clicks = 0

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1
		end

		if clicks >= this.clicks_to_destroy then
			this.health.hp = 0

			coroutine.yield()
		elseif this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
			coroutine.yield()
		else
			local next_pos = P:next_entity_node(this, store.tick_length)
            if next_pos and GR:cell_is(next_pos.x, next_pos.y, bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) and not this.health.dead and this._original_unit_name then
				local original_unit = E:create_entity(this._original_unit_name)
				original_unit.pos = V.vclone(this.pos)
				original_unit.nav_path = table.deepclone(this.nav_path)
				original_unit.health.hp = math.ceil(this.health.hp / this.health.hp_max * original_unit.health.hp_max)
				queue_insert(store, original_unit)
				queue_remove(store, this)
				return
            end
			SU.y_enemy_walk_until_blocked(store, this, true, function(store, this)
				return this.ui.clicked
			end)
		end
	end
end

scripts.tower_stage_20_arborean_oldtree = {}

function scripts.tower_stage_20_arborean_oldtree.get_info(this)
	return {
		type = STATS_TYPE_TEXT,
		desc = this.info.desc
	}
end

function scripts.tower_stage_20_arborean_oldtree.update(this, store)
	local function shot_bullet(attack)
		local b = E:create_entity(attack.bullet)
		local node_pos = P:node_pos(attack.path_index, 1, attack.node_index)

		b.bullet.from = V.v(this.pos.x - 50, this.pos.y + 30)
		b.bullet.to = V.v(node_pos.x, node_pos.y)
		b.bullet.source_id = this.id

		if this.tower.payload_entity then
			b.bullet.hit_payload = this.tower.payload_entity
		end

		queue_insert(store, b)
	end

	local start_ts = store.tick_ts
	local tree_start_ts = store.tick_ts
	local doing_action = false
	local tree_doing_action = false
	local old_cooldown = math.random(6, 10)
	local tree_cooldown = math.random(6, 10)

	this.user_selection.allowed = true

	if store.level_mode == GAME_MODE_IRON then
		this.attacks.list[1].price = this.attacks.list[1].price_iron

		if this.tower.payload_entity then
			this.attacks.list[1].path_index = this.attacks.list[1].path_index_iron
			this.attacks.list[1].node_index = this.attacks.list[1].node_index_iron
		end
	end

	while true do
		if this.user_selection.arg then
			this.user_selection.arg = nil
			this.user_selection.allowed = false

			local attack = this.attacks.list[1]

			store.player_gold = store.player_gold - attack.price

			U.animation_start(this, "attack", nil, store.tick_ts, false, 2)
			S:queue(this.sound_head_scratch)
			U.y_wait(store, attack.cast_time)
			shot_bullet(attack)
			U.y_animation_wait(this, 2)
			U.animation_start(this, "sleep", nil, store.tick_ts, true, 2)
			U.y_wait(store, attack.cooldown)
			S:queue(this.sound_wakeup)
			U.animation_start(this, "wakeUp", nil, store.tick_ts, false, 3)
			U.y_wait(store, fts(40))
			U.animation_start(this, "wakeUp", nil, store.tick_ts, false, 2)
			U.y_animation_wait(this, 3)
			U.animation_start(this, "idle1", nil, store.tick_ts, true, 3)
			U.y_animation_wait(this, 2)
			U.animation_start(this, "idle1", nil, store.tick_ts, true, 2)

			start_ts = store.tick_ts
			tree_start_ts = store.tick_ts
			this.user_selection.allowed = true

			goto label_950_0
		end

		if doing_action and U.animation_finished(this, 3, 1) then
			U.animation_start(this, "idle1", nil, store.tick_ts, true, 3)

			doing_action = false
		end

		if tree_doing_action and U.animation_finished(this, 2, 1) then
			U.animation_start(this, "idle1", nil, store.tick_ts, true, 2)

			tree_doing_action = false
		end

		if tree_cooldown < store.tick_ts - tree_start_ts then
			tree_start_ts = store.tick_ts
			tree_cooldown = math.random(6, 10)

			U.animation_start(this, "action" .. math.random(1, 2), nil, store.tick_ts, false, 2)

			tree_doing_action = true
		end

		if old_cooldown < store.tick_ts - start_ts then
			start_ts = store.tick_ts
			old_cooldown = math.random(6, 10)

			U.animation_start(this, "action" .. math.random(1, 2), nil, store.tick_ts, false, 3)

			doing_action = true
		end

		::label_950_0::

		coroutine.yield()
	end
end

scripts.stage_20_arborean_oldtree_tree = {}

function scripts.stage_20_arborean_oldtree_tree.update(this, store)
	local start_ts = store.tick_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local a = this.custom_attack
	local s = this.render.sprites[1]

	s.ts = store.tick_ts + (s.random_ts and U.frandom(-s.random_ts, 0) or 0)

	S:queue(this.sound_hit_floor)

	local did_sound_repeat = false

	while true do
		if this.nav_path.ni < 5 or not SU.y_enemy_walk_step(store, this) then
			break
		end

		if this.render.sprites[1].frame_idx == 1 then
			if not did_sound_repeat then
				S:queue(this.sound_hit_floor_repeat)

				did_sound_repeat = true
			end
		else
			did_sound_repeat = false
		end

		if store.tick_ts - last_hit_ts >= a.cycle_time then
			last_hit_ts = store.tick_ts

			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

			if targets then
				for _, target in pairs(targets) do
					local d = E:create_entity("damage")

					d.source_id = this.id
					d.target_id = target.id

					local dmin, dmax = a.damage_min, a.damage_max

					d.value = math.random(dmin, dmax)
					d.damage_type = a.damage_type

					queue_damage(store, d)

					local fx = E:create_entity(a.hit_fx)
					local target_pos = V.vclone(target.pos)

					if target.unit and target.unit.hit_offset then
						target_pos.x, target_pos.y = target_pos.x + target.unit.hit_offset.x, target_pos.y + target.unit.hit_offset.y
					end

					fx.pos = V.vclone(target_pos)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end
			end
		end
	end

	queue_remove(store, this)
end

scripts.tower_stage_20_arborean_honey = {}

function scripts.tower_stage_20_arborean_honey.can_select_point(this, x, y)
	return P:valid_node_nearby(x, y)
end

function scripts.tower_stage_20_arborean_honey.get_info(this)
	return {
		type = STATS_TYPE_TEXT,
		desc = this.info.desc
	}
end

function scripts.tower_stage_20_arborean_honey.update(this, store, script)
	if store.level_mode == GAME_MODE_HEROIC then
		this.repair.cost = this.price_repair_heroic
		this.repair_cost_config = this.price_repair_heroic
		this.repair_cost_config_iron = this.price_repair_heroic
	else
		this.repair.cost = this.price_repair
		this.repair_cost_config = this.price_repair
		this.repair_cost_config_iron = this.price_repair
	end

	local at = this.attacks
	local a = this.attacks.list[1]
	local last_target_pos = V.v(0, 0)
	local buyed = false
	local a2 = this.attacks.list[2]
	local a2_cd = 0
	local qty = 0
	local ts_disable = 0
	local waiting_disable = false
	this.user_selection.allowed = true
	a2.ts = store.tick_ts

	local available_paths = {}
	for k, v in pairs(P.paths) do
		table.insert(available_paths, k)
	end
	if store.level.ignore_walk_backwards_paths then
		available_paths = table.filter(available_paths, function(k, v)
			return not table.contains(store.level.ignore_walk_backwards_paths, v)
		end)
	end
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, available_paths, nil, nil, NF_RALLY)
	local pi, spi, ni = unpack(nodes[1])
	this.tower.spawn_path_index = pi
	this.tower.spawn_node_index = ni

	local function shot_bullet(attack, enemy)
		local b = E:create_entity(attack.bullet)

		b.bullet.from = V.v(this.pos.x, this.pos.y + 100)

		local node_offset = P:predict_enemy_node_advance(enemy, fts(35))
		local e_ni = enemy.nav_path.ni + node_offset
		local pred_pos = P:node_pos(enemy.nav_path.pi, 1, e_ni)

		b.bullet.to = pred_pos
		b.bullet.source_id = this.id
		b.bullet.damage_factor = this.tower.damage_factor

		queue_insert(store, b)
	end

	local function shoot_enemy(enemy)
		local bee = this.render.sprites[3]
		local unit = this.render.sprites[4]

		this.render.sprites[3].flip_x = enemy.pos.x < this.pos.x

		if math.random() < this.sound_bee_fly_chance then
			S:queue(this.sound_bee_fly)
		end

		U.animation_start(this, "hit", nil, store.tick_ts, false, 3)
		U.animation_start(this, "in", nil, store.tick_ts, false, 4)
		U.y_animation_wait(this, 4)
		S:queue(this.sound_bee_throw)

		local enemyLast = U.find_foremost_enemy(store.entities, tpos(this), 0, at.range, false, a.vis_flags, a.vis_bans)

		if enemyLast then
			enemy = enemyLast
		end

		if enemy.pos.x < this.pos.x then
			this.render.sprites[4].flip_x = true
		end

		U.animation_start(this, "hit", nil, store.tick_ts, false, 4)

		if enemy then
			last_target_pos = enemy.pos

			shot_bullet(a, enemy)
		end

		U.y_animation_wait(this, 4)

		this.render.sprites[3].flip_x = false

		U.animation_start(this, "out", nil, store.tick_ts, false, 4)
		U.y_animation_wait(this, 3)
		U.animation_start(this, "idle", nil, store.tick_ts, true, 3)
	end

	while true do
		local enemy

		if this.user_selection.in_progress and not this.repair.active then
			this.repair.active = true
			this.user_selection.in_progress = nil
			-- this.user_selection.allowed = false
			store.player_gold = store.player_gold - this.repair.cost
			a.disable = false

			S:queue(this.sound_bee_fly)

			this.render.sprites[2].name = "arborean_honey_tower_tower_0002"
			this.render.sprites[3].hidden = false
			this.render.sprites[4].hidden = false
			this.render.sprites[5].hidden = false

			U.animation_start(this, "arborean_honey_tower_smoke", nil, store.tick_ts, false, 5)
			U.y_animation_wait(this, 5)

			this.render.sprites[5].hidden = true
			a.ts = store.tick_ts - a.cooldown
			this.tower.cooldown_idle_ts = store.tick_ts
		end

		if this.tower.blocked then
			-- block empty
		else
			if waiting_disable and store.tick_ts - ts_disable > a2.cooldown_disable then
				waiting_disable = false
				this.user_selection.allowed = true
			end

			if this.user_selection.arg then
				this.user_selection.arg = nil
				store.player_gold = store.player_gold - a2.price
				this.user_selection.allowed = false
				buyed = true
				a2_cd = math.random(a2.cooldown_min, a2.cooldown_max)
			end

			if buyed and a2_cd < store.tick_ts - a2.ts then
				a2_cd = math.random(a2.cooldown_min, a2.cooldown_max)
				local target = U.find_foremost_enemy(store.entities, tpos(this), 0, a2.max_range, nil, a2.vis_flags, a2.vis_bans, function(e)
					if e.nav_path then
						return true
					end
					return false
				end)
				local path_index = 1
				local node_index = 1
				if target then
					path_index = target.nav_path.pi
					node_index = target.nav_path.ni + 10
				else
					path_index = this.tower.spawn_path_index
					node_index = this.tower.spawn_node_index + math.random(-3, 3)
				end

				qty = qty + 1

				local start_ts = store.tick_ts
				a2.ts = start_ts
				local spawn = E:create_entity(a2.entity)
				spawn.nav_path.pi = path_index
				spawn.nav_path.spi = math.random(1, 3)
				spawn.nav_path.ni = node_index
				spawn.pos = V.vclone(this.pos)
				spawn.motion.forced_waypoint = v(this.pos.x, this.pos.y - 30)

				queue_insert(store, spawn)

				if qty >= a2.spawns then
					qty = 0
					buyed = false
					ts_disable = start_ts
					waiting_disable = true
				end
			end

			if not a.disable and store.tick_ts - a.ts >= a.cooldown then
				enemy = U.find_foremost_enemy(store.entities, tpos(this), 0, at.range, false, a.vis_flags, a.vis_bans)

				if enemy then
					a.ts = store.tick_ts
					this.tower.cooldown_idle_ts = store.tick_ts

					shoot_enemy(enemy)

					goto label_955_0
				end
			end

			if not a.disable and store.tick_ts - this.tower.cooldown_idle_ts >= this.tower.cooldown_idle then
				this.tower.cooldown_idle_ts = store.tick_ts

				U.animation_start(this, "idle_2", nil, store.tick_ts, false, 4)
				U.y_animation_wait(this, 4)
			end
		end

		::label_955_0::

		coroutine.yield()
	end
end

scripts.tower_stage_20_arborean_barrack = {}

function scripts.tower_stage_20_arborean_barrack.get_info(this)
	return {
		type = STATS_TYPE_TEXT,
		desc = this.info.desc
	}
end

function scripts.tower_stage_20_arborean_barrack.update(this, store)
	local destroyed = false
	local current_health_th = 0
	local buyed = false
	local attack = this.attacks.list[1]
	local cooldown = 0
	local qty = 0
	local ts_disable = 0
	local waiting_disable = false

	this.user_selection.allowed = true

	local function destroy_tower()
		this.ui.can_click = false
		destroyed = true
		current_health_th = #this.life_thresholds + 1

		local fx = E:create_entity(this.explosion_fx2)

		fx.pos = V.v(this.pos.x, this.pos.y + 20)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
		U.animation_start(this, "idle" .. current_health_th, nil, store.tick_ts, true, this.render.sid_tower)

		this.render.sprites[this.render.sid_door].hidden = true
		this.render.sprites[this.render.sid_varitas].hidden = true
	end

	local function damage_tower()
		current_health_th = current_health_th + 1

		local fx = E:create_entity(this.explosion_fx)

		fx.pos = V.v(this.pos.x, this.pos.y + 20)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		if current_health_th >= #this.life_thresholds then
			S:queue(this.sound_destroyed)
			destroy_tower()
		else
			S:queue(this.sound_get_hit)
			U.animation_start(this, "idle" .. current_health_th + 1, nil, store.tick_ts, true, this.render.sid_tower)
		end
	end

	while true do
		if this.tower.blocked or destroyed then
			-- block empty
		else
			if this.health then
				if current_health_th <= #this.life_thresholds then
					local hp_percent = this.health.hp / this.health.hp_max

					if hp_percent <= this.life_thresholds[current_health_th + 1] then
						damage_tower()
					end
				end

				if this.health.dead then
					while current_health_th < #this.life_thresholds do
						damage_tower()
					end

					return
				end
			end

			if waiting_disable and store.tick_ts - ts_disable > attack.cooldown_disable then
				waiting_disable = false

				U.y_animation_play(this, "transicion1", nil, store.tick_ts, false, this.render.sid_varitas)
				U.animation_start(this, "idle1", nil, store.tick_ts, true, this.render.sid_varitas)

				this.user_selection.allowed = true
			end

			if this.user_selection.arg then
				this.user_selection.arg = nil

				local attack = this.attacks.list[1]

				store.player_gold = store.player_gold - attack.price
				this.user_selection.allowed = false
				buyed = true
				cooldown = math.random(attack.cooldown_min, attack.cooldown_max)
			end

			if buyed and cooldown < store.tick_ts - attack.ts then
				cooldown = math.random(attack.cooldown_min, attack.cooldown_max)

				local target_info = U.find_enemies_in_paths(store.entities, this.pos, 0, attack.range_nodes, 100, attack.vis_flags, attack.vis_bans, true)
				local path_index = 0
				local node_index = 0

				if target_info then
					local origin = target_info[1].origin

					path_index = origin[1]
					node_index = origin[3] + math.random(-3, 3)
				else
					path_index = this.tower.spawn_path_index
					node_index = this.tower.spawn_node_index + math.random(-3, 3)
				end

				qty = qty + 1

				U.y_animation_play(this, "open", nil, store.tick_ts, false, this.render.sid_door)

				local start_ts = store.tick_ts

				attack.ts = start_ts

				local spawn = E:create_entity(attack.entity)

				spawn.nav_path.pi = path_index
				spawn.nav_path.spi = math.random(1, 3)
				spawn.nav_path.ni = node_index
				spawn.pos = V.vclone(this.pos)
				spawn.motion.forced_waypoint = v(this.pos.x, this.pos.y - 30)

				queue_insert(store, spawn)
				U.animation_start(this, "close", nil, store.tick_ts, false, this.render.sid_door)

				if qty >= attack.spawns then
					U.y_animation_play(this, "transicion2", nil, store.tick_ts, false, this.render.sid_varitas)
					U.animation_start(this, "idle2", nil, store.tick_ts, true, this.render.sid_varitas)

					qty = 0
					buyed = false
					ts_disable = start_ts
					waiting_disable = true
				end
			end
		end

		coroutine.yield()
	end
end

scripts.soldier_charge = {}

function scripts.soldier_charge.get_info(this)
	local a = this.melee.attacks[1]
	local min, max = a.damage_min, a.damage_max

	min, max = min * this.unit.damage_factor, max * this.unit.damage_factor

	return {
		type = STATS_TYPE_SOLDIER,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		armor = this.health.armor,
		damage_min = min,
		damage_max = max
	}
end

function scripts.soldier_charge.insert(this, store, script)
	this.melee.order = U.attack_order(this.melee.attacks)

	return true
end

function scripts.soldier_charge.update(this, store, script)
	local attack = this.melee.attacks[1]
	local target
	local expired = false
	local next_pos = V.vclone(this.pos)
	local brk, sta, nearest

	if this.raise then
		if this.lifespan.duration then
			this.lifespan.ts = store.tick_ts
		end

		U.y_animation_play(this, this.raise, nil, store.tick_ts, 1)
	end

	while true do
		if this.health.dead or this.lifespan.duration and store.tick_ts - this.lifespan.ts > this.lifespan.duration then
			this.health.hp = 0

			if this.health.dead then
				SU.y_soldier_death(store, this)
			end

			this.tween.props[1].disabled = false
			this.tween.reverse = true
			this.tween.props[1].ts = store.tick_ts

			U.y_wait(store, fts(10))
			queue_remove(store, this)

			return
		end

		if SU5.go_to_forced_waypoint(this, store) then
			-- block empty
		elseif this.unit.is_stunned then
			U.animation_start(this, "idle", nil, store.tick_ts, -1)
		else
			brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

			if brk or sta ~= A_NO_TARGET then
				-- block empty
			else
				nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
					this.nav_path.pi
				}, {
					this.nav_path.spi
				})

				if nearest and nearest[1] and nearest[1][3] < this.nav_path.ni then
					this.nav_path.ni = nearest[1][3]
				end

				if this.special_walk then
					U.y_animation_play(this, "start_walk", nil, store.tick_ts, 1)
				end

				while next_pos and not target and not this.health.dead and not expired and not this.unit.is_stunned do
					U.set_destination(this, next_pos)

					local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

					U.animation_start(this, an, af, store.tick_ts, -1)
					U.walk(this, store.tick_length)
					coroutine.yield()

					target = U.find_foremost_enemy(store.entities, this.pos, 0, this.melee.range, false, attack.vis_flags, attack.vis_bans)

					if this.lifespan.duration then
						expired = store.tick_ts - this.lifespan.ts > this.lifespan.duration
					end

					next_pos = P:next_entity_node(this, store.tick_length)

					if not next_pos or not P:is_node_valid(this.nav_path.pi, this.nav_path.ni) or GR:cell_is(next_pos.x, next_pos.y, bor(TERRAIN_WATER, TERRAIN_CLIFF, TERRAIN_NOWALK)) then
						next_pos = nil
					end
				end

				target = nil

				if expired or this.health.dead or not next_pos then
					this.health.hp = 0

					if this.health.dead then
						SU.y_soldier_death(store, this)
					else
						this.tween.props[1].disabled = false
						this.tween.reverse = true
						this.tween.props[1].ts = store.tick_ts

						U.y_wait(store, fts(10))
					end

					queue_remove(store, this)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.tower_stage_20_arborean_watchtower = {}

function scripts.tower_stage_20_arborean_watchtower.update(this, store)
	local a = this.attacks
	local aa = this.attacks.list[1]
	local shooter_idx = 1
	local destroyed = false
	local threshold_index = 1
	local threshold = this.picked_enemies_to_destroy[1]
	local total_damage = 0
	local last_total_picked_enemies = 0
	local last_total_picked_enemies_ts = store.tick_ts
	local temp_all_tunnels_total_picked_enemies = 0
	local current_soldiers_amount = #this.shooter_sids - (threshold_index - 1)
	local cooldown_with_current_soldiers = aa.cooldown / current_soldiers_amount

	a._last_target_pos = a._last_target_pos or {
		v(REF_W, 0),
		v(REF_W, 0),
		v(REF_W, 0)
	}
	this.idle_flip.ts_counter = {}

	for i = 1, #this.shooter_sids do
		this.idle_flip.ts_counter[i] = math.random() * this.idle_flip.cooldown
	end

	local function watchtower_flip_idle()
		for i = 1, current_soldiers_amount do
			this.idle_flip.ts_counter[i] = this.idle_flip.ts_counter[i] + store.tick_length

			if this.idle_flip.ts_counter[i] > this.idle_flip.cooldown then
				this.idle_flip.ts_counter[i] = 0

				if math.random() < this.idle_flip.chance then
					local shooter_sid = this.shooter_sids[i]

					this.render.sprites[shooter_sid].flip_x = not this.render.sprites[shooter_sid].flip_x
				end
			end
		end
	end

	local function shot_animation(attack, shooter_idx, pos)
		local ssid = this.shooter_sids[shooter_idx]
		local soffset = this.render.sprites[ssid].offset
		local s = this.render.sprites[ssid]
		local an, af = U.animation_name_facing_point(this, attack.animation, pos, ssid, soffset)

		U.animation_start(this, an, af, store.tick_ts, 1, ssid)
	end

	local function shot_bullet(attack, shooter_idx, enemy, level)
		local ssid = this.shooter_sids[shooter_idx]
		local shooting_up = tpos(this).y < enemy.pos.y
		local shooting_right = not this.render.sprites[ssid].flip_x
		local soffset = this.render.sprites[ssid].offset
		local boffset = attack.bullet_start_offset[shooting_up and 1 or 2]
		local b = E:create_entity(attack.bullet)

		b.pos.x = this.pos.x + soffset.x + boffset.x * (shooting_right and 1 or -1)
		b.pos.y = this.pos.y + soffset.y + boffset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		b.bullet.target_id = enemy.id
		b.bullet.source_id = this.id
		b.bullet.level = level
		b.bullet.damage_factor = this.tower.damage_factor
		b.bullet.flight_time = 2 * (math.sqrt(2 * b.bullet.fixed_height * b.bullet.g * -1) / b.bullet.g * -1)

		queue_insert(store, b)
	end

	local function destroy_tower()
		for _, s_id in ipairs(this.shooter_sids) do
			this.render.sprites[s_id].hidden = true
		end

		destroyed = true
		this.ui.can_click = false
		threshold_index = #this.picked_enemies_to_destroy + 1

		U.y_animation_play_group(this, "destroy" .. threshold_index - 1, nil, store.tick_ts, false, this.tower_group)
		U.animation_start_group(this, "idle" .. threshold_index, nil, store.tick_ts, true, this.tower_group)
	end

	local function damage_tower()
		if total_damage < threshold then
			return
		end

		threshold_index = threshold_index + 1

		local fx = E:create_entity(this.explosion_fx)
		local fx_offset = V.vclone(this.render.sprites[this.shooter_sids[current_soldiers_amount]].offset)

		fx.pos = V.v(this.pos.x + fx_offset.x, this.pos.y + fx_offset.y)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		if threshold_index > #this.picked_enemies_to_destroy then
			U.y_animation_play_group(this, "destroy" .. threshold_index - 1, nil, store.tick_ts, false, this.tower_group)
			destroy_tower()
		else
			threshold = this.picked_enemies_to_destroy[threshold_index]

			local shooter_sprite_id = this.shooter_sids[#this.shooter_sids - (threshold_index - 2)]

			this.render.sprites[shooter_sprite_id].hidden = true

			U.animation_start_group(this, "idle" .. threshold_index, nil, store.tick_ts, true, this.tower_group)

			current_soldiers_amount = #this.shooter_sids - (threshold_index - 1)
			cooldown_with_current_soldiers = aa.cooldown / current_soldiers_amount
		end
	end

	local tunnels = {}
	local tunnel_index = 1

	for k, v in pairs(this.tunnel_spawns) do
		local tunnel = E:create_entity(v.template)

		tunnel.pos = this.pos
		tunnel.tunnel.pick_pi = v.pick_pi
		tunnel.tunnel.place_pi = v.place_pi

		queue_insert(store, tunnel)

		tunnels[tunnel_index] = tunnel
		tunnel_index = tunnel_index + 1
	end

	if store.level_mode == GAME_MODE_HEROIC then
		destroy_tower()
	end

	while true do
		if this.tower.blocked or destroyed then
			-- block empty
		else
			temp_all_tunnels_total_picked_enemies = 0

			for k, v in pairs(tunnels) do
				if v.total_picked_enemies then
					temp_all_tunnels_total_picked_enemies = temp_all_tunnels_total_picked_enemies + v.total_picked_enemies
				end
			end

			if store.tick_ts - last_total_picked_enemies_ts >= this.tunnel_check_cooldown then
				if temp_all_tunnels_total_picked_enemies ~= last_total_picked_enemies then
					last_total_picked_enemies = temp_all_tunnels_total_picked_enemies
					total_damage = total_damage + 1
					last_total_picked_enemies_ts = store.tick_ts

					damage_tower()

					goto label_965_0
				end
			else
				last_total_picked_enemies = temp_all_tunnels_total_picked_enemies
			end

			if cooldown_with_current_soldiers < store.tick_ts - aa.ts then
				local trigger_enemy, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

				if not trigger_enemy then
					SU.delay_attack(store, aa, fts(10))
				else
					aa.ts = store.tick_ts
					shooter_idx = km.zmod(shooter_idx + 1, current_soldiers_amount)

					shot_animation(aa, shooter_idx, trigger_enemy.pos)

					while store.tick_ts - aa.ts < aa.shoot_time do
						coroutine.yield()
					end

					local enemy, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, false, aa.vis_flags, aa.vis_bans)

					enemy = enemy or trigger_enemy

					if V.dist(tpos(this).x, tpos(this).y, enemy.pos.x, enemy.pos.y) <= a.range then
						shot_bullet(aa, shooter_idx, enemy, 0)

						a._last_target_pos[shooter_idx].x, a._last_target_pos[shooter_idx].y = enemy.pos.x, enemy.pos.y
					end

					while not U.animation_finished(this, this.shooter_sids[shooter_idx]) do
						watchtower_flip_idle()
						coroutine.yield()
					end

					this.idle_flip.ts_counter[shooter_idx] = 0
				end
			end

			if store.tick_ts - aa.ts > this.tower.long_idle_cooldown then
				for _, sid in pairs(this.shooter_sids) do
					local an, af = U.animation_name_facing_point(this, "idle", this.tower.long_idle_pos, sid)

					U.animation_start(this, an, af, store.tick_ts, -1, sid)
				end
			end

			watchtower_flip_idle()
		end

		::label_965_0::

		coroutine.yield()
	end
end

scripts.tower_stage_22_arborean_mages = {}

function scripts.tower_stage_22_arborean_mages.update(this, store)
	local a = this.attacks
	local aa = this.attacks.list[1]

	if store.level_mode ~= GAME_MODE_IRON then
		this.render.sprites[2].hidden = true
	end

	local function shot_bullet(attack, enemy, level)
		local shooting_right = not this.render.sprites[2].flip_x
		local b = E:create_entity(attack.bullet)

		b.pos.x = this.pos.x + attack.bullet_start_offset.x * (shooting_right and 1 or -1)
		b.pos.y = this.pos.y + attack.bullet_start_offset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		b.bullet.target_id = enemy.id
		b.bullet.source_id = this.id
		b.bullet.level = level
		b.bullet.damage_factor = this.tower.damage_factor

		queue_insert(store, b)
	end

	while true do
		if this.tower.blocked then
			-- block empty
		else
			if store.tick_ts - aa.ts > aa.cooldown and not this.boss_is_going_to_eat then
				local trigger_enemy, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, aa.prediction_time, aa.vis_flags, aa.vis_bans)

				if not trigger_enemy then
					SU.delay_attack(store, aa, fts(10))
				else
					aa.ts = store.tick_ts

					local an, af = U.animation_name_facing_point(this, aa.animation, pred_pos)

					U.animation_start(this, an, af, store.tick_ts, false, 2)
					U.y_wait(store, aa.shoot_time)

					local enemy, _ = U.find_foremost_enemy(store.entities, tpos(this), 0, a.range, aa.prediction_time - aa.shoot_time, aa.vis_flags, aa.vis_bans, function(e)
						local looking_left = this.render.sprites[2].flip_x

						return looking_left and e.pos.x < this.pos.x or not looking_left and e.pos.x >= this.pos.x
					end)

					enemy = enemy or trigger_enemy

					shot_bullet(aa, enemy, 0)
					U.y_animation_wait(this, 2, 1)
					U.animation_start(this, "idle", nil, store.tick_ts, true, 2)
				end
			end

			if this.appear then
				this.appear = false

				local total_wait_time = fts(30)
				local start_wait_ts = store.tick_ts

				U.y_animation_play(this, "redin", nil, store.tick_ts, 1, this.render.sid_rune)
				U.animation_start(this, "idlered", nil, store.tick_ts, true, this.render.sid_rune, true)
				U.y_wait(store, total_wait_time - (store.tick_ts - start_wait_ts))
				U.y_wait(store, fts(30))

				this.render.sprites[2].hidden = false

				U.y_animation_play(this, this.appear_anim, false, store.tick_ts, 1, 2)
				U.animation_start(this, "idle", nil, store.tick_ts, true, 2)
				U.y_wait(store, 0.4)
				U.animation_start(this, "tauntIn", nil, store.tick_ts, false, 2, true)
				U.y_wait(store, fts(15))

				this.boss_eating = false

				for _, e in pairs(store.entities) do
					if e.template_name == "decal_stage_22_rune_rock" or e.template_name == "decal_stage_22_rune_doors" then
						e.boss_eating = false
					end
				end

				U.animation_start(this, "redout", nil, store.tick_ts, false, this.render.sid_rune, true)
				U.y_animation_wait(this, 2)
				U.animation_start(this, "taunLoop", nil, store.tick_ts, true, 2, true)
				U.y_animation_wait(this, this.render.sid_rune)
				U.animation_start(this, "idleblue", nil, store.tick_ts, true, this.render.sid_rune, true)

				total_wait_time = fts(60)
				start_wait_ts = store.tick_ts

				U.y_wait(store, total_wait_time - (store.tick_ts - start_wait_ts))
				U.y_animation_play(this, "tauntOut", false, store.tick_ts, 1, 2)
				U.animation_start(this, "idle", false, store.tick_ts, true, 2)
				U.y_wait(store, 8)
			end

			if this.escape then
				U.y_animation_play(this, this.leave_anim, false, store.tick_ts, 1, 2)

				while true do
					coroutine.yield()
				end
			end

			if this.boss_eating then
				this.boss_is_going_to_eat = false

				U.animation_start(this, "idle", false, store.tick_ts, true, 2)

				local total_wait_time = fts(119)
				local start_wait_ts = store.tick_ts

				U.y_animation_play(this, "redin", nil, store.tick_ts, 1, this.render.sid_rune)
				U.animation_start(this, "idlered", nil, store.tick_ts, true, this.render.sid_rune, true)
				U.y_wait(store, total_wait_time - (store.tick_ts - start_wait_ts))
				U.animation_start(this, "tauntIn", nil, store.tick_ts, false, 2, true)
				U.y_wait(store, fts(15))

				this.boss_eating = false

				for _, e in pairs(store.entities) do
					if e.template_name == "decal_stage_22_rune_rock" or e.template_name == "decal_stage_22_rune_doors" then
						e.boss_eating = false
					end
				end

				U.animation_start(this, "redout", nil, store.tick_ts, false, this.render.sid_rune, true)
				U.y_animation_wait(this, 2)
				U.animation_start(this, "taunLoop", nil, store.tick_ts, true, 2, true)
				U.y_animation_wait(this, this.render.sid_rune)
				U.animation_start(this, "idleblue", nil, store.tick_ts, true, this.render.sid_rune, true)

				total_wait_time = fts(60)
				start_wait_ts = store.tick_ts

				U.y_wait(store, total_wait_time - (store.tick_ts - start_wait_ts))
				U.y_animation_play(this, "tauntOut", false, store.tick_ts, 1, 2)
				U.animation_start(this, "idle", false, store.tick_ts, true, 2)
				U.y_wait(store, 8)
			end
		end

		coroutine.yield()
	end
end

scripts.trees_arborean_sages = {}

function scripts.trees_arborean_sages.update(this, store, script)
	local a = this.bullet_attack

	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

	while this.spawn_wave > store.wave_group_number do
		coroutine.yield()
	end

	U.y_animation_play(this, this.spawn_anim, nil, store.tick_ts, 1)

	a.ts = store.tick_ts - a.cooldown + 1

	while true do
		U.animation_start(this, "idle", nil, store.tick_ts)

		if store.wave_group_number >= this.leave_wave then
			U.y_animation_play(this, this.leave_anim, nil, store.tick_ts, 1)
			U.animation_start(this, this.gone_anim, nil, store.tick_ts, 1)

			return
		end

		if store.tick_ts - a.ts > a.cooldown then
			local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, false, a.vis_flags, a.vis_bans)

			if not target then
				SU.delay_attack(store, a, 0.2)
			else
				a.ts = store.tick_ts

				if target and target.health and not target.health.dead then
					local b = E:create_entity(a.bullet)

					b.bullet.from = V.v(this.pos.x + a.bullet_start_offset.x, this.pos.y + a.bullet_start_offset.y)
					b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
					b.bullet.target_id = target.id
					b.bullet.source_id = this.id
					b.pos = V.vclone(b.bullet.from)

					U.animation_start(this, a.animation, nil, store.tick_ts)
					S:queue("SpecialTusken", {
						delay = fts(19)
					})
					U.y_wait(store, a.shoot_time)
					queue_insert(store, b)
					S:queue("ShotgunSound")
					U.y_animation_wait(this)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.trees_fruity_tree = {}

function scripts.trees_fruity_tree.insert(this, store, script)
	local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, 0, this.custom_attack.range, nil, nil, nil, {
		1,
		2,
		3
	})

	this.available_nodes = {}

	for i = 1, #nodes do
		table.insert(this.available_nodes, nodes[i])
	end

	return true
end

function scripts.trees_fruity_tree.update(this, store, script)
	local a = this.custom_attack

	a.ts = store.tick_ts
	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

	local function get_valid_pos(distance_between, available_nodes, selected_nodes)
		local new_pos
		local tries = 0
		local is_valid_node = false

		while not is_valid_node and tries < 40 do
			new_pos = available_nodes[math.random(1, #available_nodes)]

			local is_too_close = false

			for _, value in ipairs(selected_nodes) do
				if distance_between >= V.dist(new_pos.x, new_pos.y, value.x, value.y) then
					is_too_close = true

					break
				end
			end

			if not is_too_close then
				is_valid_node = true
			end

			tries = tries + 1
		end

		return new_pos
	end

	while true do
		U.animation_start(this, "idle", nil, store.tick_ts)

		if store.tick_ts - a.ts > a.cooldown then
			local start_ts = store.tick_ts
			local selected_nodes = {}

			for amount = 1, a.max_fruits do
				local fruit_pos = get_valid_pos(a.distance_between_fruits, this.available_nodes, selected_nodes)

				table.insert(selected_nodes, fruit_pos)

				local flip = fruit_pos.x < this.pos.x

				U.animation_start(this, "shoot", flip, store.tick_ts)

				if U.y_wait(store, a.shoot_time, false) then
					goto label_780_0
				end

				a.ts = start_ts

				local af = this.render.sprites[1].flip_x
				local b = E:create_entity(a.bullet)
				local o = a.bullet_start_offset

				b.bullet.from = V.v(this.pos.x + (af and -1 or 1) * o.x, this.pos.y + o.y)
				b.bullet.to = fruit_pos
				b.pos = V.vclone(b.bullet.from)
				b.bullet.source_id = this.id

				queue_insert(store, b)
			end

			a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

			if not U.y_animation_wait(this) then
				-- block empty
			end
		end

		::label_780_0::

		coroutine.yield()
	end
end

scripts.trees_fruity_tree_fruit = {}

function scripts.trees_fruity_tree_fruit.update(this, store, script)
	local ts = store.tick_ts

	while true do
		if store.tick_ts - ts >= this.duration then
			break
		end

		local targets = U.find_soldiers_in_range(store.entities, this.pos, 0, this.radius, this.vis_flags, this.vis_bans)

		if targets and #targets > 0 then
			if this.hit_decal then
				local dec = E:create_entity(this.hit_decal)

				dec.pos = V.vclone(this.pos)
				dec.render.sprites[1].ts = store.tick_ts

				queue_insert(store, dec)
			end

			S:queue(this.sound)

			if this.hit_fx then
				local fx = E:create_entity(this.hit_fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end

			for _, target in ipairs(targets) do
				local m = E:create_entity(this.mod)

				m.heal_hp = this.heal_hp
				m.modifier.target_id = target.id
				m.modifier.source_id = this.id

				queue_insert(store, m)
			end

			break
		end

		U.y_wait(store, this.check_interval)
	end

	queue_remove(store, this)
end

scripts.soldier_priests_barrack = {}

function scripts.soldier_priests_barrack.get_info(this)
	local attacks = this.ranged.attacks
	local min, max

	for _, a in pairs(attacks) do
		if a.damage_min then
			min, max = a.damage_min, a.damage_max

			break
		end
	end

	if this.unit and min then
		min, max = min * this.unit.damage_factor, max * this.unit.damage_factor
	end

	if min and max then
		min, max = math.ceil(min), math.ceil(max)
	end

	return {
		type = STATS_TYPE_SOLDIER,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		damage_icon = this.info.damage_icon,
		armor = this.health.armor,
		respawn = this.health.dead_lifetime
	}
end

function scripts.soldier_priests_barrack.update(this, store, script)
	local brk, sta

	if this.vis._bans then
		this.vis.bans = this.vis._bans
		this.vis._bans = nil
	end

	if this.render.sprites[1].name == "raise" then
		this.health_bar.hidden = true

		U.animation_start(this, "raise", nil, store.tick_ts, 1)

		while not U.animation_finished(this) and not this.health.dead do
			coroutine.yield()
		end

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	local function priest_transformation()
		if this.death_spawns.fx then
			local fx = E:create_entity(this.death_spawns.fx)

			fx.pos = V.vclone(this.pos)
			fx.render.sprites[1].ts = store.tick_ts

			if this.death_spawns.fx_flip_to_source and this.render and this.render.sprites[1] then
				fx.render.sprites[1].flip_x = this.render.sprites[1].flip_x
			end

			queue_insert(store, fx)
		end

		local s = E:create_entity(this.death_spawns.name)

		s.pos = V.vclone(this.pos)

		if this.death_spawns.spawn_animation and s.render then
			s.render.sprites[1].name = this.death_spawns.spawn_animation
		end

		if s.render and s.render.sprites[1] and this.render and this.render.sprites[1] then
			s.render.sprites[1].flip_x = this.render.sprites[1].flip_x
		end

		if s.nav_path then
			s.nav_path.pi = this.nav_path.pi

			local spread_nodes = this.death_spawns.spread_nodes

			if spread_nodes > 0 then
				s.nav_path.spi = km.zmod(this.nav_path.spi + i, 3)

				local node_offset = spread_nodes * -2 * math.floor(i / 3)

				s.nav_path.ni = this.nav_path.ni + node_offset + spread_nodes
			else
				s.nav_path.spi = this.nav_path.spi
				s.nav_path.ni = this.nav_path.ni + 2
			end
		end

		if s.nav_grid and this.nav_grid then
			s.nav_grid = table.deepclone(this.nav_grid)
		end

		if s.nav_rally and this.nav_rally then
			s.nav_rally = table.deepclone(this.nav_rally)
		end

		if this.death_spawns.offset then
			s.pos.x = s.pos.x + this.death_spawns.offset.x
			s.pos.y = s.pos.y + this.death_spawns.offset.y
		end

		queue_insert(store, s)

		local tower = store.entities[this.soldier.tower_id]

		s.soldier.tower_id = tower.id

		table.insert(tower.barrack.soldiers, s)

		return s
	end

	while true do
		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					SU.soldier_power_upgrade(this, pn)
				end
			end
		end

		if this.cloak then
			this.vis.flags = band(this.vis.flags, bnot(this.cloak.flags))
			this.vis.bans = band(this.vis.bans, bnot(this.cloak.bans))
			this.render.sprites[1].alpha = 255
		end

		if not this.health.dead or SU.y_soldier_revive(store, this) then
			-- block empty
		else
			local r = math.random() * 100
			local transformation = false
			local force_abomination = false

			if this.mercenary_spawn_number == 1 then
				force_abomination = true
			end

			if r < this.transform_chances[1] or force_abomination then
				S:queue(this.sound_events.death, this.sound_events.death_args)
				U.y_animation_play(this, "transformation_abomination", nil, store.tick_ts, 1)

				this.ui.can_select = false
				this.health.death_finished_ts = store.tick_ts

				if this.ui then
					this.ui.can_click = this.ui.can_click and not this.unit.hide_after_death
					this.ui.z = -1
				end

				priest_transformation()
				queue_remove(store, this)

				return
			elseif r < this.transform_chances[1] + this.transform_chances[2] then
				local tentacle = E:create_entity("decal_tentacle_priests_barrack")
				local maxOffset = 10
				local offsetX, offsetY = -maxOffset + maxOffset * math.random() * 2, -maxOffset + maxOffset * math.random() * 2

				tentacle.pos = V.v(this.pos.x + offsetX, this.pos.y + offsetY)

				queue_insert(store, tentacle)
				S:queue(this.sound_events.death, this.sound_events.death_args)
				U.y_animation_play(this, "transform_tentacle", nil, store.tick_ts, 1)

				this.ui.can_select = false
				this.health.death_finished_ts = store.tick_ts

				if this.ui then
					this.ui.can_click = this.ui.can_click and not this.unit.hide_after_death
					this.ui.z = -1
				end

				U.sprites_hide(this)
			end

			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			if this.dodge and this.dodge.active then
				this.dodge.active = false

				if this.dodge.counter_attack and this.powers[this.dodge.counter_attack.power_name].level > 0 then
					this.dodge.counter_attack_pending = true
				elseif this.dodge.animation then
					U.animation_start(this, this.dodge.animation, nil, store.tick_ts, 1)

					while not U.animation_finished(this) do
						coroutine.yield()
					end
				end

				signal.emit("soldier-dodge", this)
			end

			if SU5.go_to_forced_waypoint(this, store) then
				-- block empty
			else
				while this.nav_rally.new do
					if SU.y_soldier_new_rally(store, this) then
						goto label_1140_1
					end
				end

				this.nav_rally.delay_max = 0.25

				if this.timed_actions then
					brk, sta = SU.y_soldier_timed_actions(store, this)

					if brk then
						goto label_1140_1
					end
				end

				if this.timed_attacks then
					brk, sta = SU.y_soldier_timed_attacks(store, this)

					if brk then
						goto label_1140_1
					end
				end

				if this.ranged and this.ranged.range_while_blocking then
					brk, sta = SU.y_soldier_ranged_attacks(store, this)

					if brk then
						goto label_1140_1
					end
				end

				if this.melee then
					brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

					if brk or sta ~= A_NO_TARGET then
						goto label_1140_1
					end
				end

				if this.ranged and not this.ranged.range_while_blocking then
					brk, sta = SU.y_soldier_ranged_attacks(store, this)

					if brk or sta == A_DONE then
						goto label_1140_1
					elseif sta == A_IN_COOLDOWN and not this.ranged.go_back_during_cooldown then
						goto label_1140_0
					end
				end

				if SU.soldier_go_back_step(store, this) then
					goto label_1140_1
				end

				::label_1140_0::

				SU.soldier_idle(store, this)

				if this.cloak then
					this.vis.flags = bor(this.vis.flags, this.cloak.flags)
					this.vis.bans = bor(this.vis.bans, this.cloak.bans)

					if this.cloak.alpha then
						this.render.sprites[1].alpha = this.cloak.alpha
					end
				end

				SU.soldier_regen(store, this)
			end
		end

		::label_1140_1::

		coroutine.yield()
	end
end

scripts.soldier_abomination_priests_barrack = {}

function scripts.soldier_abomination_priests_barrack.update(this, store, script)
	local brk, sta

	this.reinforcement.ts = store.tick_ts

	if this.vis._bans then
		this.vis.bans = this.vis._bans
		this.vis._bans = nil
	end

	if this.render.sprites[1].name == "raise" then
		this.health_bar.hidden = true

		U.animation_start(this, "raise", nil, store.tick_ts, 1)

		while not U.animation_finished(this) and not this.health.dead do
			coroutine.yield()
		end

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	while true do
		if this.powers then
			for pn, p in pairs(this.powers) do
				if p.changed then
					p.changed = nil

					SU.soldier_power_upgrade(this, pn)
				end
			end
		end

		if this.cloak then
			this.vis.flags = band(this.vis.flags, bnot(this.cloak.flags))
			this.vis.bans = band(this.vis.bans, bnot(this.cloak.bans))
			this.render.sprites[1].alpha = 255
		end

		if this.health.dead then
			this.reinforcement.fade = false
			this.reinforcement.fade_out = false

			SU.remove_modifiers(store, this)
			SU.y_soldier_death(store, this)

			return
		elseif not this.soldier.target_id and this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			SU.remove_modifiers(store, this)
			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			if this.dodge and this.dodge.active then
				this.dodge.active = false

				if this.dodge.counter_attack and this.powers[this.dodge.counter_attack.power_name].level > 0 then
					this.dodge.counter_attack_pending = true
				elseif this.dodge.animation then
					U.animation_start(this, this.dodge.animation, nil, store.tick_ts, 1)

					while not U.animation_finished(this) do
						coroutine.yield()
					end
				end

				signal.emit("soldier-dodge", this)
			end

			while this.nav_rally.new do
				if SU.y_soldier_new_rally(store, this) then
					goto label_1142_1
				end
			end

			if this.timed_actions then
				brk, sta = SU.y_soldier_timed_actions(store, this)

				if brk then
					goto label_1142_1
				end
			end

			if this.timed_attacks then
				brk, sta = SU.y_soldier_timed_attacks(store, this)

				if brk then
					goto label_1142_1
				end
			end

			if this.ranged and this.ranged.range_while_blocking then
				brk, sta = SU.y_soldier_ranged_attacks(store, this)

				if brk then
					goto label_1142_1
				end
			end

			if this.melee then
				brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or sta ~= A_NO_TARGET then
					goto label_1142_1
				end
			end

			if this.ranged and not this.ranged.range_while_blocking then
				brk, sta = SU.y_soldier_ranged_attacks(store, this)

				if brk or sta == A_DONE then
					goto label_1142_1
				elseif sta == A_IN_COOLDOWN and not this.ranged.go_back_during_cooldown then
					goto label_1142_0
				end
			end

			if SU.soldier_go_back_step(store, this) then
				goto label_1142_1
			end

			::label_1142_0::

			SU.soldier_idle(store, this)

			if this.cloak then
				this.vis.flags = bor(this.vis.flags, this.cloak.flags)
				this.vis.bans = bor(this.vis.bans, this.cloak.bans)

				if this.cloak.alpha then
					this.render.sprites[1].alpha = this.cloak.alpha
				end
			end

			SU.soldier_regen(store, this)
		end

		::label_1142_1::

		coroutine.yield()
	end
end

scripts.decal_tentacle_priests_barrack = {}

function scripts.decal_tentacle_priests_barrack.update(this, store, script)
	local a = this.area_attack

	this.spawn_ts = store.tick_ts
	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

	U.y_animation_play(this, "raise", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	a.ts = store.tick_ts - a.cooldown

	while true do
		if store.tick_ts - this.spawn_ts > this.duration then
			SU.remove_modifiers(store, this)
			U.y_animation_play(this, "death", nil, store.tick_ts, 1)
			queue_remove(store, this)

			return
		end

		if store.tick_ts - a.ts > a.cooldown then
			local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, a.hit_time, a.vis_flags, a.vis_bans)

			if not target or not pred_pos then
				-- block empty
			else
				a.ts = store.tick_ts

				S:queue(a.sound)

				local flip_x = pred_pos.x < this.pos.x

				U.animation_start(this, a.animation, flip_x, store.tick_ts, false)
				U.y_wait(store, a.hit_time)

				local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)

				if enemies and #enemies > 0 then
					local e = E:create_entity(a.aura)

					e.pos.x, e.pos.y = this.pos.x, this.pos.y
					e.owner = this
					e.aura.source_id = this.id

					queue_insert(store, e)
				end

				U.y_animation_wait(this)
			end
		end

		coroutine.yield()
	end
end

scripts.instant_heal_mod = {}

function scripts.instant_heal_mod.insert(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or not target.health or target.health.dead then
		return false
	end

	target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp + this.heal_hp)
	this.render.sprites[1].ts = store.tick_ts

	return true
end

scripts.tool_auto_player = {}

function scripts.tool_auto_player.insert(this, store, script)
	return true
end

function scripts.tool_auto_player.update(this, store, script)
	this.spawn_entity_ts = store.tick_ts
	this.tower_update_ts = store.tick_ts

	local towers_to_spawn = store.selected_towers

	if this.auto_player.override_towers then
		towers_to_spawn = this.auto_player.override_towers
	end

	local terrain = 1

	if store.level_idx <= 6 then
		terrain = 1
	elseif store.level_idx <= 11 then
		terrain = 2
	elseif store.level_idx <= 16 then
		terrain = 3
	elseif store.level_idx <= 19 then
		terrain = 4
	elseif store.level_idx <= 22 then
		terrain = 5
	elseif store.level_idx <= 27 then
		terrain = 6
	elseif store.level_idx <= 30 then
		terrain = 7
	end

	local enemies = this.auto_player.enemies[terrain]

	if this.auto_player.override_enemies then
		enemies = this.auto_player.override_enemies
	end

	while true do
		game.store.player_gold = 1000
		game.store.lives = 1000

		if store.tick_ts - this.spawn_entity_ts > this.auto_player.spawn_enemy_interval then
			this.spawn_entity_ts = store.tick_ts

			local pi = math.random(#P.paths)
			local path = P.paths[pi]
			local entity_id = enemies[math.random(#enemies)]
			local e = E:create_entity(entity_id)

			if e then
				e.nav_path.pi = pi
				e.nav_path.spi = math.random(#path)
				e.nav_path.ni = P:get_start_node(pi)

				queue_insert(store, e)
			end
		end

		if store.tick_ts - this.tower_update_ts > this.auto_player.tower_update_interval then
			this.tower_update_ts = store.tick_ts

			local i = 1
			local holders = E:filter(store.entities, "tower_holder")

			if holders and #holders > 0 then
				local h = holders[math.random(#holders)]
				local type = towers_to_spawn[math.random(#towers_to_spawn)]
				local tower_levels = {}

				for i = 1, 4 do
					local tower_name = "tower_" .. type .. "_lvl" .. i

					table.insert(tower_levels, tower_name)
				end

				local tower_level = 1

				h.tower.upgrade_to = tower_levels[tower_level]
			end

			do
				local towers = table.filter(store.entities, function(k, e)
					return e.tower and not e.tower_holder and e.tower.level < 4 and not table.contains(this.auto_player.excluded_towers, e.template_name)
				end)

				if towers and #towers > 0 then
					local tower = towers[math.random(#towers)]
					local tower_type = tower.tower.type
					local tower_level = tower.tower.level
					local levels = {}

					for i = 1, 4 do
						local tower_name = "tower_" .. tower_type .. "_lvl" .. i

						table.insert(levels, tower_name)
					end

					tower.tower.upgrade_to = levels[tower_level + 1]
				end
			end

			do
				local towers = table.filter(store.entities, function(k, e)
					return e.tower and not e.tower_holder and e.tower.level == 4
				end)

				if towers and #towers > 0 then
					local tower = towers[math.random(#towers)]

					if tower.tower and tower.powers then
						for k, p in pairs(tower.powers) do
							p.level = p.max_level
							p.changed = true
						end
					end
				end
			end

			if math.random() < this.auto_player.tower_sell_chance then
				local towers = table.filter(store.entities, function(k, e)
					return e.tower and not e.tower_holder and not table.contains(this.auto_player.excluded_towers, e.template_name)
				end)

				if towers and #towers > 0 then
					local tower = towers[math.random(#towers)]

					tower.tower.sell = true
				end
			end
		end

		coroutine.yield()
	end
end

scripts.trees_guardian_tree = {}

function scripts.trees_guardian_tree.insert(this, store, script)
	return true
end

function scripts.trees_guardian_tree.update(this, store, script)
	local a = this.custom_attack

	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)
	a.ts = store.tick_ts - a.cooldown

	local is_active_on_wave = false

	local function should_be_on()
		local current_wave = store.wave_group_number
		local current_config = this.wave_config[current_wave]

		return current_config
	end

	local function can_shoot()
		return store.tick_ts - a.ts > a.cooldown
	end

	U.y_animation_play_group(this, this.animation_idle_sleep, nil, store.tick_ts, false, "layers")

	while true do
		if is_active_on_wave then
			if not should_be_on() then
				U.y_animation_play_group(this, this.animation_go_to_sleep, nil, store.tick_ts, false, "layers")
				U.y_animation_play_group(this, this.animation_idle_sleep, nil, store.tick_ts, false, "layers")

				is_active_on_wave = false
			else
				if can_shoot() then
					local enemies = U.find_enemies_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

					if not enemies then
						SU.delay_attack(store, a, 0.13333333333333333)

						goto label_790_0
					end

					a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)
					a.ts = store.tick_ts

					S:queue(this.sound_pre_cast)
					U.animation_start_group(this, a.animation, nil, store.tick_ts, false, "layers")

					if U.y_wait(store, a.shoot_time, false) then
						goto label_790_0
					end

					S:queue(this.sound_cast)

					local p = E:create_entity(a.entity)

					p.pos = V.vclone(this.pos)

					local ni = P:get_end_node(p.wave_pi)

					p.wave_ni = ni

					queue_insert(store, p)
					S:queue(this.sound_roots)
					U.y_animation_wait(this)
				end

				U.animation_start(this, this.animation_idle_awake, nil, store.tick_ts)
				U.y_wait(store, fts(95), can_shoot())
			end
		elseif should_be_on() then
			U.y_animation_play_group(this, this.animation_go_to_awake, nil, store.tick_ts, false, "layers")

			is_active_on_wave = true or is_active_on_wave
		end

		::label_790_0::

		coroutine.yield()
	end
end

scripts.trees_guardian_tree_wave_of_roots = {}

function scripts.trees_guardian_tree_wave_of_roots.update(this, store)
	local count = this.count
	local wave_pi = this.wave_pi
	local wave_ni = this.wave_ni + this.start_offset
	local rootCounter = 0
	local max_duration = 6

	local function createDecal(node_pos)
		local e = E:create_entity(this.decal)

		e.render.sprites[1].prefix = e.render.sprites[1].prefix .. 1 + rootCounter % 5
		rootCounter = rootCounter + 1
		e.pos = node_pos
		e.pos.x = e.pos.x + math.random(-10, 10)
		e.render.sprites[1].ts = store.tick_ts
		e.render.sprites[1].flip_x = math.random(0, 1) == 1
		e.sequence.steps[2] = max_duration - rootCounter * 0.1

		queue_insert(store, e)
	end

	local pos1 = this.root_hand_L_pos
	local pos2 = this.root_hand_R_pos
	local node_pos = P:node_pos(wave_pi, 1, wave_ni + this.root_hand_offset_path_merge)
	local length1 = V.dist(pos1.x, pos1.y, node_pos.x, node_pos.y)
	local length2 = V.dist(pos2.x, pos2.y, node_pos.x, node_pos.y)
	local v1 = v(node_pos.x - pos1.x, node_pos.y - pos1.y)
	local v2 = v(node_pos.x - pos2.x, node_pos.y - pos2.y)

	v1.x = v1.x / length1
	v1.y = v1.y / length1

	local v1perpendicular = v(v1.y, -v1.x)

	v2.x = v2.x / length2
	v2.y = v2.y / length2

	local v2perpendicular = v(v2.y, -v2.x)
	local distance = 0
	local patterns = {
		{
			20,
			-20
		},
		{
			0
		}
	}
	local counter = 0

	while length1 > distance + 50 do
		local pattern = patterns[1 + counter % #patterns]

		counter = counter + 1

		for i = 1, #pattern do
			local x = pos1.x + v1.x * distance + v1perpendicular.x * pattern[i]
			local y = pos1.y + v1.y * distance + v1perpendicular.y * pattern[i]

			createDecal(v(x, y))

			x = pos2.x + v2.x * distance + v2perpendicular.x * pattern[i]
			y = pos2.y + v2.y * distance + v2perpendicular.y * pattern[i]

			createDecal(v(x, y))
		end

		U.y_wait(store, U.frandom(this.show_delay_min, this.show_delay_max))

		distance = distance + math.random(10, 30)
	end

	patterns = {
		{
			3,
			2
		},
		{
			1
		}
	}

	for j = 1, count do
		local pattern = patterns[1 + j % #patterns]

		wave_ni = wave_ni - math.random(this.sep_nodes_min, this.sep_nodes_max)

		for i = 1, #pattern do
			local node = {
				pi = wave_pi,
				spi = pattern[i],
				ni = wave_ni
			}
			local node_pos = P:node_pos(node.pi, node.spi, node.ni)

			if P:is_node_valid(node.pi, node.ni) then
				createDecal(node_pos)

				local targets = U.find_enemies_in_range(store.entities, node_pos, 0, this.radius, this.vis_flags, this.vis_bans)

				if targets then
					for _, target in pairs(targets) do
						local m = E:create_entity(this.mod)

						m.modifier.target_id = target.id
						m.modifier.source_id = this.id

						queue_insert(store, m)
					end
				end
			end

			U.y_wait(store, U.frandom(this.show_delay_min, this.show_delay_max))
		end
	end

	queue_remove(store, this)
end

scripts.trees_guardian_tree_vine_aura_decal = {}

function scripts.trees_guardian_tree_vine_aura_decal.update(this, store)
	U.y_animation_play(this, "start", nil, store.tick_ts, 1)
	U.y_animation_play(this, "idle", nil, store.tick_ts, 1)

	local aura = E:create_entity(this.spawn_aura)

	aura.aura.source_id = this.id
	aura.aura.ts = store.tick_ts
	aura.pos = V.vclone(this.pos)

	queue_insert(store, aura)

	while true do
		if store.tick_ts - aura.aura.ts > aura.aura.duration then
			U.y_animation_play(this, "end", nil, store.tick_ts, 1)
			queue_remove(store, this)
		end

		coroutine.yield()
	end
end

scripts.trees_guardian_tree_vine_mod = {}

function scripts.trees_guardian_tree_vine_mod.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead then
		return false
	end

	if target.guardian_tree_vine_mod_ts and store.tick_ts - target.guardian_tree_vine_mod_ts < this.modifier.immune_for_seconds then
		return false
	end

	if target and target.unit and this.render then
		local s = this.render.sprites[1]

		if s.size_names then
			s.prefix = s.prefix .. "_" .. s.size_names[target.unit.size]
			s.flip_x = target.render.sprites[1].flip_x
		end

		if s.size_scales then
			local scale = s.size_scales[target.unit.size]

			s.scale = {
				x = s.scale.x * scale,
				y = s.scale.y * scale
			}
		end

		if this.modifier.use_mod_offset and target.unit.mod_offset then
			s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
		end

		s.flip_x = false
	end

	this.modifier.ts = store.tick_ts

	local target = store.entities[this.modifier.target_id]

	if target and not target.health.dead then
		SU.stun_inc(target)
	end

	target.guardian_tree_vine_mod_ts = store.tick_ts

	return true
end

function scripts.trees_guardian_tree_vine_mod.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		SU.stun_dec(target)
	end

	return true
end

function scripts.trees_guardian_tree_vine_mod.update(this, store)
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if target and not target.health.dead then
		this.pos = target.pos

		U.animation_start(this, "start", nil, store.tick_ts)

		while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
			coroutine.yield()
		end

		U.y_animation_play(this, "end", nil, store.tick_ts, 1)
	end

	queue_remove(store, this)
end

scripts.trees_heart_of_the_arborean_decal = {}

function scripts.trees_heart_of_the_arborean_decal.insert(this, store)
	this.danger_zones = {
		V.v(300, 565),
		V.v(710, 570)
	}
	this.safe_dist2 = 3600

	local a = this.custom_attack

	local function avoid_danger_zone(x, y)
		local dz = this.danger_zones
		local sd2 = this.safe_dist2

		return sd2 < V.dist2(x, y, dz[1].x, dz[1].y) and sd2 < V.dist2(x, y, dz[2].x, dz[2].y)
	end

	this.nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, 0, a.max_range, nil, avoid_danger_zone, nil)

	return true
end

function scripts.trees_heart_of_the_arborean_decal.update(this, store)
	local a = this.custom_attack
	local positions = {}
	local selected_positions = {}
	local max_dist2 = a.min_dist_between_tgts * a.min_dist_between_tgts

	this.clicked = false

	local function avoid_danger_zone(e, origin)
		local dz = this.danger_zones
		local sd2 = this.safe_dist2

		return sd2 < V.dist2(e.pos.x, e.pos.y, dz[1].x, dz[1].y) and sd2 < V.dist2(e.pos.x, e.pos.y, dz[2].x, dz[2].y)
	end

	local function get_pos_from_target(target)
		local node = table.deepclone(target.nav_path)

		node.spi = 1

		local node_pos = P:node_pos(node)

		return node_pos
	end

	local function shoot_bullet(pos)
		local b = E:create_entity(a.bullet)

		b.pos.x, b.pos.y = this.pos.x + a.bullet_start_offset.x, this.pos.y + a.bullet_start_offset.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = pos
		b.bullet.source_id = this.id

		queue_insert(store, b)
	end

	local function shuffle_table(nodes)
		for i = #nodes, 2, -1 do
			local j = math.random(i)

			nodes[i], nodes[j] = nodes[j], nodes[i]
		end

		return nodes
	end

	local shamans = table.filter(store.entities, function(_, e)
		return e.template_name == "trees_heart_of_the_arborean_shaman_decal"
	end)

	for _, shaman in ipairs(shamans) do
		shaman.shaman_state = "waiting"
	end

	U.animation_start(this, "idleLoading", nil, store.tick_ts, true)

	while store.wave_group_number < 1 do
		coroutine.yield()
	end

	::label_801_0::

	U.animation_start(this, "idleLoading", nil, store.tick_ts, true)

	for _, shaman in ipairs(shamans) do
		shaman.shaman_state = "charging"
	end

	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)
	a.ts = store.tick_ts

	while store.tick_ts - a.ts < a.cooldown do
		coroutine.yield()
	end

	for _, shaman in ipairs(shamans) do
		shaman.shaman_state = "charged"

		S:queue(this.sound_ready)
	end

	U.y_animation_play(this, "toLoaded", nil, store.tick_ts)
	U.animation_start(this, "idleLoaded", nil, store.tick_ts, true)

	this.ui.clicked = nil

	while true do
		if this.ui.clicked then
			selected_positions = {}

			S:queue(this.sound_cast)
			U.animation_start(this, "toLoading", nil, store.tick_ts)
			U.y_wait(store, a.cast_time / 2)

			local shaman_wait_offset = 0

			for _, shaman in ipairs(shamans) do
				shaman.shaman_state = "shoot"
			end

			U.y_wait(store, a.cast_time / 2)
			S:queue(a.sound)

			local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, a.cast_time, a.vis_flags, a.vis_bans)

			for i = #targets, 1, -1 do
				local e = targets[i]
				local dz = this.danger_zones
				local sd2 = this.safe_dist2
				local node_offset = P:predict_enemy_node_advance(e, a.cast_time + a.node_prediction)
				local e_ni = e.nav_path.ni + node_offset
				local e_pos = P:node_pos(e.nav_path.pi, e.nav_path.spi, e_ni)

				if sd2 > V.dist2(e_pos.x, e_pos.y, dz[1].x, dz[1].y) or sd2 > V.dist2(e_pos.x, e_pos.y, dz[2].x, dz[2].y) then
					table.remove(targets, i)
				end
			end

			for i = 1, a.max_targets do
				if not targets or #targets == 0 or #selected_positions > a.max_targets / 2 then
					goto label_801_1
				end

				local sel_target = targets[1]
				local node_offset = P:predict_enemy_node_advance(sel_target, a.cast_time + a.node_prediction)
				local e_ni = sel_target.nav_path.ni + node_offset
				local e_pos = P:node_pos(sel_target.nav_path.pi, sel_target.nav_path.spi, e_ni)

				table.insert(selected_positions, e_pos)
				table.remove(targets, 1)

				for i = #targets, 1, -1 do
					local e = targets[i]
					local dz = this.danger_zones
					local sd2 = this.safe_dist2

					if max_dist2 > V.dist2(sel_target.pos.x, sel_target.pos.y, e.pos.x, e.pos.y) then
						table.remove(targets, i)
					end
				end
			end

			if #selected_positions == a.max_targets then
				goto label_801_2
			end

			::label_801_1::

			do
				local nodes = table.deepclone(this.nodes)

				shuffle_table(nodes)

				for i = #selected_positions + 1, a.max_targets do
					local sel_node = nodes[1]

					table.insert(selected_positions, sel_node)
					table.remove(nodes, 1)

					for i = #nodes, 1, -1 do
						local n = nodes[i]

						if max_dist2 > V.dist2(sel_node.x, sel_node.y, n.x, n.y) then
							table.remove(nodes, i)
						end
					end
				end
			end

			::label_801_2::

			shuffle_table(selected_positions)

			for _, p in pairs(selected_positions) do
				shoot_bullet(p)
				U.y_wait(store, a.wait_between_shots)
			end

			U.y_animation_wait(this)
			U.animation_start(this, "idleLoading", nil, store.tick_ts, true)

			a.ts = store.tick_ts
			this.ui.clicked = nil

			U.y_wait(store, a.node_prediction - fts(30))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.5
			shake.aura.duration = 1.3
			shake.aura.freq_factor = 4

			queue_insert(store, shake)

			this.clicked = true

			goto label_801_0
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.bullet_heart_of_the_arborean = {}

function scripts.bullet_heart_of_the_arborean.insert(this, store, script)
	local b = this.bullet

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	local s = this.render.sprites[1]

	if not b.ignore_rotation then
		s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
	end

	U.animation_start(this, "run", nil, store.tick_ts, s.loop)

	return true
end

function scripts.bullet_heart_of_the_arborean.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	local function do_hit(hit_pos)
		local targets = U.find_enemies_in_range(store.entities, hit_pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, t in pairs(targets) do
				local d = E:create_entity("damage")

				d.damage_type = b.damage_type

				local dist_factor = U.dist_factor_inside_ellipse(t.pos, b.to, dradius)

				d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
				d.value = math.ceil(b.damage_factor * d.value)
				d.source_id = this.id
				d.target_id = t.id

				queue_damage(store, d)
			end
		end

		S:queue(b.hit_sound)

		local fx = E:create_entity(b.hit_fx)

		fx.pos = V.vclone(hit_pos)

		U.animation_start(fx, "idle", nil, store.tick_ts, false)
		queue_insert(store, fx)

		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(hit_pos)

		U.animation_start(decal, "idle", nil, store.tick_ts, false)

		decal.tween.ts = store.tick_ts

		queue_insert(store, decal)
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local pred_pos

	if target then
		pred_pos = P:predict_enemy_pos(target, fts(5))
	else
		pred_pos = b.to
	end

	local iix, iiy = V.normalize(pred_pos.x - this.pos.x, pred_pos.y - this.pos.y)
	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			local d = math.max(math.abs(target.pos.x + hit_offset.x - b.to.x), math.abs(target.pos.y + hit_offset.y - b.to.y))

			if d > b.max_track_distance then
				log.debug("BOLT MAX DISTANCE FAIL. (%s) %s / dist:%s target.pos:%s,%s b.to:%s,%s", this.id, this.template_name, d, target.pos.x, target.pos.y, b.to.x, b.to.y)

				target = nil
				b.target_id = nil
			else
				b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
			end
		end

		if this.initial_impulse and store.tick_ts - b.ts < this.initial_impulse_duration then
			local t = store.tick_ts - b.ts

			if this.initial_impulse_angle_abs then
				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(this.initial_impulse_angle_abs, 1, 0))
			else
				local angle = this.initial_impulse_angle

				if iix < 0 then
					angle = angle * -1
				end

				fm.a.x, fm.a.y = V.mul((1 - t) * this.initial_impulse, V.rotate(angle, iix, iiy))
			end
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	this.render.sprites[1].hidden = true

	do_hit(b.to)

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false
	end

	U.y_wait(store, fts(10))
	queue_remove(store, this)
end

scripts.trees_heart_of_the_arborean_shaman_decal = {}

function scripts.trees_heart_of_the_arborean_shaman_decal.insert(this, store)
	return true
end

function scripts.trees_heart_of_the_arborean_shaman_decal.update(this, store)
	while this.shaman_state == "waiting" do
		coroutine.yield()
	end

	while true do
		U.animation_start(this, "Absorb", nil, store.tick_ts, true)

		while this.shaman_state ~= "charged" do
			coroutine.yield()
		end

		U.y_animation_play(this, "TransitionToReadyToCast", nil, store.tick_ts)
		U.animation_start(this, "ReadyToCast", nil, store.tick_ts, true)

		while this.shaman_state ~= "shoot" do
			coroutine.yield()
		end

		U.animation_start(this, "Cast", nil, store.tick_ts)
		U.y_wait(store, 1)
		U.animation_start(this, "CastIdle", nil, store.tick_ts, true)
		U.y_wait(store, 3)
		U.y_animation_play(this, "CastEnd", nil, store.tick_ts)

		this.shaman_state = "charging"
	end
end

scripts.bush_ladder_decal = {}

function scripts.bush_ladder_decal.update(this, store, script)
	local sp = this.spawner
	local sprite_base = this.render.sprites[1]
	local sprite_top = this.render.sprites[2]
	local state_waiting = 1
	local state_going_up = 2
	local state_is_up = 3
	local state_going_down = 4
	local state = state_waiting
	local spawner

	this.tween.disabled = true

	while true do
		if sp.interrupt then
			-- block empty
		elseif state == state_going_up then
			if this.render.sprites[1].offset.y == 0 then
				state = state_is_up
				sprite_top.hidden = true
				spawner.disabled = false

				U.y_animation_play(this, this.animation_spawner_start, false, store.tick_ts, 1, 1)

				sprite_base.hidden = true
			end
		elseif state == state_is_up then
			if sp.spawn_data then
				local enable = sp.spawn_data.enable

				if not enable then
					state = state_going_down
					spawner.disabled = true

					S:queue("Stage04ElevatorOut")
					U.y_wait(store, this.break_time)

					this.tween.ts = store.tick_ts
					this.tween.reverse = true
				end
			end
		elseif state == state_waiting then
			if sp.spawn_data then
				local enable = sp.spawn_data.enable

				if enable then
					S:queue("Stage04ElevatorIn")
					U.y_wait(store, 1)

					state = state_going_up
					this.tween.disabled = false
					this.tween.reverse = false
					this.tween.ts = store.tick_ts
					sprite_base.hidden = false
					sprite_top.hidden = false

					U.animation_start(this, this.animation_spawner_idle, false, store.tick_ts, true)

					spawner = E:create_entity(this.spawner_template)
					spawner.pos = V.vclone(this.pos)
					spawner.disabled = true

					queue_insert(store, spawner)
				end
			end
		elseif state == state_going_down and this.render.sprites[1].offset.y == this.tween.props[2].keys[1][2].y then
			this.tween.disabled = true
			state = state_waiting
		end

		sp.interrupt = nil

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.bush_spawner_decal = {}

function scripts.bush_spawner_decal.update(this, store, script)
	local activated = false

	while true do
		if not this.disabled and not activated then
			activated = true
			this.render.sprites[1].hidden = false

			U.animation_start(this, this.animation_spawner_start, nil, store.tick_ts, false)
			U.y_wait(store, fts(57))
			S:queue("Stage04ElevatorBreak")
			U.y_animation_wait(this)
			U.animation_start(this, this.animation_spawner_idle, nil, store.tick_ts, false)
		elseif activated and this.disabled then
			U.animation_start(this, this.animation_spawner_end, nil, store.tick_ts, false)
			U.y_animation_wait(this)
			queue_remove(store, this)
		end

		coroutine.yield()
	end
end

scripts.stage_29_cocoon = {}

function scripts.stage_29_cocoon.update(this, store, script)
	if this.broken_on_iron and store.level_mode == GAME_MODE_IRON or this.broken_on_heroic and store.level_mode == GAME_MODE_HEROIC then
		U.animation_start(this, this.animation_spawner_idle_broken, nil, store.tick_ts, true, 1)

		return
	end

	local sp = this.spawner
	local state = 1

	U.animation_start(this, this.animation_spawner_idle, nil, store.tick_ts - fts(math.random(0, 20)), true, 1, true)

	while true do
		if sp.interrupt then
			-- block empty
		elseif state == 1 then
			if sp.spawn_data then
				local enable = sp.spawn_data.enable

				if enable then
					state = 2

					S:queue(this.sound_inflate)
					S:queue(this.sound_explode)
					U.y_animation_play(this, this.animation_spawner_start, nil, store.tick_ts, 1, 1)
				end
			end
		elseif state == 2 and sp.spawn_data then
			local enable = sp.spawn_data.enable

			if not enable then
				S:queue(this.sound_regenerate)
				U.y_animation_play(this, this.animation_spawner_end, nil, store.tick_ts, 1, 1)
				U.animation_start(this, this.animation_spawner_idle, nil, store.tick_ts, true, 1)

				state = 1
			end
		end

		sp.interrupt = nil

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.arrow5_fixed_height = {}

function scripts.arrow5_fixed_height.insert(this, store, script)
	this.bullet.flight_time = 2 * (math.sqrt(2 * this.bullet.fixed_height * this.bullet.g * -1) / this.bullet.g * -1)

	return scripts.arrow.insert(this, store, script)
end

scripts.arrow5_45degrees = {}

function scripts.arrow5_45degrees.insert(this, store, script)
	local dist = V.dist(this.bullet.to.x, this.bullet.to.y, this.bullet.from.x, this.bullet.from.y)

	this.bullet.flight_time = math.sqrt(2 * dist / -this.bullet.g)

	if this.bullet.flight_time_variance then
		this.bullet.flight_time = this.bullet.flight_time + fts(math.random(0, this.bullet.flight_time_variance))
	end

	return scripts.arrow.insert(this, store, script)
end

scripts.arrow5 = {}

function scripts.arrow5.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]

	local ps
	if b.particles_name then
		ps = {}
		if type(b.particles_name) == "table" then
			for i, value in ipairs(b.particles_name) do
				local p = E:create_entity(value)
				p.particle_system.emit = true
				p.particle_system.track_id = this.id
				queue_insert(store, p)
				table.insert(ps, p)
			end
		else
			local p = E:create_entity(b.particles_name)
			p.particle_system.emit = true
			p.particle_system.track_id = this.id
			queue_insert(store, p)
			table.insert(ps, p)
		end
	end

	local target = store.entities[b.target_id]

	while store.tick_ts - b.ts + store.tick_length <= b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.rotation_speed then
			s.r = s.r + b.rotation_speed * store.tick_length
		else
			s.r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)

			if b.asymmetrical and math.abs(s.r) > math.pi / 2 then
				s.flip_y = true
			else
				s.flip_y = nil
			end
			if ps then
				for i, p in ipairs(ps) do
					p.particle_system.flip_x = s.flip_y
				end
			end
		end

		if ps then
			for i, p in ipairs(ps) do
				p.particle_system.emit_direction = s.r
			end
		end

		if b.hide_radius then
			local at_start = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius
			local at_end = V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius

			s.hidden = at_start or at_end

			if ps then
				if b.extend_particles_cutoff then
					for i, p in ipairs(ps) do
						p.particle_system.emit = not at_start
					end
				else
					for i, p in ipairs(ps) do
						p.particle_system.emit = not s.hidden
					end
				end
			end
		end
	end
	this.pos.x, this.pos.y = b.to.x, b.to.y

	local hit = false
	local target = store.entities[b.target_id]

	if target and target.health and not target.health.dead then
		local target_pos = V.vclone(target.pos)

		if not b.ignore_hit_offset and target.unit and target.unit.hit_offset then
			local flip_sign = target.render and target.render.sprites[1].flip_x and -1 or 1
			target_pos.x, target_pos.y = target_pos.x + target.unit.hit_offset.x * flip_sign, target_pos.y + target.unit.hit_offset.y
		end

		-- log.error("dist = %s, x_dist = %s, y_dist = %s, name = %s", V.dist(this.pos.x, this.pos.y, target_pos.x, target_pos.y), this.pos.x - target_pos.x, 
		-- this.pos.y - target_pos.y, this.template_name)
		if V.dist(this.pos.x, this.pos.y, target_pos.x, target_pos.y) < b.hit_distance and not SU.unit_dodges(store, target, true) and (not b.hit_chance or math.random() < b.hit_chance) then
			hit = true

			local d = SU.create_bullet_damage(b, target.id, this.id)

			queue_damage(store, d)

			if b.mod or b.mods then
				local mods = b.mods or type(b.mod) == "table" and b.mod or {
					b.mod
				}

				for _, mod_name in pairs(mods) do
					local mod = E:create_entity(mod_name)

					mod.modifier.source_id = b.source_id
					mod.modifier.target_id = target.id
					mod.modifier.level = b.level
					mod.modifier.source_damage = d

					queue_insert(store, mod)
				end
			end

			if b.hit_fx then
				local fx = E:create_entity(b.hit_fx)

				fx.pos = V.vclone(target_pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end

			if b.hit_blood_fx and target.unit.blood_color ~= BLOOD_NONE then
				local sfx = E:create_entity(b.hit_blood_fx)

				sfx.pos = V.vclone(target_pos)
				sfx.render.sprites[1].ts = store.tick_ts

				if sfx.use_blood_color and target.unit.blood_color then
					sfx.render.sprites[1].name = target.unit.blood_color
					sfx.render.sprites[1].r = s.r
				end

				queue_insert(store, sfx)
			end
		end
	end

	if this.sound_events.hit then
		S:queue(this.sound_events.hit)
	end

	if not hit then
		if GR:cell_is(this.pos.x, this.pos.y, TERRAIN_WATER) then
			if b.miss_fx_water then
				local water_fx = E:create_entity(b.miss_fx_water)

				water_fx.pos.x, water_fx.pos.y = b.to.x, b.to.y
				water_fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, water_fx)
			end
		else
			if b.miss_fx then
				local fx = E:create_entity(b.miss_fx)

				fx.pos.x, fx.pos.y = b.to.x, b.to.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end

			if b.miss_decal then
				local decal = E:create_entity("decal_tween")

				decal.pos = V.vclone(b.to)
				decal.tween.props[1].keys = {
					{
						0,
						255
					},
					{
						0.5,
						255
					},
					{
						2.1,
						0
					}
				}
				decal.render.sprites[1].ts = store.tick_ts
				decal.render.sprites[1].name = b.miss_decal
				decal.render.sprites[1].animated = b.miss_decal_animated
				decal.render.sprites[1].loop = nil
				decal.render.sprites[1].z = Z_DECALS
				decal.render.sprites[1].flip_x = s.flip_y

				if b.rotation_speed then
					decal.render.sprites[1].flip_x = b.rotation_speed > 0
				elseif b.miss_decal_no_rotation then
					decal.render.sprites[1].r = math.pi / 2 * ((0.5 - math.random()) * 0.35)
				else
					decal.render.sprites[1].r = -math.pi / 2 * (1 + (0.5 - math.random()) * 0.35)
				end

				if b.miss_decal_anchor then
					decal.render.sprites[1].anchor = b.miss_decal_anchor
				end

				queue_insert(store, decal)
			end
		end
	end

	SU.create_bullet_hit_payload(this, store, s.flip_x)

	if ps then
		if b.extend_particles_cutoff then
			for i, p in ipairs(ps) do
				p.particle_system.emit = true
			end
			coroutine.yield()
		end
		s.hidden = true
		for i, p in ipairs(ps) do
			p.particle_system.emit = false
		end
		U.y_wait(store, ps[1].particle_system.particle_lifetime[2])
	end
	queue_remove(store, this)
end

scripts.mod_ray_stargazers = {}

function scripts.mod_ray_stargazers.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		queue_remove(store, this)

		return
	end

	local function apply_damage(value)
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = this.damage_type

		queue_damage(store, d)
	end

	local raw_damage = math.random(this.modifier.damage_min, this.modifier.damage_max)

	this.pos = target.pos
	m.ts = store.tick_ts

	apply_damage(raw_damage)

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

		if this.render and m.use_mod_offset and target.unit.hit_offset then
			for _, s in ipairs(this.render.sprites) do
				s.offset.x, s.offset.y = target.unit.hit_offset.x, target.unit.hit_offset.y
			end
		end

		if store.tick_ts - m.ts > m.duration then
			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.mod_stargazers_stars_death = {}

function scripts.mod_stargazers_stars_death.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local chance = m.stars_death_chance[m.level]
	local radius = m.stars_death_max_range
	local total_stars = m.stars_death_stars[m.level]
	local bullet = m.bullet
	local time = store.tick_ts
	local duration = this.modifier.duration

	if not target or target.health.dead then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	local function shoot_bullet(enemy, level)
		local b = E:create_entity(bullet)

		b.pos.x = this.pos.x
		b.pos.y = this.pos.y
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(enemy.pos.x + enemy.unit.hit_offset.x, enemy.pos.y + enemy.unit.hit_offset.y)
		b.bullet.target_id = enemy.id
		b.bullet.level = level
		b.bullet.damage_min = b._damage_min[level]
		b.bullet.damage_max = b._damage_max[level]
		b.bullet.damage_type = b._damage_type

		queue_insert(store, b)
	end

	while true do
		if not target or target.health.dead then
			if target and chance > math.random() then
				local targets = U.find_enemies_in_range(store.entities, target.pos, 0, radius, F_ENEMY, F_FLYING)

				if targets then
					for i = 1, total_stars do
						if targets[i] == nil then
							break
						end

						shoot_bullet(targets[i], m.level)
					end
				end
			end

			break
		end

		if time + duration < store.tick_ts then
			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.mod_ray_arcane = {}

function scripts.mod_ray_arcane.update(this, store)
	local cycles, total_damage = 0, 0
	local m = this.modifier
	local dps = this.dps
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		queue_remove(store, this)

		return
	end

	local function apply_damage(value)
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = dps.damage_type
		d.pop = dps.pop
		d.pop_chance = dps.pop_chance
		d.pop_conds = dps.pop_conds

		queue_damage(store, d)

		total_damage = total_damage + value
	end

	local raw_damage = math.random(this.dps.damage_min, this.dps.damage_max)
	local extra_damage = math.max(0, raw_damage - target.health.hp)
	local total_cycles = m.duration / dps.damage_every
	local dps_damage = math.floor((raw_damage - extra_damage) / total_cycles)
	local first_damage = raw_damage - extra_damage - dps_damage * total_cycles

	this.pos = target.pos
	dps.ts = store.tick_ts
	m.ts = store.tick_ts

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

		if total_cycles <= cycles then
			log.paranoid(">>>>> id:%s - mod_ray_arcane cycles:%s raw_damage:%s dps_damage:%s first_damage:%s total_damage:%s", this.id, cycles, raw_damage, dps_damage, first_damage, total_damage)
			apply_damage(extra_damage)

			break
		end

		if this.render and m.use_mod_offset and target.unit.hit_offset then
			for _, s in ipairs(this.render.sprites) do
				s.offset.x, s.offset.y = target.unit.hit_offset.x, target.unit.hit_offset.y
			end
		end

		if dps.damage_every and store.tick_ts - dps.ts >= dps.damage_every then
			cycles = cycles + 1
			dps.ts = dps.ts + dps.damage_every

			apply_damage(dps_damage + (cycles == 1 and first_damage or 0))
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_defend_point5 = {}

function scripts.decal_defend_point5.insert(this, store)
	local nodes_list = P:nearest_nodes(this.pos.x, this.pos.y)

	for _, item in pairs(nodes_list) do
		local pi, spi, ni, dist = unpack(item, 1, 4)

		if dist < P:path_width(pi) / 2 then
			P:set_defend_point_node(pi, ni)
		end
	end

	this.render.sprites[1].ts = store.tick_ts
	this.render.sprites[1].alpha = this.editor.alpha * 10
	this.render.sprites[1].flip_x = this.editor.flip > 0

	if this.editor and this.editor.exit_id then
		if not store.level.locations.exits then
			store.level.locations.exits = {}
		end

		local exits = store.level.locations.exits
		local exit = {}

		exit.pos = this.pos
		exit.exit_id = this.editor.exit_id

		table.insert(exits, exit)
		table.sort(exits, function(a1, a2)
			return a1.exit_id < a2.exit_id
		end)
	end

	local controller_upg

	for _, e in pairs(store.entities) do
		if e.template_name == "controller_upgrades_alliance" then
			controller_upg = e
		end
	end

	if controller_upg and controller_upg.seal and not this.render.sprites[1].hidden then
		local seal = E:create_entity(controller_upg.seal)

		seal.pos = V.vclone(this.pos)

		queue_insert(store, seal)

		this.render.sprites[1].hidden = true
	end

	return true
end

function scripts.decal_defend_point5.update_editor(this, store)
	while true do
		this.render.sprites[1].alpha = this.editor.alpha * 10
		this.render.sprites[1].flip_x = this.editor.flip > 0

		coroutine.yield()
	end

	return true
end

scripts.decal_defense_flag5 = {}

function scripts.decal_defense_flag5.insert(this, store)
	this.render.sprites[1].flip_x = this.editor.flip > 0

	local controller_upg

	for _, e in pairs(store.entities) do
		if e.template_name == "controller_upgrades_alliance" then
			controller_upg = e
		end
	end

	if controller_upg and controller_upg.coil and not this.render.sprites[1].hidden then
		local coil = E:create_entity(controller_upg.coil)

		coil.pos = V.vclone(this.pos)

		if this.extra_trigger_dist then
			coil.extra_trigger_dist = this.extra_trigger_dist
		end

		if this.target_only_paths then
			coil.target_only_paths = table.deepclone(this.target_only_paths)
		end

		queue_insert(store, coil)

		this.render.sprites[1].hidden = true
	end

	return true
end

function scripts.decal_defense_flag5.update_editor(this, store)
	while true do
		this.render.sprites[1].flip_x = this.editor.flip > 0

		coroutine.yield()
	end

	return true
end

scripts.decal_upgrade_alliance_seal_of_punishment = {}

function scripts.decal_upgrade_alliance_seal_of_punishment.update(this, store, script)
	while true do
		local aura

		U.y_animation_play(this, "active_start", false, store.tick_ts, 1)
		U.animation_start(this, "active_loop", false, store.tick_ts, true, 1)
		U.animation_start(this, "idle", false, store.tick_ts, true, 2)

		while not aura do
			local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, this.trigger_dist, false, this.vis_flags, this.vis_bans)

			if target then
				aura = E:create_entity(this.aura)
				aura.pos = V.vclone(this.pos)
				aura.aura.source_id = this.id
				aura.aura.ts = store.tick_ts

				queue_insert(store, aura)

				this.render.sprites[2].hidden = false
			end

			coroutine.yield()
		end

		U.y_wait(store, aura.aura.duration)

		local fx_run = this.render.sprites[2].runs

		while fx_run == this.render.sprites[2].runs do
			coroutine.yield()
		end

		this.render.sprites[2].hidden = true

		U.y_animation_play(this, "active_end", false, store.tick_ts, 1)
		U.animation_start(this, "idle", false, store.tick_ts, true, 1)
		U.y_wait(store, this.cooldown)
	end
end

scripts.mod_upgrade_alliance_seal_of_punishment = {}

function scripts.mod_upgrade_alliance_seal_of_punishment.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead then
		return false
	end

	if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	if target and target.unit and this.render then
		local s = this.render.sprites[1]

		s.ts = store.tick_ts

		if s.size_names then
			s.name = s.size_names[target.unit.size]
		end

		if target.render then
			s.z = target.render.sprites[1].z
		end

		U.animation_start(this, s.name, false, store.tick_ts, true)
		log.info("ANIM: " .. s.prefix .. "_" .. s.name)
	end

	this.modifier.ts = store.tick_ts
	this.pos = target.pos

	S:queue(this.sound_burn)

	return true
end

function scripts.mod_upgrade_alliance_seal_of_punishment.update(this, store, script)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			break
		end

		if store.tick_ts - m.ts >= m.duration - 1e-09 then
			break
		end

		if this.render and m.use_mod_offset and target.unit.mod_offset then
			local so = this.render.sprites[1].offset

			so.x, so.y = target.unit.mod_offset.x, target.unit.mod_offset.y
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_upgrade_alliance_flux_altering_coils = {}

function scripts.decal_upgrade_alliance_flux_altering_coils.update(this, store, script)
	local function find_enemy()
		local target, _ = U.find_foremost_enemy(store.entities, this.pos, 0, this.trigger_dist + this.extra_trigger_dist, false, F_TELEPORT, 0, function(e, o)
			return not U.has_modifiers(store, e, this.mod_mark) and (not this.target_only_paths or table.contains(this.target_only_paths, e.nav_path.pi))
		end)

		return target
	end

	while true do
		this.render.sprites[this.circle_sid].hidden = false

		U.animation_start(this, "activation_start", false, store.tick_ts, false, this.base_sid)
		U.animation_start(this, "activation_start", false, store.tick_ts, false, this.cristal_sid)
		U.y_animation_play(this, "activation_start", false, store.tick_ts, 1, this.circle_sid)
		U.animation_start(this, "activated_loop", false, store.tick_ts, true, this.base_sid)
		U.animation_start(this, "activated_loop", false, store.tick_ts, true, this.cristal_sid)
		U.animation_start(this, "activated_loop", false, store.tick_ts, true, this.circle_sid)

		this.render.sprites[this.particle_sid].hidden = false

		U.animation_start(this, "idle", false, store.tick_ts, true, this.particle_sid)

		local check_ts = store.tick_ts
		local check_cd = fts(10)

		while true do
			local target

			if check_cd > store.tick_ts - check_ts then
				-- block empty
			else
				target = find_enemy()
				check_ts = store.tick_ts

				if target then
					U.animation_start(this, "teleport", false, store.tick_ts, false, this.cristal_sid)

					local mod_mark = E:create_entity(this.mod_mark)

					mod_mark.modifier.target_id = target.id
					mod_mark.modifier.source_id = this.id

					queue_insert(store, mod_mark)
					U.y_wait(store, fts(11))
					S:queue("UpgradeArcaneTeleporterFull")

					if not target or target.health.dead then
						target = find_enemy()
					end

					if target then
						local mod_teleport = E:create_entity(this.mod_teleport)

						mod_teleport.modifier.target_id = target.id
						mod_teleport.modifier.source_id = this.id

						queue_insert(store, mod_teleport)
					end

					U.animation_start(this, "teleport", false, store.tick_ts, false, this.base_sid)
					U.y_animation_play(this, "teleport", false, store.tick_ts, 1, this.circle_sid)
					U.animation_start(this, "idle", false, store.tick_ts, true, this.cristal_sid)

					while not U.animation_finished(this, this.circle_sid) do
						coroutine.yield()
					end

					this.render.sprites[this.particle_sid].hidden = true

					U.animation_start(this, "idle", false, store.tick_ts, true, this.base_sid)

					break
				end
			end

			coroutine.yield()
		end

		U.y_wait(store, this.cooldown)
	end
end

scripts.mod_upgrade_alliance_display_of_true_might_dark_army = {}

function scripts.mod_upgrade_alliance_display_of_true_might_dark_army.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health and target.health.dead or not target.motion or target.motion.invulnerable then
		return false
	end

	if this.modifier.excluded_templates and table.contains(this.modifier.excluded_templates, target.template_name) then
		log.paranoid("mod_slow.insert not inserted to %s because of excluded_templates", target.id)

		return false
	end

	if target.nav_path and not P:is_node_valid(target.nav_path.pi, target.nav_path.ni) then
		return false
	end

	log.paranoid("mod_slow.insert (%s)-%s for (%s)-%s", this.id, this.template_name, target.id, target.template_name)

	target.motion.max_speed = target.motion.max_speed * this.slow.factor
	this.modifier.ts = store.tick_ts

	if target and target.unit and this.render then
		for i = 1, #this.render.sprites do
			local s = this.render.sprites[i]

			s.flip_x = target.render.sprites[1].flip_x
			s.ts = store.tick_ts

			if s.size_names then
				s.name = s.size_names[target.unit.size]
			end
		end

		if target.vis.flags and band(target.vis.flags, F_FLYING) ~= 0 then
			this.render.sprites[2].hidden = true
		end
	end

	signal.emit("mod-applied", this, target)

	return true
end

scripts.mod_upgrade_alliance_display_of_true_might_linirea = {}

function scripts.mod_upgrade_alliance_display_of_true_might_linirea.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			queue_remove(store, this)

			return
		end

		if this.render and target.unit then
			for _, s in pairs(this.render.sprites) do
				local flip_sign = 1

				if target.render then
					flip_sign = target.render.sprites[1].flip_x and -1 or 1
				end

				s.offset.x, s.offset.y = target.render.sprites[1].offset.x * flip_sign, target.render.sprites[1].offset.y
			end
		end

		coroutine.yield()
	end
end

scripts.stage_01_drag_tutorial = {}

function scripts.stage_01_drag_tutorial.update(this, store, script)
	local s = this.render.sprites[1]

	this.tween.disabled = false

	local start_ts = store.tick_ts

	while V.veq(this.hero_ref.nav_rally.center, this.hero_initial_pos) and store.tick_ts - start_ts < this.time_limit do
		coroutine.yield()
	end

	if not V.veq(this.hero_ref.nav_rally.center, this.hero_initial_pos) then
		signal.emit("ftue-step", "drag_hero")
	end

	this.tween.reverse = false
	this.tween.remove = true
end

scripts.decal_stage_01_robin_hood = {}

function scripts.decal_stage_01_robin_hood.update(this, store, script)
	local s = this.render.sprites[1]
	local can_click = true
	local clicked = false
	local last_attack = store.tick_ts

	this.attack_cooldown = math.random(this.attack_cooldown_min, this.attack_cooldown_max)

	U.y_animation_play_group(this, this.animation_idle, nil, store.tick_ts, false, "layers")

	local d = E:create_entity(this.mask_to_spawn)

	d.pos = V.v(512, 384)

	queue_insert(store, d)

	while true do
		if clicked then
			-- block empty
		elseif can_click and this.ui.clicked then
			this.ui.clicked = nil

			S:queue(this.clicked_sound)

			while true do
				U.animation_start_group(this, this.animation_click, nil, store.tick_ts, false, "layers")

				if U.y_wait(store, fts(87)) then
					-- block empty
				else
					d.render.sprites[1].hidden = false

					signal.emit("robin-stage01", this)
					U.y_animation_wait_group(this, "layers")

					break
				end

				coroutine.yield()
			end

			can_click = false
			clicked = true
		elseif store.tick_ts - last_attack > this.attack_cooldown then
			U.y_animation_play_group(this, this.animation_attack, nil, store.tick_ts, false, "layers")

			this.attack_cooldown = math.random(this.attack_cooldown_min, this.attack_cooldown_max)
			last_attack = store.tick_ts
		else
			U.y_animation_play_group(this, this.animation_idle, nil, store.tick_ts, false, "layers")
		end

		coroutine.yield()
	end
end

scripts.decal_stage_01_campfire_guy_campfire = {}

function scripts.decal_stage_01_campfire_guy_campfire.update(this, store, script)
	local count = 0
	local count_limit = 2

	while true do
		if this.ui.clicked then
			if count < count_limit then
				S:queue(this.sound_fire_off)
				U.y_animation_play(this, "extinguish", nil, store.tick_ts, 1, this.campfire_sprite_id)
				U.animation_start(this, "smoke_idle", nil, store.tick_ts, true, this.campfire_sprite_id)
				U.y_animation_play(this, "action", nil, store.tick_ts, 1, this.guy_sprite_id)
				S:queue(this.sound_fire_on)
				U.y_animation_play(this, "lit", nil, store.tick_ts, 1, this.campfire_sprite_id)

				this.ui.clicked = nil

				U.animation_start(this, "idle", nil, store.tick_ts, true)

				count = count + 1
			elseif count == count_limit then
				S:queue(this.sound_fire_final)
				U.y_animation_play(this, "extinguish", nil, store.tick_ts, 1, this.campfire_sprite_id)
				U.animation_start(this, "smoke_idle", nil, store.tick_ts, true, this.campfire_sprite_id)
				U.animation_start(this, "leaves", nil, store.tick_ts, false, this.guy_sprite_id)
				U.y_wait(store, fts(64))
				U.y_animation_play(this, "big_fire", nil, store.tick_ts, 1, this.campfire_sprite_id)
				U.animation_start(this, "idle_burnt", nil, store.tick_ts, false, this.campfire_sprite_id)

				this.ui.clicked = nil
				this.render.sprites[this.guy_sprite_id].draw_order = 10

				U.y_animation_wait(this, this.guy_sprite_id, 1)
				U.animation_start(this, "idle_gone", nil, store.tick_ts, false, this.guy_sprite_id)
				U.y_animation_play(this, "closes", nil, store.tick_ts, 1, this.tent_front_sprite_id)
				U.animation_start(this, "idle_closed_tent", nil, store.tick_ts, false, this.tent_front_sprite_id)

				count = count + 1

				signal.emit("bonfire-stage01", this)
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_01_rune = {}

function scripts.decal_stage_01_rune.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0

	while true do
		if clicks >= c.required_clicks and c.play_once then
			-- block empty
		else
			if this.ui.clicked then
				this.ui.clicked = nil
				clicks = clicks + 1
			end

			if clicks >= c.required_clicks then
				if this.tween then
					this.tween.disabled = false
				elseif not c.idle_animation then
					s.hidden = false
				end

				S:queue(c.clicked_sound)
				U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)

				this.ui.clicked = nil

				U.animation_start(this, c.idle_on_animation, nil, store.tick_ts, true)
				signal.emit("achievements_custom_event", "RUNEQUEST_1")

				if c.achievement then
					AC:got(c.achievement)
				end

				if c.achievement_flag then
					AC:flag_check(unpack(c.achievement_flag))
				end
			end
		end

		coroutine.yield()
	end
end

scripts.stage_02_arborean_old = {}

function scripts.stage_02_arborean_old.update(this, store, script)
	while true do
		U.y_animation_play(this, "idle1", nil, store.tick_ts, 1)
		U.y_wait(store, fts(30 * math.random(4, 7)))
		U.y_animation_play(this, "idle2", nil, store.tick_ts, 1)
		U.y_wait(store, fts(30 * math.random(4, 7)))
		U.y_animation_play(this, "action1", nil, store.tick_ts, 1)
		coroutine.yield()
	end
end

scripts.stage_02_arborean_baby1 = {}

function scripts.stage_02_arborean_baby1.update(this, store, script)
	while true do
		U.y_animation_play(this, "idle1", nil, store.tick_ts, 1)
		U.y_wait(store, fts(math.random(30, 90)))
		U.y_animation_play(this, "action1", nil, store.tick_ts, 1)
		U.y_animation_play(this, "idle2", nil, store.tick_ts, 1)
		U.y_wait(store, fts(30 * math.random(2, 4)))
		U.y_animation_play(this, "idle2", nil, store.tick_ts, 1)
		U.y_wait(store, fts(30 * math.random(2, 4)))
		U.y_animation_play(this, "idle2", nil, store.tick_ts, 1)
		U.y_wait(store, fts(math.random(120, 210)))
		U.y_animation_play(this, "action2", nil, store.tick_ts, 1)
		U.y_wait(store, fts(math.random(210, 270)))
		coroutine.yield()
	end
end

scripts.stage_02_arborean_baby2 = {}

function scripts.stage_02_arborean_baby2.update(this, store, script)
	local is_standup = true

	this.is_hidden = false

	local is_clicked = false
	local last_change = store.tick_ts
	local next_cd = math.random(this.change_anim_cd_min, this.change_anim_cd_max)

	while true do
		if is_clicked and store.tick_ts - last_change > this.hidden_cd then
			S:queue(this.sound_out)
			U.y_animation_play(this, "easter_egg_out", nil, store.tick_ts, 1)

			is_clicked = false
			is_standup = true
			this.ui.can_click = true
			last_change = store.tick_ts
			this.is_hidden = false
		end

		if this.ui.clicked then
			S:queue(this.sound_in)

			this.ui.clicked = nil
			is_clicked = true
			last_change = store.tick_ts
			this.ui.can_click = false

			if is_standup then
				U.y_animation_play(this, "easter_egg_sitting_in", nil, store.tick_ts, 1)
			else
				U.y_animation_play(this, "easter_egg_in", nil, store.tick_ts, 1)
			end

			this.is_hidden = true
		end

		if not is_clicked then
			if next_cd < store.tick_ts - last_change then
				if is_standup then
					U.animation_start(this, "sit_down", nil, store.tick_ts, 1)

					while not U.animation_finished(this, 1, 1) do
						coroutine.yield()
					end

					is_standup = false
				else
					U.animation_start(this, "sit_up", nil, store.tick_ts, 1)

					while not U.animation_finished(this, 1, 1) do
						coroutine.yield()
					end

					is_standup = true
				end

				next_cd = math.random(this.change_anim_cd_min, this.change_anim_cd_max)
				last_change = store.tick_ts
			elseif is_standup then
				U.animation_start(this, "idle1", nil, store.tick_ts, 1)
			else
				U.animation_start(this, "idle_sit", nil, store.tick_ts, 1)
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_02_rune = {}

function scripts.decal_stage_02_rune.insert(this, store, script)
	this.base_rock = E:create_entity(this.base_rock_entity)
	this.base_rock.pos = this.pos

	queue_insert(store, this.base_rock)

	return true
end

function scripts.decal_stage_02_rune.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0
	local already_played = false

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1
		end

		if c.play_once and already_played then
			-- block empty
		elseif clicks >= c.required_clicks then
			if this.tween then
				this.tween.disabled = false
			elseif not c.idle_animation then
				s.hidden = false
			end

			S:queue(c.clicked_sound)
			U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)

			this.ui.clicked = nil
			clicks = 0
			already_played = true

			if not c.idle_animation then
				s.hidden = true
			else
				U.animation_start(this, c.idle_animation, nil, store.tick_ts, true)
			end

			signal.emit("achievements_custom_event", "RUNEQUEST_2")

			if c.achievement then
				AC:got(c.achievement)
			end

			if c.achievement_flag then
				AC:flag_check(unpack(c.achievement_flag))
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_02_fishing_link = {}

function scripts.decal_stage_02_fishing_link.insert(this, store, script)
	if features.censored_cn then
		return false
	end

	local e = E:create_entity(this.entity_line)

	e.pos = this.pos
	e.fishing_link = this

	queue_insert(store, e)

	return true
end

function scripts.decal_stage_02_fishing_link.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local line_move_cd = math.random(this.min_line_move_cd, this.max_line_move_cd)
	local last_water_move_ts = store.tick_ts
	local water_move_cd = math.random(this.min_water_move_cd, this.max_water_move_cd)
	local last_line_move_ts = store.tick_ts

	this.window_duration = math.random(this.min_window_duration, this.max_window_duration)

	local started_first_wave = false

	while true do
		if not started_first_wave and store.wave_group_number > 0 then
			this.line_move = false
			line_move_cd = math.random(this.min_line_move_cd, this.max_line_move_cd)
			last_line_move_ts = store.tick_ts
			water_move_cd = math.random(this.min_water_move_cd, this.max_water_move_cd)
			last_water_move_ts = store.tick_ts
			this.window_duration = math.random(this.min_window_duration, this.max_window_duration)
			this.water_move = false
			started_first_wave = true
		end

		if this.ui.clicked then
			this.fish_anim = 1

			if store.wave_group_number > 0 then
				this.fish_anim = math.random(2, 3)
			end

			this.fishing = true

			U.animation_start(this, this.fish_animations[this.fish_anim], nil, store.tick_ts, false)
			U.y_wait(store, fts(30))
			S:queue(c.clicked_sound)
			U.y_animation_wait(this)

			line_move_cd = math.random(this.min_line_move_cd, this.max_line_move_cd)
			last_line_move_ts = store.tick_ts
			this.ui.clicked = nil
			this.fishing = false
		end

		if water_move_cd < store.tick_ts - last_water_move_ts then
			water_move_cd = math.random(this.min_water_move_cd, this.max_water_move_cd)
			last_water_move_ts = store.tick_ts
			this.water_move = true

			while this.water_move do
				coroutine.yield()
			end
		end

		if store.wave_group_number > 0 and line_move_cd < store.tick_ts - last_line_move_ts then
			this.line_move = true

			U.y_animation_play(this, "rupees_notice_in", nil, store.tick_ts)
			U.animation_start(this, "rupees_notice_loop", nil, store.tick_ts, true)

			local start_ts = store.tick_ts
			local anim_times = 0

			while true do
				if this.ui.clicked then
					this.fishing = true
					this.fish_anim = 4

					U.animation_start(this, "rupees_notice_clicked", nil, store.tick_ts, false)
					U.y_wait(store, fts(10))
					S:queue(c.clicked_sound)
					U.y_wait(store, fts(30))

					local gold_pos = V.v(this.pos.x + this.gold_pos_offset.x, this.pos.y + this.gold_pos_offset.y)

					signal.emit("got-gold", gold_pos, this.gold_amount)
					signal.emit("link-stage02", this)
					U.y_animation_wait(this)

					this.ui.clicked = nil
					this.fishing = false

					break
				end

				if store.tick_ts - start_ts > this.window_duration then
					U.y_animation_play(this, "rupees_notice_out", nil, store.tick_ts)

					break
				end

				coroutine.yield()
			end

			U.y_animation_wait(this, 1)
			U.animation_start(this, "idle", fals, store.tick_ts, true)

			this.line_move = false
			line_move_cd = math.random(this.min_line_move_cd, this.max_line_move_cd)
			last_line_move_ts = store.tick_ts
			water_move_cd = math.random(this.min_water_move_cd, this.max_water_move_cd)
			last_water_move_ts = store.tick_ts
			this.window_duration = math.random(this.min_window_duration, this.max_window_duration)
			this.water_move = false
		end

		coroutine.yield()
	end
end

scripts.decal_stage_02_fishing_link_line = {}

function scripts.decal_stage_02_fishing_link_line.update(this, store, script)
	local already_move = false
	local water_splash

	for _, v in pairs(store.entities) do
		if v.template_name == "decal_stage_02_fishing_link_water_splash" then
			water_splash = v

			break
		end
	end

	water_splash.render.sprites[1].hidden = true

	while true do
		if this.fishing_link.water_move then
			water_splash.render.sprites[1].hidden = false

			U.y_animation_play(water_splash, "idle", nil, store.tick_ts, false)

			water_splash.render.sprites[1].hidden = true
			this.fishing_link.water_move = false
		end

		if this.fishing_link.line_move then
			U.y_animation_play(this, "fishing_rupee_in", nil, store.tick_ts)
			U.animation_start(this, "fishing_rupee_loop", nil, store.tick_ts, true)

			local anim_times = 0
			local start_ts = store.tick_ts

			while not this.fishing_link.fishing do
				if store.tick_ts - start_ts > this.fishing_link.window_duration then
					U.y_animation_play(this, "fishing_rupee_out", nil, store.tick_ts)

					break
				end

				coroutine.yield()
			end
		end

		if this.fishing_link.fishing then
			if this.render.sprites[1].name == "fishing_rupee_loop" then
				water_splash.render.sprites[1].hidden = false

				U.animation_start(water_splash, "splash_out", nil, store.tick_ts, false)
				U.animation_start(this, "fishing_rupee_clicked", nil, store.tick_ts)
				U.y_wait(store, fts(61))
				U.animation_start(water_splash, "splash_in", nil, store.tick_ts, false)
				U.y_animation_wait(this)
			else
				if this.fishing_link.fish_anim == 1 or this.fishing_link.fish_anim == 2 then
					U.y_wait(store, fts(1))
				end

				U.animation_start(this, this.fish_animations[this.fishing_link.fish_anim], nil, store.tick_ts, false)
				U.y_wait(store, fts(41))

				water_splash.render.sprites[1].hidden = false

				if this.fishing_link.fish_anim ~= 1 and this.fishing_link.fish_anim ~= 5 then
					U.animation_start(water_splash, "splash_out", nil, store.tick_ts, false)
				end

				if this.fishing_link.fish_anim == 3 then
					U.y_wait(store, fts(78))
				else
					U.y_wait(store, fts(52))
				end

				U.animation_start(water_splash, "splash_in", nil, store.tick_ts, false)
			end

			U.y_animation_wait(this.fishing_link)

			this.fishing_link.water_move = false
		end

		coroutine.yield()
	end
end

scripts.decal_stage_02_lion_king = {}

function scripts.decal_stage_02_lion_king.insert(this, store, script)
	this.light = E:create_entity(this.entity_light)
	this.light.pos = v(979, 428)

	queue_insert(store, this.light)

	return true
end

function scripts.decal_stage_02_lion_king.update(this, store, script)
	local last_change = store.tick_ts
	local stick_cd = math.random(this.min_cooldown_idle, this.max_cooldown_idle)

	while true do
		if this.ui.clicked then
			this.ui.can_click = false
			this.ui.clicked = nil

			S:queue(this.clicked_sound)

			this.light.tween.disabled = false
			this.light.tween.ts = store.tick_ts
			this.light.render.sprites[1].hidden = false

			U.y_animation_play_group(this, this.animation_click, nil, store.tick_ts, false, "layers")

			last_change = store.tick_ts
			stick_cd = math.random(this.min_cooldown_idle, this.max_cooldown_idle)

			signal.emit("lion_king-stage02", this)
		end

		if this.ui.can_click and stick_cd < store.tick_ts - last_change then
			U.y_animation_play_group(this, this.animation_idle2, nil, store.tick_ts, false, "layers")

			last_change = store.tick_ts
			stick_cd = math.random(this.min_cooldown_idle, this.max_cooldown_idle)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_03_elder_rune = {}

function scripts.decal_stage_03_elder_rune.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0
	local already_played = false

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1
		end

		if c.play_once and already_played then
			-- block empty
		elseif clicks >= c.required_clicks then
			if this.tween then
				this.tween.disabled = false
			elseif not c.idle_animation then
				s.hidden = false
			end

			S:queue(c.clicked_sound)
			U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)

			this.ui.clicked = nil
			clicks = 0
			already_played = true

			if not c.idle_animation then
				s.hidden = true
			else
				U.animation_start(this, c.idle_animation, nil, store.tick_ts, true)
			end

			signal.emit("achievements_custom_event", "RUNEQUEST_3")

			if c.achievement then
				AC:got(c.achievement)
			end

			if c.achievement_flag then
				AC:flag_check(unpack(c.achievement_flag))
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_03_fat_arborean = {}

function scripts.decal_stage_03_fat_arborean.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0
	local already_played = false

	while true do
		if c.play_once and already_played then
			-- block empty
		else
			if this.ui.clicked then
				this.ui.clicked = nil
				clicks = clicks + 1

				S:queue(c.clicked_sound)

				if clicks >= c.required_clicks then
					U.y_animation_play(this, c.end_animation, nil, store.tick_ts, 1)

					already_played = true
					this.ui.can_click = false

					signal.emit("most_delicious-stage03", this)

					goto label_852_0
				else
					U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)
				end
			end

			U.animation_start(this, c.idle_animation, nil, store.tick_ts, true)
		end

		::label_852_0::

		coroutine.yield()
	end
end

scripts.controller_stage_03_arborean_babies = {}

function scripts.controller_stage_03_arborean_babies.update(this, store, script)
	local babies = {}
	local count = 1

	for _, v in pairs(store.entities) do
		if v.template_name == "decal_arborean_baby_clickeable" then
			babies[count] = v
			count = count + 1
		end
	end

	while true do
		local all_hidden = true

		for k, v in pairs(babies) do
			if not v.is_hidden then
				all_hidden = false

				break
			end
		end

		if all_hidden then
			signal.emit("playful_friends-stage03", this)

			break
		end

		coroutine.yield()
	end
end

scripts.click_play_and_idle = {}

function scripts.click_play_and_idle.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0
	local already_played = false

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1
		end

		if c.play_once and already_played then
			-- block empty
		elseif clicks >= c.required_clicks then
			if this.tween then
				this.tween.disabled = false
			elseif not c.idle_animation then
				s.hidden = false
			end

			S:queue(c.clicked_sound)
			U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)

			this.ui.clicked = nil
			clicks = 0
			already_played = true

			if not c.idle_animation then
				s.hidden = true
			else
				U.animation_start(this, c.idle_animation, nil, store.tick_ts, true)
			end

			if c.achievement then
				AC:got(c.achievement)
			end

			if c.achievement_flag then
				AC:flag_check(unpack(c.achievement_flag))
			end
		end

		coroutine.yield()
	end
end

scripts.decal_scripted_loop_play = {}

function scripts.decal_scripted_loop_play.update(this, store, script)
	while true do
		for _, anim_data in ipairs(this.animations) do
			local anim = anim_data[1]
			local wait_time = anim_data[2]
			local loops = 1

			if anim_data[3] then
				loops = anim_data[3]
			end

			U.y_animation_play(this, anim, nil, store.tick_ts, loops)
			U.y_wait(store, wait_time)
		end

		coroutine.yield()
	end
end

scripts.stage_4_arborean_vine = {}

function scripts.stage_4_arborean_vine.update(this, store, script)
	local s = this.render.sprites[1]
	local can_click = false
	local clicked = false
	local time_down = store.tick_ts
	local controller

	for _, v in pairs(store.entities) do
		if v.template_name == "controller_stage_04_arboreans" then
			controller = v

			break
		end
	end

	U.y_animation_play(this, this.animation_idle, nil, store.tick_ts, 1)

	while true do
		if clicked then
			-- block empty
		else
			if can_click and this.ui.clicked then
				this.ui.clicked = nil

				S:queue(this.sound_fall)
				U.y_animation_play(this, this.animation_click, nil, store.tick_ts, 1)

				can_click = false
				time_down = store.tick_ts
				clicked = true
				controller.arboreans_down = controller.arboreans_down + 1
			end

			if not can_click and store.tick_ts - time_down > this.down_cooldown then
				U.y_animation_play(this, this.animation_down, nil, store.tick_ts, 1)
				U.y_animation_play(this, this.animation_down_idle, nil, store.tick_ts, 1)

				can_click = true
				time_down = store.tick_ts
			end

			if can_click and store.tick_ts - time_down > this.down_duration then
				U.y_animation_play(this, this.animation_up, nil, store.tick_ts, 1)

				can_click = false
				time_down = store.tick_ts
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_04_elder_rune = {}

function scripts.decal_stage_04_elder_rune.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0
	local already_played = false

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1
		end

		if c.play_once and already_played then
			-- block empty
		elseif clicks >= c.required_clicks then
			if this.tween then
				this.tween.disabled = false
			elseif not c.idle_animation then
				s.hidden = false
			end

			S:queue(c.clicked_sound)
			U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)

			this.ui.clicked = nil
			clicks = 0
			already_played = true

			U.animation_start(this, c.idle_on_animation, nil, store.tick_ts, true)
			signal.emit("achievements_custom_event", "RUNEQUEST_4")

			if c.achievement then
				AC:got(c.achievement)
			end

			if c.achievement_flag then
				AC:flag_check(unpack(c.achievement_flag))
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_04_arboreans = {}

function scripts.controller_stage_04_arboreans.update(this, store, script)
	this.arboreans_down = 0

	while true do
		if this.arboreans_down == 4 then
			signal.emit("arboreans-stage04", this)

			break
		end

		coroutine.yield()
	end
end

scripts.decal_stage_04_arborean = {}

function scripts.decal_stage_04_arborean.update(this, store)
	local walking_left = false
	local is_dead = false
	local destination_idx = 1
	local start_pos = V.vclone(this.pos)
	local next_destination = this.walk_destination[destination_idx]
	local reach_height = false
	local fm = this.force_motion
	local controller

	for _, v in pairs(store.entities) do
		if v.template_name == "controller_stage_04_arboreans" then
			controller = v

			break
		end
	end

	U.animation_start(this, "walk", nil, store.tick_ts, true)
	U.set_destination(this, V.v(start_pos.x + next_destination.x, start_pos.y + next_destination.y))

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	while true do
		if is_dead then
			if move_step(this.motion.dest) then
				if not reach_height then
					reach_height = true

					U.set_destination(this, V.v(this.pos.x, this.fall_to_y))
				else
					break
				end
			end
		else
			local furthest_distance = this.walk_destination[#this.walk_destination / 2 + 1]
			local distance_destination = V.dist(this.pos.x, this.pos.y, start_pos.x + furthest_distance.x, start_pos.y + furthest_distance.y)
			local distance_origin = V.dist(this.pos.x, this.pos.y, start_pos.x, start_pos.y)

			if distance_destination > 45 and distance_origin > 45 then
				this.ui.can_click = true
			else
				this.ui.can_click = false
			end

			if this.ui.can_click and this.ui.clicked then
				this.ui.clicked = nil
				this.ui.can_click = false
				this.render.sprites[1].z = Z_BACKGROUND_COVERS - 3

				S:queue(this.sound_fall)
				U.y_animation_play(this, "tap", nil, store.tick_ts)
				U.y_wait(store, 0.5)

				is_dead = true
				controller.arboreans_down = controller.arboreans_down + 1

				U.set_destination(this, V.v(this.pos.x, this.pos.y + this.jump_distance))
			end

			if this.motion.arrived then
				destination_idx = km.zmod(destination_idx + 1, #this.walk_destination)
				next_destination = this.walk_destination[destination_idx]

				if next_destination.x - (this.pos.x - start_pos.x) > 0 then
					walking_left = false
					this.render.sprites[1].flip_x = false
				else
					walking_left = true
					this.render.sprites[1].flip_x = true
				end

				U.set_destination(this, V.v(start_pos.x + next_destination.x, start_pos.y + next_destination.y))

				if this.sprite_change then
					this.render.sprites[1].prefix = this.sprite_change[destination_idx]
				end
			end

			U.walk(this, store.tick_length)
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.controller_stage_04_easteregg_sheepy = {}

function scripts.controller_stage_04_easteregg_sheepy.update(this, store, script)
	local decal_old_man = table.filter(store.entities, function(k, v)
		return v.template_name == "decal_stage_04_easteregg_sheepy_old_man"
	end)[1]
	local decal_sheepy = table.filter(store.entities, function(k, v)
		return v.template_name == "decal_stage_04_easteregg_sheepy_sheepy"
	end)[1]
	local old_man_ts = store.tick_ts
	local sheepy_ts = store.tick_ts
	local already_fell = false

	while true do
		if store.tick_ts - old_man_ts >= this.old_man_cooldown then
			U.animation_start(decal_old_man, "talk", nil, store.tick_ts, false)

			old_man_ts = store.tick_ts
		end

		if not already_fell and store.tick_ts - sheepy_ts >= this.sheepy_man_cooldown then
			U.animation_start(decal_sheepy, "annotation", nil, store.tick_ts, false)

			sheepy_ts = store.tick_ts
		end

		if not already_fell and this.ui.clicked then
			this.ui.clicked = nil

			local entity = E:create_entity("decal_stage_04_easteregg_sheepy_baby")

			entity.pos = V.v(decal_sheepy.pos.x, decal_sheepy.pos.y + 150)
			entity.fall_dest = V.v(decal_sheepy.pos.x, decal_sheepy.pos.y + 14)

			queue_insert(store, entity)
			S:queue("Stage04SheepyFall")
			S:queue("Stage04SheepyImpact")
			U.y_wait(store, fts(25))
			U.y_animation_play(decal_sheepy, "fall", nil, store.tick_ts)
			U.animation_start(decal_sheepy, "idle_fallen", nil, store.tick_ts, true)

			already_fell = true

			signal.emit("sheepy_tap_achievement", 0)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_04_easteregg_sheepy_baby = {}

function scripts.decal_stage_04_easteregg_sheepy_baby.update(this, store, script)
	local walking_left = false
	local is_dead = false
	local destination_idx = 1
	local start_pos = V.vclone(this.pos)
	local reach_height = false
	local fm = this.force_motion
	local controller

	for _, v in pairs(store.entities) do
		if v.template_name == "controller_stage_04_arboreans" then
			controller = v

			break
		end
	end

	U.animation_start(this, "fall_loop", nil, store.tick_ts, true)

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	while true do
		if not reach_height and move_step(this.fall_dest) then
			reach_height = true

			U.y_animation_play(this, "fall", nil, store.tick_ts)
			U.animation_start(this, "sit", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_stage_05_elder_rune = {}

function scripts.decal_stage_05_elder_rune.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0
	local already_played = false

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1
		end

		if c.play_once and already_played then
			-- block empty
		elseif clicks >= c.required_clicks then
			if this.tween then
				this.tween.disabled = false
			elseif not c.idle_animation then
				s.hidden = false
			end

			S:queue(c.clicked_sound)
			U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)

			this.ui.clicked = nil
			clicks = 0
			already_played = true

			if not c.idle_animation then
				s.hidden = true
			else
				U.animation_start(this, c.idle_animation, nil, store.tick_ts, true)
			end

			signal.emit("achievements_custom_event", "RUNEQUEST_5")

			if c.achievement then
				AC:got(c.achievement)
			end

			if c.achievement_flag then
				AC:flag_check(unpack(c.achievement_flag))
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_05_blocked_path = {}

function scripts.decal_stage_05_blocked_path.update(this, store)
	while true do
		if store.wave_group_number == 7 and this.rustle_times > 0 then
			U.y_wait(store, this.rustle_delay)
			U.y_animation_play(this, "rustle", nil, store.tick_ts, false)

			this.rustle_times = this.rustle_times - 1
		end

		if store.wave_group_number < 8 then
			-- block empty
		else
			U.y_wait(store, this.cut_down_delay)

			this.road_mask.tween.disabled = nil
			this.road_mask.tween.ts = store.tick_ts
			this.road_mask.tween.reverse = true

			U.y_animation_play(this, "cutDown", nil, store.tick_ts, false)

			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_stage_05_bear_woodcutter = {}

function scripts.decal_stage_05_bear_woodcutter.update(this, store)
	local entity = E:create_entity(this.entity)
	local nodes = P:nearest_nodes(this.waypoint_pos.x, this.waypoint_pos.y, nil, nil, false)
	local pi, spi, ni = unpack(nodes[1])

	entity.pos = this.spawn_pos
	entity.nav_path.pi = pi
	entity.nav_path.spi = spi
	entity.nav_path.ni = ni
	entity.motion.forced_waypoint = P:node_pos(entity.nav_path)

	U.set_destination(entity, this.waypoint_pos)

	while true do
		U.animation_start_group(this, "loop", false, store.tick_ts, false, "layers")
		U.y_animation_wait_group(this, "layers")

		if store.wave_group_number < 8 then
			-- block empty
		else
			U.animation_start_group(this, "wakeup", false, store.tick_ts, false, "layers")
			U.y_wait(store, fts(85))
			S:queue("Stage05WoodcutterBearRoar")
			U.y_wait(store, fts(94))

			for _, e in pairs(store.entities) do
				if e.template_name == "stage_05_trees_mask" then
					queue_remove(store, e)

					break
				end
			end

			S:queue("Stage05WoodcutterBearChop")
			U.y_wait(store, fts(99))
			S:queue("Stage05WoodcutterBearChop")
			U.y_wait(store, fts(130))
			S:queue("Stage05WoodcutterBearChop")
			U.y_animation_wait_group(this, "layers")

			if this.holder then
				this.holder.render.sprites[1].z = Z_DECALS
				this.holder.render.sprites[2].z = Z_OBJECTS
				this.holder.ui.can_click = true
				this.holder.tower.can_hover = true
			end

			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
	queue_insert(store, entity)
	SU.y_enemy_walk_step(store, entity)
end

scripts.decal_stage_06_elder_rune = {}

function scripts.decal_stage_06_elder_rune.update(this, store, script)
	local s = this.render.sprites[1]
	local c = this.click_play
	local clicks = 0
	local already_played = false

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1
		end

		if c.play_once and already_played then
			-- block empty
		elseif clicks >= c.required_clicks then
			if this.tween then
				this.tween.disabled = false
			elseif not c.idle_animation then
				s.hidden = false
			end

			S:queue(c.clicked_sound)
			U.y_animation_play(this, c.click_animation, nil, store.tick_ts, 1)

			this.ui.clicked = nil
			clicks = 0
			already_played = true

			if not c.idle_animation then
				s.hidden = true
			else
				U.animation_start(this, c.idle_animation, nil, store.tick_ts, true)
			end

			signal.emit("achievements_custom_event", "RUNEQUEST_6")

			if c.achievement then
				AC:got(c.achievement)
			end

			if c.achievement_flag then
				AC:flag_check(unpack(c.achievement_flag))
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_06_minecraft_easter_egg = {}

function scripts.decal_stage_06_minecraft_easter_egg.update(this, store)
	local clicks = 0
	local last_change = store.tick_ts
	local change_anim_cd = math.random(this.change_anim_cd_min, this.change_anim_cd_max)

	local function click_and_die()
		if this.ui.clicked then
			this.ui.clicked = nil
			clicks = clicks + 1

			if clicks >= this.clicks_to_kill then
				this.ui.can_click = false

				S:queue(this.sound_death)

				if this.controller then
					this.controller.dead = this.controller.dead + 1
				end

				U.y_animation_play(this, this.animation_death, nil, store.tick_ts, 1)

				this.tween.props[1].disabled = false
				this.tween.props[1].ts = store.tick_ts

				U.y_wait(store, 3)

				return true
			else
				S:queue(this.sound_click)

				this.tween.props[2].disabled = false
				this.tween.props[2].ts = store.tick_ts
				this.tween.disabled = false
			end
		end

		return false
	end

	while true do
		if click_and_die() then
			break
		end

		if change_anim_cd < store.tick_ts - last_change then
			U.animation_start(this, this.animation_attack, nil, store.tick_ts, 1)

			while not U.animation_finished(this, 1, 1) do
				if click_and_die() then
					goto label_870_0
				end

				coroutine.yield()
			end

			last_change = store.tick_ts
			change_anim_cd = math.random(this.change_anim_cd_min, this.change_anim_cd_max)
		else
			U.animation_start(this, this.animation_idle, nil, store.tick_ts, 1)
		end

		coroutine.yield()
	end

	::label_870_0::

	queue_remove(store, this)
end

scripts.controller_stage_06_minecraft_easter_egg = {}

function scripts.controller_stage_06_minecraft_easter_egg.update(this, store)
	local miners = {}
	local count = 0

	for k, v in pairs(store.entities) do
		if v.template_name == "decal_stage_06_minecraft_easter_egg" then
			miners[count + 1] = v
			v.controller = this
			count = count + 1
		end
	end

	this.dead = 0

	while true do
		if this.dead == 3 then
			signal.emit("minecraft-stage06", this)

			return true
		end

		coroutine.yield()
	end
end

scripts.decal_stage_07_temple = {}

function scripts.decal_stage_07_temple.update(this, store)
	local freed_cells = {
		{
			30,
			35
		},
		{
			31,
			35
		},
		{
			32,
			35
		},
		{
			33,
			35
		},
		{
			34,
			35
		},
		{
			35,
			35
		},
		{
			29,
			34
		},
		{
			30,
			34
		},
		{
			31,
			34
		},
		{
			32,
			34
		},
		{
			33,
			34
		},
		{
			34,
			34
		},
		{
			35,
			34
		},
		{
			36,
			34
		},
		{
			29,
			33
		},
		{
			30,
			33
		},
		{
			31,
			33
		},
		{
			32,
			33
		},
		{
			33,
			33
		},
		{
			34,
			33
		},
		{
			35,
			33
		},
		{
			36,
			33
		},
		{
			37,
			33
		},
		{
			38,
			33
		},
		{
			29,
			32
		},
		{
			30,
			32
		},
		{
			31,
			32
		},
		{
			32,
			32
		},
		{
			33,
			32
		},
		{
			34,
			32
		},
		{
			35,
			32
		},
		{
			36,
			32
		},
		{
			37,
			32
		},
		{
			38,
			32
		},
		{
			30,
			31
		},
		{
			31,
			31
		},
		{
			32,
			31
		},
		{
			33,
			31
		},
		{
			34,
			31
		},
		{
			35,
			31
		},
		{
			36,
			31
		},
		{
			37,
			31
		},
		{
			38,
			31
		},
		{
			34,
			30
		},
		{
			35,
			30
		}
	}

	if store.level_mode == GAME_MODE_IRON or store.level_mode == GAME_MODE_HEROIC then
		-- block empty
	else
		while store.wave_group_number < this.activation_wave do
			coroutine.yield()
		end

		S:queue(this.sound)

		do
			local cave_mask

			for _, e in pairs(store.entities) do
				if e.template_name == this.cave_mask then
					cave_mask = e

					break
				end
			end

			cave_mask.render.sprites[1].hidden = true
		end

		do
			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.4
			shake.aura.duration = 4
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
		end

		U.animation_start(this, "temple_in", nil, store.tick_ts, 1)
		U.y_wait(store, 4)

		do
			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.6
			shake.aura.duration = 0.8
			shake.aura.freq_factor = 4

			queue_insert(store, shake)
		end

		U.y_animation_wait(this)
	end

	do
		local mask

		for _, e in pairs(store.entities) do
			if e.template_name == this.temple_mask then
				mask = e

				break
			end
		end

		mask.render.sprites[1].hidden = false
	end

	for _, cell in ipairs(freed_cells) do
		GR:set_cell(cell[1], cell[2], TERRAIN_LAND)
	end

	P:remove_invalid_range(4, 33, 57)
	P:remove_invalid_range(5, 33, 57)

	store.level.ignore_walk_backwards_paths = {
		4,
		5
	}

	while true do
		U.y_animation_play(this, "idle_in", nil, store.tick_ts)
		coroutine.yield()
	end
end

scripts.controller_stage_07_crows = {}

function scripts.controller_stage_07_crows.update(this, store, script)
	local crows = {}
	local count = 1

	for _, v in pairs(store.entities) do
		if string.find(v.template_name, "decal_stage_07_crow_clickable") then
			crows[count] = v
			count = count + 1
		end
	end

	while true do
		local all_away = true

		for k, v in pairs(crows) do
			if v ~= nil and not v.gone_away then
				all_away = false

				break
			end
		end

		if all_away then
			signal.emit("crows-stage07", this)

			break
		end

		coroutine.yield()
	end
end

scripts.stage_07_crow = {}

function scripts.stage_07_crow.update(this, store, script)
	local tap_count = 0
	local taps_to_fly = 3
	local chance_to_die = 0.1

	this.gone_away = false

	while true do
		if this.ui.clicked then
			tap_count = tap_count + 1
			this.ui.clicked = nil
			this.ui.can_click = false

			if tap_count == taps_to_fly then
				if chance_to_die > math.random(0, 100) / 100 then
					S:queue("Stage07CrowCaw")
					U.y_animation_play(this, "death", nil, store.tick_ts, 1)

					this.gone_away = true

					break
				else
					S:queue("Stage07CrowFly")
					U.y_animation_play(this, "flying", nil, store.tick_ts, 1)

					this.gone_away = true

					break
				end
			else
				S:queue("Stage07CrowCaw")
				U.y_animation_play(this, "tap", nil, store.tick_ts, 1)
			end

			this.ui.can_click = true
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.stage_07_witcher = {}

function scripts.stage_07_witcher.insert(this, store, script)
	return not features.censored_cn
end

function scripts.stage_07_witcher.update(this, store, script)
	while store.wave_group_number <= 0 do
		coroutine.yield()
	end

	local last_show = store.tick_ts
	local time_hiding = math.random(5, 10)

	U.animation_start(this, "idle", false, store.tick_ts, true)

	while true do
		if time_hiding < store.tick_ts - last_show then
			U.y_animation_play(this, "in", nil, store.tick_ts, 1)

			local time_showing = math.random(1.5, 2.5)
			local start_time = store.tick_ts

			U.animation_start(this, "idle_leshy", false, store.tick_ts, true)

			while time_showing > store.tick_ts - start_time do
				if this.ui.clicked then
					this.ui.clicked = nil

					S:queue("Stage07Witcher")
					U.y_animation_play(this, "action", nil, store.tick_ts, 1)
					signal.emit("witcher-stage07", this)

					goto label_876_0
				end

				coroutine.yield()
			end

			U.y_animation_play(this, "out", nil, store.tick_ts, 1)
			U.animation_start(this, "idle", false, store.tick_ts, true)

			last_show = store.tick_ts
		end

		coroutine.yield()
	end

	::label_876_0::

	return true
end

scripts.controller_stage_08_gem_baskets = {}

function scripts.controller_stage_08_gem_baskets.update(this, store, script)
	this.baskets_down = 0

	while true do
		if this.baskets_down == 3 then
			signal.emit("baskets-stage08", this)

			break
		end

		coroutine.yield()
	end
end

scripts.stage_08_gem_basket = {}

function scripts.stage_08_gem_basket.update(this, store, script)
	local tap_count = 0
	local taps_to_fall = 3
	local controller

	for _, v in pairs(store.entities) do
		if v.template_name == "controller_stage_08_gem_baskets" then
			controller = v
		end
	end

	while true do
		if this.ui.clicked then
			tap_count = tap_count + 1
			this.ui.clicked = nil
			this.ui.can_click = false

			if tap_count == taps_to_fall then
				S:queue("Stage08BasketBreak")
				U.animation_start(this, "action2", nil, store.tick_ts, 1)

				if this.gold_pos_offset then
					U.y_wait(store, fts(5))

					local rect_pos = v(this.ui.click_rect.pos.x + this.ui.click_rect.size.x / 2, this.ui.click_rect.pos.y + this.ui.click_rect.size.y / 2)
					local gold_pos = V.v(this.pos.x + rect_pos.x + this.gold_pos_offset.x, this.pos.y + rect_pos.y + this.gold_pos_offset.y)

					signal.emit("got-gold", gold_pos, this.gold_amount)
				end

				break
			else
				S:queue("Stage08BasketTap")
				U.y_animation_play(this, "action", nil, store.tick_ts, 1)
			end

			this.ui.can_click = true
		end

		coroutine.yield()
	end

	controller.baskets_down = controller.baskets_down + 1
end

scripts.controller_stage_06_tiki_bar = {}

function scripts.controller_stage_06_tiki_bar.insert(this, store)
	this.baby1 = E:create_entity(this.entity_baby1)
	this.baby1.pos = this.pos

	queue_insert(store, this.baby1)

	this.baby2 = E:create_entity(this.entity_baby2)
	this.baby2.pos = this.pos

	queue_insert(store, this.baby2)

	this.barman = E:create_entity(this.entity_barman)
	this.barman.pos = this.pos

	queue_insert(store, this.barman)

	this.old_man = E:create_entity(this.entity_old_man)
	this.old_man.pos = this.pos

	queue_insert(store, this.old_man)

	return true
end

function scripts.controller_stage_06_tiki_bar.update(this, store)
	local baby_1_ts = store.tick_ts
	local baby_1_cd = math.random(8, 12)
	local baby_2_ts = store.tick_ts
	local baby_2_cd = math.random(8, 12)
	local barman_ts = store.tick_ts
	local barman_cd = math.random(8, 12)

	while true do
		if baby_1_cd < store.tick_ts - baby_1_ts then
			U.animation_start(this.baby1, "Idle2", false, store.tick_ts, false)

			baby_1_ts = store.tick_ts
			baby_1_cd = math.random(8, 12)
		end

		if baby_2_cd < store.tick_ts - baby_2_ts then
			U.animation_start(this.baby2, "idle2", false, store.tick_ts, false)

			baby_2_ts = store.tick_ts
			baby_2_cd = math.random(8, 12)
		end

		if barman_cd < store.tick_ts - barman_ts then
			U.animation_start(this.barman, "action", false, store.tick_ts, false)

			barman_ts = store.tick_ts
			barman_cd = math.random(8, 12)
		end

		coroutine.yield()
	end
end

scripts.controller_stage_06_pool_party = {}

function scripts.controller_stage_06_pool_party.update(this, store)
	local demon_in_pool_cd = math.random(4, 8)
	local demon_in_pool_ts = store.tick_ts - demon_in_pool_cd
	local demon_jumping_cd = math.random(10, 15)
	local demon_jumping_ts = store.tick_ts - demon_jumping_cd
	local volleyball_cd = math.random(8, 12)
	local volleyball_ts = store.tick_ts - volleyball_cd

	for _, e in pairs(store.entities) do
		if e.template_name == this.entity_demon_in_pool then
			this.demon_in_pool = e
		end

		if e.template_name == this.entity_demon_jumping then
			this.demon_jumping = e
		end

		if e.template_name == this.entity_volleyball then
			this.volleyball = e
		end
	end

	while true do
		if demon_in_pool_cd < store.tick_ts - demon_in_pool_ts then
			U.animation_start(this.demon_in_pool, "demon", false, store.tick_ts, false)

			demon_in_pool_ts = store.tick_ts
			demon_in_pool_cd = math.random(4, 8)
		end

		if demon_jumping_cd < store.tick_ts - demon_jumping_ts then
			U.animation_start(this.demon_jumping, "idle", false, store.tick_ts, false)

			demon_jumping_ts = store.tick_ts
			demon_jumping_cd = math.random(10, 15)
		end

		if volleyball_cd < store.tick_ts - volleyball_ts then
			U.animation_start(this.volleyball, "idle", false, store.tick_ts, false)

			volleyball_ts = store.tick_ts
			volleyball_cd = math.random(8, 12)
		end

		coroutine.yield()
	end
end

scripts.controller_stage_08_elf_rescue = {}

function scripts.controller_stage_08_elf_rescue.update(this, store)
	if store.level_mode == GAME_MODE_IRON then
		for i = 1, 4 do
			local elf_spawned = E:create_entity(this.entity_elf)

			elf_spawned.pos = this.elf_pos[i]
			elf_spawned.elf_rescued = i

			queue_insert(store, elf_spawned)
			U.y_wait(store, fts(math.random(10, 30)))
		end

		queue_remove(store, this)

		return
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local elf_rescued = 0
	local guard_spawned
	local guard_dead_ts = store.tick_ts - this.spawn_cooldown
	local chain_spawned, elf_slave_spawned

	while true do
		if guard_spawned and (guard_spawned.health.dead or not store.entities[guard_spawned.id]) then
			guard_spawned = nil
			elf_rescued = elf_rescued + 1
			guard_dead_ts = store.tick_ts

			U.y_wait(store, fts(280))

			local elf_spawned = E:create_entity(this.entity_elf)

			elf_spawned.pos = this.elf_pos[elf_rescued]
			elf_spawned.elf_rescued = elf_rescued

			queue_insert(store, elf_spawned)

			if elf_rescued >= #this.elf_pos then
				U.y_wait(store, 1)
				signal.emit("elves-stage08", this)
			end
		end

		if not guard_spawned and elf_rescued < #this.elf_pos and store.tick_ts - guard_dead_ts > this.spawn_cooldown then
			guard_spawned = E:create_entity(this.entity_guard)
			guard_spawned.pos = this.pos_guard

			queue_insert(store, guard_spawned)

			chain_spawned = E:create_entity(this.entity_chain)
			chain_spawned.pos = this.pos_chain
			chain_spawned.guard_entity = guard_spawned

			queue_insert(store, chain_spawned)

			elf_slave_spawned = E:create_entity(this.entity_elf_slave)
			elf_slave_spawned.pos = this.pos_elf_slave
			elf_slave_spawned.guard_entity = guard_spawned

			queue_insert(store, elf_slave_spawned)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_08_elf_rescue_chains = {}

function scripts.decal_stage_08_elf_rescue_chains.update(this, store)
	this.render.sprites[1].z = Z_DECALS

	U.y_animation_play(this, "walk", nil, store.tick_ts)

	this.render.sprites[1].z = Z_OBJECTS

	U.y_animation_play(this, "idle", nil, store.tick_ts)

	while true do
		if this.guard_entity.health.dead or not store.entities[this.guard_entity.id] then
			U.y_wait(store, fts(40))
			U.y_animation_play(this, "death", nil, store.tick_ts)
			queue_remove(store, this)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_08_elf_rescue_elf_slave = {}

function scripts.decal_stage_08_elf_rescue_elf_slave.update(this, store)
	this.render.sprites[1].z = Z_DECALS

	U.y_animation_play(this, "walk1", nil, store.tick_ts)

	this.render.sprites[1].z = Z_OBJECTS

	U.y_animation_play(this, "to_idle", nil, store.tick_ts)
	U.y_animation_play(this, "idle", nil, store.tick_ts)

	local action_cooldown = math.random(this.action_cooldown_min, this.action_cooldown_max)
	local last_action_ts = store.tick_ts

	while true do
		if action_cooldown <= store.tick_ts - last_action_ts then
			U.y_animation_play(this, "picando", nil, store.tick_ts)

			last_action_ts = store.tick_ts
			action_cooldown = math.random(this.action_cooldown_min, this.action_cooldown_max)
		end

		if this.guard_entity.health.dead or not store.entities[this.guard_entity.id] then
			U.y_wait(store, fts(65))
			S:queue(this.sound_rescue, {
				delay = fts(20)
			})
			U.y_animation_play(this, "escape", nil, store.tick_ts)

			this.render.sprites[1].z = Z_DECALS

			U.y_animation_play(this, "walk2", nil, store.tick_ts)
			queue_remove(store, this)
		end

		coroutine.yield()
	end
end

scripts.enemy_unblinded_abomination_stage_8 = {}

function scripts.enemy_unblinded_abomination_stage_8.update(this, store)
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, false)
	local pi, spi, ni = unpack(nodes[1])
	local last_idle = store.tick_ts
	local idle_cooldown = math.random(this.idle_cooldown_min, this.idle_cooldown_max)

	this.nav_path.pi = pi
	this.nav_path.spi = spi
	this.nav_path.ni = ni
	this.ui.can_click = false

	local function regen(store, this)
		if this.regen and store.tick_ts - this.regen.last_hit_ts > this.regen.last_hit_standoff_time then
			this.regen.ts_counter = this.regen.ts_counter + store.tick_length

			if this.regen.ts_counter > this.regen.cooldown then
				if this.health.hp < this.health.hp_max then
					this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + this.regen.health)

					signal.emit("health-regen", this, this.regen.health)
				end

				this.regen.ts_counter = 0
			end
		end
	end

	this.vis._original_flags = this.vis.flags
	this.vis._original_bans = this.vis.bans
	this.vis.flags = 0
	this.vis.bans = bor(F_RANGED, F_BLOCK)

	U.unblock_all(store, this)

	this.render.sprites[1].z = Z_DECALS

	U.y_animation_play(this, "walk", nil, store.tick_ts)

	this.render.sprites[1].z = Z_OBJECTS

	U.animation_start(this, "idle", nil, store.tick_ts)
	U.y_animation_play(this, "action", nil, store.tick_ts)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	this.vis.flags = this.vis._original_flags
	this.vis.bans = this.vis._original_bans
	last_idle = store.tick_ts

	local hb = E:create_entity("enemy_unblinded_abomination_stage_8_lifebar")

	hb.pos = this.pos

	queue_insert(store, hb)

	this.ui.can_click = true

	::label_885_0::

	while true do
		if this.health.dead then
			this.heading.angle = 0

			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if store.waves_finished and not LU.has_alive_enemies(store, {
				this.template_name
			}) then
				this.heading.angle = 0

				SU.y_enemy_death(store, this)

				return
			end

			if idle_cooldown < store.tick_ts - last_idle then
				U.y_animation_play(this, "action", false, store.tick_ts)
				U.animation_start(this, "idle", false, store.tick_ts, true)

				idle_cooldown = math.random(this.idle_cooldown_min, this.idle_cooldown_max)
				last_idle = store.tick_ts
			end

			regen(store, this)

			if #this.enemy.blockers > 0 then
				U.cleanup_blockers(store, this)

				local blocker = store.entities[this.enemy.blockers[1]]

				if not SU.y_wait_for_blocker(store, this, blocker) then
					goto label_885_0
				end

				while SU.can_melee_blocker(store, this, blocker) do
					if not SU.y_enemy_melee_attacks(store, this, blocker) then
						goto label_885_0
					end

					coroutine.yield()
				end
			end

			coroutine.yield()
		end
	end
end

scripts.soldier_elf_stage_08 = {}

function scripts.soldier_elf_stage_08.update(this, store, script)
	local a = this.bullet_attack

	a.cooldown = U.frandom(a.cooldown_min, a.cooldown_max)

	if this.elf_rescued == 3 or this.elf_rescued == 2 then
		U.y_animation_play(this, "walk1", nil, store.tick_ts, 1)
	else
		U.y_animation_play(this, "walk2", nil, store.tick_ts, 1)
	end

	local is_resting = true
	local last_shoot = store.tick_ts

	a.ts = store.tick_ts - a.cooldown

	while true do
		if store.tick_ts - a.ts > a.cooldown then
			local target, targets = U.find_foremost_enemy(store.entities, this.pos, 0, a.max_range, false, a.vis_flags, a.vis_bans)

			if not target then
				SU.delay_attack(store, a, 0.2)

				goto label_887_0
			elseif target and target.health and not target.health.dead then
				a.ts = store.tick_ts

				local b = E:create_entity(a.bullet)
				local shooting_right = this.pos.x < target.pos.x
				local boffset = a.bullet_start_offset[shooting_right and 1 or 2]

				b.bullet.from = V.v(this.pos.x + boffset.x, this.pos.y + boffset.y)
				b.bullet.to = V.v(target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y)
				b.bullet.target_id = target.id
				b.bullet.source_id = this.id
				b.pos = V.vclone(b.bullet.from)

				local target_pos = target.pos
				local an, af = U.animation_name_facing_point(this, a.animation, target_pos)

				U.animation_start(this, an, af, store.tick_ts, false)
				U.y_wait(store, a.shoot_time)
				queue_insert(store, b)
				S:queue("ArrowSound")
				U.y_animation_wait(this)

				local an, af = U.animation_name_facing_point(this, "back_to_idle2", target_pos)

				U.animation_start(this, an, af, store.tick_ts, false)

				is_resting = false
				last_shoot = store.tick_ts

				U.y_animation_wait(this)
			end
		end

		if is_resting then
			U.animation_start(this, "idle1", nil, store.tick_ts)
		else
			U.animation_start(this, "idle2", nil, store.tick_ts)

			if store.tick_ts - last_shoot > this.idle_rest_cooldown then
				U.y_animation_play(this, "back_to_idle1", nil, store.tick_ts, 1)

				is_resting = true
			end
		end

		U.y_animation_wait(this)

		::label_887_0::

		coroutine.yield()
	end
end

scripts.controller_stage_09_spawn_nightmares = {}

function scripts.controller_stage_09_spawn_nightmares.insert(this, store)
	local portal_spawned = E:create_entity(this.entity_portal)

	portal_spawned.pos = v(526, 380)

	queue_insert(store, portal_spawned)

	this.portal_spawned = portal_spawned

	local path_portal = E:create_entity(this.path_portal)

	path_portal.pos = v(512 + this.portal_offset.x, 384 + this.portal_offset.y)

	queue_insert(store, path_portal)

	this.path_portal = path_portal
	this.candles = {}
	this.glows = {}

	return true
end

function scripts.controller_stage_09_spawn_nightmares.update(this, store)
	local portal_spawned = this.portal_spawned

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local last_wave = 0
	local start_wave_ts = store.tick_ts
	local last_index_processed = 0
	local auras = {}

	local function get_wave_data_index(current_wave_data)
		for index, wave_data in ipairs(current_wave_data) do
			if index > last_index_processed and wave_data.time_start + wave_data.duration > store.tick_ts - start_wave_ts then
				return index
			end
		end

		return nil
	end

	for _, pos in ipairs(this.pos_aura) do
		local aura_spawned = E:create_entity(this.entity_aura)

		aura_spawned.pos = pos
		aura_spawned.path_portal = this.path_portal

		queue_insert(store, aura_spawned)
		table.insert(auras, aura_spawned)
	end

	local aura_spawned_fx = E:create_entity(this.spawn_fx_aura)

	aura_spawned_fx.pos = this.pos_portal
	aura_spawned_fx.portal = this

	queue_insert(store, aura_spawned_fx)

	while true do
		if store.game_outcome and store.game_outcome.victory then
			local entities_spawned = false

			for _, aura in ipairs(auras) do
				if aura.entities_spawned > 0 then
					entities_spawned = true

					break
				end
			end

			if not entities_spawned then
				signal.emit("portal_not_spawned-stage09", this)
			end
		end

		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
			last_index_processed = 0
		end

		if current_wave_data and #current_wave_data > 0 then
			local next_index_to_check = get_wave_data_index(current_wave_data)

			if next_index_to_check and next_index_to_check ~= last_index_processed then
				local wave_data = current_wave_data[next_index_to_check]

				if store.tick_ts - start_wave_ts >= wave_data.time_start then
					S:queue(this.sound_candles_in)

					for _, candle in ipairs(this.candles) do
						candle.turn_on = true
					end

					for _, glow in ipairs(this.glows) do
						glow.render.sprites[1].hidden = false

						U.animation_start(glow, "on", nil, store.tick_ts)
					end

					this.path_portal.turn_on = true

					S:queue(this.sound_portal_in)
					U.y_animation_play(portal_spawned, "on", nil, store.tick_ts)
					U.y_animation_play(portal_spawned, "idle_on", nil, store.tick_ts)

					local start_ts = store.tick_ts

					while store.tick_ts - start_ts < wave_data.duration do
						if this.enemy_spawned then
							this.enemy_spawned = nil

							U.y_animation_play(portal_spawned, "spawn", nil, store.tick_ts)
						end

						coroutine.yield()
					end

					last_index_processed = next_index_to_check

					for _, candle in ipairs(this.candles) do
						candle.turn_off = true
					end

					for _, glow in ipairs(this.glows) do
						U.animation_start(glow, "off", nil, store.tick_ts)
					end

					U.y_animation_play(portal_spawned, "off", nil, store.tick_ts)
					U.y_animation_play(portal_spawned, "idle", nil, store.tick_ts)

					local start_ts = store.tick_ts

					while store.tick_ts - start_ts < this.path_portal_off_delay and current_wave == store.wave_group_number do
						coroutine.yield()
					end

					this.path_portal.turn_off = true
				end
			end
		end

		coroutine.yield()
	end
end

scripts.aura_stage_09_spawn_nightmare_convert = {}

function scripts.aura_stage_09_spawn_nightmare_convert.update(this, store)
	this.entities_spawned = 0

	while true do
		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if this.path_portal.render.sprites[1].name ~= "idle" then
			local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.aura.radius, this.aura.vis_flags, this.aura.vis_bans, function(e)
				return e ~= this and e.health.hp and e.can_be_converted and (this.include_templates and table.contains(this.include_templates, e.template_name) or not this.include_templates)
			end)

			if targets and #targets > 0 then
				for _, enemy in ipairs(targets) do
					local pos = V.vclone(enemy.pos)
					local nav_path = enemy.nav_path

					queue_remove(store, enemy)

					local entity = E:create_entity(this.spawn_fx)

					entity.pos = v(512 + this.portal_offset.x, 384 + this.portal_offset.y)
					entity.render.sprites[1].ts = store.tick_ts

					queue_insert(store, entity)

					entity = E:create_entity(this.entity_to_spawn)
					entity.pos = pos
					entity.nav_path = nav_path

					local original_speed = entity.motion.max_speed

					entity.motion.max_speed = 0
					entity.source_id = this.id

					queue_insert(store, entity)
					signal.emit("wave-notification", "icon", "enemy_armored_nightmare")
					S:queue(this.sound_spawn)
					U.y_wait(store, fts(5))

					entity.motion.max_speed = original_speed
					this.entities_spawned = this.entities_spawned + 1
				end
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_09_skeleton = {}

function scripts.decal_stage_09_skeleton.update(this, store)
	local is_dead = false
	local walking_left = true

	U.animation_start(this, "idle_death", nil, store.tick_ts, true)

	while true do
		if is_dead and store.tick_ts - death_ts >= this.death_time then
			S:queue("Stage09DryBonesReform")
			U.y_animation_play(this, "respawn", nil, store.tick_ts)

			is_dead = false
			this.ui.can_click = true

			U.animation_start(this, "walk", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.controller_stage_10_obelisk = {}

function scripts.controller_stage_10_obelisk.insert(this, store)
	local cultist = E:create_entity(this.entity_cultist)

	cultist.pos = this.obelisk_pos

	queue_insert(store, cultist)

	this.cultist = cultist

	local crystal = E:create_entity(this.entity_crystal)

	crystal.pos = V.v(this.crystal_pos.x, this.crystal_pos.y - crystal.move_distance)

	queue_insert(store, crystal)

	this.crystal = crystal

	local base_crystal = E:create_entity(this.entity_base_crystals)

	base_crystal.pos = this.obelisk_pos

	queue_insert(store, base_crystal)

	this.base_crystal = base_crystal
	this.golems = {}

	if store.level_mode == GAME_MODE_CAMPAIGN then
		for i = 1, 3 do
			local golem = E:create_entity(this.template_golem)

			golem.pos = this.golem_holder_pos[i]
			golem.start_as_rock = true
			golem.walk_pos = this.golem_walk_pos[i]
			golem.activate_holder = this.golem_activate_holder[i]
			golem.selected_path = this.golem_selected_paths[i]
			golem.ignore_seen_tracker = true

			queue_insert(store, golem)
			table.insert(this.golems, golem)
		end
	elseif store.level_mode == GAME_MODE_IRON then
		for i = 1, #this.golem_activate_holder do
			local golem = E:create_entity(this.template_golem)

			golem.pos = V.vclone(this.golem_holder_pos[i])
			golem.start_as_rock = true
			golem.walk_pos = V.v(golem.pos.x + this.golem_walk_pos[i].x, golem.pos.y + this.golem_walk_pos[i].y)
			golem.activate_holder = this.golem_activate_holder[i]
			golem.selected_path = this.golem_selected_paths[i]
			golem.ignore_seen_tracker = true

			queue_insert(store, golem)
			table.insert(this.golems, golem)
		end
	end

	return true
end

function scripts.controller_stage_10_obelisk.update(this, store)
	local change_mode_ts = store.tick_ts
	local MODE_STUN = 1
	local MODE_HEAL = 2
	local MODE_TELEPORT = 3
	local current_mode_idx = 1
	local crystal_mode_list = table.random_order({
		MODE_STUN,
		MODE_HEAL,
		MODE_TELEPORT
	})
	local mode_start_ts = store.tick_ts
	local mode_ability_ts = store.tick_ts
	local in_mode = false
	local comes_from_off = true
	local golems_to_spawn = table.clone(this.config.sacrifice.waves)

	local function crystal_up()
		this.crystal.tween.props[2].keys[1][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.move_distance)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = false
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_down()
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = true
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_levitate()
		if this.crystal.tween.props[1].disabled then
			this.crystal.tween.disabled = false
			this.crystal.tween.reverse = false
			this.crystal.tween.ts = store.tick_ts
			this.crystal.tween.props[1].disabled = false
			this.crystal.tween.props[1].loop = true
			this.crystal.tween.props[1].ts = store.tick_ts
			this.crystal.tween.props[2].disabled = true
			this.crystal.tween.props[2].ts = store.tick_ts
		end
	end

	local function prepare_crystal()
		if comes_from_off then
			this.cultist.render.sprites[1].hidden = false

			U.animation_start(this.cultist, "back_online", nil, store.tick_ts)
			U.animation_start(this.crystal, "back_online", nil, store.tick_ts)
			S:queue(this.sound_activation)
			U.y_animation_wait(this.cultist)

			this.crystal.tween.props[1].ts = store.tick_ts
		else
			S:queue(this.sound_change_mode)
		end

		crystal_up()
		U.animation_start(this.cultist, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.crystal, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.crystal)
		U.animation_start(this.cultist, "change_loop", nil, store.tick_ts, true)
		U.animation_start(this.crystal, "change_loop", nil, store.tick_ts, true)

		local fx = E:create_entity(this.template_crystal_fx)

		fx.pos = this.cultist.pos
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		this.crystal_fx = fx
	end

	local function change_mode()
		change_mode_ts = store.tick_ts

		if this.crystal_fx then
			this.crystal_fx.end_fx = true
		end

		U.animation_start(this.cultist, "change_out", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)
		U.animation_start(this.crystal, "to_idle" .. crystal_mode_list[current_mode_idx], nil, store.tick_ts)
		U.y_animation_wait(this.crystal)
		U.animation_start(this.crystal, "idle" .. crystal_mode_list[current_mode_idx], nil, store.tick_ts, true)

		mode_start_ts = store.tick_ts

		local set_ts = store.tick_ts

		if crystal_mode_list[current_mode_idx] == MODE_STUN then
			set_ts = set_ts - (this.config.stun.cooldown - this.config.mode_first_delay)
		elseif crystal_mode_list[current_mode_idx] == MODE_HEAL then
			set_ts = set_ts - (this.config.heal.cooldown - this.config.mode_first_delay)
		elseif crystal_mode_list[current_mode_idx] == MODE_TELEPORT then
			set_ts = set_ts - (this.config.teleport.cooldown - this.config.mode_first_delay)
		end

		mode_ability_ts = set_ts
		in_mode = true
	end

	local function on_mode_end()
		in_mode = false
		change_mode_ts = store.tick_ts
		current_mode_idx = km.zmod(current_mode_idx + 1, #crystal_mode_list)

		prepare_crystal()
	end

	local function do_while_stun()
		crystal_levitate()

		if store.tick_ts - mode_start_ts >= this.config.stun.mode_duration then
			comes_from_off = false

			on_mode_end()
		elseif store.tick_ts - mode_ability_ts >= this.config.stun.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, bor(F_ENEMY)) == 0 and v.vis and v.vis.bans and band(v.vis.bans, 0) == 0
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.stun.cooldown + 1 - 1e-06

				return
			end

			S:queue(this.sound_cast_stun)
			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)

			local fx = E:create_entity(this.fx_stun_explosion)

			fx.pos = this.cultist.pos
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
			U.y_wait(store, fts(18))

			local fx = E:create_entity(this.fx_stun_explosion_white)

			fx.pos = V.v(512, 384)
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local fx = E:create_entity(this.fx_stun_circle)

			fx.pos = this.cultist.pos
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.4
			shake.aura.duration = 0.5
			shake.aura.freq_factor = 1

			queue_insert(store, shake)

			local soldiers = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.stun_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.stun_flags) == 0 and (not this.stun_excluded_teplates or not table.contains(this.stun_excluded_teplates, v.template_name))
			end)

			if soldiers and #soldiers > 0 then
				for _, s in ipairs(soldiers) do
					local m = E:create_entity(this.stun_mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = s.id
					m.modifier.duration = this.config.stun.stun_duration

					queue_insert(store, m)
				end
			end

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_while_heal()
		crystal_levitate()

		if store.tick_ts - mode_start_ts >= this.config.heal.mode_duration then
			comes_from_off = false

			on_mode_end()
		elseif store.tick_ts - mode_ability_ts >= this.config.heal.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.heal_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.heal_flags) == 0 and (not this.heal_excluded_teplates or not table.contains(this.heal_excluded_teplates, v.template_name))
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.heal.cooldown + 1 - 1e-06

				return
			end

			S:queue(this.sound_cast_heal)
			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.y_animation_play(this.base_crystal, "heal_in", nil, store.tick_ts)
			S:queue(this.sound_heal_loop)
			U.animation_start(this.base_crystal, "heal_loop", nil, store.tick_ts, true)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)

			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.heal_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.heal_flags) == 0 and (not this.heal_excluded_teplates or not table.contains(this.heal_excluded_teplates, v.template_name))
			end)
			local mod_duration = fts(30)

			if enemies and #enemies > 0 then
				for _, enemy in ipairs(enemies) do
					local m = E:create_entity(this.heal_mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = enemy.id
					m.heal_hp = math.random(this.config.heal.heal_min, this.config.heal.heal_max)

					queue_insert(store, m)

					mod_duration = m.modifier.duration
				end
			end

			U.y_wait(store, mod_duration)
			S:stop(this.sound_heal_loop)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.animation_start(this.base_crystal, "heal_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_while_teleport()
		crystal_levitate()

		if store.tick_ts - mode_start_ts >= this.config.teleport.mode_duration then
			comes_from_off = false

			on_mode_end()
		elseif store.tick_ts - mode_ability_ts >= this.config.teleport.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.teleport_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.teleport_flags) == 0 and (not this.teleport_excluded_teplates or not table.contains(this.teleport_excluded_teplates, v.template_name)) and v.nav_path and P:nodes_to_goal(v.nav_path) >= this.config.teleport.nodes_to_goal_selectable and v.nav_path.ni >= this.config.teleport.nodes_from_selectable
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.teleport.cooldown + 1 - 1e-06

				return
			end

			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)
			U.animation_start(this.crystal, "telegraph_3", nil, store.tick_ts)

			local fx = E:create_entity(this.fx_teleport)

			fx.pos = this.cultist.pos
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
			U.y_wait(store, fts(20))
			S:queue(this.sound_cast_teleport)

			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.teleport_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.teleport_flags) == 0 and (not this.teleport_excluded_teplates or not table.contains(this.teleport_excluded_teplates, v.template_name)) and v.nav_path and P:nodes_to_goal(v.nav_path) >= this.config.teleport.nodes_to_goal_selectable and v.nav_path.ni >= this.config.teleport.nodes_from_selectable
			end)

			if enemies and #enemies > 0 then
				local sorted_enemies = {}

				for _, e1 in ipairs(enemies) do
					local enemies_in_range = 0

					for _, e2 in ipairs(enemies) do
						if e1.id ~= e2.id and e1.pos and e2.pos then
							local distance = V.dist(e1.pos.x, e1.pos.y, e2.pos.x, e2.pos.y)

							if distance < this.config.teleport.aura_radius then
								enemies_in_range = enemies_in_range + 1
							end
						end
					end

					table.insert(sorted_enemies, {
						entity = e1,
						enemies_in_range = enemies_in_range
					})
				end

				table.sort(sorted_enemies, function(e1, e2)
					return e1.enemies_in_range > e2.enemies_in_range
				end)

				local a = E:create_entity(this.teleport_aura)

				a.aura.source_id = this.id
				a.pos = V.vclone(sorted_enemies[1].entity.pos)

				queue_insert(store, a)
			end

			U.y_wait(store, fts(18))
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			mode_ability_ts = store.tick_ts
		end
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	U.y_wait(store, this.config.start_delay[store.level_mode])
	prepare_crystal()

	change_mode_ts = store.tick_ts

	while true do
		if store.waves_finished and not LU.has_alive_enemies(store) then
			crystal_down()
			U.y_animation_play(this.cultist, "death", nil, store.tick_ts)

			break
		end

		if not in_mode and store.tick_ts - change_mode_ts >= this.config.change_mode_every then
			change_mode()
		elseif in_mode then
			if store.level_mode == GAME_MODE_CAMPAIGN and table.contains(golems_to_spawn, store.wave_group_number) then
				U.animation_start(this.crystal, "to_idle4", nil, store.tick_ts)
				U.y_animation_wait(this.cultist)
				U.animation_start(this.cultist, "sacrifice", nil, store.tick_ts)
				U.animation_start(this.crystal, "sacrifice", nil, store.tick_ts)
				U.animation_start(this.light, "sacrifice", nil, store.tick_ts)
				U.y_animation_wait(this.cultist)
				crystal_down()

				this.crystal.tween.props[1].loop = false

				local golem_idx = #this.config.sacrifice.waves - #golems_to_spawn + 1

				for i = 1, 3 do
					local b = E:create_entity(this.bullet_golem_spawn)
					local pos = V.v(this.bullet_spawn_pos[i].x + this.cultist.pos.x, this.bullet_spawn_pos[i].y + this.cultist.pos.y)

					b.pos = pos
					b.bullet.from = V.vclone(b.pos)

					local golem_pos = this.golem_holder_pos[golem_idx]

					b.bullet.to = V.v(golem_pos.x + this.bullet_offset.x, golem_pos.y + this.bullet_offset.y)
					b.target_golem = this.golems[golem_idx]

					queue_insert(store, b)
					coroutine.yield()
				end

				this.cultist.render.sprites[1].hidden = true

				U.y_wait(store, this.config.sacrifice.inactive_time)

				comes_from_off = true

				table.remove(golems_to_spawn, 1)
				on_mode_end()
			elseif crystal_mode_list[current_mode_idx] == MODE_STUN then
				do_while_stun()
			elseif crystal_mode_list[current_mode_idx] == MODE_HEAL then
				do_while_heal()
			elseif crystal_mode_list[current_mode_idx] == MODE_TELEPORT then
				do_while_teleport()
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_10_obelisk_by_wave = {}

function scripts.controller_stage_10_obelisk_by_wave.update(this, store)
	local MODE_STUN = 1
	local MODE_HEAL = 2
	local MODE_TELEPORT = 3
	local MODE_SACRIFICE = 4
	local current_mode_idx = 1
	local crystal_mode_list = table.random_order({
		MODE_STUN,
		MODE_HEAL,
		MODE_TELEPORT
	})
	local comes_from_off = true
	local golems_to_spawn = table.clone(this.config.sacrifice.waves)
	local mode_ability_ts
	local last_wave_processed = 0
	local current_mode

	local function crystal_up()
		this.crystal.tween.props[2].keys[1][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.move_distance)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = false
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_down()
		this.crystal.tween.props[2].keys[1][2] = V.v(0, 0)
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = true
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_levitate()
		if this.crystal.tween.props[1].disabled then
			this.crystal.tween.disabled = false
			this.crystal.tween.reverse = false
			this.crystal.tween.ts = store.tick_ts
			this.crystal.tween.props[1].disabled = false
			this.crystal.tween.props[1].loop = true
			this.crystal.tween.props[1].ts = store.tick_ts
			this.crystal.tween.props[2].disabled = true
			this.crystal.tween.props[2].ts = store.tick_ts
		end
	end

	local function prepare_crystal()
		if comes_from_off then
			this.cultist.render.sprites[1].hidden = false

			U.animation_start(this.cultist, "back_online", nil, store.tick_ts)
			U.animation_start(this.crystal, "back_online", nil, store.tick_ts)
			S:queue(this.sound_activation)
			U.y_animation_wait(this.cultist)

			this.crystal.tween.props[1].ts = store.tick_ts
		else
			S:queue(this.sound_change_mode)
		end

		crystal_up()
		U.animation_start(this.cultist, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.crystal, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.crystal)
		U.animation_start(this.cultist, "change_loop", nil, store.tick_ts, true)
		U.animation_start(this.crystal, "change_loop", nil, store.tick_ts, true)

		local fx = E:create_entity(this.template_crystal_fx)

		fx.pos = this.cultist.pos
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		this.crystal_fx = fx

		U.y_wait(store, this.config.mode_first_delay)
	end

	local function change_mode()
		last_wave_processed = store.wave_group_number

		prepare_crystal()

		if this.crystal_fx then
			this.crystal_fx.end_fx = true
		end

		U.animation_start(this.cultist, "change_out", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

		if store.level_mode == GAME_MODE_CAMPAIGN and table.contains(golems_to_spawn, store.wave_group_number) then
			current_mode = MODE_SACRIFICE
		else
			U.animation_start(this.crystal, "to_idle" .. crystal_mode_list[current_mode_idx], nil, store.tick_ts)
			U.y_animation_wait(this.crystal)
			U.animation_start(this.crystal, "idle" .. crystal_mode_list[current_mode_idx], nil, store.tick_ts, true)

			local set_ts = store.tick_ts

			if crystal_mode_list[current_mode_idx] == MODE_STUN then
				set_ts = set_ts - (this.config.stun.cooldown - this.config.mode_first_delay)
				current_mode = MODE_STUN
			elseif crystal_mode_list[current_mode_idx] == MODE_HEAL then
				set_ts = set_ts - (this.config.heal.cooldown - this.config.mode_first_delay)
				current_mode = MODE_HEAL
			elseif crystal_mode_list[current_mode_idx] == MODE_TELEPORT then
				set_ts = set_ts - (this.config.teleport.cooldown - this.config.mode_first_delay)
				current_mode = MODE_TELEPORT
			end

			mode_ability_ts = set_ts
		end
	end

	local function on_mode_end()
		current_mode = nil
		current_mode_idx = km.zmod(current_mode_idx + 1, #crystal_mode_list)
	end

	local function do_while_stun()
		crystal_levitate()

		if store.tick_ts - mode_ability_ts >= this.config.stun.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, bor(F_ENEMY)) == 0 and v.vis and v.vis.bans and band(v.vis.bans, 0) == 0
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.stun.cooldown + 1 - 1e-06

				return
			end

			S:queue(this.sound_cast_stun)
			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)

			local fx_explosion = E:create_entity(this.fx_stun_explosion)

			fx_explosion.pos = this.cultist.pos
			fx_explosion.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx_explosion)
			U.y_wait(store, fts(18))

			local fx_white = E:create_entity(this.fx_stun_explosion_white)

			fx_white.pos = V.v(512, 384)
			fx_white.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx_white)

			local fx = E:create_entity(this.fx_stun_circle)

			fx.pos = this.cultist.pos
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.4
			shake.aura.duration = 0.5
			shake.aura.freq_factor = 1

			queue_insert(store, shake)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			local soldiers = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.stun_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.stun_flags) == 0 and (not this.stun_excluded_teplates or not table.contains(this.stun_excluded_teplates, v.template_name))
			end)

			if soldiers and #soldiers > 0 then
				for _, s in ipairs(soldiers) do
					local m = E:create_entity(this.stun_mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = s.id
					m.modifier.duration = this.config.stun.stun_duration

					queue_insert(store, m)
				end
			end

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_while_heal()
		crystal_levitate()

		if store.tick_ts - mode_ability_ts >= this.config.heal.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.heal_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.heal_flags) == 0 and (not this.heal_excluded_teplates or not table.contains(this.heal_excluded_teplates, v.template_name))
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.heal.cooldown + 1 - 1e-06

				return
			end

			S:queue(this.sound_cast_heal)
			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.y_animation_play(this.base_crystal, "heal_in", nil, store.tick_ts)
			S:queue(this.sound_heal_loop)
			U.animation_start(this.base_crystal, "heal_loop", nil, store.tick_ts, true)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)

			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.heal_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.heal_flags) == 0 and (not this.heal_excluded_teplates or not table.contains(this.heal_excluded_teplates, v.template_name))
			end)
			local mod_duration = fts(30)

			if enemies and #enemies > 0 then
				for _, enemy in ipairs(enemies) do
					local m = E:create_entity(this.heal_mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = enemy.id
					m.heal_hp = math.random(this.config.heal.heal_min, this.config.heal.heal_max)

					queue_insert(store, m)

					mod_duration = m.modifier.duration
				end
			end

			U.y_wait(store, mod_duration)
			S:stop(this.sound_heal_loop)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.animation_start(this.base_crystal, "heal_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_while_teleport()
		crystal_levitate()

		if store.tick_ts - mode_ability_ts >= this.config.teleport.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.teleport_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.teleport_flags) == 0 and (not this.teleport_excluded_teplates or not table.contains(this.teleport_excluded_teplates, v.template_name)) and v.nav_path and P:nodes_to_goal(v.nav_path) >= this.config.teleport.nodes_to_goal_selectable and v.nav_path.ni >= this.config.teleport.nodes_from_selectable
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.teleport.cooldown + 1 - 1e-06

				return
			end

			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)
			U.animation_start(this.crystal, "telegraph_3", nil, store.tick_ts)

			local fx = E:create_entity(this.fx_teleport)

			fx.pos = this.cultist.pos
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
			U.y_wait(store, fts(20))
			S:queue(this.sound_cast_teleport)

			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.teleport_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.teleport_flags) == 0 and (not this.teleport_excluded_teplates or not table.contains(this.teleport_excluded_teplates, v.template_name)) and v.nav_path and P:nodes_to_goal(v.nav_path) >= this.config.teleport.nodes_to_goal_selectable and v.nav_path.ni >= this.config.teleport.nodes_from_selectable
			end)

			if enemies and #enemies > 0 then
				local sorted_enemies = {}

				for _, e1 in ipairs(enemies) do
					local enemies_in_range = 0

					for _, e2 in ipairs(enemies) do
						if e1.id ~= e2.id and e1.pos and e2.pos then
							local distance = V.dist(e1.pos.x, e1.pos.y, e2.pos.x, e2.pos.y)

							if distance < this.config.teleport.aura_radius then
								enemies_in_range = enemies_in_range + 1
							end
						end
					end

					table.insert(sorted_enemies, {
						entity = e1,
						enemies_in_range = enemies_in_range
					})
				end

				table.sort(sorted_enemies, function(e1, e2)
					return e1.enemies_in_range > e2.enemies_in_range
				end)

				local a = E:create_entity(this.teleport_aura)

				a.aura.source_id = this.id
				a.pos = V.vclone(sorted_enemies[1].entity.pos)

				queue_insert(store, a)
			end

			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_sacrifice()
		if table.contains(golems_to_spawn, store.wave_group_number) then
			U.animation_start(this.crystal, "to_idle4", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			S:queue(this.sound_cast_golem)
			U.animation_start(this.cultist, "sacrifice_in", nil, store.tick_ts)
			U.animation_start(this.crystal, "sacrifice_in", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "sacrifice_loop", nil, store.tick_ts, true)
			U.animation_start(this.crystal, "sacrifice_loop", nil, store.tick_ts, true)
			U.y_wait(store, this.sacrifice_duration)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "sacrifice_out", nil, store.tick_ts)
			U.animation_start(this.crystal, "sacrifice_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			crystal_down()

			local golem_idx = #this.config.sacrifice.waves - #golems_to_spawn + 1

			for i = 1, 3 do
				local b = E:create_entity(this.bullet_golem_spawn)
				local pos = V.v(this.bullet_spawn_pos[i].x + this.cultist.pos.x, this.bullet_spawn_pos[i].y + this.cultist.pos.y)

				b.pos = pos
				b.bullet.from = V.vclone(b.pos)

				local golem_pos = this.golem_holder_pos[golem_idx]

				b.bullet.to = V.v(golem_pos.x + this.bullet_offset.x, golem_pos.y + this.bullet_offset.y)
				b.target_golem = this.golems[golem_idx]
				b.bullet_idx = i

				queue_insert(store, b)
			end

			coroutine.yield()

			this.cultist.render.sprites[1].hidden = true

			table.remove(golems_to_spawn, 1)
		end
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	U.y_wait(store, this.config.start_delay[store.level_mode])

	while true do
		if store.waves_finished and not LU.has_alive_enemies(store) then
			crystal_down()
			U.y_animation_play(this.cultist, "death", nil, store.tick_ts)

			break
		end

		if store.wave_group_number ~= last_wave_processed then
			if current_mode == MODE_SACRIFICE then
				comes_from_off = true
			else
				comes_from_off = false

				if current_mode == nil then
					comes_from_off = true
				end
			end

			on_mode_end()
			change_mode()
		elseif current_mode == MODE_SACRIFICE then
			do_sacrifice()
		elseif current_mode == MODE_STUN then
			do_while_stun()
		elseif current_mode == MODE_HEAL then
			do_while_heal()
		elseif current_mode == MODE_TELEPORT then
			do_while_teleport()
		end

		coroutine.yield()
	end
end

scripts.controller_stage_10_obelisk_wave_fixed = {}

function scripts.controller_stage_10_obelisk_wave_fixed.update(this, store)
	local MODE_STUN = 1
	local MODE_HEAL = 2
	local MODE_TELEPORT = 3
	local MODE_SACRIFICE = 4
	local comes_from_off = true
	local golems_to_spawn = table.clone(this.config.sacrifice.waves)
	local mode_ability_ts
	local current_mode_duration = 0
	local current_mode_start_ts = 0
	local last_wave_processed = 0
	local current_mode

	local function crystal_up()
		this.crystal.tween.props[2].keys[1][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.move_distance)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = false
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_down()
		this.crystal.tween.props[2].keys[1][2] = V.v(0, 0)
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = true
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_levitate()
		if this.crystal.tween.props[1].disabled then
			this.crystal.tween.disabled = false
			this.crystal.tween.reverse = false
			this.crystal.tween.ts = store.tick_ts
			this.crystal.tween.props[1].disabled = false
			this.crystal.tween.props[1].loop = true
			this.crystal.tween.props[1].ts = store.tick_ts
			this.crystal.tween.props[2].disabled = true
			this.crystal.tween.props[2].ts = store.tick_ts
		end
	end

	local function prepare_crystal()
		if comes_from_off then
			this.cultist.render.sprites[1].hidden = false

			U.animation_start(this.cultist, "back_online", nil, store.tick_ts)
			U.animation_start(this.crystal, "back_online", nil, store.tick_ts)
			S:queue(this.sound_activation)
			U.y_animation_wait(this.cultist)

			this.crystal.tween.props[1].ts = store.tick_ts
		else
			S:queue(this.sound_change_mode)
		end

		crystal_up()
		U.animation_start(this.cultist, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.crystal, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.crystal)
		U.animation_start(this.cultist, "change_loop", nil, store.tick_ts, true)
		U.animation_start(this.crystal, "change_loop", nil, store.tick_ts, true)

		local fx = E:create_entity(this.template_crystal_fx)

		fx.pos = this.cultist.pos
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		this.crystal_fx = fx

		U.y_wait(store, this.config.mode_first_delay)
	end

	local function change_mode()
		local per_wave_config = store.level_mode == GAME_MODE_CAMPAIGN and this.config.per_wave_config_campaign or this.config.per_wave_config_heroic

		U.y_wait(store, per_wave_config[store.wave_group_number].delay)

		last_wave_processed = store.wave_group_number

		prepare_crystal()

		if this.crystal_fx then
			this.crystal_fx.end_fx = true
		end

		U.animation_start(this.cultist, "change_out", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

		if store.level_mode == GAME_MODE_CAMPAIGN and table.contains(golems_to_spawn, store.wave_group_number) then
			current_mode = MODE_SACRIFICE
		else
			local current_mode_name = per_wave_config[store.wave_group_number].mode

			if current_mode_name == "teleport" then
				current_mode = MODE_TELEPORT
			elseif current_mode_name == "heal" then
				current_mode = MODE_HEAL
			end

			U.animation_start(this.crystal, "to_idle" .. current_mode, nil, store.tick_ts)
			U.y_animation_wait(this.crystal)
			U.animation_start(this.crystal, "idle" .. current_mode, nil, store.tick_ts, true)

			local set_ts = store.tick_ts

			if current_mode == MODE_STUN then
				set_ts = set_ts - (this.config.stun.cooldown - this.config.mode_first_delay)
			elseif current_mode == MODE_HEAL then
				set_ts = set_ts - (this.config.heal.cooldown - this.config.mode_first_delay)
			elseif current_mode == MODE_TELEPORT then
				set_ts = set_ts - (this.config.teleport.cooldown - this.config.mode_first_delay)
			end

			mode_ability_ts = set_ts
			current_mode_duration = per_wave_config[store.wave_group_number].duration
			current_mode_start_ts = store.tick_ts
		end
	end

	local function on_mode_end()
		current_mode = nil
	end

	local function do_while_stun()
		crystal_levitate()

		if store.tick_ts - mode_ability_ts >= this.config.stun.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, bor(F_ENEMY)) == 0 and v.vis and v.vis.bans and band(v.vis.bans, 0) == 0
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.stun.cooldown + 1 - 1e-06

				return
			end

			S:queue(this.sound_cast_stun)
			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)

			local fx_explosion = E:create_entity(this.fx_stun_explosion)

			fx_explosion.pos = this.cultist.pos
			fx_explosion.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx_explosion)
			U.y_wait(store, fts(18))

			local fx_white = E:create_entity(this.fx_stun_explosion_white)

			fx_white.pos = V.v(512, 384)
			fx_white.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx_white)

			local fx = E:create_entity(this.fx_stun_circle)

			fx.pos = this.cultist.pos
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.4
			shake.aura.duration = 0.5
			shake.aura.freq_factor = 1

			queue_insert(store, shake)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			local soldiers = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.stun_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.stun_flags) == 0 and (not this.stun_excluded_teplates or not table.contains(this.stun_excluded_teplates, v.template_name))
			end)

			if soldiers and #soldiers > 0 then
				for _, s in ipairs(soldiers) do
					local m = E:create_entity(this.stun_mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = s.id
					m.modifier.duration = this.config.stun.stun_duration

					queue_insert(store, m)
				end
			end

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_while_heal()
		crystal_levitate()

		if store.tick_ts - mode_ability_ts >= this.config.heal.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.heal_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.heal_flags) == 0 and (not this.heal_excluded_teplates or not table.contains(this.heal_excluded_teplates, v.template_name))
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.heal.cooldown + 1 - 1e-06

				return
			end

			S:queue(this.sound_cast_heal)
			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.y_animation_play(this.base_crystal, "heal_in", nil, store.tick_ts)
			S:queue(this.sound_heal_loop)
			U.animation_start(this.base_crystal, "heal_loop", nil, store.tick_ts, true)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)

			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.heal_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.heal_flags) == 0 and (not this.heal_excluded_teplates or not table.contains(this.heal_excluded_teplates, v.template_name))
			end)
			local mod_duration = fts(30)

			if enemies and #enemies > 0 then
				for _, enemy in ipairs(enemies) do
					local m = E:create_entity(this.heal_mod)

					m.modifier.source_id = this.id
					m.modifier.target_id = enemy.id
					m.heal_hp = math.random(this.config.heal.heal_min, this.config.heal.heal_max)

					queue_insert(store, m)

					mod_duration = m.modifier.duration
				end
			end

			U.y_wait(store, mod_duration)
			S:stop(this.sound_heal_loop)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.animation_start(this.base_crystal, "heal_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_while_teleport()
		crystal_levitate()

		if store.tick_ts - mode_ability_ts >= this.config.teleport.cooldown then
			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.teleport_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.teleport_flags) == 0 and (not this.teleport_excluded_teplates or not table.contains(this.teleport_excluded_teplates, v.template_name)) and v.nav_path and P:nodes_to_goal(v.nav_path) >= this.config.teleport.nodes_to_goal_selectable and v.nav_path.ni >= this.config.teleport.nodes_from_selectable
			end)

			if not enemies or #enemies < this.config.min_enemies then
				mode_ability_ts = store.tick_ts - this.config.teleport.cooldown + 1 - 1e-06

				return
			end

			U.y_animation_play(this.cultist, "telegraph_in", nil, store.tick_ts)
			U.animation_start(this.cultist, "telegraph_loop", nil, store.tick_ts, true)
			U.animation_start(this.crystal, "telegraph_3", nil, store.tick_ts)

			local fx = E:create_entity(this.fx_teleport)

			fx.pos = this.cultist.pos
			fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, fx)
			U.y_wait(store, fts(20))
			S:queue(this.sound_cast_teleport)

			local enemies = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.health and not v.health.dead and v.vis and v.vis.flags and band(v.vis.flags, this.teleport_bans) == 0 and v.vis and v.vis.bans and band(v.vis.bans, this.teleport_flags) == 0 and (not this.teleport_excluded_teplates or not table.contains(this.teleport_excluded_teplates, v.template_name)) and v.nav_path and P:nodes_to_goal(v.nav_path) >= this.config.teleport.nodes_to_goal_selectable and v.nav_path.ni >= this.config.teleport.nodes_from_selectable
			end)

			if enemies and #enemies > 0 then
				local sorted_enemies = {}

				for _, e1 in ipairs(enemies) do
					local enemies_in_range = 0

					for _, e2 in ipairs(enemies) do
						if e1.id ~= e2.id and e1.pos and e2.pos then
							local distance = V.dist(e1.pos.x, e1.pos.y, e2.pos.x, e2.pos.y)

							if distance < this.config.teleport.aura_radius then
								enemies_in_range = enemies_in_range + 1
							end
						end
					end

					table.insert(sorted_enemies, {
						entity = e1,
						enemies_in_range = enemies_in_range
					})
				end

				table.sort(sorted_enemies, function(e1, e2)
					return e1.enemies_in_range > e2.enemies_in_range
				end)

				local a = E:create_entity(this.teleport_aura)
				local target = enemies[1]

				if #sorted_enemies > 0 then
					target = sorted_enemies[1].entity
				end

				a.aura.source_id = this.id

				local pos = P:node_pos(target.nav_path.pi, 1, target.nav_path.ni)

				a.pos = V.vclone(pos)

				queue_insert(store, a)
			end

			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "telegraph_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			mode_ability_ts = store.tick_ts
		end
	end

	local function do_sacrifice()
		if table.contains(golems_to_spawn, store.wave_group_number) then
			U.animation_start(this.crystal, "to_idle4", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			S:queue(this.sound_cast_golem)
			U.animation_start(this.cultist, "sacrifice_in", nil, store.tick_ts)
			U.animation_start(this.crystal, "sacrifice_in", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "sacrifice_loop", nil, store.tick_ts, true)
			U.animation_start(this.crystal, "sacrifice_loop", nil, store.tick_ts, true)
			U.y_wait(store, this.sacrifice_duration)
			U.y_animation_wait(this.cultist)
			U.animation_start(this.cultist, "sacrifice_out", nil, store.tick_ts)
			U.animation_start(this.crystal, "sacrifice_out", nil, store.tick_ts)
			U.y_animation_wait(this.cultist)
			crystal_down()

			local golem_idx = #this.config.sacrifice.waves - #golems_to_spawn + 1

			for i = 1, 3 do
				local b = E:create_entity(this.bullet_golem_spawn)
				local pos = V.v(this.bullet_spawn_pos[i].x + this.cultist.pos.x, this.bullet_spawn_pos[i].y + this.cultist.pos.y)

				b.pos = pos
				b.bullet.from = V.vclone(b.pos)

				local golem_pos = this.golem_holder_pos[golem_idx]

				b.bullet.to = V.v(golem_pos.x + this.bullet_offset.x, golem_pos.y + this.bullet_offset.y)
				b.target_golem = this.golems[golem_idx]
				b.bullet_idx = i

				queue_insert(store, b)
			end

			coroutine.yield()

			this.cultist.render.sprites[1].hidden = true

			table.remove(golems_to_spawn, 1)
		end
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	while true do
		if store.waves_finished and not LU.has_alive_enemies(store) then
			crystal_down()
			U.y_animation_play(this.cultist, "death", nil, store.tick_ts)

			break
		end

		if store.wave_group_number ~= last_wave_processed then
			if current_mode == MODE_SACRIFICE then
				comes_from_off = true
			else
				comes_from_off = false

				if current_mode == nil then
					comes_from_off = true
				end
			end

			on_mode_end()
			change_mode()
		else
			if current_mode == MODE_SACRIFICE then
				do_sacrifice()
			elseif current_mode == MODE_STUN then
				do_while_stun()
			elseif current_mode == MODE_HEAL then
				do_while_heal()
			elseif current_mode == MODE_TELEPORT then
				do_while_teleport()
			end

			if current_mode ~= nil and current_mode_duration <= store.tick_ts - current_mode_start_ts then
				on_mode_end()
				U.y_animation_play(this.cultist, "death", nil, store.tick_ts)
				U.y_wait(store, 0.8)
				crystal_down()
				U.animation_start(this.crystal, "turn_off", nil, store.tick_ts)
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_10_obelisk_iron = {}

function scripts.controller_stage_10_obelisk_iron.update(this, store)
	local MODE_STUN = 1
	local MODE_HEAL = 2
	local MODE_TELEPORT = 3
	local MODE_SACRIFICE = 4
	local comes_from_off = true
	local golems_to_spawn = table.clone(this.config.sacrifice.waves)
	local mode_ability_ts
	local current_mode_duration = 0
	local current_mode_start_ts = 0
	local last_wave_processed = 0
	local current_mode
	local next_sacrifice_id = 1
	local next_sacrifice_ts = this.config.iron_config.golem_activate_delay[next_sacrifice_id]
	local max_sacrifices = #this.config.iron_config.golem_activate_delay

	local function crystal_up()
		this.crystal.tween.props[2].keys[1][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.move_distance)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = false
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_down()
		this.crystal.tween.props[2].keys[1][2] = V.v(0, 0)
		this.crystal.tween.props[2].keys[2][2] = V.v(0, this.crystal.render.sprites[1].offset.y)
		this.crystal.tween.disabled = false
		this.crystal.tween.reverse = true
		this.crystal.tween.ts = store.tick_ts
		this.crystal.tween.props[1].disabled = true
		this.crystal.tween.props[2].disabled = false
		this.crystal.tween.props[2].ts = store.tick_ts
	end

	local function crystal_levitate()
		if this.crystal.tween.props[1].disabled then
			this.crystal.tween.disabled = false
			this.crystal.tween.reverse = false
			this.crystal.tween.ts = store.tick_ts
			this.crystal.tween.props[1].disabled = false
			this.crystal.tween.props[1].loop = true
			this.crystal.tween.props[1].ts = store.tick_ts
			this.crystal.tween.props[2].disabled = true
			this.crystal.tween.props[2].ts = store.tick_ts
		end
	end

	local function prepare_crystal()
		if comes_from_off then
			this.cultist.render.sprites[1].hidden = false

			U.animation_start(this.cultist, "back_online", nil, store.tick_ts)
			U.animation_start(this.crystal, "back_online", nil, store.tick_ts)
			S:queue(this.sound_activation)
			U.y_animation_wait(this.cultist)

			this.crystal.tween.props[1].ts = store.tick_ts
		else
			S:queue(this.sound_change_mode)
		end

		crystal_up()
		U.animation_start(this.cultist, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.crystal, "change_in", nil, store.tick_ts)
		U.y_animation_wait(this.crystal)
		U.animation_start(this.cultist, "change_loop", nil, store.tick_ts, true)
		U.animation_start(this.crystal, "change_loop", nil, store.tick_ts, true)

		local fx = E:create_entity(this.template_crystal_fx)

		fx.pos = this.cultist.pos
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)

		this.crystal_fx = fx

		U.y_wait(store, this.prepare_delay)
	end

	local function change_mode()
		prepare_crystal()

		if this.crystal_fx then
			this.crystal_fx.end_fx = true
		end

		U.animation_start(this.cultist, "change_out", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)
	end

	local function do_sacrifice()
		U.animation_start(this.crystal, "to_idle4", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		S:queue(this.sound_cast_golem)
		U.animation_start(this.cultist, "sacrifice_in", nil, store.tick_ts)
		U.animation_start(this.crystal, "sacrifice_in", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.cultist, "sacrifice_loop", nil, store.tick_ts, true)
		U.animation_start(this.crystal, "sacrifice_loop", nil, store.tick_ts, true)
		U.y_wait(store, this.sacrifice_duration)
		U.y_animation_wait(this.cultist)
		U.animation_start(this.cultist, "sacrifice_out", nil, store.tick_ts)
		U.animation_start(this.crystal, "sacrifice_out", nil, store.tick_ts)
		U.y_animation_wait(this.cultist)
		crystal_down()

		local golem_idx = next_sacrifice_id - 1

		for i = 1, 3 do
			local b = E:create_entity(this.bullet_golem_spawn)
			local pos = V.v(this.bullet_spawn_pos[i].x + this.cultist.pos.x, this.bullet_spawn_pos[i].y + this.cultist.pos.y)

			b.pos = pos
			b.bullet.from = V.vclone(b.pos)

			local golem_pos = this.golem_holder_pos[golem_idx]

			b.bullet.to = V.v(golem_pos.x + this.bullet_offset.x, golem_pos.y + this.bullet_offset.y)
			b.target_golem = this.golems[golem_idx]
			b.bullet_idx = i

			queue_insert(store, b)
		end

		coroutine.yield()

		this.cultist.render.sprites[1].hidden = true
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local start_ts = store.tick_ts

	while true do
		if store.waves_finished and not LU.has_alive_enemies(store) then
			crystal_down()
			U.y_animation_play(this.cultist, "death", nil, store.tick_ts)

			break
		end

		if max_sacrifices < next_sacrifice_id then
			break
		end

		if next_sacrifice_ts <= store.tick_ts - start_ts then
			next_sacrifice_id = next_sacrifice_id + 1

			if next_sacrifice_id <= max_sacrifices then
				next_sacrifice_ts = this.config.iron_config.golem_activate_delay[next_sacrifice_id]
			end

			change_mode()
			do_sacrifice()
		end

		coroutine.yield()
	end
end

scripts.decal_stage_10_obelisk_crystal_fx = {}

function scripts.decal_stage_10_obelisk_crystal_fx.update(this, store)
	U.y_animation_play(this, "in", nil, store.tick_ts)

	while true do
		if this.end_fx then
			break
		end

		U.animation_start(this, "loop", false, store.tick_ts, true)
		coroutine.yield()
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	U.y_animation_play(this, "out", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.bullet_stage_10_obelisk_priests = {}

function scripts.bullet_stage_10_obelisk_priests.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	::label_956_0::

	if b.store and not b.target_id then
		S:queue(this.sound_events.summon)

		s.z = Z_OBJECTS
		s.sort_y_offset = b.store_sort_y_offset

		if ps then
			ps.particle_system.emit = false
		end
	else
		S:queue(this.sound_events.travel)

		s.z = Z_BULLETS
		s.sort_y_offset = nil

		if ps then
			ps.particle_system.emit = true
		end
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		coroutine.yield()

		if not target_invalid then
			target = store.entities[b.target_id]
		end

		if target and not new_target then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
				target_invalid = true
				target = nil
			end
		end

		if target and target.health and not target.health.dead then
			if b.ignore_hit_offset then
				b.to.x, b.to.y = target.pos.x, target.pos.y
			else
				b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
			end

			new_target = false
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if not b.ignore_rotation then
			s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		end

		if ps then
			ps.particle_system.emit_direction = s.r
		end
	end

	while b.store and not b.target_id do
		coroutine.yield()

		if b.target_id then
			mspeed = b.min_speed
			new_target = true

			goto label_956_0
		end
	end

	this.pos.x, this.pos.y = b.to.x, b.to.y
	this.target_golem.wake_up = true

	if b.payload then
		local hp = b.payload

		hp.pos.x, hp.pos.y = b.to.x, b.to.y

		queue_insert(store, hp)
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].runs = 0

		if target and sfx.render.sprites[1].size_names then
			sfx.render.sprites[1].name = sfx.render.sprites[1].size_names[target.unit.size]
		end

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.bullet_stage_10_obelisk_priests_alternative = {}

function scripts.bullet_stage_10_obelisk_priests_alternative.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local ps

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 4 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	local function fly_to_pos(target_pos)
		local start_ts = store.tick_ts
		local last_pos = V.vclone(this.pos)
		local dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)

		while V.len(dx, dy) > 20 do
			last_pos.x, last_pos.y = this.pos.x, this.pos.y

			move_step(target_pos)

			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
			dist = V.len(dx, dy)

			coroutine.yield()
		end
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts
	fm.a.x, fm.a.y = 0, 80

	local target_pos = v(b.from.x - 70 + 30 * this.bullet_idx, b.from.y + 110 - 10 * this.bullet_idx)

	fly_to_pos(target_pos)

	fm.a.x, fm.a.y = 100, 0

	if this.bullet_idx == 3 then
		local target_pos = v(b.from.x + 70, b.from.y + 50)

		fly_to_pos(target_pos)
	else
		local target_pos = v(b.from.x - 70, b.from.y + 50)

		fly_to_pos(target_pos)
	end

	b.initial_impulse = nil
	fm.a_step = 10
	fm.max_a = 6000
	fm.max_v = 510
	ps.particle_system.emission_rate = 60

	fly_to_pos(b.to)

	this.pos.x, this.pos.y = b.to.x, b.to.y
	this.target_golem.wake_up = true
	this.render.sprites[1].hidden = true

	if b.hit_fx and this.bullet_idx == 1 then
		local fx = E:create_entity(b.hit_fx)

		fx.pos.x, fx.pos.y = b.to.x, b.to.y
		fx.render.sprites[1].ts = store.tick_ts
		fx.render.sprites[1].runs = 0

		queue_insert(store, fx)
	end

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	queue_remove(store, this)
end

scripts.mod_stage_10_obelisk_stun = {}

function scripts.mod_stage_10_obelisk_stun.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	local target_fly = target and band(target.vis.flags, F_FLYING) ~= 0

	if target_fly then
		this.render.sprites[1].prefix = this.prefix_flying
		this.render.sprites[1].offset.y = target.render.sprites[1].offset.y
	end

	this.pos = target.pos
	start_ts = store.tick_ts

	if m.animation_phases then
		U.animation_start(this, "start", nil, store.tick_ts)

		while not U.animation_finished(this) do
			if not target_hidden and m.hide_target_delay and store.tick_ts - start_ts > m.hide_target_delay then
				target_hidden = true

				if target.ui then
					target.ui.can_click = false
				end

				if target.health_bar then
					target.health_bar.hidden = true
				end

				U.sprites_hide(target, nil, nil, true)
				SU.hide_modifiers(store, target, true, this)
				SU.hide_auras(store, target, true)
			end

			coroutine.yield()
		end
	end

	U.animation_start(this, "loop", nil, store.tick_ts, true)

	while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
		if this.render and m.use_mod_offset and target.unit.mod_offset and not m.custom_offsets then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	if m.animation_phases then
		U.animation_start(this, "end", nil, store.tick_ts)

		if target_hidden then
			if target.ui then
				target.ui.can_click = true
			end

			if target.health_bar and not target.health.dead then
				target.health_bar.hidden = nil
			end

			U.sprites_show(target, nil, nil, true)
			SU.show_modifiers(store, target, true, this)
			SU.show_auras(store, target, true)
		end

		while not U.animation_finished(this) do
			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.mod_stage_10_obelisk_heal = {}

function scripts.mod_stage_10_obelisk_heal.update(this, store, script)
	local m = this.modifier
	local hps = this.hps
	local duration = m.duration

	if m.duration_inc then
		duration = duration + m.level * m.duration_inc
	end

	local heal_min = hps.heal_min
	local heal_max = hps.heal_max

	if hps.heal_min_inc and hps.heal_max_inc then
		heal_min = hps.heal_min + m.level * hps.heal_min_inc
		heal_max = hps.heal_max + m.level * hps.heal_max_inc
	end

	if hps.heal_inc then
		heal_min = hps.heal_min + m.level * hps.heal_inc
		heal_max = hps.heal_max + m.level * hps.heal_inc
	end

	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos
	this.render.sprites[1].prefix = this.render.sprites[1].size_prefix[target.unit.size]
	this.render.sprites[2].prefix = this.render.sprites[2].size_prefix[target.unit.size]

	local target_fly = target and band(target.vis.flags, F_FLYING) ~= 0

	if target_fly then
		this.render.sprites[1].hidden = true
		this.render.sprites[2].hidden = true
		m.use_mod_offset = true
	end

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "Idle", nil, store.tick_ts, true)

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or duration < store.tick_ts - m.ts then
			U.y_animation_play(this, "out", nil, store.tick_ts)
			queue_remove(store, this)

			return
		end

		if this.render and m.use_mod_offset and target.unit.mod_offset then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				if not s.exclude_mod_offset then
					s.offset.x, s.offset.y = -target.unit.mod_offset.x, -target.unit.mod_offset.y
				end
			end
		end

		if hps.heal_every and store.tick_ts - hps.ts >= hps.heal_every then
			hps.ts = store.tick_ts

			local hp_start = target.health.hp

			target.health.hp = target.health.hp + math.random(heal_min, heal_max)
			target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp)

			local heal_amount = target.health.hp - hp_start

			target.health.hp_healed = (target.health.hp_healed or 0) + heal_amount

			signal.emit("entity-healed", this, target, heal_amount)

			if hps.fx then
				local fx = E:create_entity(hps.fx)

				fx.pos = V.vclone(this.pos)
				fx.render.sprites[1].ts = store.tick_ts
				fx.render.sprites[1].runs = 0

				queue_insert(store, fx)
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_10_ymca = {}

function scripts.controller_stage_10_ymca.insert(this, store)
	this.statues = {}

	for i = 1, 4 do
		local statue = E:create_entity(this.entity_statue)

		statue.pos = this.statue_position[i]
		statue.letter_idx = this.start_formation[i]

		queue_insert(store, statue)
		table.insert(this.statues, statue)
	end

	local dots = E:create_entity(this.entity_dots)

	dots.pos = this.dots_pos
	dots.render.sprites[1].hidden = true

	queue_insert(store, dots)

	this.dots = dots

	return true
end

function scripts.controller_stage_10_ymca.update(this, store)
	local function create_fireworks()
		local fireworks = E:create_entity(this.entity_fireworks)

		fireworks.pos = this.dots_pos
		fireworks.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fireworks)
		S:queue("Stage10VillagePeopleFireworks")
	end

	local function create_lights()
		local lights = E:create_entity(this.entity_lights)

		lights.pos = this.dots_pos
		lights.render.sprites[1].ts = store.tick_ts

		queue_insert(store, lights)

		this.lights = lights
	end

	local puzzle_solved = false

	local function is_puzzle_solved()
		for statue_idx, s in ipairs(this.statues) do
			if s.letter_idx ~= statue_idx then
				return false
			end
		end

		return true
	end

	while true do
		if not puzzle_solved and is_puzzle_solved() then
			puzzle_solved = true

			for statue_idx, s in ipairs(this.statues) do
				s.ui.can_click = false
			end

			U.y_wait(store, 1)

			for statue_idx, s in ipairs(this.statues) do
				s.dance = true
			end

			create_fireworks()
			create_lights()

			this.dots.render.sprites[1].hidden = false

			U.y_animation_play(this.dots, "start", nil, store.tick_ts)
			S:queue("Stage10VillagePeopleSong", {
				delay = fts(12)
			})
			U.animation_start(this.dots, "idle", nil, store.tick_ts, true)

			local center = V.v(0, 0)

			for i, s in ipairs(this.entities_soldiers) do
				center.x = center.x + this.soldier_path_pos[i].x
				center.y = center.y + this.soldier_path_pos[i].y
			end

			center.x = center.x / #this.entities_soldiers
			center.y = center.y / #this.entities_soldiers

			for i, s in ipairs(this.entities_soldiers) do
				local soldier = E:create_entity(s)

				soldier.pos = this.soldier_spawn_pos[i]
				if band(soldier.vis.flags, F_HERO) == 0 then
					soldier.nav_rally.center = V.vclone(center)
					local line_pos = V.v(this.soldier_line_pos_offset[i].x + soldier.pos.x, this.soldier_line_pos_offset[i].y + soldier.pos.y)

					soldier.spawn_delay = this.soldier_spawn_delay[i]
					soldier.position_in_line = line_pos
					soldier.path_pos = this.soldier_path_pos[i]
					soldier.reinforcement.squad_id = this.id
				else
					soldier.nav_rally.center = V.vclone(soldier.pos)
					soldier.nav_rally.pos = soldier.nav_rally.center
					soldier.hero.level = 10
					for key, value in pairs(soldier.hero.skills) do
						value.level = 3
					end
				end

				queue_insert(store, soldier)
			end

			while this.statues[1].dance do
				coroutine.yield()
			end

			queue_remove(store, this.dots)
			queue_remove(store, this.lights)
			signal.emit("ymca-stage10", this)
		end

		coroutine.yield()
	end
end

scripts.aura_stage_10_obelisk_teleport = {}

function scripts.aura_stage_10_obelisk_teleport.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_967_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_967_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_967_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_967_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end

			U.y_animation_play(this, "decal_in", nil, store.tick_ts)
			U.animation_start(this, "decal_loop", nil, store.tick_ts, true)
		end

		::label_967_0::

		coroutine.yield()
	end

	U.y_animation_play(this, "decal_out", nil, store.tick_ts)
	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.decal_stage_10_ymca_statue = {}

function scripts.decal_stage_10_ymca_statue.update(this, store)
	local function get_letter(idx)
		if idx == 1 then
			return "y"
		elseif idx == 2 then
			return "m"
		elseif idx == 3 then
			return "c"
		elseif idx == 4 then
			return "a"
		end
	end

	local function create_dust_fx()
		local fx = E:create_entity(this.click_fx)

		fx.pos = this.pos
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	U.animation_start(this, get_letter(this.letter_idx), nil, store.tick_ts)

	while true do
		if features.censored_cn then
			-- block empty
		else
			if this.dance then
				U.y_animation_play(this, "dance_loop", nil, store.tick_ts, 2)
				create_dust_fx()

				this.dance = nil
			end

			if this.ui.clicked then
				this.ui.clicked = nil
				this.letter_idx = km.zmod(this.letter_idx + 1, 4)

				S:queue("Stage10VillagePeopleStatuePuff")
				create_dust_fx()
			end

			U.animation_start(this, get_letter(this.letter_idx), nil, store.tick_ts)
		end

		coroutine.yield()
	end
end

scripts.soldier_stage_10_ymca = {}

function scripts.soldier_stage_10_ymca.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts
	this.ui.can_click = false

	U.y_wait(store, this.spawn_delay)
	U.set_destination(this, this.position_in_line)

	local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

	U.animation_start(this, an, af, store.tick_ts, -1)

	while not U.walk(this, store.tick_length) do
		coroutine.yield()
	end

	U.set_destination(this, this.path_pos)

	local an, af = U.animation_name_facing_point(this, "walk", this.motion.dest)

	U.animation_start(this, an, af, store.tick_ts, -1)

	while not U.walk(this, store.tick_length) do
		coroutine.yield()
	end

	this.nav_rally.pos = this.path_pos

	U.animation_start(this, "idle", af, store.tick_ts, -1)

	if this.reinforcement.fade or this.reinforcement.fade_in then
		SU.y_reinforcement_fade_in(store, this)
	elseif this.render.sprites[1].name == "raise" then
		if this.sound_events and this.sound_events.raise then
			S:queue(this.sound_events.raise)
		end

		this.health_bar.hidden = true

		U.y_animation_play(this, "raise", nil, store.tick_ts, 1)

		if not this.health.dead then
			this.health_bar.hidden = nil
		end
	end

	this.ui.can_click = true

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			SU.remove_modifiers(store, this)
			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			while this.nav_rally.new do
				if this.nav_rally.move_order then
					U.y_wait(store, this.nav_rally.move_order * math.random() * 0.2)
				end

				if SU.y_hero_new_rally(store, this) then
					goto label_972_1
				end
			end

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_972_1
				end
			end

			if this.ranged then
				brk, star = SU.y_soldier_ranged_attacks(store, this)

				if brk or star == A_DONE then
					goto label_972_1
				elseif star == A_IN_COOLDOWN then
					goto label_972_0
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				goto label_972_1
			end

			if SU.soldier_go_back_step(store, this) then
				goto label_972_1
			end

			::label_972_0::

			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_972_1::

		coroutine.yield()
	end
end

scripts.soldier_hero_lava_double_trouble = {}

function scripts.soldier_hero_lava_double_trouble.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].ts = store.tick_ts
	this.ui.can_click = false

	U.y_animation_play(this, "spawn", af, store.tick_ts, -1)
	U.animation_start(this, "idle", af, store.tick_ts, -1)

	this.nav_rally.pos = V.vclone(this.pos)
	this.ui.can_click = true

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = 0
			end

			this.health.hp = 0
			this.render.sprites[1].z = Z_DECALS

			SU.remove_modifiers(store, this)
			SU.y_soldier_death(store, this)

			this.tween.disabled = false
			this.tween.ts = store.tick_ts

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			SU.soldier_courage_upgrade(store, this)

			while this.nav_rally.new do
				if this.nav_rally.move_order then
					U.y_wait(store, this.nav_rally.move_order * math.random() * 0.2)
				end

				if SU.y_hero_new_rally(store, this) then
					goto label_1244_1
				end
			end

			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_1244_1
				end
			end

			if this.ranged then
				brk, star = SU.y_soldier_ranged_attacks(store, this)

				if brk or star == A_DONE then
					goto label_1244_1
				elseif star == A_IN_COOLDOWN then
					goto label_1244_0
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				goto label_1244_1
			end

			if SU.soldier_go_back_step(store, this) then
				goto label_1244_1
			end

			::label_1244_0::

			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end

		::label_1244_1::

		coroutine.yield()
	end
end

scripts.controller_stage_11_cult_leader = {}

function scripts.controller_stage_11_cult_leader.insert(this, store)
	if store.level_mode == GAME_MODE_CAMPAIGN then
		local cultist = E:create_entity(this.entity_cultist)

		cultist.pos = this.cultist_pos

		queue_insert(store, cultist)

		this.cultist = cultist

		return true
	end

	return false
end

function scripts.controller_stage_11_cult_leader.update(this, store)
	local last_wave_processed = 0
	local wave_config = {}
	local last_ability_ts = store.tick_ts
	local ability_cd = this.config.ability_cooldown

	this.projections_in_bossfight = 0
	this.active_illusions = {}
	this.selected_paths = {}

	local MODE_SHIELD = 1
	local MODE_CHAIN = 2

	this.is_denas_dead = false
	this.leave = false

	if not this._ability_deck then
		this._ability_deck = SU.deck_new(this.config.deck_chain_ability, this.config.deck_total_cards)
	end

	local function get_illusion_pos(mode)
		local available_paths = {}

		if mode == MODE_SHIELD then
			local radius_check_enemies = this.spawn_check_enemies_range

			for _, available in ipairs(this.spawn_available_pos) do
				local found = false

				for _, selected in ipairs(this.selected_paths) do
					if selected.x == available.x and selected.y == available.y then
						found = true

						break
					end
				end

				if not found then
					local enemies = table.filter(store.entities, function(k, v)
						return v.enemy and v.vis and v.health and not v.health.dead and U.is_inside_ellipse(v.pos, available, radius_check_enemies)
					end)

					table.insert(available_paths, {
						pos = available,
						enemies = #enemies
					})
				end
			end

			table.sort(available_paths, function(e1, e2)
				return e1.enemies > e2.enemies
			end)
		elseif mode == MODE_CHAIN then
			local radius_check_towers = this.spawn_check_towers_range

			for _, available in ipairs(this.spawn_available_pos) do
				local found = false

				for _, selected in ipairs(this.selected_paths) do
					if selected.x == available.x and selected.y == available.y then
						found = true

						break
					end
				end

				if not found then
					local towers = table.filter(store.entities, function(k, v)
						return v.tower and not v.tower_holder and U.is_inside_ellipse(v.pos, available, radius_check_towers)
					end)

					if #towers > 0 then
						table.insert(available_paths, {
							pos = available,
							towers = #towers
						})
					end
				end
			end

			table.sort(available_paths, function(e1, e2)
				return e1.towers > e2.towers
			end)
		end

		return #available_paths > 0 and available_paths[1].pos or nil
	end

	local function do_chain_ability()
		for _, illusion in ipairs(this.active_illusions) do
			illusion.dissapear = true
		end

		this.active_illusions = {}
		this.selected_paths = {}

		for i = 1, wave_config.illusions do
			local illusion_pos = get_illusion_pos(MODE_CHAIN)

			if illusion_pos then
				local illusion = E:create_entity(this.entity_illusion)

				illusion.pos = V.vclone(illusion_pos)
				illusion.mode = MODE_CHAIN

				queue_insert(store, illusion)
				S:queue(this.sound_illusion_summon_spawn)
				table.insert(this.active_illusions, illusion)
				table.insert(this.selected_paths, illusion_pos)
				U.y_wait(store, this.illusion_delay_between)
			end
		end
	end

	local function do_shield_ability()
		for _, illusion in ipairs(this.active_illusions) do
			illusion.dissapear = true
		end

		this.active_illusions = {}
		this.selected_paths = {}

		for i = 1, wave_config.illusions do
			local illusion_pos = get_illusion_pos(MODE_SHIELD)

			if illusion_pos then
				local illusion = E:create_entity(this.entity_illusion)

				illusion.pos = V.vclone(illusion_pos)
				illusion.mode = MODE_SHIELD

				queue_insert(store, illusion)
				table.insert(this.active_illusions, illusion)
				table.insert(this.selected_paths, illusion_pos)
				U.y_wait(store, this.illusion_delay_between)
			end
		end
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local taunt_delay = math.random(this.cultist.taunts.delay_min, this.cultist.taunts.delay_max)

	this.last_taunt = store.tick_ts
	this.taunts_enabled = true

	local function break_fn()
		return this.is_denas_dead or this.cultist.veznan_hit
	end

	while true do
		::label_974_0::

		if this.is_denas_dead then
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

			while not this.leave do
				coroutine.yield()
			end

			U.animation_start(this.cultist, "leave", nil, store.tick_ts)
			U.y_wait(store, 1.4)
			S:queue("Stage11MidCinematicPlatformMove")
			S:queue("Stage11CultLeaderLeave")
			U.y_wait(store, 1.6)
			S:queue("Stage11MidCinematicPlatformMove")
			U.y_animation_wait(this.cultist)
			queue_remove(store, this)

			return
		end

		if this.cultist.veznan_hit then
			this.cultist.veznan_hit = false

			U.y_animation_play(this.cultist, "stunnedin", nil, store.tick_ts)
			U.animation_start(this.cultist, "stunnedloop", nil, store.tick_ts, true)

			local start_ts = store.tick_ts

			while true do
				if store.tick_ts - start_ts >= this.cultist_stun_time then
					break
				end

				if break_fn() then
					U.y_animation_play(this.cultist, "stunnedout", nil, store.tick_ts)
					U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

					goto label_974_0
				end

				coroutine.yield()
			end

			U.y_animation_play(this.cultist, "stunnedout", nil, store.tick_ts)
			U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)
		end

		if taunt_delay <= store.tick_ts - this.last_taunt and this.taunts_enabled then
			local taunt_set = "pre_bossfight"

			if store.waves_finished and LU.has_alive_enemies(store) then
				taunt_set = "in_bossfight"
			end

			y_show_taunt_set(store, this.cultist.taunts, taunt_set, false)

			this.last_taunt = store.tick_ts
			taunt_delay = math.random(this.cultist.taunts.delay_min, this.cultist.taunts.delay_max)
		end

		if store.wave_group_number ~= last_wave_processed and last_wave_processed < 15 then
			last_wave_processed = store.wave_group_number
			wave_config = this.config.config_per_wave[last_wave_processed]
			last_ability_ts = store.tick_ts - ability_cd + this.config.ability_first_delay
		end

		if last_wave_processed == 15 then
			local bossfight = false

			for _, v in pairs(store.entities) do
				if v.template_name == "boss_corrupted_denas" then
					bossfight = true

					break
				end
			end

			if bossfight then
				last_wave_processed = 16
				wave_config = this.config.config_per_wave[last_wave_processed]
				ability_cd = this.config.ability_cooldown_bossfight
				last_ability_ts = store.tick_ts
			end
		end

		if ability_cd <= store.tick_ts - last_ability_ts then
			local is_in_cinematic = not this.taunts_enabled

			if LU.has_alive_enemies(store, {
				"enemy_stage_11_cult_leader_illusion"
			}) and not is_in_cinematic then
				if SU.deck_draw(this._ability_deck) then
					local illusion_pos = get_illusion_pos(MODE_CHAIN)

					if illusion_pos then
						S:queue(this.sound_illusion_summon_cast)
						U.y_animation_play(this.cultist, "attack", nil, store.tick_ts)
						U.animation_start(this.cultist, "attackloop", nil, store.tick_ts, true)

						if last_wave_processed == 16 then
							this.projections_in_bossfight = this.projections_in_bossfight + 1
						end

						do_chain_ability()

						if U.y_wait(store, this.cultist_attack_time, break_fn) then
							U.y_animation_play(this.cultist, "attackleave", false, store.tick_ts)
							U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

							goto label_974_0
						end

						U.y_animation_play(this.cultist, "attackleave", false, store.tick_ts)
					end
				else
					S:queue(this.sound_illusion_summon_cast)
					U.y_animation_play(this.cultist, "attack", nil, store.tick_ts)
					U.animation_start(this.cultist, "attackloop", nil, store.tick_ts, true)

					if last_wave_processed == 16 then
						this.projections_in_bossfight = this.projections_in_bossfight + 1
					end

					do_shield_ability()

					if U.y_wait(store, this.cultist_attack_time, break_fn) then
						U.y_animation_play(this.cultist, "attackleave", false, store.tick_ts)
						U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

						goto label_974_0
					end

					U.y_animation_play(this.cultist, "attackleave", false, store.tick_ts)
				end

				U.y_animation_wait(this.cultist)
				U.animation_start(this.cultist, "idle", nil, store.tick_ts, true)

				last_ability_ts = store.tick_ts
			end
		end

		coroutine.yield()
	end
end

scripts.enemy_stage_11_cult_leader_illusion = {}

function scripts.enemy_stage_11_cult_leader_illusion.update(this, store)
	local MODE_SHIELD = 1
	local MODE_CHAIN = 2
	local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, false)
	local pi, spi, ni = unpack(nodes[1])

	this.nav_path.pi = pi
	this.nav_path.spi = spi
	this.nav_path.ni = ni

	local attack_chain = this.timed_attacks.list[1]
	local attack_shield = this.timed_attacks.list[2]
	local spawn_ts, ttl

	if this.mode == MODE_CHAIN then
		ttl = this.chain_illusion_ttl
	else
		ttl = this.shield_illusion_ttl
	end

	local function find_holders_in_range()
		local attack = attack_chain
		local holders = table.filter(store.entities, function(k, v)
			return v.tower and v.tower.type == "holder" and U.is_inside_ellipse(v.pos, this.pos, attack_chain.max_range) and (attack.min_range == 0 or not U.is_inside_ellipse(v.pos, this.pos, attack.min_range))
		end)

		return holders
	end

	local function find_towers_in_range()
		local attack = attack_chain
		local towers = table.filter(store.entities, function(k, v)
			return not v.pending_removal and v.tower and not v.tower.blocked and (not attack.excluded_templates or not table.contains(attack.excluded_templates, v.template_name)) and U.is_inside_ellipse(v.pos, this.pos, attack_chain.max_range) and (attack.min_range == 0 or not U.is_inside_ellipse(v.pos, this.pos, attack.min_range)) and v.tower.can_be_mod
		end)

		return towers
	end

	local function do_while_chain()
		if not this.enemy.can_do_magic then
			return
		end
		
		local start_ts = store.tick_ts

		while store.tick_ts - start_ts <= fts(12) do
			if this.veznan_hit then
				return
			end

			coroutine.yield()
		end

		local towers = find_towers_in_range()
		local holders

		if towers then
			for i = 1, #towers do
				local tower = towers[i]
				local mod = E:create_entity(attack_chain.mod)

				mod.modifier.target_id = tower.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)
				U.y_wait(store, fts(2))
			end
		end

		if holders then
			for i = 1, #holders do
				local holder = holders[i]
				local mod = E:create_entity(attack_chain.mod)

				mod.modifier.target_id = holder.id
				mod.modifier.source_id = this.id
				mod.render.sprites[1].scale = V.v(0.85, 0.85)
				mod.render.sprites[2].scale = V.v(0.85, 0.85)

				queue_insert(store, mod)
				U.y_wait(store, fts(2))
			end
		end

		U.y_animation_wait(this)
		U.animation_start(this, attack_chain.animation_loop, nil, store.tick_ts, true)

		start_ts = store.tick_ts

		while store.tick_ts - start_ts <= this.chain_every do
			if this.veznan_hit or store.tick_ts - spawn_ts > ttl then
				return
			end

			coroutine.yield()
		end
	end

	local function break_fn()
		local nodes_to_goal = P:nodes_to_goal(this.nav_path)

		if nodes_to_goal <= this.nodes_limit then
			return true
		end

		if this.dissapear or this.veznan_hit or store.tick_ts - spawn_ts > ttl then
			return true
		end

		return false
	end

	local function do_while_shield()
		if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, break_fn, break_fn, break_fn) then
			this.dissapear = true
		end
	end

	this.vis._bans = this.vis.bans
	this.vis.bans = F_ALL

	local fx = E:create_entity(this.fx_spawn)

	fx.pos = V.vclone(this.pos)
	fx.tween.ts = store.tick_ts

	queue_insert(store, fx)

	this.render.sprites[1].hidden = true

	U.y_wait(store, this.spawn_charge_time, function()
		return this.veznan_hit
	end)

	if this.veznan_hit then
		-- block empty
	else
		S:queue(this.sound_spawn)

		this.vis.bans = this.vis._bans
		this.render.sprites[1].hidden = false

		U.y_animation_play(this, "spawn", nil, store.tick_ts)

		spawn_ts = store.tick_ts

		if this.mode == MODE_CHAIN then
			U.animation_start(this, attack_chain.animation_start, nil, store.tick_ts)
			S:queue(this.sound_tentacles_spawn)
		elseif this.mode == MODE_SHIELD then
			local aura = E:create_entity(attack_shield.aura)

			aura.pos = this.pos
			aura.aura.ts = store.tick_ts
			aura.aura.source_id = this.id

			queue_insert(store, aura)
			S:queue(this.sound_shield)
		end

		while true do
			if this.dissapear and not this.unit.is_stunned or this.health.dead or this.veznan_hit or ttl < store.tick_ts - spawn_ts then
				break
			end

			if this.unit.is_stunned then
				-- block empty
			elseif this.mode == MODE_SHIELD then
				do_while_shield()
			elseif this.mode == MODE_CHAIN then
				do_while_chain()
			end

			coroutine.yield()
		end
	end

	this.health.dead = true

	if this.mode == MODE_CHAIN then
		S:queue(this.sound_tentacles_death)
		U.y_animation_play(this, attack_chain.animation_end, nil, store.tick_ts)
	end

	SU.y_enemy_death(store, this)
	queue_remove(store, this)
end

scripts.bullet_stage_11_cult_leader_illusion = {}

function scripts.bullet_stage_11_cult_leader_illusion.insert(this, store, script)
	local b = this.bullet

	b.speed.x, b.speed.y = V.normalize(b.to.x - b.from.x, b.to.y - b.from.y)

	return true
end

function scripts.bullet_stage_11_cult_leader_illusion.update(this, store, script)
	local b = this.bullet
	local mspeed = b.min_speed
	local target, ps

	U.animation_start(this, "start", nil, store.tick_ts)

	local start_animation = true

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	if b.target_id then
		S:queue(this.sound_events.travel)
	else
		S:queue(this.sound_events.summon)
	end

	while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
		if start_animation and this.render.sprites[1].runs > 0 then
			U.animation_start(this, "run", nil, store.tick_ts, true)

			start_animation = false
		end

		if b.target_id then
			target = store.entities[b.target_id]
		end

		if target then
			local ho = target.unit.hit_offset

			if U.flag_has(target.vis.bans, F_RANGED) or target.health.dead then
				b.target_id = nil
				target = nil
			elseif b.max_track_distance then
				local d = math.max(math.abs(target.pos.x + ho.x - b.to.x), math.abs(target.pos.y + ho.y - b.to.y))

				if d > b.max_track_distance then
					b.target_id = nil
					target = nil
				end
			else
				b.to.x, b.to.y = target.pos.x + ho.x, target.pos.y + ho.y
			end
		end

		mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
		mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
		b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
		this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
		else
			this.render.sprites[1].flip_x = b.to.x < this.pos.x
		end

		if ps then
			ps.particle_system.emit_direction = this.render.sprites[1].r
		end

		coroutine.yield()
	end

	if target and not target.health.dead then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)

		if b.mod then
			local mod = E:create_entity(b.mod)

			mod.modifier.target_id = target.id

			queue_insert(store, mod)
		end

		if b.hit_payload then
			local hp

			if type(b.hit_payload) == "string" then
				hp = E:create_entity(b.hit_payload)
			else
				hp = b.hit_payload
			end

			hp.pos.x, hp.pos.y = this.pos.x, this.pos.y

			queue_insert(store, hp)
		end
	end

	local sfx, sfx_ignore_offset

	if b.hit_fx_air and target and U.flag_has(target.vis.flags, F_FLYING) then
		sfx = b.hit_fx_air
		sfx_ignore_offset = b.hit_fx_ignore_offset_air
	elseif b.hit_fx then
		sfx = b.hit_fx
		sfx_ignore_offset = b.hit_fx_ignore_offset
	end

	if sfx then
		local sfx = E:create_entity(sfx)

		if sfx_ignore_offset and target then
			sfx.pos.x, sfx.pos.y = target.pos.x, target.pos.y
		else
			sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		end

		sfx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.mod_enemy_stage_11_cult_leader_illusion_chain = {}

function scripts.mod_enemy_stage_11_cult_leader_illusion_chain.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	local function block_holder()
		local t = target.tower

		t.block_count = t.block_count + 1

		if t.block_count > 0 then
			t.blocked = true

			if target.ui then
				target.ui.can_click = false
			end
		end
	end

	local function unblock_holder()
		local t = target.tower

		t.block_count = 0

		if t.block_count < 1 then
			t.blocked = nil
			t.block_count = 0

			if target.ui then
				target.ui.can_click = true
			end
		end
	end

	if target.tower and not target.tower_holder then
		SU.tower_block_inc(target)
	else
		block_holder()
	end

	this.pos = target.pos

	if not this.tween.disabled then
		this.tween.ts = store.tick_ts
	end

	U.animation_start(this, "spawn", nil, store.tick_ts, false, 1)
	U.animation_start(this, "spawn", nil, store.tick_ts, false, 2)
	U.y_wait(store, fts(8))
	U.animation_start(this, "run", nil, store.tick_ts, true, 1)
	U.animation_start(this, "run", nil, store.tick_ts, true, 2)

	local start_ts = store.tick_ts

	while true do
		if store.tick_ts - start_ts >= m.duration - fts(40) then
			break
		end

		if source.health.dead or source.unit.is_stunned then
			break
		end

		if not store.entities[m.source_id] then
			break
		end

		coroutine.yield()
	end

	U.animation_start(this, "dissipate", nil, store.tick_ts, false, 1)
	U.animation_start(this, "dissipate", nil, store.tick_ts, false, 2)
	U.y_wait(store, fts(15))

	if target.tower and not target.tower_holder then
		SU.tower_block_dec(target)
	else
		unblock_holder()
	end

	queue_remove(store, this)
end

scripts.aura_enemy_stage_11_cult_leader_illusion_shield = {}

function scripts.aura_enemy_stage_11_cult_leader_illusion_shield.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	U.y_animation_play(this, "spawn", nil, store.tick_ts)
	U.animation_start(this, "loop", false, store.tick_ts, true)

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.actual_duration then
			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_997_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_997_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_997_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_997_0
			end
		end

		if this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.unit and te.unit.is_stunned then
				goto label_997_0
			end
		end

		if not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod

					if target.template_name == "boss_corrupted_denas" then
						new_mod = E:create_entity(this.aura.mod_denas)
					else
						new_mod = E:create_entity(mod_name)
					end

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.aura.source_id

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end
			end
		end

		::label_997_0::

		coroutine.yield()
	end

	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.mod_enemy_stage_11_cult_leader_illusion_shield = {}

function scripts.mod_enemy_stage_11_cult_leader_illusion_shield.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or target.enemy and not target.enemy.can_accept_magic then
		return false
	end

	if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	SU.armor_inc(target, 1)
	SU.magic_armor_inc(target, 1)

	this.last_immune_to = target.health.immune_to
	target.health.immune_to = U.flag_set(target.health.immune_to, bor(DAMAGE_PHYSICAL, DAMAGE_EXPLOSION))

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_enemy_stage_11_cult_leader_illusion_shield.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		target.health.immune_to = this.last_immune_to

		SU.armor_dec(target, 1)
		SU.magic_armor_dec(target, 1)
	end

	return true
end

function scripts.mod_enemy_stage_11_cult_leader_illusion_shield.update(this, store, script)
	local m = this.modifier

	this.modifier.ts = store.tick_ts

	local target = store.entities[m.target_id]

	if not target or not target.pos then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	if target.unit.size == UNIT_SIZE_MEDIUM then
		this.render.sprites[1].scale = v(1.5, 1.5)
	elseif target.unit.size == UNIT_SIZE_LARGE and target.template_name ~= "boss_corrupted_denas" then
		this.render.sprites[1].scale = v(2, 2)
	end

	U.y_animation_play(this, "in", nil, store.tick_ts)
	U.animation_start(this, "loop", false, store.tick_ts, true)

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or m.duration >= 0 and store.tick_ts - m.ts > m.duration or m.last_node and target.nav_path.ni > m.last_node then
			break
		end

		local source = store.entities[m.source_id]

		if not source or not source.unit or source.unit.is_stunned then
			break
		end

		if this.render and target.unit then
			local s = this.render.sprites[1]
			local flip_sign = 1

			if target.render then
				flip_sign = target.render.sprites[1].flip_x and -1 or 1
			end

			if m.health_bar_offset and target.health_bar then
				local hb = target.health_bar.offset
				local hbo = m.health_bar_offset

				s.offset.x, s.offset.y = hb.x + hbo.x * flip_sign, hb.y + hbo.y
			elseif m.use_mod_offset and target.unit.mod_offset then
				s.offset.x, s.offset.y = target.unit.mod_offset.x * flip_sign, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	U.y_animation_play(this, "out", nil, store.tick_ts)
	queue_remove(store, this)
end

scripts.controller_stage_11_portal = {}

function scripts.controller_stage_11_portal.insert(this, store)
	local portal = E:create_entity(this.entity_portal)

	portal.pos = V.vclone(this.portal_pos)

	queue_insert(store, portal)

	this.portal = portal

	local aura = E:create_entity(this.entity_aura)

	aura.pos = V.vclone(this.aura_pos)

	queue_insert(store, aura)

	this.aura = aura

	local torches = E:create_entity(this.entity_torches)

	torches.pos = V.vclone(this.torches_pos)

	queue_insert(store, torches)

	this.torches = torches
	this.crystals = {}

	for i = 1, this.crystals_count do
		local crystal = E:create_entity(this.entity_crystals_prefix .. i)

		crystal.pos = V.vclone(this.crystals_pos)
		crystal.tween.ts = store.tick_ts + fts(math.random(0, 120))

		local tween_frecueny = math.random(crystal.tween_frecueny_min, crystal.tween_frecueny_max)

		crystal.tween.props[1].keys = {
			{
				fts(0),
				v(0, 0)
			},
			{
				fts(tween_frecueny),
				v(0, crystal.tween_amplitude)
			},
			{
				fts(tween_frecueny * 2),
				v(0, 0)
			}
		}

		queue_insert(store, crystal)

		this.crystals[i] = crystal
	end

	return true
end

function scripts.controller_stage_11_portal.update(this, store)
	local last_wave_processed = 0
	local is_on = false
	local thunder_cd = math.random(this.sound_thunder_cd_min, this.sound_thunder_cd_max)
	local thunder_ts = store.tick_ts - thunder_cd

	local function update_lightnings()
		for _, lightning in ipairs(this.lightnings) do
			if store.tick_ts - lightning.ts > lightning.cd then
				lightning.entity.render.sprites[1].hidden = false

				U.animation_start(lightning.entity, "run", nil, store.tick_ts, false)

				lightning.cd = math.random(1, 3)
				lightning.ts = store.tick_ts
			end

			if not lightning.entity.render.sprites[1].hidden and U.animation_finished(lightning.entity) then
				lightning.entity.render.sprites[1].hidden = true
			end
		end

		if this.reset_thunder_cd then
			thunder_ts = store.tick_ts
			this.reset_thunder_cd = false
		end

		if (store.wave_group_number == 0 or this.in_cinematic) and store.tick_ts - thunder_ts > thunder_cd then
			S:queue(this.sound_thunder)

			thunder_cd = math.random(this.sound_thunder_cd_min, this.sound_thunder_cd_max)
			thunder_ts = store.tick_ts
		end
	end

	this.rocks = {}

	local rocks_count = 0

	this.lightnings = {}

	local lightning_templates = {
		"decal_stage_11_lightnings_1",
		"decal_stage_11_lightnings_2",
		"decal_stage_11_lightnings_3"
	}

	for _, e in pairs(store.entities) do
		if string.find(e.template_name, "decal_stage_11_rock") then
			rocks_count = rocks_count + 1
			this.rocks[rocks_count] = e
			e.tween.ts = store.tick_ts + fts(math.random(0, 120))
			e.tween.props[1].keys = {
				{
					fts(0),
					v(0, 0)
				},
				{
					fts(e.tween_frecueny),
					v(0, e.tween_amplitude)
				},
				{
					fts(e.tween_frecueny * 2),
					v(0, 0)
				}
			}
		end

		if table.contains(lightning_templates, e.template_name) then
			table.insert(this.lightnings, {
				entity = e,
				cd = math.random(1, 3),
				ts = store.tick_ts
			})
		end
	end

	while store.wave_group_number == 0 do
		update_lightnings()
		coroutine.yield()
	end

	while true do
		local enemies_from_portal = false

		if store.level_mode == GAME_MODE_CAMPAIGN then
			enemies_from_portal = table.contains(this.config.waves_campaign, store.wave_group_number)
		elseif store.level_mode == GAME_MODE_HEROIC then
			enemies_from_portal = table.contains(this.config.waves_heroic, store.wave_group_number)
		elseif store.level_mode == GAME_MODE_IRON then
			enemies_from_portal = table.contains(this.config.waves_iron, store.wave_group_number)
		end

		if not is_on and enemies_from_portal then
			S:queue(this.sound_portal_open)

			for i = 1, this.crystals_count do
				U.animation_start(this.crystals[i], "on", nil, store.tick_ts, false)
			end

			U.y_animation_play(this.portal, "on", nil, store.tick_ts)
			U.animation_start(this.portal, "loop", nil, store.tick_ts, true)

			for i = 1, this.crystals_count do
				U.animation_start(this.crystals[i], "idle_on", nil, store.tick_ts, true)
			end

			is_on = true
		end

		if is_on and not enemies_from_portal then
			S:queue(this.sound_portal_close)

			for i = 1, this.crystals_count do
				U.animation_start(this.crystals[i], "off", nil, store.tick_ts, false)
			end

			U.y_animation_play(this.portal, "off", nil, store.tick_ts)
			U.animation_start(this.portal, "idle", nil, store.tick_ts, true)

			for i = 1, this.crystals_count do
				U.animation_start(this.crystals[i], "idle_off", nil, store.tick_ts, true)
			end

			is_on = false
		end

		update_lightnings()
		coroutine.yield()
	end
end

scripts.mod_stage_11_portal = {}

function scripts.mod_stage_11_portal.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return false
	end

	if band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	S:queue("Stage11CreepPortalIn")

	local fx = E:create_entity(this.fx)

	fx.pos = V.vclone(target.pos)
	fx.pos.x, fx.pos.y = fx.pos.x + target.unit.hit_offset.x, fx.pos.y + target.unit.hit_offset.y
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	return true
end

scripts.decal_stage_11_veznan = {}

function scripts.decal_stage_11_veznan.can_select_point(this, x, y)
	return P:valid_node_nearby(x, y)
end

function scripts.decal_stage_11_veznan.update(this, store)
	local SKILL_1 = 1
	local SKILL_2 = 2
	local SKILL_3 = 3
	local last_skill_ts = store.tick_ts
	local last_hint_ts = store.tick_ts

	this.render.sprites[1].hidden = true

	local fx = E:create_entity(this.spawn_fx)

	fx.pos = v(113, 377)

	queue_insert(store, fx)

	local fx_base = E:create_entity(this.spawn_fx_base)

	fx_base.pos = v(113, 377)

	queue_insert(store, fx_base)
	U.animation_start(fx_base, "start", false, store.tick_ts)
	U.y_animation_play(fx, "start", false, store.tick_ts)
	U.animation_start(fx_base, "loop", false, store.tick_ts, true)
	U.animation_start(fx, "loop", false, store.tick_ts, true)
	U.y_wait(store, this.spawn_delay)
	U.animation_start(fx, "end", false, store.tick_ts)
	U.animation_start(fx_base, "end", false, store.tick_ts)

	local shake = E:create_entity("aura_screen_shake")

	shake.aura.amplitude = 0.3
	shake.aura.duration = 0.5
	shake.aura.freq_factor = 2

	queue_insert(store, shake)
	U.y_wait(store, fts(13))

	this.render.sprites[1].hidden = false

	U.animation_start(this, "spawn", false, store.tick_ts)
	U.y_animation_wait(fx)
	queue_remove(store, fx)
	queue_remove(store, fx_base)
	U.y_animation_wait(this)

	local cult_leader = table.filter(store.entities, function(k, v)
		return v.template_name == this.cult_leader_template_name
	end)[1]
	local corrupted_denas

	local function find_boss_corrupted_denas()
		return table.filter(store.entities, function(k, v)
			return v.template_name == this.boss_corrupted_denas_template_name
		end)[1]
	end

	local function confirm_skill_1()
		local attack = this.attacks.list[1]

		U.animation_start(this, "skill1", false, store.tick_ts)
		S:queue(this.sound_soul_impact_cast)
		U.y_wait(store, fts(6))

		local illusions = table.filter(store.entities, function(k, v)
			return v.health and not v.health.dead and v.template_name == this.illusion_template_name
		end)
		local bullet_amount = #illusions + 1
		local bullet_formation = this.bullet_formation[bullet_amount]

		for i, illusion in ipairs(illusions) do
			local b = E:create_entity(attack.bullet)
			local pos = V.v(bullet_formation[i].x + this.pos.x, bullet_formation[i].y + this.pos.y)

			b.pos = pos
			b.bullet.from = V.vclone(b.pos)
			b.bullet.to = V.v(this.pos.x + bullet_formation[i].x, this.pos.y + 400)
			b.target_down = illusion.pos
			b.target_id = illusion.id

			queue_insert(store, b)
			U.y_wait(store, fts(3))
		end

		local b = E:create_entity(attack.bullet)
		local pos = V.v(bullet_formation[#illusions + 1].x + this.pos.x, bullet_formation[#illusions + 1].y + this.pos.y)

		b.pos = pos
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.v(this.pos.x + bullet_formation[#illusions + 1].x, this.pos.y + 400)
		b.target_down = cult_leader.pos
		b.target_id = cult_leader.id

		queue_insert(store, b)
		U.y_animation_wait(this)
		U.animation_start(this, "charging", false, store.tick_ts, true)
	end

	local function confirm_skill_2()
		local attack = this.attacks.list[2]

		U.animation_start(this, "Skill2_loop", false, store.tick_ts, true)
		U.y_wait(store, attack.preparation_time)

		for i = 1, 2 do
			local decal = E:create_entity(attack.decal)

			decal.pos = attack.decal_pos[i]

			queue_insert(store, decal)
		end

		U.y_wait(store, attack.spawn_time)
		S:queue(this.sound_demon_guard_cast)

		for i = 1, 2 do
			local soldier = E:create_entity(attack.entity)

			soldier.pos = V.vclone(attack.decal_pos[i])
			soldier.available_paths = attack.available_paths[i]
			soldier.path_spi = 2

			queue_insert(store, soldier)

			soldier = E:create_entity(attack.entity)
			soldier.pos = V.vclone({
				x = attack.decal_pos[i].x - 10,
				y = attack.decal_pos[i].y - 10
			})
			soldier.available_paths = attack.available_paths[i]
			soldier.path_spi = 3

			queue_insert(store, soldier)
		end

		U.y_animation_wait(this)
		U.y_animation_play(this, "Skill2_out", nil, store.tick_ts)
		U.animation_start(this, "charging", false, store.tick_ts, true)
	end

	local function confirm_skill_cage()
		if not corrupted_denas then
			corrupted_denas = find_boss_corrupted_denas()
		end

		if corrupted_denas then
			local attack = this.attacks.list[3]
			local decal_fx = E:create_entity("decal_stage_11_veznan_skill_cage")

			decal_fx.pos = this.pos
			decal_fx.render.sprites[1].ts = store.tick_ts

			queue_insert(store, decal_fx)
			U.animation_start(decal_fx, "loop", false, store.tick_ts, true)
			U.animation_start(this, "skill3_loop", false, store.tick_ts, true)
			U.y_wait(store, attack.preparation_time)

			local modifier = E:create_entity(attack.mod)

			modifier.modifier.target_id = corrupted_denas.id

			queue_insert(store, modifier)
			U.y_animation_wait(this)
			U.animation_start(this, "skill3_out", false, store.tick_ts)
			U.y_animation_play(decal_fx, "out", nil, store.tick_ts)
			U.y_animation_wait(this)
			U.animation_start(this, "charging", false, store.tick_ts, true)
		end
	end

	U.y_animation_play(this, "talking_in", nil, store.tick_ts)
	U.animation_start(this, "talking_loop", false, store.tick_ts, true)
	U.y_wait(store, fts(90))
	U.y_animation_play(this, "talking_out", nil, store.tick_ts)
	U.animation_start(this, "charging", false, store.tick_ts, true)

	while true do
		if not this.user_selection.allowed and store.tick_ts - last_skill_ts >= this.skill_cooldown then
			this.user_selection.allowed = true

			S:queue(this.sound_ready)
			U.y_animation_play(this, "READY_in", nil, store.tick_ts)
			U.animation_start(this, "READY_loop", false, store.tick_ts, true)
		end

		if this.user_selection.allowed and store.tick_ts - last_hint_ts >= this.hint_cooldown then
			this.hint = E:create_entity(this.hint_template_name)
			this.hint.pos = this.pos
			this.hint.tween.ts = store.tick_ts

			queue_insert(store, this.hint)

			last_hint_ts = store.tick_ts
		end

		if this.user_selection.menu_shown and this.hint then
			this.hint.render.sprites[1].hidden = true

			queue_remove(store, this.hint)

			this.hint = nil
		end

		if this.user_selection.in_progress then
			this.user_selection.in_progress = nil
			this.user_selection.allowed = false

			local start_ts = store.tick_ts

			if this.user_selection.arg == SKILL_1 then
				confirm_skill_1()
			elseif this.user_selection.arg == SKILL_2 then
				confirm_skill_2()
			elseif this.user_selection.arg == SKILL_3 then
				confirm_skill_cage()
			end

			last_skill_ts = start_ts
			last_hint_ts = start_ts
		end

		coroutine.yield()
	end
end

scripts.bullet_stage_11_veznan_skill_1 = {}

function scripts.bullet_stage_11_veznan_skill_1.update(this, store, script)
	local b = this.bullet
	local s = this.render.sprites[1]
	local mspeed = b.min_speed
	local target, ps
	local new_target = false
	local target_invalid = false

	U.y_animation_play(this, "spawn", nil, store.tick_ts)

	local function fly_to_pos()
		::label_1016_0::

		if b.store and not b.target_id then
			S:queue(this.sound_events.summon)

			s.z = Z_OBJECTS
			s.sort_y_offset = b.store_sort_y_offset

			U.animation_start(this, "idle", nil, store.tick_ts, true)

			if ps then
				ps.particle_system.emit = false
			end
		else
			S:queue(this.sound_events.travel)

			s.z = Z_BULLETS
			s.sort_y_offset = nil

			U.animation_start(this, "idle", nil, store.tick_ts, true)

			if ps then
				ps.particle_system.emit = true
			end
		end

		while V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) > mspeed * store.tick_length do
			coroutine.yield()

			if not target_invalid then
				target = store.entities[b.target_id]
			end

			if target and not new_target then
				local tpx, tpy = target.pos.x, target.pos.y

				if not b.ignore_hit_offset then
					tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
				end

				local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

				if d > b.max_track_distance or band(target.vis.bans, F_RANGED) ~= 0 then
					target_invalid = true
					target = nil
				end
			end

			if target and target.health and not target.health.dead then
				if b.ignore_hit_offset then
					b.to.x, b.to.y = target.pos.x, target.pos.y
				else
					b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
				end

				new_target = false
			end

			mspeed = mspeed + FPS * math.ceil(mspeed * (1 / FPS) * b.acceleration_factor)
			mspeed = km.clamp(b.min_speed, b.max_speed, mspeed)
			b.speed.x, b.speed.y = V.mul(mspeed, V.normalize(b.to.x - this.pos.x, b.to.y - this.pos.y))
			this.pos.x, this.pos.y = this.pos.x + b.speed.x * store.tick_length, this.pos.y + b.speed.y * store.tick_length

			if not b.ignore_rotation then
				s.r = V.angleTo(b.to.x - this.pos.x, b.to.y - this.pos.y)
			end

			if ps then
				ps.particle_system.emit_direction = s.r
			end
		end

		while b.store and not b.target_id do
			coroutine.yield()

			if b.target_id then
				mspeed = b.min_speed
				new_target = true

				goto label_1016_0
			end
		end
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	fly_to_pos(b.to)

	this.pos.x = this.target_down.x
	this.pos.y = this.target_down.y + 400
	b.to = this.target_down

	fly_to_pos(b.to)

	this.pos.x, this.pos.y = b.to.x, b.to.y

	local target = store.entities[this.target_id]

	if target and table.contains({
		"decal_stage_11_cult_leader",
		"enemy_stage_11_cult_leader_illusion"
	}, target.template_name) then
		target.veznan_hit = true
	end

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos.x, sfx.pos.y = b.to.x, b.to.y
		sfx.render.sprites[2].ts = store.tick_ts
		sfx.render.sprites[3].ts = store.tick_ts
		sfx.tween.ts = store.tick_ts
		sfx.tween.props[1].ts = store.tick_ts

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.soldier_stage_11_veznan_skill_soldiers = {}

function scripts.soldier_stage_11_veznan_skill_soldiers.update(this, store, script)
	local brk, stam

	this.render.sprites[1].hidden = true

	local fx = E:create_entity(this.spawn_fx)

	fx.pos = this.pos
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)
	U.y_wait(store, this.spawn_delay)

	local fx = E:create_entity(this.spawn_fx_top)

	fx.pos = this.pos
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	this.render.sprites[1].hidden = false
	this.render.sprites[1].ts = store.tick_ts

	U.animation_start(this, "idle", nil, store.tick_ts, true)
	U.y_wait(store, this.idle_time)

	this.reinforcement.ts = store.tick_ts
	this.nav_rally.center = nil
	this.nav_rally.pos = V.vclone(this.pos)

	if this.sound_events and this.sound_events.raise then
		S:queue(this.sound_events.raise)
	end

	local path_ni = 1
	local path_spi = 1
	local path_pi = 1
	local node_pos
	local paths_with_enemies = {}

	for _, path in ipairs(this.available_paths) do
		local enemies = table.filter(store.entities, function(k, v)
			return v.health and not v.health.dead and v.enemy and v.nav_path and v.nav_path.pi == path
		end)

		table.insert(paths_with_enemies, {
			path = path,
			enemies = #enemies
		})
	end

	table.sort(paths_with_enemies, function(e1, e2)
		return e1.enemies > e2.enemies
	end)

	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, paths_with_enemies[1])

	if #nearest > 0 then
		path_pi, path_spi, path_ni = unpack(nearest[1])
	end

	path_spi = this.path_spi
	path_ni = path_ni - 3

	local distance = 0

	while true do
		if this.health.dead then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			U.animation_start(this, "death", nil, store.tick_ts, false)
			U.y_wait(store, fts(20))
			U.y_animation_wait(this)
			queue_remove(store, this)

			return
		end

		if path_ni < -20 then
			SU.y_soldier_death(store, this)

			return
		end

		local nodes_from_start = P:nodes_from_start(path_pi, path_spi, path_ni)

		if nodes_from_start < this.nodes_from_start then
			SU.y_soldier_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			if this.melee then
				brk, stam = SU.y_soldier_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					goto label_1017_0
				end
			end

			node_pos = this.nav_rally.pos
			distance = V.dist2(node_pos.x, node_pos.y, this.pos.x, this.pos.y)

			if distance < 25 then
				path_ni = path_ni - 3
				this.nav_rally.pos = P:node_pos(path_pi, path_spi, path_ni)
			end

			if SU.soldier_go_back_step(store, this) then
				-- block empty
			else
				SU.soldier_regen(store, this)
			end
		end

		::label_1017_0::

		coroutine.yield()
	end
end

scripts.boss_corrupted_denas = {}

function scripts.boss_corrupted_denas.update(this, store, script)
	local path_pi, path_spi, path_ni
	local spawn_entities_attack = this.timed_attacks.list[1]
	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
		4
	}, {
		1
	})

	if #nearest > 0 then
		path_pi, path_spi, path_ni = unpack(nearest[1])
	end

	this.nav_path.pi = path_pi
	this.nav_path.spi = path_spi
	this.nav_path.ni = path_ni

	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_boss

	for _, value in pairs(spawners) do
		if value.load_file == "level11_spawner" then
			megaspawner_boss = value
		end
	end

	local current_life_threshold_stun_index = 1
	local next_life_threshold_stun = this.life_threshold_stun.life_percentage[1]
	local cult_leader = table.filter(store.entities, function(k, v)
		return v.template_name == this.cult_leader_template_name
	end)[1]

	local function check_life_threshold_stun()
		if next_life_threshold_stun and this.health.hp * 100 / this.health.hp_max <= next_life_threshold_stun then
			return true
		end

		return false
	end

	local function break_fn()
		if store.tick_ts - spawn_entities_attack.ts >= spawn_entities_attack.cooldown then
			return true
		end

		if this.cage_applied then
			return true
		end

		return check_life_threshold_stun()
	end

	local function y_on_death()
		-- LU.kill_all_enemies(store, true)
		S:stop_all()

		-- megaspawner_boss.interrupt = true

		S:queue(this.sound_transform_in)
		U.y_animation_play(this, "stunin", nil, store.tick_ts)
		U.animation_start(this, "stunloop", nil, store.tick_ts, true)
		-- LU.kill_all_enemies(store, true)
		signal.emit("boss-killed", this)
	end

	this.vis._flags = this.vis.flags
	this.vis._bans = this.vis.bans
	this.vis.flags = bor(F_ENEMY, F_BOSS)
	this.vis.bans = bor(F_RANGED, F_BLOCK)
	this.render.sprites[1].flip_x = true

	U.y_animation_play(this, "spawn", nil, store.tick_ts)

	local start_ts = store.tick_ts

	while store.tick_ts - start_ts < 10 do
		U.y_animation_play(this, "cagein", nil, store.tick_ts)
		U.y_animation_play(this, "cageloop", nil, store.tick_ts)
		U.y_animation_play(this, "cageout", nil, store.tick_ts)
		U.y_wait(store, 3.5)
	end

	spawn_entities_attack.ts = store.tick_ts

	signal.emit("boss_fight_start", this)

	megaspawner_boss.manual_wave = "BOSS"
	this.vis.flags = this.vis._flags
	this.vis.bans = this.vis._bans

	::label_1020_0::

	while true do
		if this.health.dead then
			y_on_death()

			return
		end

		if this.unit.is_stunned and not this.cage_applied then
			SU.y_enemy_stun(store, this)
		else
			if this.cage_applied then
				this.cage_applied = nil

				U.y_animation_play(this, "cagein", nil, store.tick_ts)
				U.animation_start(this, "cageloop", nil, store.tick_ts, true)

				while true do
					if this.unit.stun_count <= 0 then
						break
					end

					coroutine.yield()
				end

				U.y_animation_play(this, "cageout", nil, store.tick_ts)
			end

			if check_life_threshold_stun() then
				S:queue(this.sound_transform_in)
				U.y_animation_play(this, "stunin", nil, store.tick_ts)

				cult_leader.denas = this

				U.animation_start(this, "stunloop", nil, store.tick_ts, true)

				local stun_ts = store.tick_ts

				while store.tick_ts - stun_ts < this.life_threshold_stun.stun_duration do
					if this.health.dead then
						y_on_death()

						return
					end

					coroutine.yield()
				end

				S:queue(this.sound_transform_out)
				U.y_animation_play(this, "stunout", nil, store.tick_ts)

				current_life_threshold_stun_index = current_life_threshold_stun_index + 1
				next_life_threshold_stun = (not (current_life_threshold_stun_index > #this.life_threshold_stun.life_percentage) or nil) and this.life_threshold_stun.life_percentage[current_life_threshold_stun_index]
				spawn_entities_attack.ts = store.tick_ts
			end

			if store.tick_ts - spawn_entities_attack.ts >= spawn_entities_attack.cooldown then
				local start_ts = store.tick_ts

				this.available_nodes = {}

				local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, spawn_entities_attack.min_range, spawn_entities_attack.max_range, nil, nil, nil, {
					1,
					2,
					3
				})

				nodes = table.random_order(nodes)

				for j = 1, #nodes do
					local is_far = true

					for k = 1, #this.available_nodes do
						local distance = V.dist(nodes[j].x, nodes[j].y, this.available_nodes[k].x, this.available_nodes[k].y)

						if distance < spawn_entities_attack.distance_between_entities then
							is_far = false

							break
						end
					end

					if is_far then
						table.insert(this.available_nodes, nodes[j])

						if #this.available_nodes >= spawn_entities_attack.entities_amount then
							break
						end
					end
				end

				U.animation_start(this, spawn_entities_attack.animation, nil, store.tick_ts)
				U.y_wait(store, fts(28))

				for i = 1, #this.available_nodes do
					local b = E:create_entity(spawn_entities_attack.bullet)
					local bullet_start_offset = spawn_entities_attack.bullet_start_offset

					b.pos.x, b.pos.y = this.pos.x + bullet_start_offset.x, this.pos.y + bullet_start_offset.y
					b.bullet.from = V.vclone(b.pos)
					b.bullet.to = this.available_nodes[i]
					b.bullet.source_id = this.id

					queue_insert(store, b)
					U.y_wait(store, spawn_entities_attack.delay_between)
				end

				U.y_animation_wait(this)
				U.y_wait(store, spawn_entities_attack.idle_time)

				spawn_entities_attack.ts = start_ts
			end

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, nil, break_fn)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_1020_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_1020_0
						end

						coroutine.yield()
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_1020_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.bullet_boss_corrupted_denas_spawn_entities = {}

function scripts.bullet_boss_corrupted_denas_spawn_entities.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius
	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
		else
			hp = b.hit_payload
		end

		hp.pos.x, hp.pos.y = b.to.x, b.to.y
		hp.spawn_from_bullet = true

		if hp.aura then
			hp.aura.level = this.bullet.level
		end

		if this.path_to_spawn then
			hp.path_to_spawn = this.path_to_spawn
		end

		queue_insert(store, hp)
		signal.emit("wave-notification", "icon", "enemy_glareling")
	end

	queue_remove(store, this)
end

scripts.enemy_glareling = {}

function scripts.enemy_glareling.update(this, store, script)
	if this.spawn_from_bullet then
		this.render.sprites[1].flip_x = true

		U.y_animation_play(this, "spawn", nil, store.tick_ts)

		local nearest

		if this.path_to_spawn then
			nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
				this.path_to_spawn
			}, {
				1,
				2,
				3
			})
		else
			nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
				4
			}, {
				1,
				2,
				3
			})
		end

		local path_pi, path_spi, path_ni

		if #nearest > 0 then
			path_pi, path_spi, path_ni = unpack(nearest[1])
		end

		this.nav_path.pi = path_pi
		this.nav_path.spi = path_spi
		this.nav_path.ni = path_ni
	end

	if this.render.sprites[1].name == "egg_spawn" then
		U.y_animation_wait(this)
	end

	local function check_sacrifice()
		if not this.amalgam_sacrifice then
			return false
		end

		local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

		return nodes_to_end < 2
	end

	while true do
		if this.health.dead then
			SU.y_enemy_death(store, this)

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if this.amalgam_sacrifice then
				local nodes_to_end = P:get_end_node(this.nav_path.pi) - this.nav_path.ni

				if nodes_to_end <= 2 then
					this.health_bar.alpha = 0
					this.trigger_deselect = true

					S:queue(this.sound_events.sacrifice)
					U.y_animation_play(this, "jump", nil, store.tick_ts)

					if this.amalgam_controller and not this.health.dead then
						this.amalgam_controller.sacrifices = this.amalgam_controller.sacrifices + 1
					end

					queue_remove(store, this)

					return
				end
			end

			if not SU.y_enemy_mixed_walk_melee_ranged(store, this, false, check_sacrifice) then
				-- block empty
			else
				coroutine.yield()
			end
		end
	end
end

scripts.decal_stage_11_boss_corrupted_denas_hit = {}

function scripts.decal_stage_11_boss_corrupted_denas_hit.update(this, store, script)
	this.available_nodes = {}

	local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, 0, this.decal_spawn_range, nil, nil, nil, {
		1,
		2,
		3
	})

	table.insert(this.available_nodes, nodes[1])

	nodes = table.random_order(nodes)

	for j = 1, #nodes do
		local is_far = true

		for k = 1, #this.available_nodes do
			local distance = V.dist(nodes[j].x, nodes[j].y, this.available_nodes[k].x, this.available_nodes[k].y)

			if distance < this.distance_between then
				is_far = false

				break
			end
		end

		if is_far then
			table.insert(this.available_nodes, nodes[j])

			if #this.available_nodes >= this.decal_amount then
				break
			end
		end
	end

	local spikes = {}

	for i = 1, this.decal_amount do
		if i <= #this.available_nodes then
			local spike = E:create_entity(this.spike_decals[math.random(1, #this.spike_decals)])

			spike.pos = this.available_nodes[i]
			spike.render.sprites[1].ts = store.tick_ts

			queue_insert(store, spike)
			table.insert(spikes, spike)

			local d = E:create_entity(this.floor_decal)

			d.pos = this.available_nodes[i]
			d.tween.ts = store.tick_ts

			local opacity = math.random(130, 255)

			d.tween.props[1].keys[1][2] = opacity
			d.tween.props[1].keys[2][2] = opacity

			queue_insert(store, d)
		end
	end

	U.y_wait(store, 2)

	for i = 1, #spikes do
		queue_remove(store, spikes[i])
	end

	queue_remove(store, this)
end

scripts.mod_stage_11_veznan_skill_cage = {}

function scripts.mod_stage_11_veznan_skill_cage.update(this, store, script)
	local start_ts, target_hidden
	local m = this.modifier
	local target = store.entities[this.modifier.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.pos = target.pos

	SU.stun_inc(target)

	target.cage_applied = true

	S:queue(this.sound_cast)

	start_ts = store.tick_ts

	if m.animation_phases then
		U.animation_start(this, "in", nil, store.tick_ts)

		while not U.animation_finished(this) do
			if not target_hidden and m.hide_target_delay and store.tick_ts - start_ts > m.hide_target_delay then
				target_hidden = true

				if target.ui then
					target.ui.can_click = false
				end

				if target.health_bar then
					target.health_bar.hidden = true
				end

				U.sprites_hide(target, nil, nil, true)
				SU.hide_modifiers(store, target, true, this)
				SU.hide_auras(store, target, true)
			end

			coroutine.yield()
		end
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while store.tick_ts - m.ts < m.duration and target and not target.health.dead do
		if this.render and m.use_mod_offset and target.unit.mod_offset and not m.custom_offsets then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
			end
		end

		coroutine.yield()
	end

	S:queue(this.sound_end)

	if m.animation_phases then
		U.animation_start(this, "out", nil, store.tick_ts)

		if target_hidden then
			if target.ui then
				target.ui.can_click = true
			end

			if target.health_bar and not target.health.dead then
				target.health_bar.hidden = nil
			end

			U.sprites_show(target, nil, nil, true)
			SU.show_modifiers(store, target, true, this)
			SU.show_auras(store, target, true)
		end

		while not U.animation_finished(this) do
			coroutine.yield()
		end
	end

	SU.stun_dec(target)
	queue_remove(store, this)
end

scripts.controller_stage_11_cultist_leader_modes = {}

function scripts.controller_stage_11_cultist_leader_modes.update(this, store)
	local action_cd = math.random(15, 20)
	local last_action_ts = store.tick_ts

	for _, e in pairs(store.entities) do
		if e.template_name == this.entity_tables then
			this.tables = e
		end

		if e.template_name == this.entity_worker then
			this.worker = e
		end
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	while true do
		if action_cd < store.tick_ts - last_action_ts then
			if math.random(1, 3) <= 2 then
				U.y_animation_play(this.tables, "action", false, store.tick_ts)
				U.animation_start(this.tables, "idle", false, store.tick_ts, true)
			else
				U.y_animation_play(this.tables, "action2", false, store.tick_ts)
				U.animation_start(this.tables, "idle", false, store.tick_ts, true)
				U.y_animation_play(this.worker, "action", false, store.tick_ts)
				U.animation_start(this.worker, "idle", false, store.tick_ts, true)
			end

			action_cd = math.random(15, 20)
			last_action_ts = store.tick_ts
		end

		coroutine.yield()
	end
end

scripts.decal_stage_11_sam_and_frodo = {}

function scripts.decal_stage_11_sam_and_frodo.update(this, store)
	this.render.sprites[1].hidden = true
	this.ui.can_click = false

	while store.wave_group_number < 2 do
		coroutine.yield()
	end

	U.y_wait(store, 20)

	this.render.sprites[1].hidden = false

	U.y_animation_play(this, "in", false, store.tick_ts)

	this.ui.can_click = true

	local last_push = store.tick_ts
	local already_done_action = false

	while true do
		if not already_done_action then
			if this.ui.clicked then
				this.ui.clicked = nil
				this.ui.can_click = false

				S:queue("Stage11EasterEggFrodoAndSam", {
					delay = fts(90)
				})
				U.y_animation_play(this, "action", nil, store.tick_ts)

				already_done_action = true

				signal.emit("lotr-stage11", this)

				break
			end

			if store.tick_ts - last_push >= this.push_up_cooldown then
				U.y_animation_play(this, "idle2", nil, store.tick_ts)

				last_push = store.tick_ts
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.controller_terrain_3_floating_elements = {}

function scripts.controller_terrain_3_floating_elements.update(this, store)
	this.floating_elems = {}

	local floating_elems_count = 0

	for _, e in pairs(store.entities) do
		if string.find(e.template_name, "decal_terrain_3_floating") then
			floating_elems_count = floating_elems_count + 1
			this.floating_elems[floating_elems_count] = e
			e.tween.ts = store.tick_ts + fts(math.random(0, 120))

			local frec = e.tween_frecueny + math.random(-50, 50)
			local amp = e.tween_amplitude + math.random(-5, 5)

			e.tween.props[1].keys = {
				{
					fts(0),
					v(0, 0)
				},
				{
					fts(frec),
					v(0, amp)
				},
				{
					fts(frec * 2),
					v(0, 0)
				}
			}
		end
	end
end

scripts.controller_terrain_3_local_glare = {}

function scripts.controller_terrain_3_local_glare.insert(this, store)
	this.eyes = {}

	for _, v in pairs(this.eyes_t) do
		local eye = E:create_entity(v)

		eye.ts = store.tick_ts
		eye.pos = this.pos
		eye.controller_ref = this

		queue_insert(store, eye)
		U.animation_start(eye, "idle_close", nil, store.tick_ts, true, this.sid_eyelids)
		table.insert(this.eyes, eye)
	end

	return true
end

function scripts.controller_terrain_3_local_glare.update(this, store)
	local ptr = 1

	while true do
		local hold_start_ts
		local wave_start_ts = store.tick_ts
		local wave_number = store.wave_group_number

		local function fn_new_wave(store, time)
			return store.wave_group_number ~= wave_number
		end

		while this.waves[ptr] and this.waves[ptr][1] == wave_number and wave_number == store.wave_group_number do
			local d_wave, d_delay, d_duration = unpack(this.waves[ptr])
			local delay = d_delay - (store.tick_ts - wave_start_ts)
			local aura, decal
			local start_ts = store.tick_ts

			for i = 1, #this.eyes do
				while store.tick_ts - start_ts < delay - 2 * (#this.eyes - i) do
					if fn_new_wave(store, _) then
						goto label_1034_0
					end

					coroutine.yield()
				end

				if i == 1 then
					U.animation_start(this.eyes[1], "loop", nil, store.tick_ts, true, this.sid_eyelids)
				end

				if i == 1 or i == 2 then
					S:queue(this.sound_small_eye_1)
				elseif i == 3 then
					S:queue(this.sound_small_eye_2)
				elseif i == 4 then
					S:queue(this.sound_big_eye)
				end

				U.y_animation_play(this.eyes[#this.eyes + 1 - i], "open", nil, store.tick_ts, 1, this.sid_eyelids)
				U.animation_start(this.eyes[#this.eyes + 1 - i], "idle_open", nil, store.tick_ts, true, this.sid_eyelids)
			end

			this.glare_active = true
			aura = E:create_entity(this.aura_glare)
			aura.aura.ts = store.tick_ts
			aura.pos = V.vclone(this.pos)
			aura.render.sprites[1].scale.x = aura.aura.radius / 137
			aura.render.sprites[1].scale.y = ASPECT * aura.aura.radius / 137
			aura.render.sprites[1].hidden = true

			queue_insert(store, aura)

			decal = E:create_entity(this.decal_ground)
			decal.pos = V.vclone(this.pos)

			queue_insert(store, decal)
			U.y_animation_play(decal, "in", nil, store.tick_ts)
			U.animation_start(decal, "idle", nil, store.tick_ts, true)

			start_ts = store.tick_ts

			while d_duration > store.tick_ts - start_ts do
				if fn_new_wave(store, _) then
					break
				end

				if store.tick_ts - start_ts > d_duration - 1 and not this.eyes[1].dont_blink then
					for _, eye in pairs(this.eyes) do
						eye.dont_blink = true
					end
				end

				coroutine.yield()
			end

			S:queue(this.sound_off)

			for i = 1, #this.eyes do
				U.y_wait(store, fts(math.random(0, 5)))
				U.y_animation_play(this.eyes[#this.eyes + 1 - i], "close", nil, store.tick_ts, 1, this.sid_eyelids)
				U.animation_start(this.eyes[#this.eyes + 1 - i], "idle_close", nil, store.tick_ts, true, this.sid_eyelids)

				this.eyes[#this.eyes + 1 - i].dont_blink = false
			end

			this.glare_active = false

			queue_remove(store, aura)
			U.y_animation_play(decal, "out", nil, store.tick_ts)
			queue_remove(store, decal)

			::label_1034_0::

			ptr = ptr + 1
		end

		while wave_number == store.wave_group_number do
			if this.force_finish then
				goto label_1034_1
			end

			coroutine.yield()
		end
	end

	store.level.glare_controller = nil

	::label_1034_1::

	for i = 1, #this.eyes do
		queue_remove(store, this.eyes[i])
	end
end

scripts.decal_terrain_3_glare_eye = {}

function scripts.decal_terrain_3_glare_eye.update(this, store)
	local blink_ts = -1
	local blink_cd_min = 35
	local blink_cd_max = 60

	if this.is_big_eye then
		blink_cd_min = 25
		blink_cd_max = 50
	end

	local blink_cd = math.random(blink_cd_min, blink_cd_max) / 10
	local look_ts = -1
	local look_cd = math.random(10, 40) / 10

	if this.sid_pupil then
		U.animation_start(this, "look", nil, store.tick_ts, false, this.sid_pupil)
	else
		U.animation_start(this, "look", nil, store.tick_ts, false, this.sid_eye)
	end

	while true do
		if not this.controller_ref.glare_active or this.dont_blink then
			blink_ts = -1
		else
			if blink_ts < 0 then
				blink_cd = math.random(blink_cd_min, blink_cd_max) / 10
				blink_ts = store.tick_ts
			end

			if this.render.sprites[this.sid_eyelids].name == "idle_open" and blink_cd < store.tick_ts - blink_ts then
				local double_blink = math.random(1, 5) == 1 and this.is_big_eye

				U.y_animation_play(this, "blink", nil, store.tick_ts, 1, this.sid_eyelids)
				U.animation_start(this, "idle_open", nil, store.tick_ts, true, this.sid_eyelids)

				if double_blink then
					U.y_animation_play(this, "blink", nil, store.tick_ts, 1, this.sid_eyelids)
					U.animation_start(this, "idle_open", nil, store.tick_ts, true, this.sid_eyelids)
				end

				blink_ts = store.tick_ts
				blink_cd = math.random(blink_cd_min, blink_cd_max) / 10
			end
		end

		if U.animation_finished(this, this.sid_pupil) then
			if look_ts < 0 then
				look_ts = store.tick_ts
				look_cd = math.random(10, 40) / 10
			end

			if look_cd < store.tick_ts - look_ts then
				if this.sid_pupil then
					U.animation_start(this, "look", nil, store.tick_ts, false, this.sid_pupil)
				else
					U.animation_start(this, "look", nil, store.tick_ts, false, this.sid_eye)
				end

				look_ts = -1
			end
		end

		coroutine.yield()
	end
end

scripts.mod_glare = {}

function scripts.mod_glare.insert(this, store)
	local m = this.modifier
	local t = store.entities[m.target_id]

	if not t or t.health.dead or not t.glare_kr5 then
		return false
	end

	if band(this.modifier.vis_flags, t.vis.bans) ~= 0 or band(this.modifier.vis_bans, t.vis.flags) ~= 0 then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, t.id, t.template_name)

		return false
	end

	if t and t.unit and this.render then
		for i = 1, #this.render.sprites do
			local s = this.render.sprites[i]

			s.ts = store.tick_ts

			if s.size_names then
				s.name = s.size_names[t.unit.size]
			end
		end
	end

	t.glare_kr5.active = true
	this.hps.heal_min = t.glare_kr5.regen_hp
	this.hps.heal_max = t.glare_kr5.regen_hp
	this.hps.ts = store.tick_ts - this.hps.heal_every
	this.modifier.ts = store.tick_ts

	if t._glare_mod_removed_externally_ts and store.tick_ts - t._glare_mod_removed_externally_ts < 5 then
		return true
	end

	t._glare_mod_removed_externally_ts = nil

	if t.glare_kr5.speed_factor and t.motion then
		t.motion.max_speed = t.motion.max_speed * t.glare_kr5.speed_factor
	end

	if t.glare_kr5.damage_factor and t.melee then
		t.unit.damage_factor = t.unit.damage_factor * t.glare_kr5.damage_factor
	end

	if t.glare_kr5.on_start_glare then
		t.glare_kr5.on_start_glare(t, store)
	end

	signal.emit("mod-applied", this, t)

	return true
end

function scripts.mod_glare.update(this, store, script)
	local m = this.modifier
	local hps = this.hps
	local duration = m.duration
	local heal_min = hps.heal_min
	local heal_max = hps.heal_max
	local target = store.entities[m.target_id]

	if not target then
		queue_remove(store, this)

		return
	end

	this.tween.disabled = false
	this.pos = target.pos

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead or duration < store.tick_ts - m.ts then
			this.ended_glare = true
			this.tween.reverse = false
			this.tween.remove = true
			this.tween.ts = store.tick_ts

			return
		end

		if this.render and m.use_mod_offset and target.unit.mod_offset then
			for i = 1, #this.render.sprites do
				local s = this.render.sprites[i]

				if not s.exclude_mod_offset then
					s.offset.x, s.offset.y = target.unit.mod_offset.x, target.unit.mod_offset.y
				end
			end
		end

		if hps.heal_every and store.tick_ts - hps.ts >= hps.heal_every then
			hps.ts = store.tick_ts

			local hp_start = target.health.hp

			target.health.hp = target.health.hp + math.random(heal_min, heal_max)
			target.health.hp = km.clamp(0, target.health.hp_max, target.health.hp)

			local heal_amount = target.health.hp - hp_start

			target.health.hp_healed = (target.health.hp_healed or 0) + heal_amount

			signal.emit("entity-healed", this, target, heal_amount)
		end

		coroutine.yield()
	end
end

function scripts.mod_glare.remove(this, store)
	local m = this.modifier
	local t = store.entities[m.target_id]

	if not t or not t.health or t.health.dead then
		return true
	end

	if not this.ended_glare then
		t._glare_mod_removed_externally_ts = store.tick_ts

		return true
	end

	t.glare_kr5.active = nil

	if t.glare_kr5.speed_factor and t.motion then
		t.motion.max_speed = t.motion.max_speed / t.glare_kr5.speed_factor
	end

	if t.glare_kr5.damage_factor and t.melee then
		t.unit.damage_factor = t.unit.damage_factor / t.glare_kr5.damage_factor
	end

	if t.glare_kr5.on_end_glare then
		t.glare_kr5.on_end_glare(t, store)
	end

	return true
end

scripts.controller_terrain_3_stage_15_glare = {}

function scripts.controller_terrain_3_stage_15_glare.update(this, store)
	local waves_glare = table.filter(store.entities, function(k, v)
		return v.template_name == "controller_terrain_3_local_glare"
	end)[1]

	while not this.phase do
		coroutine.yield()
	end

	waves_glare.force_finish = true
	this.eyes = {}

	for _, v in pairs(this.eyes_t) do
		local eye = E:create_entity(v)

		eye.ts = store.tick_ts
		eye.pos = this.pos
		eye.controller_ref = this

		queue_insert(store, eye)
		U.animation_start(eye, "idle_close", nil, store.tick_ts, true, this.sid_eyelids)
		table.insert(this.eyes, eye)
	end

	local hold_start_ts
	local last_phase = 0

	while true do
		if this.phase == last_phase or #this.phases < this.phase then
			-- block empty
		elseif not this.phases[this.phase] then
			-- block empty
		elseif this.phases[this.phase][1] < 0 then
			-- block empty
		else
			last_phase = this.phase

			local phase_start_ts = store.tick_ts
			local d_delay, d_duration = unpack(this.phases[this.phase])
			local delay = d_delay - (store.tick_ts - phase_start_ts)
			local aura, decal
			local start_ts = store.tick_ts

			for i = 1, #this.eyes do
				while store.tick_ts - start_ts < delay - 2 * (#this.eyes - i) do
					if last_phase ~= this.phase then
						goto label_1040_0
					end

					coroutine.yield()
				end

				if i == 1 then
					U.animation_start(this.eyes[1], "loop", nil, store.tick_ts, true, this.sid_eyelids)
				end

				if i == 1 or i == 2 then
					S:queue(this.sound_small_eye_1)
				elseif i == 3 then
					S:queue(this.sound_small_eye_2)
				elseif i == 4 then
					S:queue(this.sound_big_eye)
				end

				U.y_animation_play(this.eyes[#this.eyes + 1 - i], "open", nil, store.tick_ts, 1, this.sid_eyelids)
				U.animation_start(this.eyes[#this.eyes + 1 - i], "idle_open", nil, store.tick_ts, true, this.sid_eyelids)
			end

			this.glare_active = true
			aura = E:create_entity(this.aura_glare)
			aura.aura.ts = store.tick_ts
			aura.pos = V.vclone(this.pos)
			aura.render.sprites[1].scale.x = aura.aura.radius / 137
			aura.render.sprites[1].scale.y = ASPECT * aura.aura.radius / 137
			aura.render.sprites[1].hidden = true

			queue_insert(store, aura)

			decal = E:create_entity(this.decal_ground)
			decal.pos = V.vclone(this.pos)

			queue_insert(store, decal)
			U.y_animation_play(decal, "in", nil, store.tick_ts)
			U.animation_start(decal, "idle", nil, store.tick_ts, true)

			start_ts = store.tick_ts

			while d_duration > store.tick_ts - start_ts do
				if last_phase ~= this.phase then
					break
				end

				if store.tick_ts - start_ts > d_duration - 1 and not this.eyes[1].dont_blink then
					for _, eye in pairs(this.eyes) do
						eye.dont_blink = true
					end
				end

				coroutine.yield()
			end

			::label_1040_0::

			S:queue(this.sound_off)

			for i = 1, #this.eyes do
				U.y_wait(store, fts(math.random(0, 5)))
				U.y_animation_play(this.eyes[#this.eyes + 1 - i], "close", nil, store.tick_ts, 1, this.sid_eyelids)
				U.animation_start(this.eyes[#this.eyes + 1 - i], "idle_close", nil, store.tick_ts, true, this.sid_eyelids)

				this.eyes[#this.eyes + 1 - i].dont_blink = false
			end

			this.glare_active = false

			queue_remove(store, aura)
			U.y_animation_play(decal, "out", nil, store.tick_ts)
			queue_remove(store, decal)
		end

		coroutine.yield()
	end
end

scripts.controller_terrain_3_stage_16_glare = {}

function scripts.controller_terrain_3_stage_16_glare.update(this, store)
	local overseer = table.filter(store.entities, function(k, v)
		return v.template_name == "controller_stage_16_overseer"
	end)[1]
	local hold_start_ts
	local last_phase = 0

	while true do
		if overseer.phase == last_phase or #this.phase_config < overseer.phase then
			-- block empty
		elseif not this.phase_config[overseer.phase] then
			-- block empty
		elseif this.phase_config[overseer.phase][1] < 0 then
			-- block empty
		else
			last_phase = overseer.phase

			local phase_start_ts = store.tick_ts
			local d_delay, d_duration = unpack(this.phase_config[overseer.phase])
			local delay = d_delay - (store.tick_ts - phase_start_ts)
			local aura, decal
			local start_ts = store.tick_ts

			for i = 1, #this.eyes do
				while store.tick_ts - start_ts < delay - 2 * (#this.eyes - i) do
					if last_phase ~= overseer.phase then
						goto label_1042_0
					end

					coroutine.yield()
				end

				if i == 1 then
					U.animation_start(this.eyes[1], "loop", nil, store.tick_ts, true, this.sid_eyelids)
				end

				if i == 1 or i == 2 then
					S:queue(this.sound_small_eye_1)
				elseif i == 3 then
					S:queue(this.sound_small_eye_2)
				elseif i == 4 then
					S:queue(this.sound_big_eye)
				end

				U.y_animation_play(this.eyes[#this.eyes + 1 - i], "open", nil, store.tick_ts, 1, this.sid_eyelids)
				U.animation_start(this.eyes[#this.eyes + 1 - i], "idle_open", nil, store.tick_ts, true, this.sid_eyelids)
			end

			this.glare_active = true
			aura = E:create_entity(this.aura_glare)
			aura.aura.ts = store.tick_ts
			aura.pos = V.vclone(this.pos)
			aura.render.sprites[1].scale.x = aura.aura.radius / 137
			aura.render.sprites[1].scale.y = ASPECT * aura.aura.radius / 137
			aura.render.sprites[1].hidden = true

			queue_insert(store, aura)

			decal = E:create_entity(this.decal_ground)
			decal.pos = V.vclone(this.pos)

			queue_insert(store, decal)
			U.y_animation_play(decal, "in", nil, store.tick_ts)
			U.animation_start(decal, "idle", nil, store.tick_ts, true)

			start_ts = store.tick_ts

			while d_duration > store.tick_ts - start_ts do
				if last_phase ~= overseer.phase then
					break
				end

				if store.tick_ts - start_ts > d_duration - 1 and not this.eyes[1].dont_blink then
					for _, eye in pairs(this.eyes) do
						eye.dont_blink = true
					end
				end

				coroutine.yield()
			end

			::label_1042_0::

			S:queue(this.sound_off)

			for i = 1, #this.eyes do
				U.y_wait(store, fts(math.random(0, 5)))
				U.y_animation_play(this.eyes[#this.eyes + 1 - i], "close", nil, store.tick_ts, 1, this.sid_eyelids)
				U.animation_start(this.eyes[#this.eyes + 1 - i], "idle_close", nil, store.tick_ts, true, this.sid_eyelids)

				this.eyes[#this.eyes + 1 - i].dont_blink = false
			end

			this.glare_active = false

			queue_remove(store, aura)
			U.y_animation_play(decal, "out", nil, store.tick_ts)
			queue_remove(store, decal)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_12_windmill = {}

function scripts.decal_stage_12_windmill.update(this, store)
	local start_ts = store.tick_ts
	local pause_ts
	local s = this.render.sprites[1]
	local start_tween_ts = store.tick_ts

	this.tween.ts = start_tween_ts

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil

			if pause_ts then
				start_ts = store.tick_ts - (pause_ts - start_ts)
				pause_ts = nil
			else
				pause_ts = store.tick_ts
			end
		end

		if pause_ts then
			s.ts = store.tick_ts - (pause_ts - start_ts)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_12_easter_egg_strangerthings = {}

function scripts.decal_stage_12_easter_egg_strangerthings.update(this, store)
	local phase = 0

	while store.wave_group_number == 0 do
		this.render.sprites[1].ts = store.tick_ts

		coroutine.yield()
	end

	U.y_animation_play(this, "in", false, store.tick_ts)

	this.ui.clicked = nil

	while true do
		if phase == 0 then
			if this.ui.clicked then
				this.ui.clicked = nil

				S:queue("Stage12WeirderThingsEnterChar")
				S:queue("Stage12WeirderThingsFirstStrum")
				U.y_animation_play(this, "action_1", nil, store.tick_ts, 1)
				U.animation_start(this, "idle", false, store.tick_ts, true)

				phase = 1
			end
		elseif phase == 1 and this.ui.clicked then
			this.ui.clicked = nil

			S:queue("Stage12WeirderThingsEnterCharTap2")
			U.y_animation_play(this, "action_2", nil, store.tick_ts, 1)
			signal.emit("stranger_things-stage12", this)

			phase = 2
		end

		coroutine.yield()
	end
end

scripts.decal_stage_12_sheepy_easteregg = {}

function scripts.decal_stage_12_sheepy_easteregg.update(this, store)
	local already_tapped = false

	while true do
		if not already_tapped and this.ui.clicked then
			this.ui.clicked = nil
			already_tapped = true

			U.animation_start(this, "action", nil, store.tick_ts, false)
			U.y_wait(store, 2.1)
			S:queue("Stage12SheepyPart1")
			U.y_wait(store, 1.9)
			S:queue("Stage12SheepyPart2")
			U.y_wait(store, 1)
			S:queue("Stage12SheepyPart3")
			U.y_animation_wait(this)
			signal.emit("sheepy_tap_achievement", 2)
		end

		coroutine.yield()
	end
end

scripts.tower_stage_13_sunray = {}

function scripts.tower_stage_13_sunray.can_select_point(this, x, y)
	return P:valid_node_nearby(x, y)
end

function scripts.tower_stage_13_sunray.update(this, store)
	local ab, as = this.attacks.list[1], this.attacks.list[2]
	local min_attacks_before_special = this.min_attacks_before_special
	local max_attacks_before_special = this.max_attacks_before_special
	local attacks_before_special
	local attacks_count = 0
	local last_ts = store.tick_ts - ab.cooldown
	local times_repaired = 0
	local repair_costs = this.repair_cost_config

	this.total_enemies_killed = 0

	if store.level_mode == GAME_MODE_IRON then
		repair_costs = this.repair_cost_config_iron
		min_attacks_before_special = this.min_attacks_before_special_iron
		max_attacks_before_special = this.max_attacks_before_special_iron
	end

	this.repair.cost = repair_costs[1]

	U.animation_start(this, "idleinactive", false, store.tick_ts, true, 1)

	local function activate()
		this.repair.active = true
		times_repaired = times_repaired + 1

		if times_repaired < #repair_costs then
			this.repair.cost = repair_costs[times_repaired + 1]
		else
			this.repair.cost = repair_costs[#repair_costs]
		end

		S:queue(this.repair.sound)
		U.y_animation_play(this, "activate", false, store.tick_ts, nil, 1)
		U.animation_start(this, "idle", false, store.tick_ts, true, 1)

		ab.ts = store.tick_ts - ab.cooldown + this.attacks.attack_delay_on_spawn
		attacks_before_special = math.random(min_attacks_before_special, max_attacks_before_special)
		attacks_count = 0
	end

	local function find_target(aa)
		local target, _, pred_pos = U.find_foremost_enemy(store.entities, tpos(this), 0, this.attacks.range, aa.node_prediction, aa.vis_flags, aa.vis_bans)

		return target, pred_pos
	end

	while true do
		while this.tower.blocked do
			coroutine.yield()
		end
		if not this.repair.active then
			-- block empty
		elseif store.tick_ts - ab.ts < ab.cooldown then
			-- block empty
		elseif attacks_before_special <= attacks_count then
			local enemy, pred_pos = find_target(as)

			if not enemy then
				-- block empty
			else
				local enemy_id = enemy.id
				local enemy_pos, pi, spi, ni
				if enemy.nav_path then
					enemy_pos = P:node_pos(enemy.nav_path.pi, enemy.nav_path.spi, enemy.nav_path.ni)
					pi, spi, ni = enemy.nav_path.pi, enemy.nav_path.spi, enemy.nav_path.ni
				else
					enemy_pos = V.vclone(enemy.pos)
					local available_paths = {}
					for k, v in pairs(P.paths) do
						table.insert(available_paths, k)
					end
					if store.level.ignore_walk_backwards_paths then
						available_paths = table.filter(available_paths, function(k, v)
							return not table.contains(store.level.ignore_walk_backwards_paths, v)
						end)
					end
					local nearest = P:nearest_nodes(enemy_pos.x, enemy_pos.y, available_paths, nil, true)
					pi, spi, ni = unpack(nearest[1])
				end

				S:queue(as.sound)

				local soffset = this.shooter_offset

				U.animation_start(this, as.animation_in, nil, store.tick_ts, nil, 1)
				U.y_wait(store, fts(29))

				local b = E:create_entity(as.bullet)
				local start_offset = as.bullet_start_offset

				enemy, pred_pos = find_target(as)

				if enemy then
					enemy_id = enemy.id
					enemy_pos = enemy.pos
				end

				local target_pos = V.vclone(enemy_pos)
				local aura = E:create_entity(as.aura)

				aura.ts = store.tick_ts
				aura.pos = target_pos
				aura.aura.source_id = this.id

				queue_insert(store, aura)

				this.total_enemies_killed = 0
				as.ts = store.tick_ts
				b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
				b.bullet.from = V.vclone(b.pos)
				b.bullet.to = target_pos
				b.bullet.source_id = this.id
				b.tower_ref = this
				b.target_pos = target_pos

				queue_insert(store, b)

				spi = 1
				local steps = 3
				local c_step = 0
				local show_decal = 2

				while store.tick_ts - as.ts <= as.duration and ni >= 0 do
					local cn = P:node_pos(pi, spi, ni)
					local nn = P:node_pos(pi, spi, ni - 1)
					local dif_x, dif_y = V.sub(nn.x, nn.y, cn.x, cn.y)
					local step_x, step_y = V.mul(c_step / steps, dif_x, dif_y)

					target_pos.x, target_pos.y = V.add(nn.x, nn.y, step_x, step_y)
					target_pos.x = target_pos.x + math.random(-2, 2)
					target_pos.y = target_pos.y + math.random(-3, 3)
					aura.pos = target_pos
					c_step = c_step + 1

					if c_step == steps then
						ni = ni - 1
						c_step = 0
					end

					show_decal = show_decal + 1

					if show_decal == 5 then
						local decal = E:create_entity(as.decal)

						decal.ts = store.tick_ts
						decal.tween.ts = store.tick_ts
						decal.pos = V.vclone(target_pos)
						decal.render.sprites[1].flip_x = math.random(1, 2) > 1

						queue_insert(store, decal)

						show_decal = 0
					end

					if U.animation_finished(this) and this.render.sprites[1].name == as.animation_in then
						U.animation_start(this, as.animation_loop, nil, store.tick_ts, true, 1)
					end

					if store.tick_ts - as.ts > as.duration - fts(1) and this.render.sprites[1].name ~= as.animation_out then
						S:queue(as.sound_destroy)
						U.animation_start(this, as.animation_out, nil, store.tick_ts, nil, 1)
					end

					coroutine.yield()
				end

				queue_remove(store, aura)
				U.y_animation_wait(this)
				U.animation_start(this, "idleinactive", false, store.tick_ts, true, 1, true)

				this.repair.active = false
				this.user_selection.allowed = true
			end
		else
			local enemy, pred_pos = find_target(ab)

			if not enemy then
				goto label_1048_0
			end

			local enemy_id = enemy.id
			local enemy_pos = enemy.pos

			last_ts = store.tick_ts

			local soffset = this.shooter_offset

			U.y_animation_play(this, ab.animation_in, nil, store.tick_ts, nil, 1)
			U.animation_start(this, ab.animation_loop, nil, store.tick_ts, true, 1)
			S:queue(ab.sound)

			local b = E:create_entity(ab.bullet)
			local start_offset = ab.bullet_start_offset

			if b.bullet.out_fx then
				local fx = E:create_entity(b.bullet.out_fx)

				fx.pos.x, fx.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)

				this.ray_fx_start = fx
			end

			enemy, pred_pos = find_target(ab)

			if enemy then
				enemy_id = enemy.id
				enemy_pos = enemy.pos
			end

			ab.ts = last_ts
			b.pos.x, b.pos.y = this.pos.x + start_offset.x, this.pos.y + start_offset.y
			b.bullet.from = V.vclone(b.pos)
			b.bullet.to = V.vclone(enemy_pos)
			b.bullet.target_id = enemy_id
			b.bullet.source_id = this.id
			b.tower_ref = this

			queue_insert(store, b)
			U.y_wait(store, ab.duration, function()
				return not enemy or enemy.health.dead
			end)
			U.y_animation_play(this, ab.animation_out, nil, store.tick_ts, nil, 1)

			attacks_count = attacks_count + 1

			if attacks_before_special <= attacks_count then
				U.animation_start(this, "idle_supercharge", nil, store.tick_ts, true, 1)
			else
				U.animation_start(this, "idle", nil, store.tick_ts, true, 1)
			end
		end

		::label_1048_0::

		if this.user_selection.in_progress and not this.repair.active then
			this.user_selection.in_progress = nil
			this.user_selection.allowed = false
			store.player_gold = store.player_gold - this.repair.cost

			activate()
		end

		coroutine.yield()
	end
end

scripts.mod_sunray = {}

function scripts.mod_sunray.update(this, store)
	local cycles, total_damage = 0, 0
	local m = this.modifier
	local dps = this.dps
	local target = store.entities[m.target_id]

	if not target or target.health.dead then
		queue_remove(store, this)

		return
	end

	local function apply_damage(value)
		local d = E:create_entity("damage")

		d.source_id = this.id
		d.target_id = target.id
		d.value = value
		d.damage_type = dps.damage_type
		d.pop = dps.pop
		d.pop_chance = dps.pop_chance
		d.pop_conds = dps.pop_conds

		queue_damage(store, d)

		total_damage = total_damage + value
	end

	local raw_damage = math.random(this.dps.damage_min, this.dps.damage_max)
	local extra_damage = math.max(0, raw_damage - target.health.hp)
	local total_cycles = m.duration / dps.damage_every
	local dps_damage = math.floor((raw_damage - extra_damage) / total_cycles)
	local first_damage = raw_damage - extra_damage - dps_damage * total_cycles

	this.pos = target.pos
	dps.ts = store.tick_ts
	m.ts = store.tick_ts

	while true do
		target = store.entities[m.target_id]

		if not target or target.health.dead then
			U.y_animation_play(this, "fade", nil, store.tick_ts)

			break
		end

		if total_cycles <= cycles then
			log.paranoid(">>>>> id:%s - mod_ray_arcane cycles:%s raw_damage:%s dps_damage:%s first_damage:%s total_damage:%s", this.id, cycles, raw_damage, dps_damage, first_damage, total_damage)
			apply_damage(extra_damage)

			break
		end

		if this.render and m.use_mod_offset and target.unit.hit_offset then
			for _, s in ipairs(this.render.sprites) do
				s.offset.x, s.offset.y = target.unit.hit_offset.x + this.render.sprites[1].base_offset.x, target.unit.hit_offset.y + this.render.sprites[1].base_offset.y
			end
		end

		if dps.damage_every and store.tick_ts - dps.ts >= dps.damage_every then
			cycles = cycles + 1
			dps.ts = dps.ts + dps.damage_every

			apply_damage(dps_damage + (cycles == 1 and first_damage or 0))
		end

		if store.tick_ts - m.ts > m.duration - fts(11) and this.render.sprites[1].name ~= "fade" then
			U.animation_start(this, "fade", nil, store.tick_ts)
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.bullet_tower_stage_13_sunray = {}

function scripts.bullet_tower_stage_13_sunray.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)
	local tower = this.tower_ref

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	s.hidden = true

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	local mods_added = {}

	if target and (b.mod or b.mods) then
		local mods = b.mods or {
			b.mod
		}

		for _, mod_name in pairs(mods) do
			local m = E:create_entity(mod_name)
			m.modifier.target_id = b.target_id
			if m.dps then
				local damage_factor = 1
				if tower and tower.tower and tower.tower.damage_factor then
					damage_factor = tower.tower.damage_factor
				end
				m.dps.damage_min = math.ceil(m.dps.damage_min * damage_factor)
				m.dps.damage_max = math.ceil(m.dps.damage_max * damage_factor)
			end
			table.insert(mods_added, m)
			queue_insert(store, m)
		end
	end

	local disable_hit = false

	if this.hit_fx_only_no_target then
		disable_hit = target ~= nil and not target.health.dead
	end

	local fx

	if b.hit_fx and not disable_hit then
		local is_air = target and band(target.vis.flags, F_FLYING) ~= 0

		fx = E:create_entity(b.hit_fx)

		if b.hit_fx_ignore_hit_offset and target and not is_air then
			fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
		else
			fx.pos.x, fx.pos.y = dest.x, dest.y
		end

		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	while store.tick_ts - s.ts < this.ray_duration and (this.render.sprites[1].name ~= "fade" or not U.animation_finished(this)) do
		if this.track_target then
			update_sprite()
		end

		if tower and not store.entities[tower.id] then
			queue_remove(store, this)

			if fx then
				queue_remove(store, fx)
			end

			for key, value in pairs(mods_added) do
				queue_remove(store, value)
			end

			break
		end

		if this.render.sprites[1].name ~= "fade" and (store.tick_ts - s.ts > this.ray_duration - fts(8) or not target or target.health.dead) then
			U.animation_start(this, "fade", nil, store.tick_ts)
		end

		coroutine.yield()

		s.hidden = false
	end

	s.hidden = true

	queue_remove(store, this)
end

scripts.bullet_tower_stage_13_sunray_special = {}

function scripts.bullet_tower_stage_13_sunray_special.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local dest = V.vclone(b.to)
	local tower = this.tower_ref

	local function update_sprite()
		local tpx, tpy = this.target_pos.x, this.target_pos.y
		local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

		if d > b.max_track_distance then
			log.info("(%s) bullet_tower_stage_13_sunray_special out of max_track_distance", this.id)
		else
			dest.x, dest.y = tpx, tpy
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	s.hidden = true

	while store.tick_ts - s.ts < this.ray_duration do
		update_sprite()

		if tower and not store.entities[tower.id] then
			queue_remove(store, this)

			break
		end

		if store.tick_ts - s.ts > this.ray_duration - fts(8) and this.render.sprites[1].name ~= "fade" then
			U.animation_start(this, "fade", nil, store.tick_ts)
		end

		coroutine.yield()

		s.hidden = false
	end

	queue_remove(store, this)
end

scripts.mod_tower_stage_13_sunray_special = {}

function scripts.mod_tower_stage_13_sunray_special.remove(this, store)
	local target = store.entities[this.modifier.target_id]
	local source = store.entities[this.modifier.source_id]

	if target and source and target.health and target.health.dead then
		local tower = store.entities[source.aura.source_id]

		if tower then
			tower.total_enemies_killed = tower.total_enemies_killed + 1

			if tower.total_enemies_killed >= 10 then
				signal.emit("sunray_kills-stage13", this)
			end
		end
	end

	return true
end

scripts.controller_stage_14_amalgam = {}

function scripts.controller_stage_14_amalgam.update(this, store)
	local amalgams_spawned = 0
	local path_to_spawn = 7
	local change_path = false

	for _, v in pairs(store.entities) do
		if v.template_name == this.aura_t then
			this.aura_ref = v
			v.controller_ref = this

			break
		end
	end

	local function check_notify_achievement()
		if store.game_outcome and store.game_outcome.victory and amalgams_spawned == 0 then
			signal.emit("no_amalgams_spawned-stage14", this)
		end
	end

	::label_1059_0::

	this.sacrifices = 0

	while this.sacrifices < this.sacrifices_to_show_1 do
		check_notify_achievement()
		coroutine.yield()
	end

	local decal = E:create_entity(this.amalgam_decal_t)

	decal.render.sprites[1].ts = store.tick_ts
	decal.pos = V.vclone(this.amalgam_spawn_pos)

	queue_insert(store, decal)
	S:queue(this.sound_1)
	U.y_animation_play(decal, "state_1", nil, store.tick_ts)
	U.animation_start(decal, "state_1_loop", nil, store.tick_ts, true)

	while this.sacrifices < this.sacrifices_to_show_2 do
		check_notify_achievement()
		coroutine.yield()
	end

	S:queue(this.sound_2)
	U.y_animation_play(decal, "state_2", nil, store.tick_ts)
	U.animation_start(decal, "state_2_loop", nil, store.tick_ts, true)

	while this.sacrifices < this.sacrifices_to_spawn do
		check_notify_achievement()
		coroutine.yield()
	end

	S:queue(this.sound_spawn)
	U.y_animation_play(decal, "spawn", nil, store.tick_ts)

	if amalgams_spawned == 0 then
		path_to_spawn = 7
	elseif change_path then
		if path_to_spawn == 6 then
			path_to_spawn = 7
		else
			path_to_spawn = 6
		end
	else
		local last_path = path_to_spawn

		path_to_spawn = math.random(6, 7)

		if path_to_spawn == last_path then
			change_path = true
		end
	end

	local amalgam = E:create_entity(this.amalgam_t)

	amalgam.pos = V.vclone(this.amalgam_spawn_pos)
	amalgam.nav_path.pi = path_to_spawn
	amalgam.source_id = this.id
	amalgam.render.sprites[1].hidden = true
	amalgam.spawned_from_lake = true

	local original_speed = amalgam.motion.max_speed

	amalgam.motion.max_speed = 0

	queue_insert(store, amalgam)

	amalgam.motion.max_speed = original_speed

	queue_remove(store, decal)

	amalgam.render.sprites[1].hidden = false

	signal.emit("wave-notification", "icon", this.amalgam_t)

	amalgams_spawned = amalgams_spawned + 1

	goto label_1059_0
end

scripts.aura_controller_stage_14_amalgam = {}

function scripts.aura_controller_stage_14_amalgam.update(this, store)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	while true do
		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.health and not v.health.dead and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name))
			end)

			for i, target in ipairs(targets) do
				target.amalgam_sacrifice = true
				target.amalgam_controller = this.controller_ref
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.aura_stage_14_prevent_polymorph = {}

function scripts.aura_stage_14_prevent_polymorph.update(this, store)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	while true do
		if store.tick_ts - last_hit_ts >= this.aura.cycle_time then
			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.health and not v.health.dead and v.enemy and 
				U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and not U.flag_has(v.vis.bans, F_POLYMORPH) and
				(v.nav_path.pi == 2 or v.nav_path.pi == 3) and
				(not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name))
			end)

			for i, target in ipairs(targets) do
				target.vis.bans = U.flag_set(target.vis.bans, F_POLYMORPH)
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_stage_14_easter_egg_rickmorty = {}

function scripts.decal_stage_14_easter_egg_rickmorty.insert(this, store, script)
	return not features.censored_cn
end

function scripts.decal_stage_14_easter_egg_rickmorty.update(this, store, script)
	local idle_cooldown = math.random(this.idle_cooldown_min, this.idle_cooldown_max)
	local idle_ts = store.tick_ts
	local click_amounts = 1

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil

			if click_amounts == 3 then
				S:queue("Stage14RickPortal3Out")
				U.y_animation_play(this, "portal_open", nil, store.tick_ts, 1)

				break
			end

			S:queue("Stage14RickPortal12Open")
			S:queue("Stage14RickPortal12Open")
			U.animation_start(this, "portal_open", nil, store.tick_ts, false)
			U.y_wait(store, 3)
			S:queue("Stage14RickPortal12Pass")
			U.y_wait(store, 0.9)
			S:queue("Stage14RickPortal12Pass")
			U.y_wait(store, 1)
			S:queue("Stage14RickPortal12Close")
			U.y_animation_wait(this)

			this.pos = this.pos_spawn[click_amounts]
			this.render.sprites[1].prefix = this.prefix_names[click_amounts]
			click_amounts = click_amounts + 1

			U.animation_start(this, "start", nil, store.tick_ts, false)
			U.y_wait(store, 0)
			S:queue("Stage14RickPortalOpenNoLaser")
			U.y_wait(store, 1)
			S:queue("Stage14RickPortal12Pass")
			U.y_wait(store, 0.9)
			S:queue("Stage14RickPortal12Pass")

			if click_amounts == 3 then
				U.y_wait(store, 0.7)
				S:queue("Stage14RickPortal12Pass")
				U.y_wait(store, 0.4)
			else
				U.y_wait(store, 1)
			end

			S:queue("Stage14RickPortal12Close")
			U.y_animation_wait(this)
			U.animation_start(this, "idle", nil, store.tick_ts, true)
		end

		if idle_cooldown <= store.tick_ts - idle_ts then
			U.y_animation_play(this, "idle_2", nil, store.tick_ts, 1)

			idle_cooldown = math.random(this.idle_cooldown_min, this.idle_cooldown_max)
			idle_ts = store.tick_ts

			U.animation_start(this, "idle", nil, store.tick_ts, 1)
		end

		coroutine.yield()
	end

	signal.emit("rickmorty-stage14")
	queue_remove(store, this)
end

scripts.soldier_reinforcement_stage_15_denas = {}

function scripts.soldier_reinforcement_stage_15_denas.update(this, store, script)
	local brk, stam, star

	this.reinforcement.ts = store.tick_ts
	this.render.sprites[1].hidden = false

	local a = this.melee.attacks

	a[1].ts = store.tick_ts
	a[2].ts = store.tick_ts
	a[3].ts = store.tick_ts

	local timeout_controller = E:create_entity(this.timeout_controller)

	timeout_controller.denas = this

	queue_insert(store, timeout_controller)
	S:queue(this.spawn_sfx)
	U.animation_start(this, "spawn", nil, store.tick_ts, 1)
	U.y_wait(store, fts(6))

	local spawn_decal = E:create_entity(this.spawn_decal)

	spawn_decal.pos = V.vclone(this.pos)
	spawn_decal.render.sprites[1].ts = store.tick_ts

	queue_insert(store, spawn_decal)

	local floor_decal = E:create_entity(this.floor_decal)

	floor_decal.pos = V.vclone(this.pos)
	floor_decal.render.sprites[1].ts = store.tick_ts

	queue_insert(store, floor_decal)

	local enemies = U.find_enemies_in_range(store.entities, this.pos, 0, this.spawn_stun_radius, this.spawn_vis_flags, this.spawn_vis_bans)

	if enemies and #enemies > 0 then
		for _, enemy in pairs(enemies) do
			local mod = E:create_entity(this.spawn_stun_mod)

			mod.modifier.target_id = enemy.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)
		end
	end

	U.y_animation_wait(this)
	U.animation_start(this, "idle_a", nil, store.tick_ts, true)

	local function y_denas_new_rally(store, this)
		local r = this.nav_rally

		if r.new then
			r.new = false

			U.unblock_target(store, this)

			if this.sound_events then
				S:queue(this.sound_events.change_rally_point)
			end

			this.vis.bans = F_ALL
			this.health.immune_to = r.immune_to

			return SU.y_hero_walk_waypoints(store, this)
		end
	end

	local function y_denas_melee_block_and_attacks(store, this)
		local target = SU.soldier_pick_melee_target(store, this)

		if not target then
			return false, A_NO_TARGET
		end

		if this.render.sprites[1].name == "idle_a" then
			U.y_animation_play(this, "sword_out", nil, store.tick_ts, 1)
		end

		if SU.soldier_move_to_slot_step(store, this, target) then
			return true
		end

		local attack = SU.soldier_pick_melee_attack(store, this, target)

		if not attack then
			return false, A_IN_COOLDOWN
		end

		::label_1068_0::

		-- attack.hit_offset.x = target.pos.x - this.pos.x + target.unit.hit_offset.x

		-- if attack ~= a[3] then
		-- 	attack.hit_offset.y = target.pos.y - this.pos.y + target.unit.hit_offset.y
		-- end

		local attack_done

		if attack.type == "area" then
			attack_done = SU.y_soldier_do_single_area_attack(store, this, target, attack)
		else
			attack_done = SU.y_soldier_do_single_melee_attack(store, this, target, attack)
		end

		if attack_done then
			if attack == a[1] then
				local target = SU.soldier_pick_melee_target(store, this)

				if target then
					attack = a[2]

					goto label_1068_0
				end
			end

			return false, A_DONE
		else
			return true
		end
	end

	while true do
		if this.health.dead or this.reinforcement.duration and store.tick_ts - this.reinforcement.ts > this.reinforcement.duration then
			if this.health.hp > 0 then
				this.reinforcement.hp_before_timeout = this.health.hp
			end

			this.health.hp = 0

			SU.remove_modifiers(store, this)

			this.ui.can_click = false
			this.ui.z = -1

			U.unblock_target(store, this)
			S:queue("Stage15ReinforcementDenasOut")
			U.y_animation_play(this, "out", nil, store.tick_ts, 1)

			this.health.death_finished_ts = store.tick_ts
			this.render.sprites[1].hidden = true

			queue_remove(store, this)
		end

		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			while this.nav_rally.new do
				if this.render.sprites[1].name == "idle_a" then
					U.y_animation_play(this, "sword_out", nil, store.tick_ts, 1)
				end

				local vis_bans = this.vis.bans
				local prev_immune = this.health.immune_to

				if y_denas_new_rally(store, this) and SU.soldier_pick_melee_target(store, this) then
					U.y_animation_play(this, "sword_in", nil, store.tick_ts, 1)
					U.animation_start(this, "idle_a", nil, store.tick_ts, true)

					this.vis.bans = vis_bans
					this.health.immune_to = prev_immune

					goto label_1066_0
				end

				this.vis.bans = vis_bans
				this.health.immune_to = prev_immune
			end

			if this.melee then
				brk, stam = y_denas_melee_block_and_attacks(store, this)

				if brk or stam == A_DONE or stam == A_IN_COOLDOWN and not this.melee.continue_in_cooldown then
					if stam == A_DONE and this.render.sprites[1].name == "attack_a" then
						U.y_animation_play(this, "attack_a_to_idle", nil, store.tick_ts, 1)
					end

					goto label_1066_0
				elseif stam == A_NO_TARGET then
					if this.render.sprites[1].name == "attack_a" then
						U.y_animation_play(this, "attack_a_to_idle", nil, store.tick_ts, 1)
						U.animation_start(this, "idle_b", nil, store.tick_ts, true)
					end

					if this.render.sprites[1].name ~= "idle_a" then
						U.y_animation_play(this, "sword_in", nil, store.tick_ts, 1)
						U.animation_start(this, "idle_a", nil, store.tick_ts, true)
					end
				end
			end

			if this.melee.continue_in_cooldown and stam == A_IN_COOLDOWN then
				-- block empty
			else
				SU.soldier_idle(store, this)
				SU.soldier_regen(store, this)
			end
		end

		::label_1066_0::

		coroutine.yield()
	end
end

scripts.controller_soldier_reinforcement_stage_15_denas_timeout = {}

function scripts.controller_soldier_reinforcement_stage_15_denas_timeout.update(this, store, script)
	while true do
		if this.denas.reinforcement.duration and store.tick_ts - this.denas.reinforcement.ts > this.denas.reinforcement.duration then
			this.denas.health.dead = true
			this.denas.health_bar.hidden = true
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.controller_stage_15_cult_leader_tower = {}

function scripts.controller_stage_15_cult_leader_tower.update(this, store)
	local last_wave_processed = 0
	local last_attack_ts = store.tick_ts
	local attack_cd, time_to_leave_after_attack

	U.animation_start_group(this, "idlenothing", nil, store.tick_ts, true, "layers")

	this.boss_fight_started = false
	this.soldiers_grabbed = 0

	while true do
		if store.wave_group_number == 0 then
			-- block empty
		else
			if store.wave_group_number ~= last_wave_processed then
				last_wave_processed = store.wave_group_number
				attack_cd = this.config_per_wave[store.wave_group_number].tentacle_cd

				if last_wave_processed == 1 then
					last_attack_ts = store.tick_ts
				end
			end

			if this.transform_out then
				this.transform_out = nil

				U.y_wait(store, 2)
				signal.emit("show-curtains")
				signal.emit("pan-zoom-camera", 2, {
					x = 680,
					y = 860
				}, 2)
				signal.emit("hide-gui")
				signal.emit("start-cinematic")
				U.y_wait(store, 2)
				S:queue("Stage15MydriasEnter")
				U.y_animation_play_group(this, "enter", nil, store.tick_ts, 1, "layers")
				U.animation_start_group(this, "idleup", nil, store.tick_ts, true, "layers")
				signal.emit("show-balloon_tutorial", "LV15_CULTIST03", false)
				U.y_wait(store, 4)
				signal.emit("show-balloon_tutorial", "LV15_CULTIST04", false)
				U.y_wait(store, 4)
				S:queue("Stage15MutatedMydriasEnter")
				U.y_animation_play_group(this, "transform", nil, store.tick_ts, 1, "layers")
				U.animation_start_group(this, "transformloop", nil, store.tick_ts, true, "layers")
				U.y_animation_play_group(this, "transform2", nil, store.tick_ts, 1, "layers")
				U.y_wait(store, fts(60))

				local boss = E:create_entity(this.boss_to_spawn)

				queue_insert(store, boss)
				U.y_wait(store, 2)

				local denas = E:create_entity("soldier_reinforcement_stage_15_denas")

				denas.pos = v(560, 440)
				denas.nav_rally.center = V.vclone(denas.pos)
				denas.nav_rally.pos = V.vclone(denas.pos)
				denas.reinforcement.squad_id = denas.id

				queue_insert(store, denas)
				U.y_wait(store, 2)
				signal.emit("show-balloon_tutorial", "LV15_DENAS01", false)
				U.y_wait(store, 4)
				S:stop_group("MUSIC")
				S:queue("MusicBossFight_15")
				signal.emit("hide-curtains")
				signal.emit("pan-zoom-camera", 2, {
					x = 400,
					y = 400
				}, 1.3)
				signal.emit("show-gui")
				signal.emit("end-cinematic")

				this.boss_fight_started = true
			end

			if this.boss_fight_started and this.boss_dead then
				queue_remove(store, this)
			end

			if this.boss_fight_started and this.boss_teleport then
				this.boss_teleport = nil

				local soldiers = table.filter(store.entities, function(k, v)
					return not v.pending_removal and v.soldier and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.bans) == 0 and band(v.vis.bans, this.flags) == 0
				end)
				local soldier_groups = {}

				local function closest_soldier_group(pos)
					local closest_group
					local closest_distance = 1e+99

					for _, soldier_group in ipairs(soldier_groups) do
						local soldier_distance = V.dist(soldier_group.pos.x, soldier_group.pos.y, pos.x, pos.y)

						if soldier_distance < closest_distance then
							closest_distance = soldier_distance
							closest_group = soldier_group
						end
					end

					return closest_group, closest_distance
				end

				if soldiers and #soldiers > 0 then
					for _, soldier in ipairs(soldiers) do
						local closest_group, closest_distance = closest_soldier_group(V.vclone(soldier.pos))

						if closest_group and closest_distance < this.distance_to_group then
							table.insert(closest_group.soldiers, soldier)
						else
							table.insert(soldier_groups, {
								soldiers = {
									soldier
								},
								pos = V.vclone(soldier.pos)
							})
						end
					end
				end

				if soldier_groups and #soldier_groups > 0 then
					for _, soldier_group in ipairs(soldier_groups) do
						local surrounded_soldier, surrounded_soldiers = U.find_entity_most_surrounded(soldier_group.soldiers)
						local aura = E:create_entity(this.aura)
						local nearest_nodes = P:nearest_nodes(surrounded_soldier.pos.x, surrounded_soldier.pos.y, nil, {
							1
						}, true)
						local pi, spi, ni = unpack(nearest_nodes[1])
						local npos = P:node_pos(pi, spi, ni)

						aura.pos = npos
						aura.aura.source_id = this.id
						aura.aura.ts = store.tick_ts
						aura.mod_duration = this.config_per_wave[store.wave_group_number].tentacle_duration

						queue_insert(store, aura)
					end
				end
			end

			if not this.boss_fight_started and attack_cd <= store.tick_ts - last_attack_ts then
				U.y_animation_play_group(this, "enter", nil, store.tick_ts, 1, "layers")
				U.animation_start_group(this, "idleup", nil, store.tick_ts, true, "layers")
				y_show_taunt_set(store, this.taunts, "in_bossfight", false)
				U.y_wait(store, math.random(this.time_before_attack_min, this.time_before_attack_max))
				U.y_animation_wait_group(this, "layers")

				local start_ts = store.tick_ts

				U.y_animation_play_group(this, "attack", nil, store.tick_ts, 1, "layers")
				U.animation_start_group(this, "attackloop", nil, store.tick_ts, true, "layers")

				local soldiers = table.filter(store.entities, function(k, v)
					return not v.pending_removal and v.soldier and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.bans) == 0 and band(v.vis.bans, this.flags) == 0
				end)
				local soldier_groups = {}

				local function closest_soldier_group(pos)
					local closest_group
					local closest_distance = 1e+99

					for _, soldier_group in ipairs(soldier_groups) do
						local soldier_distance = V.dist(soldier_group.pos.x, soldier_group.pos.y, pos.x, pos.y)

						if soldier_distance < closest_distance then
							closest_distance = soldier_distance
							closest_group = soldier_group
						end
					end

					return closest_group, closest_distance
				end

				if soldiers and #soldiers > 0 then
					for _, soldier in ipairs(soldiers) do
						local closest_group, closest_distance = closest_soldier_group(V.vclone(soldier.pos))

						if closest_group and closest_distance < this.distance_to_group then
							table.insert(closest_group.soldiers, soldier)
						else
							table.insert(soldier_groups, {
								soldiers = {
									soldier
								},
								pos = V.vclone(soldier.pos)
							})
						end
					end
				end

				if soldier_groups and #soldier_groups > 0 then
					soldier_groups = table.random_order(soldier_groups)
					soldier_groups = table.slice(soldier_groups, 1, this.config_per_wave[store.wave_group_number].targets_amount)

					for _, soldier_group in ipairs(soldier_groups) do
						local surrounded_soldier, surrounded_soldiers = U.find_entity_most_surrounded(soldier_group.soldiers)
						local aura = E:create_entity(this.aura)
						local nearest_nodes = P:nearest_nodes(surrounded_soldier.pos.x, surrounded_soldier.pos.y, nil, {
							1
						}, true)
						local pi, spi, ni = unpack(nearest_nodes[1])
						local npos = P:node_pos(pi, spi, ni)

						aura.pos = npos
						aura.aura.source_id = this.id
						aura.aura.ts = store.tick_ts
						aura.mod_duration = this.config_per_wave[store.wave_group_number].tentacle_duration

						queue_insert(store, aura)
					end
				end

				U.y_wait(store, fts(30))
				U.y_animation_wait_group(this, "layers")
				U.y_animation_play_group(this, "attackleave", nil, store.tick_ts, 1, "layers")

				last_attack_ts = start_ts

				U.animation_start_group(this, "idleup", nil, store.tick_ts, true, "layers")
				U.y_wait(store, math.random(this.time_to_leave_after_attack_min, this.time_to_leave_after_attack_max))
				U.y_animation_play_group(this, "leave", nil, store.tick_ts, 1, "layers")
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_15_easter_egg_goblin = {}

function scripts.decal_stage_15_easter_egg_goblin.update(this, store)
	local portal_spawned = false
	local decal_portal

	local function check_click_and_spawn_portal()
		if not portal_spawned and this.ui.clicked then
			this.ui.clicked = nil
			decal_portal = E:create_entity("decal_stage_15_easter_egg_goblin_portal")
			decal_portal.pos = V.vclone(this.pos)

			queue_insert(store, decal_portal)
			U.animation_start(decal_portal, "in", nil, store.tick_ts, false)

			portal_spawned = true
		end

		if decal_portal and U.animation_finished(decal_portal) then
			U.animation_start(decal_portal, "loop", nil, store.tick_ts, true)
		end
	end

	if store.level_mode == GAME_MODE_CAMPAIGN then
		this.render.sprites[1].hidden = true

		while not this.cult_leader_tower.boss_fight_started do
			coroutine.yield()
		end

		local out_ts = store.tick_ts
		local is_out = false
		local sweep_ts = store.tick_ts

		while true do
			if is_out then
				if portal_spawned then
					U.animation_start(this, "tap", nil, store.tick_ts, false)
					U.y_wait(store, 0.2)
					S:queue("Stage15RiffPortalOpen")
					U.y_wait(store, 0.3)
					queue_remove(store, decal_portal)
					U.y_wait(store, 2.7)
					S:queue("Stage15RiffPortalBroom")
					U.y_wait(store, 2.6)
					S:queue("Stage15RiffPortalClose")
					U.y_animation_wait(this)

					break
				else
					check_click_and_spawn_portal()
				end

				if store.tick_ts - sweep_ts >= this.sweep_cooldown then
					sweep_ts = store.tick_ts

					U.animation_start(this, "sweeping", nil, store.tick_ts, false)
				end

				if store.tick_ts - out_ts >= this.time_to_in_cooldown then
					U.y_animation_play(this, "leave", nil, store.tick_ts)

					this.render.sprites[1].hidden = true
					is_out = false
					out_ts = store.tick_ts
				end
			elseif store.tick_ts - out_ts >= this.out_cooldown then
				out_ts = store.tick_ts
				this.render.sprites[1].hidden = false

				U.animation_start(this, "in", nil, store.tick_ts, false)

				local min_time_in_ts = store.tick_ts
				local min_time_cooldown = 2

				while not U.animation_finished(this) do
					if min_time_cooldown <= store.tick_ts - min_time_in_ts then
						check_click_and_spawn_portal()
					end

					coroutine.yield()
				end

				this.ui.clicked = nil
				is_out = true
				sweep_ts = store.tick_ts
			end

			coroutine.yield()
		end
	end

	signal.emit("goblintap-stage15")
	queue_remove(store, this)
end

scripts.aura_stage_15_cult_leader_tower_stun = {}

function scripts.aura_stage_15_cult_leader_tower_stun.update(this, store, script)
	local first_hit_ts
	local last_hit_ts = 0
	local cycles_count = 0
	local victims_count = 0

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	last_hit_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.apply_delay then
		last_hit_ts = last_hit_ts + this.aura.apply_delay
	end

	this.tween.disabled = false
	this.tween.ts = store.tick_ts

	S:queue(this.sound_pre)
	U.animation_start(this, "start", false, store.tick_ts, true)
	U.y_wait(store, this.time_before_stun)

	this.aura.ts = store.tick_ts

	S:queue(this.sound_grab)
	U.animation_start(this, "stun", false, store.tick_ts, true)

	local already_applied_mod = false
	local decal_on_grab_shown = false

	while true do
		if this.interrupt then
			last_hit_ts = 1e+99
		end

		if this.aura.cycles and cycles_count >= this.aura.cycles or this.aura.duration >= 0 and store.tick_ts - this.aura.ts > this.aura.duration then
			log.info(store.tick_ts - this.aura.ts)

			break
		end

		if this.aura.stop_on_max_count and this.aura.max_count and victims_count >= this.aura.max_count then
			break
		end

		if this.aura.track_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if not te or te.health and te.health.dead and not this.aura.track_dead then
				break
			end
		end

		if this.aura.requires_magic then
			local te = store.entities[this.aura.source_id]

			if not te or not te.enemy then
				goto label_1077_0
			end

			if this.render then
				this.render.sprites[1].hidden = not te.enemy.can_do_magic
			end

			if not te.enemy.can_do_magic then
				goto label_1077_0
			end
		end

		if this.aura.source_vis_flags and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.vis and band(te.vis.bans, this.aura.source_vis_flags) ~= 0 then
				goto label_1077_0
			end
		end

		if this.aura.requires_alive_source and this.aura.source_id then
			local te = store.entities[this.aura.source_id]

			if te and te.health and te.health.dead then
				goto label_1077_0
			end
		end

		if already_applied_mod or not (store.tick_ts - last_hit_ts >= this.aura.cycle_time) or this.aura.apply_duration and first_hit_ts and store.tick_ts - first_hit_ts > this.aura.apply_duration then
			-- block empty
		else
			if this.render and this.aura.cast_resets_sprite_id then
				this.render.sprites[this.aura.cast_resets_sprite_id].ts = store.tick_ts
			end

			if not decal_on_grab_shown then
				local decal_on_grab = E:create_entity(this.decal_on_grab)

				decal_on_grab.render.sprites[1].ts = store.tick_ts
				decal_on_grab.pos = V.vclone(this.pos)
				decal_on_grab.tween.ts = store.tick_ts

				queue_insert(store, decal_on_grab)

				decal_on_grab_shown = true
			end

			first_hit_ts = first_hit_ts or store.tick_ts
			last_hit_ts = store.tick_ts
			cycles_count = cycles_count + 1

			local targets = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.filter_source or this.aura.source_id ~= v.id)
			end)

			for i, target in ipairs(targets) do
				if this.aura.targets_per_cycle and i > this.aura.targets_per_cycle then
					break
				end

				if this.aura.max_count and victims_count >= this.aura.max_count then
					break
				end

				local mods = this.aura.mods or {
					this.aura.mod
				}

				for _, mod_name in pairs(mods) do
					local new_mod = E:create_entity(mod_name)

					new_mod.modifier.level = this.aura.level
					new_mod.modifier.target_id = target.id
					new_mod.modifier.source_id = this.id
					new_mod.modifier.duration = this.mod_duration

					if this.aura.hide_source_fx and target.id == this.aura.source_id then
						new_mod.render = nil
					end

					queue_insert(store, new_mod)

					victims_count = victims_count + 1
				end

				already_applied_mod = true
			end

			if already_applied_mod then
				break
			end
		end

		::label_1077_0::

		coroutine.yield()
	end

	local decal_activate = E:create_entity(this.decal_on_activate)

	decal_activate.pos = this.pos
	decal_activate.tween.ts = store.tick_ts

	queue_insert(store, decal_activate)

	local decal_leave = E:create_entity(this.decal_on_leave)

	decal_leave.pos = this.pos
	decal_leave.tween.ts = store.tick_ts

	queue_insert(store, decal_leave)
	signal.emit("aura-apply-mod-victims", this, victims_count)
	queue_remove(store, this)
end

scripts.mod_stage_15_cult_leader_tower_stun = {}

function scripts.mod_stage_15_cult_leader_tower_stun.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]
	local source = store.entities[this.modifier.source_id]

	if target and source then
		local controller = store.entities[source.aura.source_id]

		if controller then
			controller.soldiers_grabbed = controller.soldiers_grabbed + 1
		end
	end

	if target then
		SU.stun_dec(target)
		log.paranoid("mod_stun.remove (%s)-%s for target (%s)-%s", this.id, this.template_name, target.id, target.template_name)
	else
		log.paranoid("mod_stun.remove target is nil for id %s", this.modifier.target_id)
	end

	return true
end

scripts.boss_cult_leader = {}

function scripts.boss_cult_leader.update(this, store)
	local path_pi, path_spi, path_ni
	local is_protected = true
	local current_life_threshold_teleport_index = 1
	local next_life_threshold_teleport = this.life_threshold_teleport.life_percentage[1]
	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_boss

	for _, value in pairs(spawners) do
		if value.load_file == "level15_spawner" then
			megaspawner_boss = value
		end
	end

	local cult_leader = table.filter(store.entities, function(k, v)
		return v.template_name == this.cult_leader_template_name
	end)[1]
	local glare = table.filter(store.entities, function(k, v)
		return v.template_name == this.glare_template_name
	end)[1]

	local function adjust_position(path)
		local nearest = P:nearest_nodes(this.pos.x, this.pos.y, {
			path
		}, {
			1
		})

		if #nearest > 0 then
			path_pi, path_spi, path_ni = unpack(nearest[1])
		end

		this.nav_path.pi = path_pi
		this.nav_path.spi = path_spi
		this.nav_path.ni = path_ni
	end

	local function aoe_attack(radius, damage_min, damage_max, damage_type, vis, bans, min_targets)
		local targets = table.filter(store.entities, function(_, e)
			return e.health and not e.health.dead and e.vis and band(e.vis.flags, bans) == 0 and band(e.vis.bans, vis) == 0 and U.is_inside_ellipse(e.pos, this.pos, radius)
		end)

		if targets and min_targets <= #targets then
			for _, target in pairs(targets) do
				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id

				local dmin, dmax = damage_min, damage_max

				d.value = math.random(dmin, dmax)
				d.damage_type = damage_type

				queue_damage(store, d)
			end
		end
	end

	local function update_armor()
		if is_protected then
			this.health.armor = this.close_armor
			this.health.magic_armor = this.close_magic_armor
		else
			this.health.armor = this.open_armor
			this.health.magic_armor = this.open_magic_armor
		end
	end

	local function check_life_threshold_stun()
		if next_life_threshold_teleport and this.health.hp * 100 / this.health.hp_max <= next_life_threshold_teleport then
			return true
		end

		return false
	end

	local function break_fn()
		return check_life_threshold_stun()
	end

	local function y_on_death()
		LU.kill_all_enemies(store, true)
		S:stop_all()

		megaspawner_boss.interrupt = true

		S:queue(this.sound_transform_in)
		S:queue("Stage15MydriasDeath")
		U.y_animation_play(this, "deathstart", nil, store.tick_ts)
		U.animation_start(this, "deathloop", nil, store.tick_ts, true)
		U.y_wait(store, this.time_death)
		LU.kill_all_enemies(store, true)
		signal.emit("boss-killed", this)

		cult_leader.boss_dead = true
	end

	local function y_wait_for_blocker_cult_leader(store, this, blocker)
		local idle_anim = "walk"

		if not is_protected then
			idle_anim = "standingidle"
		end

		local pos = blocker.motion.arrived and blocker.pos or blocker.motion.dest
		local an, af = U.animation_name_facing_point(this, idle_anim, pos)

		U.animation_start(this, an, af, store.tick_ts, true)

		while not blocker.motion.arrived do
			coroutine.yield()

			if this.health.dead or this.unit.is_stunned or not table.contains(this.enemy.blockers, blocker.id) or blocker.health.dead or not store.entities[blocker.id] then
				return false
			end

			if blocker.unit.is_stunned then
				U.unblock_target(store, blocker)

				return false
			end
		end

		return true
	end

	local function y_enemy_walk_until_blocked_cult_leader(store, this, ignore_soldiers, func)
		local ranged, blocker
		local terrain_type = band(GR:cell_type(this.pos.x, this.pos.y), bor(TERRAIN_WATER, TERRAIN_LAND))

		while ignore_soldiers or not blocker and not ranged do
			if this.unit.is_stunned then
				return false
			end

			if func and func(store, this) then
				return false, nil, nil
			end

			if this.health.dead then
				return false
			end

			local node_valid = P:is_node_valid(this.nav_path.pi, this.nav_path.ni)

			if node_valid and not ignore_soldiers and this.ranged then
				for _, a in pairs(this.ranged.attacks) do
					if not a.disabled and (not a.requires_magic or this.enemy.can_do_magic) and (a.hold_advance or store.tick_ts - a.ts > a.cooldown) then
						ranged = U.find_nearest_soldier(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

						if ranged ~= nil then
							break
						end
					end
				end
			end

			if node_valid and not ignore_soldiers and #this.enemy.blockers > 0 then
				U.cleanup_blockers(store, this)

				blocker = store.entities[this.enemy.blockers[1]]
			end

			if ignore_soldiers or not blocker and not ranged then
				if not is_protected then
					U.y_animation_play(this, "close", nil, store.tick_ts)

					is_protected = true

					update_armor()
				end

				SU.y_enemy_walk_step(store, this)
			else
				U.animation_start(this, "idle", nil, store.tick_ts, true)
			end

			if terrain_type ~= band(GR:cell_type(this.pos.x, this.pos.y), bor(TERRAIN_WATER, TERRAIN_LAND)) then
				return false, nil, nil
			end
		end

		return true, blocker, ranged
	end

	local function y_enemy_melee_attacks_cult_leader(store, this, target)
		for _, i in ipairs(this.melee.order) do
			do
				local ma = this.melee.attacks[i]
				local cooldown = ma.cooldown

				if ma.shared_cooldown then
					cooldown = this.melee.cooldown
				end

				if not ma.disabled and cooldown <= store.tick_ts - ma.ts and band(ma.vis_flags, target.vis.bans) == 0 and band(ma.vis_bans, target.vis.flags) == 0 and (not ma.fn_can or ma.fn_can(this, store, ma, target)) then
					if ma.type == "area" then
						local hit_pos = V.vclone(this.pos)
						local targets = table.filter(store.entities, function(_, e)
							return e.soldier and e.vis and e.health and not e.health.dead and band(e.vis.flags, ma.vis_bans) == 0 and band(e.vis.bans, ma.vis_flags) == 0 and U.is_inside_ellipse(e.pos, hit_pos, ma.damage_radius) and (not ma.fn_filter or ma.fn_filter(this, store, ma, e))
						end)

						if not targets or #targets < ma.min_count then
							goto label_1092_0
						end
					end

					ma.ts = store.tick_ts

					if math.random() >= ma.chance then
						-- block empty
					else
						log.paranoid("attack %i selected for entity %s", i, this.template_name)

						for _, aa in pairs(this.melee.attacks) do
							if aa ~= ma and aa.shared_cooldown then
								aa.ts = ma.ts
							end
						end

						ma.ts = store.tick_ts

						S:queue(ma.sound, ma.sound_args)

						local an, af = U.animation_name_facing_point(this, ma.animation, target.pos)

						for i = 1, #this.render.sprites do
							if this.render.sprites[i].animated then
								U.animation_start(this, an, af, store.tick_ts, 1, i)
							end
						end

						local hit_pos = V.vclone(this.pos)

						if ma.hit_offset then
							hit_pos.x = hit_pos.x + (af and -1 or 1) * ma.hit_offset.x
							hit_pos.y = hit_pos.y + ma.hit_offset.y
						end

						local hit_times = ma.hit_times and ma.hit_times or {
							ma.hit_time
						}

						for i = 1, #hit_times do
							local hit_time = hit_times[i]
							local dodged = false

							if ma.dodge_time and target.dodge then
								local dodge_time = ma.dodge_time

								if target.dodge and target.dodge.time_before_hit then
									dodge_time = hit_time - target.dodge.time_before_hit
								end

								while dodge_time > store.tick_ts - ma.ts do
									if this.health.dead or this.unit.is_stunned and not ma.ignore_stun or this.dodge and this.dodge.active and not this.dodge.silent then
										return false
									end

									coroutine.yield()
								end

								dodged = SU.unit_dodges(store, target, false, ma, this)
							end

							while hit_time > store.tick_ts - ma.ts do
								if this.health.dead or this.unit.is_stunned and not ma.ignore_stun or this.dodge and this.dodge.active and not this.dodge.silent then
									return false
								end

								coroutine.yield()
							end

							S:queue(ma.sound_hit, ma.sound_hit_args)

							if ma.type == "melee" and not dodged and table.contains(this.enemy.blockers, target.id) then
								local d = E:create_entity("damage")

								d.source_id = this.id
								d.target_id = target.id
								d.track_kills = this.track_kills ~= nil
								d.track_damage = ma.track_damage
								d.pop = ma.pop
								d.pop_chance = ma.pop_chance
								d.pop_conds = ma.pop_conds

								if ma.instakill then
									d.damage_type = DAMAGE_INSTAKILL

									queue_damage(store, d)
								elseif ma.damage_min then
									d.damage_type = ma.damage_type
									d.value = math.ceil(this.unit.damage_factor * math.random(ma.damage_min, ma.damage_max))

									queue_damage(store, d)
								end

								if ma.mod then
									local mod = E:create_entity(ma.mod)

									mod.modifier.target_id = target.id
									mod.modifier.source_id = this.id

									queue_insert(store, mod)
								end
							elseif ma.type == "area" then
								local targets = table.filter(store.entities, function(_, e)
									return e.soldier and e.vis and e.health and not e.health.dead and band(e.vis.flags, ma.vis_bans) == 0 and band(e.vis.bans, ma.vis_flags) == 0 and U.is_inside_ellipse(e.pos, hit_pos, ma.damage_radius) and (not ma.fn_filter or ma.fn_filter(this, store, ma, e))
								end)

								for i, e in ipairs(targets) do
									if e == target and dodged then
										-- block empty
									else
										if ma.count and i > ma.count then
											break
										end

										local d = E:create_entity("damage")

										d.source_id = this.id
										d.target_id = e.id
										d.damage_type = ma.damage_type
										d.value = math.ceil(this.unit.damage_factor * math.random(ma.damage_min, ma.damage_max))
										d.pop = ma.pop
										d.pop_chance = ma.pop_chance
										d.pop_conds = ma.pop_conds

										if e.template_name == "soldier_reinforcement_stage_15_denas" then
											d.value = d.value * this.denas_ray_resistance
										end

										queue_damage(store, d)

										if ma.mod then
											local mod = E:create_entity(ma.mod)

											mod.modifier.target_id = e.id
											mod.modifier.source_id = this.id

											queue_insert(store, mod)
										end
									end
								end
							end

							if ma.hit_fx and (not ma.hit_fx_once or i == 1) then
								local fx = E:create_entity(ma.hit_fx)

								fx.pos = V.vclone(hit_pos)

								if ma.hit_fx_offset then
									fx.pos.x = fx.pos.x + (af and -1 or 1) * ma.hit_fx_offset.x
									fx.pos.y = fx.pos.y + ma.hit_fx_offset.y
								end

								if ma.hit_fx_flip then
									fx.render.sprites[1].flip_x = af
								end

								fx.render.sprites[1].ts = store.tick_ts

								queue_insert(store, fx)
							end

							if ma.hit_decal then
								local fx = E:create_entity(ma.hit_decal)

								fx.pos = V.vclone(hit_pos)
								fx.render.sprites[1].ts = store.tick_ts

								if ma.hit_decal_offset then
									fx.pos.x = fx.pos.x + (af and -1 or 1) * ma.hit_decal_offset.x
									fx.pos.y = fx.pos.y + ma.hit_decal_offset.y
								end

								queue_insert(store, fx)
							end
						end

						while not U.animation_finished(this) do
							if this.health.dead or ma.ignore_stun and this.unit.is_stunned or this.dodge and this.dodge.active and not this.dodge.silent then
								return false
							end

							coroutine.yield()
						end

						U.animation_start(this, "standingidle", nil, store.tick_ts, true)

						return true
					end
				end
			end

			::label_1092_0::
		end

		return true
	end

	this.pos = this.teleport_pos[1]

	adjust_position(this.teleport_path[1])

	this.vis._flags = this.vis.flags
	this.vis._bans = this.vis.bans
	this.vis.flags = bor(F_ENEMY, F_BOSS)
	this.vis.bans = bor(F_RANGED, F_BLOCK)

	S:queue(this.sound_burrow_out)
	U.y_animation_play(this, "teleportout", true, store.tick_ts)
	U.animation_start(this, "walk", true, store.tick_ts, true)

	while not cult_leader.boss_fight_started do
		coroutine.yield()
	end

	local start_ts = store.tick_ts

	signal.emit("boss_fight_start", this)
	signal.emit("change_power_button", "power_button_1", "bottom_powers_icons_0002", 25)

	megaspawner_boss.manual_wave = "BOSS1"
	this.vis.flags = this.vis._flags
	this.vis.bans = this.vis._bans
	glare.phase = 1

	::label_1080_0::

	while true do
		if this.health.dead then
			y_on_death()

			return
		end

		if this.unit.is_stunned and not this.cage_applied then
			SU.y_enemy_stun(store, this)
		else
			if check_life_threshold_stun() then
				this.vis._flags = this.vis.flags
				this.vis._bans = this.vis.bans
				this.vis.flags = bor(F_ENEMY, F_BOSS)
				this.vis.bans = bor(F_RANGED, F_BLOCK, F_MOD)
				cult_leader.boss_teleport = true
				this.ui.can_click = false
				this.ui.can_select = false
				this.health_bar.hidden = true

				SU.remove_modifiers(store, this)

				this.unit.marker_hidden = true

				S:queue(this.sound_burrow_in)
				U.y_animation_play(this, "teleportin", true, store.tick_ts)

				current_life_threshold_teleport_index = current_life_threshold_teleport_index + 1

				if current_life_threshold_teleport_index > #this.life_threshold_teleport.life_percentage then
					next_life_threshold_teleport = nil
				else
					next_life_threshold_teleport = this.life_threshold_teleport.life_percentage[current_life_threshold_teleport_index]
					megaspawner_boss.manual_wave = string.format("BOSS%i", current_life_threshold_teleport_index)
				end

				glare.phase = current_life_threshold_teleport_index

				U.y_wait(store, this.teleport_away_duration)

				this.pos = this.teleport_pos[current_life_threshold_teleport_index]

				adjust_position(this.teleport_path[current_life_threshold_teleport_index])
				S:queue(this.sound_burrow_out)
				U.y_animation_play(this, "teleportout", true, store.tick_ts)

				is_protected = true

				update_armor()

				this.health_bar.hidden = false
				this.ui.can_click = true
				this.ui.can_select = true
				this.vis.flags = this.vis._flags
				this.vis.bans = this.vis._bans
			end

			local cont, blocker, ranged = y_enemy_walk_until_blocked_cult_leader(store, this, nil, break_fn)

			if not cont and not blocker and not is_protected then
				U.y_animation_play(this, "close", true, store.tick_ts)

				is_protected = true

				update_armor()
			end

			if not cont then
				-- block empty
			else
				if blocker then
					if not y_wait_for_blocker_cult_leader(store, this, blocker) then
						goto label_1080_0
					end

					if is_protected then
						S:queue(this.sound_uncloak)
						U.animation_start(this, "open", true, store.tick_ts)
						U.y_wait(store, this.block_attack.delay)
						aoe_attack(this.block_attack.radius, this.block_attack.damage_min, this.block_attack.damage_max, this.block_attack.damage_type, this.block_attack.vis, this.block_attack.bans, this.block_attack.min_targets)
						U.y_animation_wait(this)
						U.animation_start(this, "standingidle", true, store.tick_ts, true)

						is_protected = false

						update_armor()
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not y_enemy_melee_attacks_cult_leader(store, this, blocker) then
							goto label_1080_0
						end

						if break_fn() then
							goto label_1080_0
						end

						coroutine.yield()
					end
				elseif ranged then
					while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							goto label_1080_0
						end

						coroutine.yield()
					end
				end

				coroutine.yield()
			end
		end
	end
end

scripts.controller_stage_16_overseer = {}

function scripts.controller_stage_16_overseer.update(this, store)
	if store.level_mode ~= GAME_MODE_CAMPAIGN then
		this.health.hp = 0
		this.health.dead = true
		this.ui.can_click = nil
		U.animation_start(this, "death", nil, store.tick_ts, false, 1)
		U.y_animation_wait(this, 1)
		return
	end

	this.phase = 1

	local change_phase_ts = store.tick_ts
	local change_tower_ts = store.tick_ts
	local disable_tower_ts = store.tick_ts
	local destroy_holder_last_ts = store.tick_ts
	local next_holder_to_destroy_i = 1
	local next_idle_anim_cooldown = math.random(this.idle_cooldown_min, this.idle_cooldown_max)
	local last_idle_anim_ts = store.tick_ts
	local disable_tower_cooldown, change_tower_cooldown
	local change_tower_first_time = true
	local disable_tower_first_time = true
	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_boss

	for _, value in pairs(spawners) do
		if value.load_file == "level16_spawner" then
			megaspawner_boss = value
		end
	end

	local function set_phase(new_phase)
		this.phase = new_phase
		change_phase_ts = store.tick_ts
		megaspawner_boss.manual_wave = string.format("BOSS%i", this.phase)

		if this.change_tower_cooldown[this.phase] then
			if change_tower_first_time then
				change_tower_cooldown = this.first_time_cooldown
				change_tower_first_time = false
			else
				change_tower_cooldown = this.change_tower_cooldown[this.phase]
			end
		end

		if this.disable_tower_cooldown[this.phase] then
			if disable_tower_first_time then
				disable_tower_cooldown = this.first_time_cooldown
				disable_tower_first_time = false
			else
				disable_tower_cooldown = this.disable_tower_cooldown[this.phase]
			end
		end
	end

	local function check_change_phase()
		for i, v in ipairs(this.phase_per_hp_threshold) do
			if this.health.hp <= this.health.hp_max * (this.phase_per_hp_threshold[i] / 100) and i > this.phase then
				set_phase(i)

				return
			end
		end

		if this.phase <= #this.phase_per_time and store.tick_ts - change_phase_ts >= this.phase_per_time[this.phase] then
			set_phase(this.phase + 1)

			return
		end
	end

	local function check_change_idle_anim()
		if store.tick_ts - last_idle_anim_ts >= next_idle_anim_cooldown then
			U.y_animation_play(this, this.idle_anims[math.random(1, #this.idle_anims)], nil, store.tick_ts, 1, 1)

			next_idle_anim_cooldown = math.random(this.idle_cooldown_min, this.idle_cooldown_max)
			last_idle_anim_ts = store.tick_ts
		end
	end

	local function spawn_blood()
		S:queue(this.sound_hurt)

		local blood = E:create_entity("decal_stage_16_overseer_blood")

		blood.pos = V.vclone(this.pos)
		blood.pos.y = blood.pos.y + 100

		queue_insert(store, blood)
	end

	local function check_change_damaged_state()
		local life_percentage = this.health.hp * 100 / this.health.hp_max

		if life_percentage < this.life_hurt_threshold[1] then
			if table.contains(this.render.sprites[1].exo_hide_prefix, "hurt2") then
				table.remove(this.render.sprites[1].exo_hide_prefix, 1)
				spawn_blood()
			end
		elseif life_percentage < this.life_hurt_threshold[2] and table.contains(this.render.sprites[1].exo_hide_prefix, "hurt1") then
			table.remove(this.render.sprites[1].exo_hide_prefix, 2)
			table.insert(this.render.sprites[1].exo_hide_prefix, "hurt0")
			spawn_blood()
		end
	end

	local function check_last_phase_repeat()
		if this.phase >= #this.phase_per_hp_threshold then
			local time_to_wait = megaspawner_boss.spawner_waves.BOSS6[#megaspawner_boss.spawner_waves.BOSS6][1]

			if time_to_wait <= store.tick_ts - change_phase_ts then
				megaspawner_boss.manual_wave = nil

				coroutine.yield()

				change_phase_ts = store.tick_ts
				megaspawner_boss.manual_wave = string.format("BOSS%i", this.phase)
			end
		end
	end

	U.animation_start(this, "startidle1", false, store.tick_ts, false, 1)

	for i = 1, #this.hit_point_pos do
		local h = E:create_entity(this.hit_point_template)

		h.pos = this.hit_point_pos[i]
		h.boss = this

		queue_insert(store, h)
	end

	this.idle_anims = this.idle_start_anims

	while store.wave_group_number == 0 do
		check_change_idle_anim()
		coroutine.yield()
	end

	signal.emit("boss_fight_start", this)
	S:queue(this.sound_unchain_center)
	U.animation_start(this, "startend1", nil, store.tick_ts, false, 1)
	U.y_wait(store, fts(10))
	S:queue(this.sound_rumble)

	local shake = E:create_entity("aura_screen_shake")

	shake.aura.amplitude = 0.4
	shake.aura.duration = fts(30)
	shake.aura.freq_factor = 2

	queue_insert(store, shake)
	U.y_wait(store, fts(30))

	local shake = E:create_entity("aura_screen_shake")

	shake.aura.amplitude = 0.7
	shake.aura.duration = fts(20)
	shake.aura.freq_factor = 3

	queue_insert(store, shake)
	U.y_animation_wait(this, 1)

	local start_ts = store.tick_ts

	this.idle_anims = this.idle_fight_anims
	last_idle_anim_ts = store.tick_ts

	set_phase(1)

	while true do
		if this.health.dead then
			LU.kill_all_enemies(store, true)

			megaspawner_boss.interrupt = true

			signal.emit("boss_fight_end")
			signal.emit("pan-zoom-camera", 2, {
				x = 505,
				y = 520
			}, 1.5)
			signal.emit("show-curtains")
			signal.emit("hide-gui")
			signal.emit("start-cinematic")
			U.y_wait(store, 2)
			signal.emit("boss-killed", this)
			S:queue(this.sound_death)
			U.y_animation_play(this, "deathstart", nil, store.tick_ts, 1)
			U.animation_start(this, "deathloop", nil, store.tick_ts, true, 1, true)
			U.y_wait(store, 0.5)
			signal.emit("show-balloon_tutorial", "LV16_DENAS01_BOSSFIGHT_01", false)
			U.y_wait(store, 3.5)
			S:queue(this.sound_rumble)
			U.y_animation_wait(this)

			local death_fx = E:create_entity("decal_stage_16_death_bright")

			death_fx.pos = V.vclone(this.pos)

			queue_insert(store, death_fx)
			U.animation_start(death_fx, "death", nil, store.tick_ts, 1, 1)
			U.animation_start(this, "death", nil, store.tick_ts, 1, 1)
			U.y_wait(store, 2)

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.3
			shake.aura.duration = 8
			shake.aura.freq_factor = 2.5

			queue_insert(store, shake)
			U.y_animation_wait(this)
			LU.kill_all_enemies(store, true)

			break
		end

		if this.change_tower_cooldown[this.phase] and change_tower_cooldown and change_tower_cooldown <= store.tick_ts - change_tower_ts then
			local towers = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.tower and not v.tower.blocked and v.tower.can_be_sold and v.tower.can_be_mod
			end)
			local holders = table.filter(store.entities, function(k, v)
				return v.tower and v.tower.type == "holder"
			end)

			if towers and #towers > 0 then
				towers = table.random_order(towers)

				if holders and #holders > 0 then
					holders = table.random_order(holders)
				end

				S:queue(this.sound_teleport_charge)

				local start_ts = store.tick_ts

				U.animation_start(this, "swaptowers1", false, store.tick_ts, nil, 1)

				local tower_index = 1

				towers = table.filter(store.entities, function(k, v)
					return not v.pending_removal and v.tower and not v.tower.blocked and v.tower.can_be_sold and v.tower.can_be_mod
				end)
				holders = table.filter(store.entities, function(k, v)
					return v.tower and v.tower.type == "holder"
				end)

				for i = 1, this.change_tower_amount[this.phase] do
					if tower_index <= #towers and holders and tower_index <= #holders then
						local change_tower_fx = E:create_entity(this.change_towers_template)

						change_tower_fx.pos = towers[tower_index].pos
						change_tower_fx.render.sprites[1].ts = store.tick_ts
						change_tower_fx.tween.ts = store.tick_ts

						queue_insert(store, change_tower_fx)
						signal.emit("force-tower-swap", towers[tower_index], holders[tower_index])

						local change_tower_fx = E:create_entity(this.change_towers_template)

						change_tower_fx.pos = holders[tower_index].pos
						change_tower_fx.render.sprites[1].ts = store.tick_ts
						change_tower_fx.tween.ts = store.tick_ts

						queue_insert(store, change_tower_fx)

						towers[tower_index].tower.blocked = true
						holders[tower_index].tower.blocked = true
						towers[tower_index].ui.can_click = false
						holders[tower_index].ui.can_click = false

						U.y_wait(store, this.swap_delay + 1)

						local controller = E:create_entity("controller_tower_swap_overseer")

						controller.tower_1 = towers[tower_index]
						controller.tower_2 = holders[tower_index]

						queue_insert(store, controller)
					elseif (not holders or tower_index > #holders) and #towers >= tower_index + 1 then
						local change_tower_fx = E:create_entity(this.change_towers_template)

						change_tower_fx.pos = towers[tower_index].pos
						change_tower_fx.render.sprites[1].ts = store.tick_ts
						change_tower_fx.tween.ts = store.tick_ts

						queue_insert(store, change_tower_fx)
						signal.emit("force-tower-swap", towers[tower_index], towers[tower_index + 1])

						local change_tower_fx = E:create_entity(this.change_towers_template)

						change_tower_fx.pos = towers[tower_index + 1].pos
						change_tower_fx.render.sprites[1].ts = store.tick_ts
						change_tower_fx.tween.ts = store.tick_ts

						queue_insert(store, change_tower_fx)

						towers[tower_index].tower.blocked = true
						towers[tower_index + 1].tower.blocked = true
						towers[tower_index].ui.can_click = false
						towers[tower_index + 1].ui.can_click = false

						U.y_wait(store, this.swap_delay + 1)

						local controller = E:create_entity("controller_tower_swap_overseer")

						controller.tower_1 = towers[tower_index]
						controller.tower_2 = towers[tower_index + 1]

						queue_insert(store, controller)

						tower_index = tower_index + 1
					end

					tower_index = tower_index + 1
				end

				U.y_animation_wait(this)

				last_idle_anim_ts = store.tick_ts
				change_tower_ts = start_ts
				change_tower_cooldown = this.change_tower_cooldown[this.phase]
			else
				change_tower_ts = store.tick_ts - change_tower_cooldown + fts(1) - 1e-06
			end
		end

		if this.disable_tower_cooldown[this.phase] and disable_tower_cooldown and disable_tower_cooldown <= store.tick_ts - disable_tower_ts then
			local close_towers = table.filter(store.entities, function(k, v)
				return not v.pending_removal and v.tower and not v.tower.blocked and v.tower.can_be_sold and v.tower.can_be_mod and table.contains(this.holders_close, v.tower.holder_id) and v.tower.type ~= "tower_timed_destroy"
			end)

			if #close_towers > 0 then
				table.random_order(close_towers)
				S:queue(this.sound_destroy_charge)

				if close_towers[1].tower.holder_id == this.holders_close[1] then
					U.animation_start(this, "marktower2", false, store.tick_ts, nil, 1)
				elseif close_towers[1].tower.holder_id == this.holders_close[2] then
					U.animation_start(this, "marktower3", false, store.tick_ts, nil, 1)
				elseif close_towers[1].tower.holder_id == this.holders_close[3] then
					U.animation_start(this, "marktower4", false, store.tick_ts, nil, 1)
				elseif close_towers[1].tower.holder_id == this.holders_close[4] then
					U.animation_start(this, "marktower5", false, store.tick_ts, nil, 1)
				elseif close_towers[1].tower.holder_id == this.holders_close[5] then
					U.animation_start(this, "marktower5", false, store.tick_ts, nil, 1)
				end

				U.y_wait(store, this.disable_delay)

				local mod = E:create_entity(this.disable_tower_mod)

				mod.modifier.target_id = close_towers[1].id
				mod.disable_tower_recover_price = this.disable_tower_recover_price
				mod.modifier.source_id = this.id
				mod.destroy_tower_cooldown = this.destroy_tower_cooldown

				queue_insert(store, mod)
				U.y_animation_wait(this)

				last_idle_anim_ts = store.tick_ts
				disable_tower_ts = store.tick_ts
				disable_tower_cooldown = this.disable_tower_cooldown[this.phase]
			else
				disable_tower_ts = store.tick_ts - disable_tower_cooldown + fts(1) - 1e-06
			end
		end

		if this.destroy_holder_cooldown[this.phase] ~= nil and store.tick_ts - destroy_holder_last_ts >= this.destroy_holder_cooldown[this.phase] and next_holder_to_destroy_i <= #this.holders_to_destroy then
			local holder_by_id = table.filter(store.entities, function(k, v)
				return v.tower and v.tower.holder_id == this.holders_to_destroy[next_holder_to_destroy_i]
			end)

			if holder_by_id and #holder_by_id > 0 then
				S:queue(this.sound_destroy_charge)
				U.animation_start(this, "swaptowers1", false, store.tick_ts, nil, 1)

				if holder_by_id[1].tower and holder_by_id[1].tower.can_be_sold then
					holder_by_id[1].tower.blocked = true
					holder_by_id[1].ui.can_click = false
				end

				U.y_wait(store, fts(70))
				S:queue(this.sound_destroy_ray)

				local bullet = E:create_entity(this.destroy_holders_bullet)

				bullet.pos = V.vclone(this.pos)
				bullet.pos.y = bullet.pos.y + 65
				bullet.bullet.from = V.vclone(bullet.pos)
				bullet.bullet.to = V.vclone(holder_by_id[1].pos)
				bullet.bullet.to.y = bullet.bullet.to.y + 20
				bullet.bullet.target_id = nil
				bullet.bullet.source_id = this.id

				queue_insert(store, bullet)
				U.y_wait(store, fts(2))

				local overseer_fx = E:create_entity("decal_stage_16_overseer_destroy_holder_bright")

				overseer_fx.pos = V.vclone(holder_by_id[1].pos)
				overseer_fx.render.sprites[1].ts = store.tick_ts
				overseer_fx.tween.ts = store.tick_ts

				queue_insert(store, overseer_fx)
				U.y_wait(store, fts(12))
				S:queue(this.sound_destroy_explosion)

				local holder_destroy = E:create_entity(this.destroy_holders_template)

				holder_destroy.pos = V.vclone(holder_by_id[1].pos)
				holder_destroy.render.sprites[1].ts = store.tick_ts

				queue_insert(store, holder_destroy)

				local holder_crater = E:create_entity(this.destroy_holders_crater_template)

				holder_crater.pos = V.vclone(holder_by_id[1].pos)
				holder_crater.render.sprites[1].ts = store.tick_ts

				queue_insert(store, holder_crater)
				queue_remove(store, holder_by_id[1])

				destroy_holder_last_ts = store.tick_ts
				next_holder_to_destroy_i = next_holder_to_destroy_i + 1

				local nav_mesh_patch = this.nav_mesh_patches[holder_by_id[1].ui.nav_mesh_id]

				if nav_mesh_patch then
					log.todo("fixing nav_mesh for mesh_id:%s", holder_by_id[1].ui.nav_mesh_id)

					for k, v in pairs(nav_mesh_patch) do
						store.level.nav_mesh[k] = v
					end
				end

				S:queue(this.sound_rumble)

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 0.7
				shake.aura.duration = fts(20)
				shake.aura.freq_factor = 3

				queue_insert(store, shake)
				U.y_animation_wait(this)

				last_idle_anim_ts = store.tick_ts
			end
		end

		check_change_phase()
		check_last_phase_repeat()
		check_change_damaged_state()
		check_change_idle_anim()
		coroutine.yield()
	end
end

scripts.decal_stage_16_overseer_blood = {}

function scripts.decal_stage_16_overseer_blood.update(this, store)
	for i, v in ipairs(this.blood_pos) do
		local blood = E:create_entity(this.fx_template)

		blood.pos.x, blood.pos.y = this.pos.x + v.x, this.pos.y + v.y
		blood.render.sprites[1].ts = store.tick_ts
		blood.tween.ts = store.tick_ts

		queue_insert(store, blood)
		U.y_wait(store, fts(1))
	end

	queue_remove(store, this)
end

function scripts.controller_stage_16_overseer.get_info(this)
	return {
		damage_max = 0,
		damage_min = 0,
		lives = 0,
		magic_armor = 0,
		armor = 0,
		type = STATS_TYPE_ENEMY,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_icon = this.info.damage_icon,
		immune = this.health.immune_to == DAMAGE_ALL_TYPES
	}
end

scripts.controller_stage_16_overseer_mouth_door = {}

function scripts.controller_stage_16_overseer_mouth_door.update(this, store)
	local last_check_enemy = store.tick_ts
	local is_open = false

	U.animation_start(this, "closeidle", nil, store.tick_ts, true)

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local function search_enemies_nearby()
		local targets = U.find_enemies_in_range(store.entities, this.check_pos, 0, this.check_radius, this.check_vis_flags, this.check_vis_bans, function(e)
			return e.enemy and e.health and not e.health.dead
		end)

		if targets and #targets > 0 then
			if not is_open then
				U.y_animation_wait(this)
				U.y_animation_play(this, "open", nil, store.tick_ts)
				U.animation_start(this, "openidle", nil, store.tick_ts, true, 1, true)

				is_open = true
			end
		elseif is_open then
			U.y_animation_wait(this)
			U.y_animation_play(this, "close", nil, store.tick_ts)
			U.animation_start(this, "closeidle", nil, store.tick_ts, true)

			is_open = false
		end
	end

	local start_ts = store.tick_ts

	last_check_enemy = store.tick_ts

	local last_index_processed = 0

	while true do
		if store.tick_ts - last_check_enemy >= this.check_cooldown then
			search_enemies_nearby()

			last_check_enemy = store.tick_ts
		end

		coroutine.yield()
	end
end

scripts.controller_stage_16_overseer_tentacle = {}

function scripts.controller_stage_16_overseer_tentacle.update(this, store)
	local current_phase = 1
	local can_spawn_enemies = false
	local last_shot_ts = store.tick_ts
	local overseer = table.filter(store.entities, function(k, v)
		return v.template_name == "controller_stage_16_overseer"
	end)[1]

	U.animation_start(this, "idletrapped", nil, store.tick_ts, true)

	this.tentacle_mouth = E:create_entity(this.tentacle_mouth_template)
	this.tentacle_mouth.pos = this.pos

	queue_insert(store, this.tentacle_mouth)

	while true do
		if overseer.health.dead then
			-- block empty
		elseif this.config.cooldown[overseer.phase] ~= nil then
			if not can_spawn_enemies then
				U.y_animation_wait(this)
				S:queue(this.sound_rumble)

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 0.3
				shake.aura.duration = fts(120)
				shake.aura.freq_factor = 3

				queue_insert(store, shake)
				S:queue(this.sound_unchain)
				U.y_animation_play(this, "shake", nil, store.tick_ts, 1)

				this.tentacle_mouth.anim_free = true

				U.animation_start(this, "free", nil, store.tick_ts, false, 1)
				U.y_wait(store, fts(50))
				S:queue(this.sound_rumble)

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 0.7
				shake.aura.duration = fts(10)
				shake.aura.freq_factor = 3

				queue_insert(store, shake)
				U.y_animation_wait(this)
				U.animation_start(this, "idlemouth", nil, store.tick_ts, true, 1, true)

				can_spawn_enemies = true
				last_shot_ts = store.tick_ts - this.first_cooldown
			end

			if store.tick_ts - last_shot_ts >= this.config.cooldown[overseer.phase] then
				local start_ts = store.tick_ts

				this.tentacle_mouth.anim_shot = true

				S:queue(this.sound_spawn)
				U.animation_start(this, "spawnenemies", nil, store.tick_ts, false)
				U.y_wait(store, this.shot_delay)

				local spawn_pos_i = math.random(1, #this.spawn_pos)
				local b = E:create_entity(this.bullet)

				b.pos.x, b.pos.y = this.pos.x + this.spawn_offset.x, this.pos.y + this.spawn_offset.y
				b.bullet.from = V.vclone(b.pos)
				b.bullet.to = this.spawn_pos[spawn_pos_i]
				b.bullet.source_id = this.id
				b.path_to_spawn = this.spawn_path
				b.overseer = overseer
				b.spawn_path = this.spawn_path[spawn_pos_i]

				queue_insert(store, b)
				U.y_animation_wait(this)
				U.animation_start(this, "idlemouth", nil, store.tick_ts, true, 1, true)

				last_shot_ts = start_ts
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_16_overseer_tentacle_mouth = {}

function scripts.controller_stage_16_overseer_tentacle_mouth.update(this, store)
	this.render.sprites[1].hidden = true

	while true do
		if this.anim_free then
			this.render.sprites[1].hidden = false

			U.y_animation_play(this, "free", nil, store.tick_ts, false)
			U.animation_start(this, "idlemouth", nil, store.tick_ts, true, 1, true)

			this.anim_free = nil
		end

		if this.anim_shot then
			U.y_animation_play(this, "spawnenemies", nil, store.tick_ts, false)
			U.animation_start(this, "idlemouth", nil, store.tick_ts, true, 1, true)

			this.anim_shot = nil
		end

		coroutine.yield()
	end
end

scripts.enemy_overseer_hit_point = {}

function scripts.enemy_overseer_hit_point.update(this, store)
	local going_right = math.random(0, 1) == 0
	local going_up = math.random(0, 1) == 0
	local nearest = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1
	})

	if #nearest > 0 then
		path_pi, path_spi, path_ni = unpack(nearest[1])
	end

	this.nav_path.pi = path_pi
	this.nav_path.spi = path_spi
	this.nav_path.ni = path_ni

	local npos = P:node_pos(path_pi, path_spi, path_ni)

	this.pos = npos

	local min_x = this.pos.x - this.move_bounds.x / 2
	local max_x = min_x + this.move_bounds.x
	local min_y = this.pos.y - this.move_bounds.y / 2
	local max_y = this.pos.y + this.move_bounds.y

	this.vis._bans = this.vis.bans
	this.vis.bans = bit.bor(F_ALL)

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	U.y_wait(store, fts(60))

	this.vis.bans = this.vis._bans

	local overseer = table.filter(store.entities, function(k, v)
		return v.template_name == "controller_stage_16_overseer"
	end)[1]

	while true do
		if overseer.health.dead then
			break
		end

		if going_right then
			if max_x <= this.pos.x then
				going_right = false
			else
				this.pos.x = this.pos.x + this.move_speed.x
			end
		end

		if not going_right then
			if min_x >= this.pos.x then
				going_right = true
			else
				this.pos.x = this.pos.x - this.move_speed.x
			end
		end

		if going_up then
			if max_y <= this.pos.y then
				going_up = false
			else
				this.pos.y = this.pos.y + this.move_speed.y
			end
		end

		if not going_up then
			if min_y >= this.pos.y then
				going_up = true
			else
				this.pos.y = this.pos.y - this.move_speed.y
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

function scripts.enemy_overseer_hit_point.on_damage(this, store, damage)
	local d = E:create_entity("damage")

	d.damage_type = damage.damage_type
	d.value = damage.value
	d.source_id = damage.source_id
	d.target_id = this.boss.id

	queue_damage(store, d)

	return true
end

scripts.bullet_stage_16_overseer_tentacle_spawn = {}

function scripts.bullet_stage_16_overseer_tentacle_spawn.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius

	if b.level and b.level > 0 then
		if b.damage_radius_inc then
			dradius = dradius + b.level * b.damage_radius_inc
		end

		if b.damage_min_inc then
			dmin = dmin + b.level * b.damage_min_inc
		end

		if b.damage_max_inc then
			dmax = dmax + b.level * b.damage_max_inc
		end
	end

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	local enemies = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, b.damage_bans) == 0 and band(v.vis.bans, b.damage_flags) == 0 and U.is_inside_ellipse(v.pos, b.to, dradius)
	end)

	for _, enemy in pairs(enemies) do
		local d = E:create_entity("damage")

		d.damage_type = b.damage_type
		d.reduce_armor = b.reduce_armor
		d.reduce_magic_armor = b.reduce_magic_armor

		if b.damage_decay_random then
			d.value = U.frandom(dmin, dmax)
		elseif this.up_alchemical_powder_chance and math.random() < this.up_alchemical_powder_chance or UP:get_upgrade("engineer_efficiency") then
			d.value = dmax
		else
			local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, b.to, dradius)

			d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
		end

		d.value = math.ceil(b.damage_factor * d.value)
		d.source_id = this.id
		d.target_id = enemy.id

		queue_damage(store, d)
		log.paranoid("bomb id:%s, radius:%s, enemy id:%s, dist:%s, damage:%s damage_type:%x", this.id, dradius, enemy.id, V.dist(enemy.pos.x, enemy.pos.y, b.to.x, b.to.y), d.value, d.damage_type)

		if this.up_shock_and_awe_chance and band(enemy.vis.bans, F_STUN) == 0 and band(enemy.vis.flags, bor(F_BOSS, F_CLIFF, F_FLYING)) == 0 and math.random() < this.up_shock_and_awe_chance then
			local mod = E:create_entity("mod_shock_and_awe")

			mod.modifier.target_id = enemy.id

			queue_insert(store, mod)
		end

		if b.mod then
			local mod = E:create_entity(b.mod)

			mod.modifier.target_id = enemy.id
			mod.modifier.source_id = this.id

			queue_insert(store, mod)
		end
	end

	local p = SU.create_bullet_pop(store, this)

	queue_insert(store, p)

	local cell_type = GR:cell_type(b.to.x, b.to.y)

	if b.hit_fx_water and band(cell_type, TERRAIN_WATER) ~= 0 then
		S:queue(this.sound_events.hit_water)

		local water_fx = E:create_entity(b.hit_fx_water)

		water_fx.pos.x, water_fx.pos.y = b.to.x, b.to.y
		water_fx.render.sprites[1].ts = store.tick_ts
		water_fx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, water_fx)
	elseif b.hit_fx then
		S:queue(this.sound_events.hit)

		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, sfx)
	end

	if b.hit_decal and band(cell_type, TERRAIN_WATER) == 0 then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	local enemy_template = "enemy_glareling"
	local path_pi, path_spi, path_ni

	for i = 1, this.spawn_amounts_per_phase[this.overseer.phase] do
		local enemy = E:create_entity(enemy_template)
		local enemy_pos = V.v(b.to.x + this.spawn_offset[i].x, b.to.y + this.spawn_offset[i].y)
		local nearest = P:nearest_nodes(enemy_pos.x, enemy_pos.y, {
			this.spawn_path
		}, {
			1,
			2,
			3
		})

		if #nearest > 0 then
			path_pi, path_spi, path_ni = unpack(nearest[1])
			enemy_pos = P:node_pos(path_pi, path_spi, path_ni)
		end

		enemy.pos.x, enemy.pos.y = enemy_pos.x, enemy_pos.y
		enemy.nav_path.pi = path_pi
		enemy.nav_path.spi = path_spi
		enemy.nav_path.ni = path_ni
		enemy.nav_path_data = nearest[1]

		queue_insert(store, enemy)
	end

	local soldiers = U.find_soldiers_in_range(store.entities, b.to, 0, this.explosion_damage.range, this.explosion_damage.vis_flags, this.explosion_damage.vis_bans)

	if soldiers then
		for _, soldier in pairs(soldiers) do
			local d = E:create_entity("damage")

			d.damage_type = this.explosion_damage.damage_type

			local dist_factor = U.dist_factor_inside_ellipse(soldier.pos, b.to, this.explosion_damage.range)

			d.value = math.floor(this.explosion_damage.damage_max - (this.explosion_damage.damage_max - this.explosion_damage.damage_min) * dist_factor)
			d.source_id = this.id
			d.target_id = soldier.id

			queue_damage(store, d)
		end
	end

	queue_remove(store, this)
end

scripts.mod_stage_16_overseer_tower_disable = {}

function scripts.mod_stage_16_overseer_tower_disable.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return false
	end

	target.tower._type = target.tower.type
	target.tower._prevent_timed_destroy_price = this.disable_tower_recover_price
	target.tower._prevent_timed_destroy = false
	target.tower.type = "tower_timed_destroy"
	target.tower.blocked = true

	return true
end

function scripts.mod_stage_16_overseer_tower_disable.update(this, store)
	local target = store.entities[this.modifier.target_id]
	local holder_id = target.tower.holder_id
	local holder = store.entities[holder_id]
	local overseer = table.filter(store.entities, function(k, v)
		return v.template_name == "controller_stage_16_overseer"
	end)[1]

	this.pos = target.pos

	U.animation_start(this, "spawn", nil, store.tick_ts, false, 1)
	U.animation_start(this, "spawn", nil, store.tick_ts, false, 2)
	U.y_animation_wait(this, 1)
	U.animation_start(this, "run", nil, store.tick_ts, true, 1)
	U.animation_start(this, "run", nil, store.tick_ts, true, 2)

	local start_ts = store.tick_ts

	while true do
		if target.tower._prevent_timed_destroy then
			break
		end

		if overseer.health.dead then
			break
		end

		if store.tick_ts - start_ts >= this.destroy_tower_cooldown then
			target.ui.can_click = false
			target.tower.type = target.tower._type
			target.tower.blocked = true

			U.animation_start(this, "destroytower", nil, store.tick_ts, false, 1)
			U.animation_start(this, "destroytower", nil, store.tick_ts, false, 2)
			U.y_wait(store, fts(40))

			target.tower.destroy = true

			U.y_animation_wait(this, 1)
			queue_remove(store, this)
		end

		coroutine.yield()
	end

	target.tower.type = target.tower._type
	target.tower.blocked = false

	U.y_animation_wait(this, 1)
	U.animation_start(this, "dissipate", nil, store.tick_ts, false, 1)
	U.animation_start(this, "dissipate", nil, store.tick_ts, false, 2)
	U.y_animation_wait(this, 1)
	queue_remove(store, this)
end

function scripts.mod_stage_16_overseer_tower_disable.remove(this, store)
	return true
end

scripts.controller_stage_16_overseer_eye = {}

function scripts.controller_stage_16_overseer_eye.update(this, store)
	local start_ts = store.tick_ts
	local blink_cooldown = math.random(this.blink_min_cooldown, this.blink_max_cooldown)
	local last_blink = store.tick_ts
	local overseer = table.filter(store.entities, function(k, v)
		return v.template_name == "controller_stage_16_overseer"
	end)[1]
	local damaged = false

	this.idle_anims = this.idle_not_damaged

	local function check_change_damaged_state()
		if not damaged then
			local life_percentage = overseer.health.hp * 100 / overseer.health.hp_max

			if life_percentage < this.life_hurt_threshold then
				U.y_animation_play(this, "eyehurt", nil, store.tick_ts)

				this.idle_anims = this.idle_damaged
				damaged = true
			end
		end
	end

	while true do
		if blink_cooldown <= store.tick_ts - last_blink then
			U.y_animation_play(this, this.idle_anims[math.random(1, #this.idle_anims)], nil, store.tick_ts)

			blink_cooldown = math.random(this.blink_min_cooldown, this.blink_max_cooldown)
			last_blink = store.tick_ts
		end

		check_change_damaged_state()
		coroutine.yield()
	end
end

scripts.controller_stage_16_tentacle_bottom = {}

function scripts.controller_stage_16_tentacle_bottom.update(this, store)
	local overseer = table.filter(store.entities, function(k, v)
		return v.template_name == "controller_stage_16_overseer"
	end)[1]
	local is_free = false

	while true do
		if not is_free and overseer.phase == this.phase_to_free then
			is_free = true

			S:queue(this.sound_unchain)
			U.animation_start(this, "free", nil, store.tick_ts, false, 1)
			S:queue(this.sound_rumble)

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.3
			shake.aura.duration = fts(35)
			shake.aura.freq_factor = 3

			queue_insert(store, shake)
			U.y_wait(store, fts(40))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.7
			shake.aura.duration = fts(20)
			shake.aura.freq_factor = 3

			queue_insert(store, shake)
			U.y_animation_wait(this)
			U.animation_start(this, "idle2", false, store.tick_ts, true, 1)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_16_holder_destroy_crater = {}

function scripts.decal_stage_16_holder_destroy_crater.update(this, store)
	U.y_animation_play(this, "start", nil, store.tick_ts)
	U.animation_start(this, "loop", false, store.tick_ts, true)

	while true do
		coroutine.yield()
	end
end

scripts.decal_terrain_4_cheshire_cat_easter_egg = {}

function scripts.decal_terrain_4_cheshire_cat_easter_egg.insert(this, store)
	if features.censored_cn then
		return false
	end

	return true
end

function scripts.decal_terrain_4_cheshire_cat_easter_egg.update(this, store)
	local last_ts = store.tick_ts
	local appear_cd = math.random(this.appear_cd_min, this.appear_cd_max)
	local appear_duration = math.random(this.appear_duration_min, this.appear_duration_max)
	local is_showing = false
	local tap_animation = this.animations_tap[this.level_index + 1]

	this.ui.can_click = is_showing
	this.render.sprites[1].alpha = is_showing and 255 or 0

	local function click_and_die()
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false

			S:queue(this.sound_in)
			S:queue(this.sound_out)
			U.y_animation_play(this, tap_animation, nil, store.tick_ts, 1)
			U.y_wait(store, 0.4)

			return true
		end

		return false
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	last_ts = store.tick_ts

	while true do
		if click_and_die() then
			break
		end

		if is_showing then
			if appear_duration < store.tick_ts - last_ts then
				this.ui.can_click = false

				U.y_animation_play(this, "out", nil, store.tick_ts, 1)

				is_showing = false
				last_ts = store.tick_ts
				appear_cd = math.random(this.appear_cd_min, this.appear_cd_max)
			end
		elseif appear_cd < store.tick_ts - last_ts then
			this.render.sprites[1].alpha = 255

			U.y_animation_play(this, "in", nil, store.tick_ts, 1)
			U.animation_start(this, "idle", nil, store.tick_ts, false)

			is_showing = true
			this.ui.can_click = true
			last_ts = store.tick_ts
			appear_duration = math.random(this.appear_duration_min, this.appear_duration_max)
		end

		coroutine.yield()
	end

	signal.emit("cheshine-cat-terrain4", this.level_index)
	queue_remove(store, this)
end

scripts.decal_stage20_ruperto_easter_egg = {}

function scripts.decal_stage20_ruperto_easter_egg.update(this, store)
	local last_ts = store.tick_ts
	local appear_cd = math.random(this.appear_cd_min, this.appear_cd_max)
	local random_animation = this.animations_random
	local b = E:create_entity("decal_stage20_ruperto_ruperto_easter_egg")

	b.pos = v(this.pos.x - 50, this.pos.y)

	queue_insert(store, b)

	last_ts = store.tick_ts
	appear_cd = math.random(this.appear_cd_min, this.appear_cd_max)

	while true do
		if appear_cd < store.tick_ts - last_ts then
			local anim = random_animation[math.random(1, #random_animation)]

			U.y_animation_play(this, anim, nil, store.tick_ts, 1)
			U.animation_start(this, "idle", nil, store.tick_ts, true)

			appear_cd = math.random(this.appear_cd_min, this.appear_cd_max)
			last_ts = store.tick_ts
		end

		coroutine.yield()
	end
end

scripts.controller_stage_19_mausoleum = {}

function scripts.controller_stage_19_mausoleum.update(this, store)
	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local last_wave = 0
	local start_wave_ts = store.tick_ts
	local last_index_processed = 0
	local auras = {}

	local function get_wave_data_index(current_wave_data)
		for index, wave_data in ipairs(current_wave_data) do
			if index > last_index_processed and wave_data.time_start + wave_data.duration > store.tick_ts - start_wave_ts then
				return index
			end
		end

		return nil
	end

	while true do
		if store.waves_finished then
			local found_navira = false

			while not found_navira do
				for k, v in pairs(store.entities) do
					if v.template_name == "boss_navira" then
						found_navira = true

						break
					end
				end

				U.y_wait(store, 0.5)
			end

			this.render.sprites[2].hidden = false

			U.y_animation_play(this, "on", nil, store.tick_ts, 1, 2)
			U.animation_start(this, "idle", nil, store.tick_ts, true, 2)

			while true do
				coroutine.yield()
			end
		end

		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
			last_index_processed = 0
		end

		if current_wave_data and #current_wave_data > 0 then
			local next_index_to_check = get_wave_data_index(current_wave_data)

			if next_index_to_check and next_index_to_check ~= last_index_processed then
				local wave_data = current_wave_data[next_index_to_check]

				if store.tick_ts - start_wave_ts >= wave_data.time_start then
					this.render.sprites[2].hidden = false

					U.y_animation_play(this, "on", nil, store.tick_ts, 1, 2)
					U.animation_start(this, "idle", nil, store.tick_ts, true, 2)

					local turn_off_delay = fts(45)

					U.y_wait(store, wave_data.duration + turn_off_delay)

					last_index_processed = next_index_to_check

					U.y_animation_play(this, "off", nil, store.tick_ts, 1, 2)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_18_eridan = {}

function scripts.controller_stage_18_eridan.update(this, store, script)
	local ab = this.bullet_attack

	ab.ts = store.tick_ts - ab.cooldown

	local ai = this.custom_attack

	ai.ts = store.tick_ts - ai.cooldown

	local last_shot_pos
	local taunt_ts = store.tick_ts
	local taunt_cd = math.random(this.taunts.delay_min, this.taunts.delay_max)

	local function shoot_bullet(target, flip_x)
		local target_pos, offset, tid

		if target then
			target_pos = target.pos
			offset = target.unit.hit_offset
			tid = target.id
		else
			target_pos = last_shot_pos
			target_pos.x = target_pos.x + math.random(-5, 5)
			target_pos.y = target_pos.y + math.random(-5, 5)
			offset = V.vv(0)
		end

		local b = E:create_entity(ab.bullet)
		local boffset = ab.bullet_start_offset[flip_x and 2 or 1]

		b.bullet.from = V.v(this.pos.x + boffset.x, this.pos.y + boffset.y)
		b.bullet.to = V.v(target_pos.x + offset.x, target_pos.y + offset.y)
		b.bullet.target_id = tid
		b.bullet.source_id = this.id
		b.pos = V.vclone(b.bullet.from)

		queue_insert(store, b)
		S:queue("ArrowSound")
	end

	local function find_target()
		return U.find_foremost_enemy(store.entities, this.pos, 0, ab.max_range, false, ab.vis_flags, ab.vis_bans,
			function(e, o)
				return P:nodes_to_goal(e.nav_path) > 20
			end)
	end

	while true do
		if taunt_cd < store.tick_ts - taunt_ts and store.tick_ts - ai.ts < ai.cooldown - 3 then
			if store.wave_group_number == 0 then
				y_show_taunt_set(store, this.taunts, "preparation", false)
			else
				y_show_taunt_set(store, this.taunts, "fight", false)
			end

			taunt_ts = store.tick_ts
			taunt_cd = math.random(this.taunts.delay_min, this.taunts.delay_max)
		end

		if store.tick_ts - ab.ts > ab.cooldown then
			local target, targets, pred_pos = find_target()

			if not target or not pred_pos then
				SU.delay_attack(store, ab, 0.2)

				goto label_1135_0
			end

			if target and target.health and not target.health.dead then
				ab.ts = store.tick_ts
				last_shot_pos = target.pos

				local an, af = U.animation_name_facing_point(this, ab.animation, pred_pos)

				U.animation_start(this, an, af, store.tick_ts, false)
				U.y_wait(store, ab.shoot_times[1])
				shoot_bullet(target, af)
				U.y_wait(store, ab.shoot_times[2] - ab.shoot_times[1])

				local target, targets, pred_pos = find_target()

				shoot_bullet(target, af)
				U.y_wait(store, ab.shoot_times[3] - ab.shoot_times[2])

				local target, targets, pred_pos = find_target()

				shoot_bullet(target, af)
				U.y_animation_wait(this)
				U.animation_start(this, "idle", nil, store.tick_ts, true)
			end
		elseif store.tick_ts - ai.ts > ai.cooldown then
			local target, targets, pred_pos = U.find_foremost_enemy(store.entities, this.pos, 0, ai.max_range, false,
				ai.vis_flags, ai.vis_bans, function(e, o)
				return e.health and e.health.hp < ai.hp_threshold and e.enemy and #e.enemy.blockers == 0
			end)

			if not target or not pred_pos then
				SU.delay_attack(store, ai, 0.2)

				goto label_1135_0
			end

			if target and target.health and not target.health.dead then
				ai.ts = store.tick_ts

				local start_pos = V.vclone(this.pos)
				local mod = E:create_entity(ai.mod)

				mod.modifier.target_id = target.id
				mod.modifier.source_id = this.id

				queue_insert(store, mod)

				target.health.ignore_damage = true

				U.y_wait(store, fts(1))

				target.vis.bans = F_ALL

				S:queue(this.sound_in_out)
				U.y_animation_play(this, ai.animation_start, false, store.tick_ts)

				this.pos = V.vclone(target.pos)
				this.pos.x = this.pos.x - ai.melee_slot_x
				this.render.sprites[1].z = Z_OBJECTS

				U.y_animation_play(this, ai.animation_end, false, store.tick_ts)
				S:queue(this.sound_instakill)
				U.animation_start(this, ai.animation_fight, false, store.tick_ts, false)
				U.y_wait(store, ai.hit_time)

				target.health.ignore_damage = false

				local d = E:create_entity("damage")

				d.source_id = this.id
				d.target_id = target.id
				d.pop = ai.pop
				d.pop_chance = 1
				d.damage_type = ai.damage_type

				queue_damage(store, d)
				U.y_animation_wait(this)
				S:queue(this.sound_in_out)
				U.y_animation_play(this, ai.animation_start, false, store.tick_ts)

				this.pos = start_pos
				this.render.sprites[1].z = Z_OBJECTS_COVERS + 1

				U.y_animation_play(this, ai.animation_end, false, store.tick_ts)
				U.animation_start(this, "idle", false, store.tick_ts, true)
			end
		end

		U.y_animation_wait(this)

		::label_1135_0::

		coroutine.yield()
	end
end

scripts.controller_stage_19_navira = {}

function scripts.controller_stage_19_navira.update(this, store)
	local taunt_ts = store.tick_ts
	local taunt_cd = math.random(this.taunts.delay_min, this.taunts.delay_max) + 5
	local fire_balls_ts = store.tick_ts
	local balls = {}
	local statue_hands

	for _, e in pairs(store.entities) do
		if e.template_name == "decal_stage_19_statue_hands" then
			statue_hands = e

			break
		end
	end

	local function find_tower(towers_chosen)
		local towers = {}

		for _, v in pairs(store.entities) do
			if v.tower and not v.tower.blocked and not v.tower_holder and v.tower.can_be_mod and not table.contains(towers_chosen, v) then
				table.insert(towers, v)
			end
		end

		return towers[math.random(1, #towers)]
	end

	local function shoot_fire_ball(tower, ball)
		local b = E:create_entity(this.fire_ball_bullet_t)

		b.pos = V.vclone(ball.pos)
		b.pos.y = b.pos.y + 40
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.vclone(tower.pos)
		b.bullet.target_id = tower.id
		b.bullet.source_id = this.id

		queue_insert(store, b)
	end

	local function break_fn()
		return this.start_bossfight or store.waves_finished and not LU.has_alive_enemies(store)
	end

	while not this.start_bossfight do
		coroutine.yield()

		if taunt_cd < store.tick_ts - taunt_ts and (store.wave_group_number == 0 or LU.has_alive_enemies(store)) then
			y_show_taunt_set(store, this.taunts, "pre_bossfight", false)

			taunt_ts = store.tick_ts
			taunt_cd = math.random(this.taunts.delay_min, this.taunts.delay_max)
		end

		if store.wave_group_number > 0 and LU.has_alive_enemies(store) and store.tick_ts - fire_balls_ts > this.fire_balls_cd - this.fire_balls_wait_between_balls then
			for i = 1, this.fire_balls_count do
				local ball = E:create_entity(this.fire_ball_t)
				local angle = i * 2 * math.pi / this.fire_balls_count % (2 * math.pi)

				ball.render.sprites[1].name = string.format(ball.render.sprites[1].name, i)
				ball.render.sprites[1].ts = store.tick_ts
				ball.render.sprites[1].hidden = true

				queue_insert(store, ball)
				table.insert(balls, ball)
			end

			local rot_controller = E:create_entity(this.fire_ball_rotation_controller_t)

			rot_controller.balls_count = this.fire_balls_count
			rot_controller.balls = balls
			rot_controller.center_pos = this.pos

			queue_insert(store, rot_controller)

			for _, v in pairs(balls) do
				if U.y_wait(store, this.fire_balls_wait_between_balls, break_fn) then
					goto label_1140_0
				end

				v.render.sprites[1].hidden = false

				S:queue(this.sound_fireball_spawn)
				U.y_animation_play(v, "spawn", nil, store.tick_ts)
				U.animation_start(v, "idle", nil, store.tick_ts, true)
			end

			if U.y_wait(store, this.fire_balls_wait_before_shoot, break_fn) then
				break
			end

			local towers_chosen = {}
			local tower = find_tower(towers_chosen)

			while not tower do
				if U.y_wait(store, fts(10), break_fn) then
					goto label_1140_0
				end

				tower = find_tower(towers_chosen)
			end

			U.animation_start(this, "sealofruin", nil, store.tick_ts, false)

			if U.y_wait(store, fts(50), break_fn) then
				break
			end

			S:queue(this.sound_fireball_cast)

			for _, b in pairs(balls) do
				tower = find_tower(towers_chosen)

				if tower then
					shoot_fire_ball(tower, b)
					table.insert(towers_chosen, tower)
					U.y_wait(store, this.fire_balls_wait_between_shots)
				end

				queue_remove(store, b)
			end

			queue_remove(store, rot_controller)
			U.y_animation_wait(this)
			U.animation_start(this, "idle", nil, store.tick_ts, true)

			balls = {}
			fire_balls_ts = store.tick_ts
		end
	end

	::label_1140_0::

	for _, b in pairs(balls) do
		if b then
			queue_remove(store, b)
		end
	end

	while not this.start_bossfight do
		coroutine.yield()
	end

	local fx = E:create_entity(this.hands_dust_1_t)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	local fx = E:create_entity(this.hands_dust_2_t)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	local fx = E:create_entity(this.hands_stones_1_t)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	local fx = E:create_entity(this.hands_stones_2_t)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)
	S:queue(this.sound_hands_down)
	S:queue(this.sound_hands_up)
	U.animation_start(statue_hands, "hands_shake", nil, store.tick_ts)
	U.y_animation_play(this, "shake_in", nil, store.tick_ts)
	U.y_animation_play(this, "shake_down", nil, store.tick_ts)
	U.y_animation_play(this, "shake_out", nil, store.tick_ts)

	this.ended_entrance = true
end

scripts.controller_stage_19_navira_ball_rotation = {}

function scripts.controller_stage_19_navira_ball_rotation.update(this, store)
	local rot_phase = 0

	while true do
		rot_phase = rot_phase + this.fire_ball_rot_speed * store.tick_length

		for i, t in ipairs(this.balls) do
			if t then
				local a = (i * 2 * math.pi / this.balls_count + rot_phase) % (2 * math.pi)

				t.pos = U.point_on_ellipse(this.center_pos, this.fire_ball_rot_radius, a)
			end
		end

		coroutine.yield()
	end
end

scripts.bullet_stage_19_navira_fire_ball_ray = {}

function scripts.bullet_stage_19_navira_fire_ball_ray.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target

	if b.target_id then
		target = store.entities[b.target_id]
	end

	local dest = V.vclone(b.to)

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

	s.r = angle
	s.scale.x = V.dist(dest.x, dest.y, this.pos.x, this.pos.y) / this.image_width

	U.animation_start(this, "run", nil, store.tick_ts, false)
	U.y_wait(store, b.hit_time)

	local mods_added = {}

	if target and (b.mod or b.mods) then
		local mods = b.mods or {
			b.mod
		}

		for _, mod_name in pairs(mods) do
			local m = E:create_entity(mod_name)

			m.modifier.target_id = b.target_id

			table.insert(mods_added, m)
			queue_insert(store, m)
		end
	end

	U.y_animation_wait(this)
	queue_remove(store, this)
end

scripts.mod_bullet_stage_19_navira_fire_ball_ray_stun = {}

function scripts.mod_bullet_stage_19_navira_fire_ball_ray_stun.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	SU.tower_block_inc(target)

	this.pos = target.pos

	if this.tween and not this.tween.disabled then
		this.tween.ts = store.tick_ts
	end

	U.y_animation_play(this, "start", nil, store.tick_ts)
	U.animation_start(this, "loop", nil, store.tick_ts, true)

	local start_ts = store.tick_ts

	while store.tick_ts - start_ts < m.duration do
		if this.remove then
			break
		end

		coroutine.yield()
	end

	U.y_animation_play(this, "end", nil, store.tick_ts)
	SU.tower_block_dec(target)
	queue_remove(store, this)
end

scripts.boss_navira = {}

function scripts.boss_navira.update(this, store, script)
	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_boss

	for _, value in pairs(spawners) do
		if value.load_file == "level19_spawner" then
			megaspawner_boss = value
		end
	end

	local current_phase = 1
	local is_tornado = false
	local tornado_ts

	this.corruption_ts = store.tick_ts

	local spawn_ts = store.tick_ts

	local function check_tornado_in()
		return not is_tornado and current_phase <= #this.tornado_hp_trigger and
		this.health.hp < this.tornado_hp_trigger[current_phase] * this.health.hp_max
	end

	local function check_tornado_out()
		return is_tornado and store.tick_ts - tornado_ts > this.tornado_duration
	end

	local function break_fn()
		if not this.corruption_kr5.enabled and not is_tornado and store.tick_ts - this.corruption_ts > this.corruption_kr5.cooldown then
			this.corruption_kr5.enabled = true
		end

		return check_tornado_in() or check_tornado_out()
	end

	local function shoot_fire_ball(target, offset_y, flip_y)
		local b = E:create_entity(this.fire_ball_bullet_t)

		b.pos = V.vclone(this.pos)
		b.pos.y = b.pos.y + offset_y
		b.bullet.from = V.vclone(b.pos)

		if target.id then
			b.bullet.to = V.vclone(target.pos)
			b.bullet.target_id = target.id
		else
			b.bullet.to = V.vclone(target)
			b.bullet.target_id = nil
		end

		b.bullet.source_id = this.id

		if flip_y then
			b.render.sprites[1].scale = V.v(1, -1)
		end

		queue_insert(store, b)
	end

	local function y_on_death()
		LU.kill_all_enemies(store, true)
		S:stop_all()

		megaspawner_boss.interrupt = true

		if is_tornado then
			S:queue(this.sound_transform_out)
			queue_remove(store, this.tornado_aura)
			U.y_animation_play(this, "tornadoend", nil, store.tick_ts)
		end

		S:queue(this.sound_death)
		U.animation_start(this, "death", nil, store.tick_ts, false)

		local x_mult = this.render.sprites[1].flip_x and -1 or 1

		shoot_fire_ball(V.v(this.pos.x + 100 * x_mult, this.pos.y + 100), 25)
		U.y_wait(store, fts(32))
		shoot_fire_ball(V.v(this.pos.x - 70 * x_mult, this.pos.y + 120), 25)
		U.y_wait(store, fts(18))
		shoot_fire_ball(V.v(this.pos.x, this.pos.y + 160), 25)
		U.y_wait(store, fts(61))
		shoot_fire_ball(V.v(this.pos.x - 20 * x_mult, this.pos.y + 160), 0)

		local delays = {
			9,
			7,
			5,
			5,
			3,
			2,
			2,
			2,
			2
		}

		for i = 1, #delays do
			U.y_wait(store, fts(delays[i]))
			shoot_fire_ball(V.v(this.pos.x + math.random(-70, 70), this.pos.y + math.random(120, 160)), 0,
				math.random(1, 2) > 1)
		end

		U.y_animation_wait(this)
		LU.kill_all_enemies(store, true)
		signal.emit("boss-killed", this)

		this.bossfight_ended = true
	end

	local function find_tower(towers_chosen)
		local towers = {}

		for _, v in pairs(store.entities) do
			if v.tower and v.tower.can_be_mod and not v.tower.blocked and not v.tower_holder and not table.contains(towers_chosen, v) then
				table.insert(towers, v)
			end
		end

		return towers[math.random(1, #towers)]
	end

	local function tornado_in()
		S:queue(this.sound_transform_in)

		current_phase = current_phase + 1

		U.y_animation_play(this, "tornadoin", nil, store.tick_ts)
		U.animation_start(this, "tornadoloop", nil, store.tick_ts, true)

		this.render.sprites[1].angles.walk = {
			"tornadoloop",
			"tornadoloop"
		}
		tornado_ts = store.tick_ts
		is_tornado = true

		U.unblock_all(store, this)

		this.vis._bans = this.vis.bans
		this.vis.bans = bor(F_BLOCK, F_STUN)
		this.motion.max_speed = this.motion.max_speed * this.tornado_speed_mult
		this.health_bar._offset_y = this.health_bar.offset.y
		this.health_bar.offset.y = 115
		this.tornado_aura = E:create_entity(this.tornado_aura_t)
		this.tornado_aura.aura.source_id = this.id

		queue_insert(store, this.tornado_aura)

		this.corruption_kr5.enabled = false
	end

	local function tornado_out()
		S:queue(this.sound_transform_out)
		U.animation_start(this, "tornadoend", nil, store.tick_ts, false)
		U.y_wait(store, fts(18))

		local towers_chosen = {}
		local balls = this.tornado_balls_count[current_phase - 1]

		for i = 1, balls do
			local tower = find_tower(towers_chosen)

			if tower then
				shoot_fire_ball(tower, 80)
				table.insert(towers_chosen, tower)
			end

			U.y_wait(store, fts(10 / balls))
		end

		U.y_animation_wait(this)
		U.animation_start(this, "idle", nil, store.tick_ts, true)

		is_tornado = false
		this.render.sprites[1].angles.walk = {
			"idle",
			"idle"
		}
		this.vis.bans = this.vis._bans
		this.motion.max_speed = this.motion.max_speed / this.tornado_speed_mult
		this.health_bar.offset.y = this.health_bar._offset_y

		queue_remove(store, this.tornado_aura)

		this.corruption_kr5.enabled = true
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true)
	U.y_wait(store, 2)

	this.tween.disabled = true

	signal.emit("boss_fight_start", this)

	megaspawner_boss.manual_wave = "BOSS"

	while true do
		if this.health.dead then
			y_on_death()

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		elseif check_tornado_out() then
			tornado_out()
		elseif check_tornado_in() then
			tornado_in()
		else
			if this.render.sprites[1].z >= Z_OBJECTS_COVERS and store.tick_ts - spawn_ts > 5 then
				this.render.sprites[1].z = Z_OBJECTS
			end

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this, nil, break_fn)

			if not cont then
				-- block empty
			elseif not blocker or not SU.y_wait_for_blocker(store, this, blocker) then
				-- block empty
			else
				while SU.can_melee_blocker(store, this, blocker) do
					if not SU.y_enemy_melee_attacks(store, this, blocker) then
						break
					end

					coroutine.yield()
				end
			end
		end

		coroutine.yield()
	end
end

function scripts.boss_navira.on_corrupt(this, store)
	if not this.corruption_kr5.enabled then
		return
	end

	this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + this.corruption_kr5.hp)
	this.corruption_kr5.enabled = false
	this.corruption_ts = store.tick_ts

	local m = E:create_entity(this.mod_heal)

	m.modifier.target_id = this.id

	queue_insert(store, m)
end

scripts.controller_terrain_4_animated_armor_achievement = {}

function scripts.controller_terrain_4_animated_armor_achievement.update(this, store)
	while not store.waves_finished or LU.has_alive_enemies(store) do
		coroutine.yield()
	end

	if this.revived == 0 then
		signal.emit("no-anim-armored-respawn", nil)
	end
end

scripts.decal_stage_21_falling_rocks = {}

function scripts.decal_stage_21_falling_rocks.update(this, store, script)
	this.render.sprites[2].pos = V.vclone(this.fall_position)
	this.render.sprites[2].scale = V.vv(this.damage_radius / 60)

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			this.render.sprites[1].name = this.render.sprites[1].name_fallen

			local targets = U.find_enemies_in_range(store.entities, this.fall_position, 0, this.damage_radius, this.vis_flags, this.vis_bans)

			if targets then
				for _, t in pairs(targets) do
					local d = E:create_entity("damage")

					d.damage_type = this.damage_type

					local dist_factor = U.dist_factor_inside_ellipse(t.pos, this.fall_position, this.damage_radius)

					d.value = math.floor(this.damage * dist_factor)
					d.source_id = this.id
					d.target_id = t.id

					queue_damage(store, d)
				end
			end

			this.render.sprites[2].hidden = false

			local start_ts = store.tick_ts
			local wait_time = 0.6

			while wait_time > store.tick_ts - start_ts do
				local alpha_val = (1 - (store.tick_ts - start_ts) / wait_time) * 255

				this.render.sprites[2].alpha = alpha_val

				coroutine.yield()
			end

			this.render.sprites[2].hidden = true
		end

		coroutine.yield()
	end
end

scripts.decal_stage_22_rune_rock = {}

function scripts.decal_stage_22_rune_rock.update(this, store, script)
	while true do
		if this.boss_eating then
			U.y_animation_play(this, this.animation_start, nil, store.tick_ts)
			U.animation_start(this, this.animation_loop, nil, store.tick_ts, true)

			while this.boss_eating do
				coroutine.yield()
			end

			U.y_animation_play(this, this.animation_end, nil, store.tick_ts)
			U.animation_start(this, this.animation_idle, nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_22_remolino = {}

function scripts.decal_stage_22_remolino.update(this, store, script)
	local wave_index = 0
	local run_this_wave = false
	local wave_start_ts = store.tick_ts
	local interval_index = 1
	local wave_config = {}
	local on_boss_wave = false
	local waves_mode = this.waves[store.level_mode]
	local FROM = 1
	local TO = 2

	while true do
		if wave_index ~= store.wave_group_number or this.start_wave_boss then
			wave_index = store.wave_group_number

			if this.start_wave_boss then
				wave_config = waves_mode.BOSS
			else
				wave_config = waves_mode[store.wave_group_number]
			end

			run_this_wave = wave_config and #wave_config > 0
			wave_start_ts = store.tick_ts
			interval_index = 1
			this.start_wave_boss = false
		end

		if run_this_wave and store.tick_ts >= wave_start_ts + wave_config[interval_index][FROM] then
			this.render.sprites[1].hidden = false

			U.y_animation_play(this, this.animation_start, nil, store.tick_ts)
			U.animation_start(this, this.animation_loop, nil, store.tick_ts, true)
			U.y_wait(store, wave_config[interval_index][TO] - wave_config[interval_index][FROM])
			U.y_animation_wait(this)
			U.y_animation_play(this, this.animation_end, nil, store.tick_ts)

			this.render.sprites[1].hidden = true
			interval_index = interval_index + 1

			if interval_index > #wave_config then
				run_this_wave = false
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_22_boss_crocs = {}

function scripts.controller_stage_22_boss_crocs.update(this, store)
	local previous_wave_index = store.wave_group_number
	local run_this_wave = false
	local cooldown = 0
	local max_casts = 99
	local casts = 0
	local next_ts = store.tick_ts
	local taunt_index = 1
	local idle_anim_next_ts = store.tick_ts

	local function update_idle_anim_next_ts()
		idle_anim_next_ts = store.tick_ts + this.idle_anims_min_cd + (this.idle_anims_max_cd - this.idle_anims_min_cd) * math.random()
	end

	update_idle_anim_next_ts()
	U.animation_start(this, this.default_idle, nil, store.tick_ts, true, 1, true)

	local function get_towers_to_eat()
		-- local all_towers = table.filter(store.entities, function(k, v)
		-- 	local is_tower = v.tower and not v.pending_removal and (not this.excluded_templates or not table.contains(this.excluded_templates, v.template_name)) and v.vis and band(v.vis.flags, this.vis_bans) == 0 and band(v.vis.bans, this.vis_flags) == 0 and (not this.exclude_tower_kind or not table.contains(this.exclude_tower_kind, v.tower.kind)) and v.tower.can_be_mod and not U.has_modifiers(store, v, "mod_stage_22_tower_destroyed")

		-- 	return is_tower
		-- end)
		-- local priority_towers

		-- if all_towers and #all_towers > 0 then
		-- 	priority_towers = table.filter(all_towers, function(k, v)
		-- 		return not table.contains(this.low_priority_holders, v.tower.holder_id)
		-- 	end)
		-- end

		-- if priority_towers and #priority_towers > 0 then
		-- 	return priority_towers
		-- else
		-- 	return all_towers
		-- end
		local towers = table.filter(store.entities, function(k, v)
			local is_tower = v.tower and not v.pending_removal and (not this.excluded_templates or not table.contains(this.excluded_templates, v.template_name)) and v.vis and band(v.vis.flags, this.vis_bans) == 0 and band(v.vis.bans, this.vis_flags) == 0 and (not this.exclude_tower_kind or not table.contains(this.exclude_tower_kind, v.tower.kind)) and v.tower.can_be_mod

			return is_tower
		end)

		return towers
	end

	while true do
		if previous_wave_index ~= store.wave_group_number then
			previous_wave_index = store.wave_group_number
			run_this_wave = false

			for i, v in ipairs(this.waves) do
				if store.wave_group_number == v then
					run_this_wave = true
					cooldown = this.cooldown[i]
					casts = 0
					max_casts = this.max_casts[i]
					next_ts = store.tick_ts + this.first_cooldown[i]

					break
				end
			end
		end

		if run_this_wave and casts < max_casts and not this.eat_towers_disabled and next_ts <= store.tick_ts then
			casts = casts + 1

			local towers = get_towers_to_eat()

			if towers and #towers > 0 then
				U.animation_start(this, this.skill_anim, nil, store.tick_ts, false)

				for _, e in pairs(store.entities) do
					if e.template_name == "tower_stage_22_arborean_mages" then
						e.boss_is_going_to_eat = true

						break
					end
				end

				U.y_wait(store, fts(10))
				S:queue(this.sound_release_arm_cinematic)
				U.y_wait(store, fts(55))

				for _, e in pairs(store.entities) do
					if e.template_name == "decal_stage_22_rune_rock" or e.template_name == "decal_stage_22_rune_doors" then
						e.boss_eating = true
					end

					if e.template_name == "tower_stage_22_arborean_mages" then
						e.boss_eating = true
					end
				end

				U.y_wait(store, fts(22))

				towers = get_towers_to_eat()

				if towers and #towers > 0 then
					towers = table.random_order(towers)

					local twr = towers[1]
					local mods_in_tower = table.filter(store.entities, function(_, ee)
						return ee.modifier and ee.modifier.target_id == twr.id
					end)

					for _, mod_in_tower in pairs(mods_in_tower) do
						queue_remove(store, mod_in_tower)
					end

					local mod = E:create_entity(this.mod)

					mod.modifier.target_id = twr.id
					mod.modifier.source_id = this.id
					mod.use_secondary_anim = true
					mod.muted = true

					queue_insert(store, mod)
				end

				U.y_wait(store, fts(2))

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 1.5
				shake.aura.duration = 2
				shake.aura.freq_factor = 2

				queue_insert(store, shake)
				U.y_wait(store, fts(98))
				S:queue(this.sound_catch_arm)
				U.y_wait(store, fts(30))

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 1
				shake.aura.duration = 1
				shake.aura.freq_factor = 2

				queue_insert(store, shake)
				U.y_animation_wait(this)
				U.animation_start(this, this.default_idle, nil, store.tick_ts, true, 1, true)

				next_ts = store.tick_ts + cooldown

				U.y_wait(store, 0.5)
				signal.emit("show-balloon_tutorial", "LV22_BOSS_BEFORE_FIGHT_EAT_0" .. taunt_index, false)
				U.y_wait(store, 3.5)
				signal.emit("show-balloon_tutorial", "LV22_MAGE_BEFORE_FIGHT_RESPONSE_0" .. taunt_index, false)

				taunt_index = taunt_index + 1

				if taunt_index > this.taunt_keys_amount then
					taunt_index = 1
				end

				update_idle_anim_next_ts()
			else
				next_ts = store.tick_ts + cooldown
			end
		end

		if this.start_cinematic_eat then
			this.start_cinematic_eat = false

			local towers = get_towers_to_eat()

			U.animation_start(this, this.skill_anim, nil, store.tick_ts, false)
			U.y_wait(store, fts(10))
			S:queue(this.sound_release_arm_cinematic)
			U.y_wait(store, fts(55))

			for _, e in pairs(store.entities) do
				if e.template_name == "decal_stage_22_rune_rock" or e.template_name == "decal_stage_22_rune_doors" then
					e.boss_eating = true
				end

				if e.template_name == "tower_stage_22_arborean_mages" then
					e.appear = true
					e.boss_eating = true
				end
			end

			U.y_wait(store, fts(22))

			if towers and #towers > 0 then
				towers = table.random_order(towers)

				local twr = towers[1]
				local mod = E:create_entity(this.mod)

				mod.modifier.target_id = twr.id
				mod.modifier.source_id = this.id
				mod.use_secondary_anim = true
				mod.muted = true

				queue_insert(store, mod)
			end

			U.y_wait(store, fts(2))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 2.5
			shake.aura.duration = 2
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
			U.y_wait(store, fts(98))
			S:queue(this.sound_catch_arm)
			U.y_wait(store, fts(30))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 1
			shake.aura.duration = 1
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
			U.y_animation_wait(this)
			U.animation_start(this, this.default_idle, nil, store.tick_ts, true, 1, true)

			next_ts = store.tick_ts + cooldown

			update_idle_anim_next_ts()

			this.cinematic_eat_finished = true
		end

		if idle_anim_next_ts < store.tick_ts then
			local random_idle = table.random(this.idle_anims)

			U.y_animation_wait(this, 1, this.render.sprites[1].runs + 1)
			U.y_animation_play(this, random_idle, nil, store.tick_ts)
			U.animation_start(this, this.default_idle, nil, store.tick_ts, true, 1, true)
			update_idle_anim_next_ts()
		end

		if this.do_exit then
			U.y_animation_wait(this, 1, this.render.sprites[1].runs + 1)
			S:queue(this.sound_set_free)
			U.y_animation_play(this, this.anim_exit, nil, store.tick_ts)

			this.finished = true

			while not this.rocks_fall do
				coroutine.yield()
			end

			U.animation_start(this, "bossFight", nil, store.tick_ts, true, 1, true)

			return
		end

		coroutine.yield()
	end
end

scripts.mod_boss_crocs_tower_timed_destroy = {}

function scripts.mod_boss_crocs_tower_timed_destroy.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	if not target then
		return false
	end

	target.tower._type = target.tower.type
	target.tower._prevent_timed_destroy_price = this._prevent_timed_destroy_price
	target.tower._prevent_timed_destroy = false
	target.tower.type = "tower_timed_destroy"

	local was_clickeable = target.ui.can_click

	SU.tower_block_inc(target)

	if this.can_prevent_destroy then
		target.ui.can_click = was_clickeable
	end

	return true
end

function scripts.mod_boss_crocs_tower_timed_destroy.update(this, store)
	local target = store.entities[this.modifier.target_id]
	local holder_id = target.tower.holder_id
	local holder = store.entities[holder_id]

	local function find_boss_id()
		local boss_table = table.filter(store.entities, function(k, v)
			return v.boss_crocs_level ~= nil
		end)

		if not boss_table or #boss_table < 1 then
			return nil
		else
			return boss_table[1].id
		end
	end

	local boss_id = find_boss_id()
	local ignore_boss = boss_id == nil

	local function is_boss_alive()
		if not boss_id or not store.entities[boss_id] then
			boss_id = find_boss_id()
		end

		if not boss_id or store.entities[boss_id].health.dead then
			return false
		else
			return true
		end
	end

	this.pos = target.pos

	U.animation_start(this, "spawn", nil, store.tick_ts, false, 1)
	U.animation_start(this, "spawn", nil, store.tick_ts, false, 2)
	U.y_animation_wait(this, 1)
	U.animation_start(this, "run", nil, store.tick_ts, true, 1)
	U.animation_start(this, "run", nil, store.tick_ts, true, 2)

	local arborean_mage_towers_ids = {}

	for _, e in pairs(store.entities) do
		if e.template_name == "tower_stage_22_arborean_mages" then
			table.insert(arborean_mage_towers_ids, e.id)
		end
	end

	local start_ts = store.tick_ts

	while true do
		if not this.can_prevent_destroy then
			if target.tower._prevent_timed_destroy then
				break
			end

			if target.ui.can_click and this.needs_arborean_mages_to_clean then
				local found_arborean_tower = false

				for _, v in pairs(arborean_mage_towers_ids) do
					if store.entities[v] and not store.entities[v].health.dead then
						found_arborean_tower = true

						break
					end
				end

				if not found_arborean_tower then
					target.ui.can_click = false
				end
			end
		end

		if not ignore_boss and not is_boss_alive() then
			break
		end

		if store.tick_ts - start_ts >= this.destroy_tower_cooldown then
			target.ui.can_click = false
			target.tower.type = target.tower._type
			target.tower.blocked = true

			U.animation_start(this, "destroytower", nil, store.tick_ts, false, 1)
			U.animation_start(this, "destroytower", nil, store.tick_ts, false, 2)
			U.y_wait(store, fts(40))

			target.tower.destroy = true

			U.y_animation_wait(this, 1)
			queue_remove(store, this)
		end

		coroutine.yield()
	end

	target.tower.type = target.tower._type

	SU.tower_block_dec(target)
	U.y_animation_wait(this, 1)
	U.animation_start(this, "dissipate", nil, store.tick_ts, false, 1)
	U.animation_start(this, "dissipate", nil, store.tick_ts, false, 2)
	U.y_animation_wait(this, 1)
	queue_remove(store, this)
end

function scripts.mod_boss_crocs_tower_timed_destroy.remove(this, store)
	return true
end

scripts.mod_stage_22_tower_destroyed = {}

function scripts.mod_stage_22_tower_destroyed.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	if target.tower and not target.tower._type then
		target.tower._type = target.tower.type
		target.tower.type = "tower_broken_stage_22"
		target.trigger_deselect = true
		target.repair = {}
		target.repair.cost = this.repair_cost
		target.repair.active = false

		if not target.user_selection then
			E:add_comps(target, "user_selection")
		end

		if target.ui then
			this._ui_click_rect = table.deepclone(target.ui.click_rect)
			target.ui.click_rect = table.deepclone(this.click_rect)
		end

		this._menu_offset = V.vclone(target.tower.menu_offset)
		target.tower.menu_offset = V.vclone(this.menu_offset)
		this._can_be_sold = target.tower.can_be_sold
		target.tower.can_be_sold = false
	end

	this.pos = target.pos

	if target.ui and target.tower.block_count <= 1 then
		target.ui.can_click = true
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_exo)

	local start_ts = store.tick_ts
	local tap_ts = store.tick_ts
	local hand
	local hand_times = 0
	local hand_times_max = store.has_restored_destroyed_tower and 0 or 3

	if store.wave_group_number == 0 then
		tap_ts = tap_ts + 12
	end

	while true do
		if target.user_selection and target.user_selection.in_progress and not target.repair.active then
			target.user_selection.in_progress = nil
			target.user_selection.allowed = false
			store.player_gold = store.player_gold - target.repair.cost
			target.repair.active = true
			target.ui.can_click = false

			break
		end

		if store.tick_ts - tap_ts > 4 and hand_times < hand_times_max then
			tap_ts = store.tick_ts
			hand_times = hand_times + 1
			hand = E:create_entity(this.hand_decal_t)
			hand.pos = this.pos
			hand.render.sprites[1].ts = store.tick_ts
			hand.tween.ts = store.tick_ts

			queue_insert(store, hand)
		end

		coroutine.yield()
	end

	target.user_selection.allowed = true
	store.has_restored_destroyed_tower = true

	if hand then
		queue_remove(store, hand)
	end

	S:queue(this.sound_restore)
	U.animation_start(this, "run", nil, store.tick_ts, false, this.render.sid_exo)
	U.y_wait(store, fts(44))

	target = store.entities[m.target_id]

	if target then
		target.tower.type = target.tower._type
		target.tower._type = nil

		for _, i in pairs(this.hidden_sprites) do
			target.render.sprites[i].hidden = false
		end

		for _, id in pairs(this.hidden_particles) do
			local ps = store.entities[id]

			if ps then
				ps.particle_system.emit = true
			end
		end

		if not this.skip_all_modifiers then
			SU.show_modifiers(store, target, true, this.skip_modifier)
		end

		if not this.skip_all_auras then
			SU.show_auras(store, target, true, this.skip_aura)
		end

		SU.tower_block_dec(target)

		if this._ui_click_rect then
			target.ui.click_rect = table.deepclone(this._ui_click_rect)
			this._ui_click_rect = nil
		end

		target.tower.menu_offset = V.vclone(this._menu_offset)
		this._menu_offset = nil
		target.tower.can_be_sold = this._can_be_sold
		this._can_be_sold = nil
	end

	while not U.animation_finished(this, this.render.sid_exo) do
		U.sprites_hide(this, this.render.sid_holder, this.render.sid_flag, true)
		coroutine.yield()
	end

	target.trigger_deselect = nil

	queue_remove(store, this)
end

scripts.mod_hide_tower = {}

function scripts.mod_hide_tower.insert(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if not target then
		return false
	end

	this.hidden_sprites = {}

	for i, spr in ipairs(target.render.sprites) do
		if spr.hidden then
			-- block empty
		elseif table.contains(this.skip_sprite_index, i) then
			-- block empty
		else
			local tower_specific_indexes = this.skip_sprite_index[target.tower.type]

			if tower_specific_indexes and table.contains(tower_specific_indexes, i) then
				-- block empty
			else
				table.insert(this.hidden_sprites, i)

				spr.hidden = true
			end
		end
	end

	this.hidden_particles = {}

	for k, v in pairs(store.entities) do
		if v.particle_system and v.particle_system.track_id == m.target_id and v.particle_system.emit then
			table.insert(this.hidden_particles, v.id)

			v.particle_system.emit = false
		end
	end

	if not this.skip_all_modifiers then
		if not this.skip_hide_modifier_self then
			table.insert(this.skip_modifiers, this.template_name)
		end

		local mods = table.filter(store.entities, function(k, v)
			return v.modifier and v.modifier.target_id == target.id and not table.contains(this.skip_modifiers, v.template_name)
		end)

		for _, m in pairs(mods) do
			U.sprites_hide(m, nil, nil, true)
		end
	end

	if not this.skip_all_auras then
		SU.hide_auras(store, target, true, this.skip_aura)
	end

	if this.handle_stun then
		SU.tower_block_inc(target)
	end

	return true
end

function scripts.mod_hide_tower.remove(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]

	if target then
		for _, i in pairs(this.hidden_sprites) do
			target.render.sprites[i].hidden = false
		end

		for _, id in pairs(this.hidden_particles) do
			local ps = store.entities[id]

			if ps then
				ps.particle_system.emit = true
			end
		end

		if not this.skip_all_modifiers then
			local mods = table.filter(store.entities, function(k, v)
				return v.modifier and v.modifier.target_id == target.id and not table.contains(this.skip_modifiers, v.template_name)
			end)

			for _, m in pairs(mods) do
				U.sprites_show(m, nil, nil, true)
			end
		end

		if not this.skip_all_auras then
			SU.show_auras(store, target, true, this.skip_aura)
		end

		if this.handle_stun then
			SU.tower_block_dec(target)
		end
	end

	return true
end

scripts.controller_stage_29_spider_holders = {}

function scripts.controller_stage_29_spider_holders.update(this, store)
	local previous_wave_index = store.wave_group_number
	local run_this_wave = false
	local cooldown = 0
	local max_casts = 99
	local casts = 0
	local next_ts = store.tick_ts

	this.render.sprites[1].hidden = true
	this.waves = this.waves[store.level_mode] and this.waves[store.level_mode] or this.waves[GAME_MODE_CAMPAIGN]
	this.first_cooldown = this.first_cooldown[store.level_mode] and this.first_cooldown[store.level_mode] or this.first_cooldown[GAME_MODE_CAMPAIGN]
	this.cooldown = this.cooldown[store.level_mode] and this.cooldown[store.level_mode] or this.cooldown[GAME_MODE_CAMPAIGN]
	this.max_casts = this.max_casts[store.level_mode] and this.max_casts[store.level_mode] or this.max_casts[GAME_MODE_CAMPAIGN]
	this.game_start_blocked_holders = this.game_start_blocked_holders[store.level_mode] and this.game_start_blocked_holders[store.level_mode] or this.game_start_blocked_holders[GAME_MODE_CAMPAIGN]

	local taps_count = 0
	local shown_hand = false

	local function check_tap()
		if taps_count >= this.taps_to_cancel then
			return
		end

		if this.ui.clicked then
			this.ui.clicked = nil
			taps_count = taps_count + 1

			if taps_count >= this.taps_to_cancel then
				return "canceled"
			else
				return "clicked"
			end
		end
	end

	local function get_holders_to_block()
		local visible_center_x = game.camera.x / game.game_scale
		local left = visible_center_x < REF_W / 2
		local holders = table.filter(store.entities, function(k, v)
			local is_holder = v.tower_holder and not v.tower_holder.blocked and not v.tower.blocked and (left and v.pos.x <= REF_W / 2 or not left and v.pos.x > REF_W / 2) and (not v.vis or band(v.vis.bans, F_STUN) == 0)

			return is_holder
		end)

		return holders
	end

	local function replace_holder(store, hldr, new_hldr, select_new)
		local th = E:create_entity(new_hldr)

		th.pos = V.vclone(hldr.pos)
		th.tower.holder_id = hldr.tower.holder_id
		th.tower.flip_x = hldr.tower.flip_x

		if hldr.tower.default_rally_pos then
			th.tower.default_rally_pos = hldr.tower.default_rally_pos
		end

		if hldr.tower.terrain_style then
			th.tower.terrain_style = hldr.tower.terrain_style
		end

		if th.ui and hldr.ui then
			th.ui.nav_mesh_id = hldr.ui.nav_mesh_id
		end

		queue_insert(store, th)
		queue_remove(store, hldr)
		signal.emit("tower-removed", hldr, th, select_new)

		return th
	end

	local holders_to_block_game_start = table.filter(store.entities, function(k, v)
		local is_holder = v.tower_holder and not v.tower_holder.blocked and not v.tower.blocked and (not v.vis or band(v.vis.bans, F_STUN) == 0) and table.contains(this.game_start_blocked_holders, v.tower.holder_id)

		return is_holder
	end)

	for _, v in pairs(holders_to_block_game_start) do
		replace_holder(store, v, "tower_holder_blocked_spiders")
	end

	local new_hldr
	local buy_tower = false
	local flag

	while true do
		if previous_wave_index ~= store.wave_group_number then
			previous_wave_index = store.wave_group_number
			run_this_wave = false

			for i, v in ipairs(this.waves) do
				if store.wave_group_number == v then
					run_this_wave = true
					cooldown = this.cooldown[i]
					casts = 0
					max_casts = this.max_casts[i]
					next_ts = store.tick_ts + this.first_cooldown[i]

					break
				end
			end
		end

		if run_this_wave and casts < max_casts and next_ts <= store.tick_ts then
			local holders = get_holders_to_block()

			if holders and #holders > 0 then
				casts = casts + 1
				next_ts = store.tick_ts + cooldown
				holders = table.random_order(holders)

				local hldr = holders[1]

				taps_count = 0

				for i = 1, this.threads_amount do
					this.render.sprites[i + 1].hidden = false
					this.render.sprites[i + 1].name = table.random(this.threads_idles)
				end

				this.pos = V.v(hldr.pos.x, REF_H + 50)
				this.render.sprites[1].hidden = false

				U.animation_start(this, "climb_down", nil, store.tick_ts, true, 1)

				local start_ts = store.tick_ts
				local phase

				repeat
					if not table.contains(store.entities, hldr) then
						goto label_1545_0
					end

					phase = (store.tick_ts - start_ts) / this.time_to_down
					this.pos.y = U.ease_value(REF_H + 100, hldr.pos.y + 80, phase, "quad")

					coroutine.yield()
				until phase >= 1

				U.animation_start(this, "arrive", nil, store.tick_ts, false, 1)

				while not U.animation_finished(this, 1) do
					if not table.contains(store.entities, hldr) then
						buy_tower = true

						goto label_1545_1
					end

					coroutine.yield()
				end

				hldr.ui.can_click = false
				hldr.tower.blocked = true

				S:queue(this.sound_loop)
				U.animation_start(this, "netting", nil, store.tick_ts, true, 1)

				flag = E:create_entity("tower_holder_pre_blocked_spiders")
				flag.pos = V.vclone(hldr.pos)

				queue_insert(store, flag)
				U.y_wait(store, fts(1))

				start_ts = store.tick_ts

				while store.tick_ts - start_ts < this.time_netting do
					if not shown_hand then
						shown_hand = true

						local hand = E:create_entity(this.hand_decal_t)

						hand.pos = V.vclone(hldr.pos)
						hand.render.sprites[1].ts = store.tick_ts
						hand.tween.ts = store.tick_ts

						queue_insert(store, hand)
					end

					local status = check_tap()

					if status == "canceled" then
						S:stop(this.sound_loop)
						S:queue(this.sound_death)

						buy_tower = true

						goto label_1545_1
					end

					if status == "clicked" then
						-- block empty
					end

					coroutine.yield()
				end

				if flag then
					queue_remove(store, flag)

					flag = nil
				end

				new_hldr = replace_holder(store, hldr, "tower_holder_blocked_spiders")

				::label_1545_0::

				S:stop(this.sound_loop)
				U.animation_start(this, "climb_up_start", nil, store.tick_ts, false, 1)
				U.y_animation_wait(this, 1)
				U.animation_start(this, "climbing_up_idle", nil, store.tick_ts, true, 1)
				U.y_ease_key(store, this.pos, "y", this.pos.y, REF_H + 100, this.time_to_up, "quad")

				::label_1545_1::

				if buy_tower then
					buy_tower = false
					hldr.ui.can_click = true
					hldr.tower.blocked = false

					if flag then
						queue_remove(store, flag)

						flag = nil
					end

					U.animation_start(this, "explode", nil, store.tick_ts, false, 1)
					U.y_wait(store, fts(5))
				end

				for i = 2, #this.render.sprites do
					local s = this.render.sprites[i]

					s.name = "dissolve"
					s.ts = store.tick_ts
				end

				U.y_animation_wait(this, 1)

				this.render.sprites[1].hidden = true
			else
				next_ts = store.tick_ts + cooldown
			end
		end

		U.y_wait(store, fts(10))
		coroutine.yield()
	end
end

scripts.controller_stage_30_boss_spiders = {}

function scripts.controller_stage_30_boss_spiders.update(this, store)
	local function easingJump(x)
		return 1 - math.cos(x * math.pi / 2)
	end

	if store.level_difficulty == DIFFICULTY_IMPOSSIBLE then
		this.wave_spawns = this.wave_spawns_impossible
	end

	local taunts_index = 1

	if not this.restarted then
		U.y_animation_play(this, "walk", nil, store.tick_ts, 1, this.render.sid_queen_podium)
	end

	U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_queen_podium)

	local current_wave, last_wave
	local start_wave_ts = store.tick_ts

	while not this.do_exit do
		current_wave = store.wave_group_number

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
		end

		if this.do_taunt then
			this.render.sprites[this.render.sid_queen_podium].runs = 0
			this.render.sprites[this.render.sid_queen_podium].loop = false

			U.y_animation_wait(this, this.render.sid_queen_podium)
			signal.emit("show-balloon_tutorial", this.do_taunt, false)
			U.y_animation_play(this, "taunt", nil, store.tick_ts, 1, this.render.sid_queen_podium)
			U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_queen_podium)

			this.do_taunt = nil
		end

		if this.wave_spawns[current_wave] then
			for _, w in pairs(this.wave_spawns[current_wave]) do
				if not w.done and start_wave_ts + w.delay < store.tick_ts then
					w.done = true

					U.animation_start(this, "ability", nil, store.tick_ts, false, this.render.sid_queen_podium)
					U.y_wait(store, fts(10))

					for _, ws in pairs(w.spawns) do
						local spawn = E:create_entity(this.wave_spawns_object)

						spawn.pos = P:node_pos(ws.pi, ws.spi, ws.ni)
						spawn.nav_path.pi = ws.pi
						spawn.nav_path.spi = ws.spi
						spawn.nav_path.ni = ws.ni

						queue_insert(store, spawn)
					end

					U.y_animation_wait(this, this.render.sid_queen_podium)
					U.animation_start(this, "idle", nil, store.tick_ts, true, this.render.sid_queen_podium)

					this.do_taunt = "LV30_BOSS_ABILITY_0" .. taunts_index
					taunts_index = taunts_index + 1

					if taunts_index > 7 then
						taunts_index = 1
					end
				end
			end
		end

		coroutine.yield()
	end

	U.y_wait(store, 2.5)
	S:queue("Stage30BossfightCinematic")
	U.y_animation_play(this, "transform", nil, store.tick_ts, 1, this.render.sid_queen_podium)
	signal.emit("pan-zoom-camera", 2, {
		x = 300,
		y = 600
	}, 1.5)
	U.y_animation_play(this, "jump_in", nil, store.tick_ts, 1, this.render.sid_queen_podium)

	this.pos = P:node_pos(this.spawn_path, 1, this.spawn_node)
	this.render.sprites[this.render.sid_queen_podium].hidden = true

	U.y_wait(store, 0.5)

	this.render.sprites[this.render.sid_jump].hidden = false
	this.render.sprites[this.render.sid_jump].sort_y_offset = -100

	U.animation_start(this, "in", nil, store.tick_ts, false, this.render.sid_jump)

	local start_fall_ts = store.tick_ts
	local fall_duration = 0.5
	local fall_height = -600

	while store.tick_ts < start_fall_ts + fall_duration do
		local elapsed_percentage = (start_fall_ts - store.tick_ts) / fall_duration
		local eased_percentage = easingJump(elapsed_percentage)

		this.render.sprites[this.render.sid_jump].offset = V.v(0, fall_height - fall_height * eased_percentage)

		coroutine.yield()
	end

	this.render.sprites[this.render.sid_jump].hidden = true
	this.render.sprites[this.render.sid_smoke].hidden = false
	this.render.sprites[this.render.sid_land].hidden = false

	U.animation_start(this, "in", nil, store.tick_ts, false, this.render.sid_smoke)
	U.y_animation_play(this, "in", nil, store.tick_ts, 1, this.render.sid_land)

	local boss = E:create_entity("boss_spider_queen")

	boss.pos = V.vclone(this.pos)
	boss.nav_path.pi = this.spawn_path
	boss.nav_path.spi = 1
	boss.nav_path.ni = this.spawn_node

	queue_insert(store, boss)
	signal.emit("hide-curtains")
	W:start_manual_wave("BOSS1")
	coroutine.yield()

	this.render.sprites[this.render.sid_land].hidden = true

	U.y_wait(store, 0.3)
	signal.emit("show-gui")
	signal.emit("boss_fight_start_tweened", boss, 0.3)
	signal.emit("end-cinematic")
	signal.emit("pan-zoom-camera", 2, {
		x = 300,
		y = 430
	}, OVm(1, 1.2))
	U.y_animation_wait(this, this.render.sid_smoke)
	queue_remove(store, this)
end

scripts.decal_stage_30_door = {}

function scripts.decal_stage_30_door.update(this, store, script)
	local wave_index = 0
	local run_this_wave = false
	local wave_start_ts = store.tick_ts
	local interval_index = 1
	local wave_config = {}
	local on_boss_wave = false
	local waves_mode = this.waves[store.level_mode]
	local FROM = 1
	local TO = 2

	while true do
		if wave_index ~= store.wave_group_number or this.start_wave_boss then
			wave_index = store.wave_group_number

			if this.start_wave_boss then
				wave_config = waves_mode.BOSS
			else
				wave_config = waves_mode[store.wave_group_number]
			end

			run_this_wave = wave_config and #wave_config > 0
			wave_start_ts = store.tick_ts
			interval_index = 1
			this.start_wave_boss = false
		end

		if run_this_wave and store.tick_ts >= wave_start_ts + wave_config[interval_index][FROM] then
			S:queue("Stage30BossfightClawOpen")
			U.y_animation_play(this, this.animation_open, nil, store.tick_ts)
			U.animation_start(this, this.animation_idle_open, nil, store.tick_ts, true)
			U.y_wait(store, wave_config[interval_index][TO] - wave_config[interval_index][FROM])

			if store.level.bossfight_ended then
				return
			end

			U.y_animation_wait(this)
			S:queue("Stage30BossfightClawClose")
			U.y_animation_play(this, this.animation_close, nil, store.tick_ts)
			U.animation_start(this, this.animation_idle_closed, nil, store.tick_ts, true)

			interval_index = interval_index + 1

			if interval_index > #wave_config then
				run_this_wave = false
			end
		end

		if store.level.bossfight_ended then
			return
		end

		coroutine.yield()
	end
end

scripts.decal_terrain_6_exodia_part = {}

function scripts.decal_terrain_6_exodia_part.update(this, store, script)
	local shine_ts = store.tick_ts
	local shine_cd = math.random(10, 15)

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false

			S:queue(this.sound_click)
			U.y_animation_play(this, "action", nil, store.tick_ts, 1)
			signal.emit("exodia-terrain6", store.level_idx - 23)
			queue_remove(store, this)

			return
		end

		if shine_cd < store.tick_ts - shine_ts then
			shine_ts = store.tick_ts
			shine_cd = math.random(10, 15)

			U.animation_start(this, "shine", nil, store.tick_ts, false)
		end

		if this.render.sprites[1].name == "shine" and U.animation_finished(this) then
			U.animation_start(this, "idle", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.controller_stage_23_roboboots = {}

function scripts.controller_stage_23_roboboots.update(this, store)
	local mask_boot_right, mask_boot_left
	local BOOT_STATE_CLOSED = 0
	local BOOT_STATE_OPENING = 1
	local BOOT_STATE_OPEN = 2
	local BOOT_STATE_CLOSING = 3
	local legs_data = {
		{
			timing_index = 1,
			state = BOOT_STATE_CLOSED,
			paths = {
				{
					pi = 4,
					to = 30,
					from = 15
				},
				{
					pi = 10,
					to = 30,
					from = 15
				}
			}
		},
		{
			timing_index = 1,
			state = BOOT_STATE_CLOSED,
			paths = {
				{
					pi = 5,
					to = 30,
					from = 15
				}
			}
		}
	}

	for _, ldata in pairs(legs_data) do
		for _, pdata in pairs(ldata.paths) do
			P:add_invalid_range(pdata.pi, 0, pdata.from)
			P:add_invalid_range(pdata.pi, pdata.from, pdata.to)
		end
	end

	local function kill_enemies(pi, from, to)
		for _, e in pairs(store.entities) do
			if not e.pending_removal and e.enemy and e.nav_path and e.health and not e.health.dead and e.nav_path.pi == pi and from <= e.nav_path.ni and to >= e.nav_path.ni then
				queue_remove(store, e)
			end
		end
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local last_wave = 0
	local start_wave_ts = store.tick_ts

	for _, e in pairs(store.entities) do
		if e.template_name == "decal_stage_23_mask_5" then
			mask_boot_right = e.id
		elseif e.template_name == "decal_stage_23_mask_6" then
			mask_boot_left = e.id
		end
	end

	while true do
		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
			legs_data[1].timing_index = 1
			legs_data[2].timing_index = 1
			legs_data[1].next_ts = nil
			legs_data[2].next_ts = nil

			if current_wave_data and #current_wave_data > 0 then
				for index, wave_data in ipairs(current_wave_data) do
					if wave_data then
						local leg_index = wave_data.leg
						local current_leg = legs_data[leg_index]

						if current_leg.state == BOOT_STATE_OPEN then
							current_leg.next_ts = start_wave_ts + wave_data.timings[1][2]

							log.info("BOOT_STATE_OPEN " .. current_leg.next_ts)
						else
							current_leg.next_ts = start_wave_ts + wave_data.timings[1][1]

							log.info("BOOT_STATE_CLOSE " .. current_leg.next_ts)
						end
					end
				end
			end
		end

		if current_wave_data and #current_wave_data > 0 then
			for index, wave_data in ipairs(current_wave_data) do
				local leg_index = wave_data.leg
				local current_leg = legs_data[leg_index]

				if current_leg.state == BOOT_STATE_CLOSED then
					if current_leg.next_ts and store.tick_ts >= current_leg.next_ts then
						S:queue(this.sound_open)
						U.animation_start(this, "open", nil, store.tick_ts, false, leg_index)
						U.animation_start(this, "open", nil, store.tick_ts, false, leg_index + 2)

						if leg_index == 1 then
							this.render.sprites[leg_index + 2].z = Z_OBJECTS
							this.render.sprites[leg_index + 2].sort_y_offset = 100
						elseif leg_index == 2 then
							this.render.sprites[leg_index + 2].z = Z_OBJECTS_COVERS
						end

						current_leg.state = BOOT_STATE_OPENING

						if #wave_data.timings[current_leg.timing_index] > 1 and wave_data.timings[current_leg.timing_index][2] then
							local timing_data = wave_data.timings[current_leg.timing_index]

							current_leg.next_ts = start_wave_ts + timing_data[2]
						else
							current_leg.next_ts = nil
						end
					end
				elseif current_leg.state == BOOT_STATE_OPENING then
					if U.animation_finished(this, leg_index) then
						if leg_index == 1 then
							store.entities[mask_boot_left].render.sprites[1].hidden = false
						end

						current_leg.state = BOOT_STATE_OPEN

						for _, pdata in pairs(current_leg.paths) do
							log.info("unlock paths ")
							P:remove_invalid_range(pdata.pi, pdata.from, pdata.to)
						end

						U.animation_start(this, "idleopen", nil, store.tick_ts, true, leg_index)
						U.animation_start(this, "idleopen", nil, store.tick_ts, true, leg_index + 2)
					end
				elseif current_leg.state == BOOT_STATE_OPEN then
					if current_leg.next_ts and store.tick_ts >= current_leg.next_ts then
						S:queue(this.sound_close)
						U.animation_start(this, "close", nil, store.tick_ts, false, leg_index)
						U.animation_start(this, "close", nil, store.tick_ts, false, leg_index + 2)

						if leg_index == 1 then
							store.entities[mask_boot_left].render.sprites[1].hidden = true
						end

						for _, pdata in pairs(current_leg.paths) do
							P:add_invalid_range(pdata.pi, pdata.from, pdata.to)
						end

						U.y_wait(store, 1)

						for _, pdata in pairs(current_leg.paths) do
							kill_enemies(pdata.pi, 0, pdata.to)
						end

						U.y_wait(store, 0.5)

						this.render.sprites[leg_index + 2].z = Z_OBJECTS

						if leg_index == 2 then
							-- block empty
						end

						current_leg.state = BOOT_STATE_CLOSING
						current_leg.timing_index = current_leg.timing_index + 1

						if #wave_data.timings >= current_leg.timing_index then
							local timing_data = wave_data.timings[current_leg.timing_index]

							current_leg.next_ts = start_wave_ts + timing_data[1]
						else
							current_leg.next_ts = nil
						end
					end
				elseif current_leg.state == BOOT_STATE_CLOSING and U.animation_finished(this, leg_index) then
					current_leg.state = BOOT_STATE_CLOSED

					U.animation_start(this, "idle", nil, store.tick_ts, true, leg_index)
					U.animation_start(this, "idle", nil, store.tick_ts, true, leg_index + 2)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_23_crane = {}

function scripts.decal_stage_23_crane.update(this, store, script)
	local taps = 0

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			taps = taps + 1

			if taps < 3 then
				S:queue(this.sound_tap_1_2)
				U.y_animation_play(this, "action", nil, store.tick_ts, 1)
				U.animation_start(this, "idle", nil, store.tick_ts, true)

				this.ui.can_click = true
			else
				S:queue(this.sound_tap_3)
				U.y_animation_play(this, "explosion", nil, store.tick_ts, 1)
				U.animation_start(this, "idle_dead", nil, store.tick_ts, true)
				signal.emit("crane-stage23", this)
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_24_gears = {}

function scripts.decal_stage_24_gears.update(this, store)
	local start_ts = store.tick_ts
	local pause_ts
	local s = this.render.sprites[1]

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil

			if pause_ts then
				start_ts = store.tick_ts - (pause_ts - start_ts)
				pause_ts = nil
			else
				pause_ts = store.tick_ts
			end
		end

		if pause_ts then
			s.ts = store.tick_ts - (pause_ts - start_ts)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_24_factory_sparks = {}

function scripts.decal_stage_24_factory_sparks.update(this, store)
	while true do
		if this.play then
			this.play = false
			this.render.sprites[1].hidden = false
			this.render.sprites[1].r = km.deg2rad(math.random(-30, 30))

			U.y_animation_play(this, "run", math.random(0, 1) == 1, store.tick_ts, 1)

			this.render.sprites[1].hidden = true
		end

		coroutine.yield()
	end
end

scripts.decal_stage_24_elevator = {}

function scripts.decal_stage_24_elevator.update(this, store)
	local mask_door

	for i, v in pairs(store.entities) do
		if v.template_name == "decal_stage_24_mask_4" then
			mask_door = v
		end
	end

	while true do
		if this.go_up then
			this.go_up = false

			S:queue(this.sound_machinist_in)
			U.y_animation_play(this, "open", nil, store.tick_ts, 1)
			U.animation_start(this, "idleopen", nil, store.tick_ts, true)

			mask_door.render.sprites[1].hidden = false
		end

		if this.go_down then
			this.go_down = false
			mask_door.render.sprites[1].hidden = true

			S:queue(this.sound_machinist_out)
			U.y_animation_play(this, "close", nil, store.tick_ts, 1)
			U.animation_start(this, "idle", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.controller_stage_24_machinist = {}

function scripts.controller_stage_24_machinist.update(this, store)
	local factory, elevator

	for i, v in pairs(store.entities) do
		if v.template_name == "decal_stage_24_factory" then
			factory = v
		end

		if v.template_name == "decal_stage_24_elevator" then
			elevator = v
		end
	end

	local kept_factory_closed = true

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local last_wave = 0
	local start_wave_ts = store.tick_ts
	local last_index_processed = 0

	local function get_wave_data_index(current_wave_data)
		for index, wave_data in ipairs(current_wave_data) do
			if index > last_index_processed and wave_data.time_start + wave_data.duration > store.tick_ts - start_wave_ts then
				return index
			end
		end

		return nil
	end

	while not this.bossfight do
		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
			last_index_processed = 0
		end

		if current_wave_data and #current_wave_data > 0 then
			local next_index_to_check = get_wave_data_index(current_wave_data)

			if next_index_to_check and next_index_to_check ~= last_index_processed then
				local wave_data = current_wave_data[next_index_to_check]

				if store.tick_ts - start_wave_ts >= wave_data.time_start then
					elevator.go_up = true

					U.y_wait(store, fts(30))

					factory.wave_counter = factory.wave_counter + 1

					local machinist = E:create_entity(this.machinist_t)

					machinist.pos = V.v(-17, 453)
					machinist.nav_path.pi = 7
					machinist.source_id = this.id

					queue_insert(store, machinist)
					signal.emit("wave-notification", "icon", this.machinist_t)
					U.y_wait(store, 2)

					elevator.go_down = true

					local activated_factory = false

					while machinist and not machinist.escape do
						if machinist.operation_done then
							machinist.operation_done = false

							if machinist.current_op > machinist.op_needed then
								factory.open = true

								U.y_wait(store, fts(15))

								elevator.go_up = true

								U.y_wait(store, fts(100))

								elevator.go_down = true
								activated_factory = true
								kept_factory_closed = false

								break
							else
								U.y_animation_play(factory, "startup", nil, store.tick_ts, 1)
							end
						end

						coroutine.yield()
					end

					if not activated_factory then
						elevator.go_up = true

						U.y_wait(store, fts(90))

						elevator.go_down = true
					end

					last_index_processed = next_index_to_check
				end
			end
		end

		coroutine.yield()
	end

	if kept_factory_closed then
		signal.emit("factory-stage24", this)
	end

	elevator.go_up = true

	U.y_wait(store, fts(30))

	local machinist = E:create_entity(this.machinist_t)

	machinist.pos = V.v(-17, 453)
	machinist.nav_path.pi = 7
	machinist.source_id = this.id
	machinist.bossfight = true

	queue_insert(store, machinist)
	U.y_wait(store, 2)

	elevator.go_down = true

	while not machinist.ended_cinematic do
		if machinist.operation_done then
			machinist.operation_done = false

			if machinist.current_op > machinist.op_needed then
				factory.open = true
				factory.bossfight = true
			else
				U.y_animation_play(factory, "startup", nil, store.tick_ts, 1)
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.decal_stage_24_factory = {}

function scripts.decal_stage_24_factory.update(this, store)
	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_door

	this.wave_counter = 0

	local conveyor_belt, factory_gate_mask
	local sp = this.spawner

	for key, value in pairs(spawners) do
		if value.load_file == "level24_factory" then
			megaspawner_door = value
		end
	end

	for i, v in pairs(store.entities) do
		if v.template_name == "decal_stage_24_factory_conveyor_belt" then
			conveyor_belt = v
		end

		if v.template_name == "decal_stage_24_mask_6" then
			factory_gate_mask = v
		end
	end

	if store.level_mode == GAME_MODE_CAMPAIGN then
		while true do
			if this.open then
				this.open = false

				U.y_animation_play(this, "loop", nil, store.tick_ts, 5)

				conveyor_belt.render.sprites[1].hidden = false

				S:queue(this.sound_factory_turn_on_end)
				U.animation_start(this, "in", nil, store.tick_ts, false)
				U.y_animation_play(conveyor_belt, "in", nil, store.tick_ts, 1)
				S:queue(this.sound_conveyor_belt_loop)
				U.animation_start(this, "activeloop", nil, store.tick_ts, true)
				U.animation_start(conveyor_belt, "activeloop", nil, store.tickts, true)

				factory_gate_mask.render.sprites[1].hidden = false
				megaspawner_door.manual_wave = "DOOR" .. this.wave_counter

				while not sp.spawn_data or not sp.spawn_data.close or this.bossfight do
					coroutine.yield()
				end

				sp.spawn_data.close = nil
				factory_gate_mask.render.sprites[1].hidden = true

				S:stop(this.sound_conveyor_belt_loop)
				S:queue(this.sound_factory_turn_off)
				U.y_animation_play(conveyor_belt, "out", nil, store.tick_ts, 1)

				conveyor_belt.render.sprites[1].hidden = true

				U.y_animation_play(this, "out", nil, store.tick_ts, 1)
				U.y_animation_play(this, "loop", nil, store.tick_ts, 2)
				U.y_animation_play(this, "startup", nil, store.tick_ts, 1)
				U.animation_start(this, "idle", nil, store.tick_ts, true)
			end

			coroutine.yield()
		end
	else
		U.animation_start(this, "activeloop", nil, store.tick_ts, true)
		U.animation_start(conveyor_belt, "activeloop", nil, store.tickts, true)

		conveyor_belt.render.sprites[1].hidden = false
		factory_gate_mask.render.sprites[1].hidden = false
	end
end

scripts.enemy_machinist = {}

function scripts.enemy_machinist.update(this, store)
	local start_ts = store.tick_ts
	local near_op_pos = false
	local reached_op_pos = false
	local op_ts

	this.current_op = 1

	local sparks = {}
	local spawn_pos = V.vclone(this.pos)

	for i, v in pairs(store.entities) do
		if v.template_name == "decal_stage_24_factory_sparks" then
			table.insert(sparks, v)
		end
	end

	local function regen(store, this)
		if this.regen and store.tick_ts - this.regen.last_hit_ts > this.regen.last_hit_standoff_time then
			this.regen.ts_counter = this.regen.ts_counter + store.tick_length

			if this.regen.ts_counter > this.regen.cooldown then
				if this.health.hp < this.health.hp_max then
					this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp + this.regen.health)

					signal.emit("health-regen", this, this.regen.health)
				end

				this.regen.ts_counter = 0
			end
		end
	end

	local function escape()
		local nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, nil, false)
		local pi, spi, ni = unpack(nodes[1])

		this.motion.forced_waypoint = P:node_pos(pi, spi, ni)
		this.escape = true

		SU.remove_modifiers(store, this)
		U.unblock_all(store, this)

		this.vis.bans = F_ALL
		this.health_bar.hidden = true
		this.ui.can_click = false
	end

	local function walk_break_fn()
		if near_op_pos then
			return not this.motion.forced_waypoint
		else
			return V.dist2(this.pos.x, this.pos.y, this.operation_pos.x, this.operation_pos.y) < 1521
		end
	end

	local function escape_break_fn()
		local w = this.motion.forced_waypoint

		return not w or V.dist2(this.pos.x, this.pos.y, w.x, w.y) < 9
	end

	local function show_sparks()
		local sparks_ids = {}

		for i = 1, #sparks do
			table.insert(sparks_ids, i)
		end

		local selected_sparks = {}

		for i = 1, 3 do
			local si = math.random(1, #sparks_ids)

			table.insert(selected_sparks, sparks_ids[si])
			table.remove(sparks_ids, si)
		end

		for k, v in pairs(selected_sparks) do
			sparks[v].play = true
		end
	end

	if this.bossfight then
		this.vis.bans = F_ALL
		this.health_bar.hidden = true
		this.ui.can_click = false
	end

	::label_1463_0::

	while true do
		if this.escape then
			local cont, blocker, _ = SU.y_enemy_walk_until_blocked(store, this, true, escape_break_fn)

			this.motion.forced_waypoint = spawn_pos

			local cont, blocker, _ = SU.y_enemy_walk_until_blocked(store, this, true, escape_break_fn)

			this.escaped = true

			queue_remove(store, this)

			return
		end

		if this.health.dead or store.tick_ts - start_ts > this.timeout then
			this.health.dead = false
			this.health.hp = km.clamp(1, this.health.hp_max, this.health.hp)

			escape()
		elseif this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if reached_op_pos then
				regen(store, this)

				if #this.enemy.blockers > 0 then
					U.cleanup_blockers(store, this)

					local blocker = store.entities[this.enemy.blockers[1]]

					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_1463_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							U.animation_start(this, "idle", true, store.tick_ts, true)

							this.heading.angle = 0

							goto label_1463_0
						end

						coroutine.yield()
					end
				end

				if store.tick_ts - op_ts > this.op_cd and #this.enemy.blockers == 0 then
					op_ts = store.tick_ts
					this.render.sprites[1].z = Z_OBJECTS_COVERS

					S:queue(this.sound_lever[this.current_op])
					U.animation_start(this, "factory" .. this.current_op, true, store.tick_ts, false)

					if this.current_op == 3 then
						S:queue(this.sound_factory_on)
					end

					U.y_wait(store, fts(17))
					show_sparks()

					this.operation_done = true
					this.current_op = this.current_op + 1

					U.y_animation_wait(this)

					this.render.sprites[1].z = Z_OBJECTS

					if this.current_op > this.op_needed then
						escape()

						goto label_1463_0
					end
				end
			else
				local cont, blocker, _ = SU.y_enemy_walk_until_blocked(store, this, this.bossfight, walk_break_fn)

				if not cont then
					if walk_break_fn() then
						if near_op_pos then
							if this.bossfight then
								this.render.sprites[1].z = Z_OBJECTS_COVERS

								S:queue(this.sound_lever[1])
								U.animation_start(this, "factory1", true, store.tick_ts, false)
								U.y_wait(store, fts(17))
								show_sparks()

								this.operation_done = true
								this.current_op = this.current_op + 1

								U.y_animation_wait(this)
								S:queue(this.sound_lever[2])
								U.animation_start(this, "factory2", true, store.tick_ts, false)
								U.y_wait(store, fts(17))
								show_sparks()

								this.operation_done = true
								this.current_op = this.current_op + 1

								U.y_animation_wait(this)
								S:queue(this.sound_lever[3])
								S:queue(this.sound_factory_on)
								U.animation_start(this, "factory3", true, store.tick_ts, false)
								U.y_wait(store, fts(17))
								show_sparks()

								this.operation_done = true
								this.current_op = this.current_op + 1

								U.y_animation_wait(this)

								this.render.sprites[1].z = Z_OBJECTS

								local ship

								for _, e in pairs(store.entities) do
									if e.template_name == "boss_machinist" then
										ship = e

										break
									end
								end

								this.ready_to_jump = true

								while not ship.descended do
									coroutine.yield()
								end

								U.y_wait(store, fts(8))
								U.y_animation_play(this, "preparetojump", false, store.tick_ts, 1)

								this.render.sprites[1].hidden = true
								this.ended_cinematic = true

								U.y_wait(store, fts(30))
								queue_remove(store, this)
							end

							reached_op_pos = true
							this.motion.forced_waypoint = nil
							this.pos = V.vclone(this.operation_pos)

							U.animation_start(this, "idle", true, store.tick_ts, true)

							this.heading.angle = 0
							op_ts = store.tick_ts
						else
							near_op_pos = true

							if this.bossfight then
								U.y_animation_play(this, "talkin", false, store.tick_ts, 1)
								U.animation_start(this, "talkloop", false, store.tick_ts, true)
								U.y_wait(store, 1.5)
								U.y_animation_play(this, "talkout", false, store.tick_ts, 1)
							end

							this.motion.forced_waypoint = V.vclone(this.operation_pos)
						end
					end

					goto label_1463_0
				end

				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_1463_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_1463_0
						end

						coroutine.yield()
					end
				end
			end

			coroutine.yield()
		end
	end
end

scripts.boss_machinist = {}

function scripts.boss_machinist.update(this, store, script)
	local a = this.ranged.attacks[1]
	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_boss

	for _, value in pairs(spawners) do
		if value.load_file == "level24_spawner" then
			megaspawner_boss = value
		end
	end

	local spawn_ts = store.tick_ts

	U.animation_start(this, "nopilot", nil, store.tick_ts - fts(10), true, 1, true)
	U.y_wait(store, this.descend_duration)

	this.descended = true

	local machinist

	for _, e in pairs(store.entities) do
		if e.template_name == "enemy_machinist" then
			machinist = e

			break
		end
	end

	while not machinist.ready_to_jump do
		coroutine.yield()
	end

	U.y_animation_play(this, "getin", nil, store.tick_ts, 1)
	U.animation_start(this, "run", nil, store.tick_ts, true)
	U.y_wait(store, 0.5)
	signal.emit("boss_fight_start", this)

	megaspawner_boss.manual_wave = "BOSS"
	this.vis.bans = this.vis._bans
	this.walk_ts = store.tick_ts
	this.burn_aura = E:create_entity(this.burn_aura_t)
	this.burn_aura.aura.source_id = this.id

	queue_insert(store, this.burn_aura)

	local function y_on_death()
		LU.kill_all_enemies(store, true)
		S:stop_all()

		megaspawner_boss.interrupt = true

		S:queue(this.sound_death)
		U.animation_start(this, "dyingloop", nil, store.tick_ts, true)

		local death_ts = store.tick_ts

		while store.tick_ts - death_ts < 3 do
			local smoke = E:create_entity(this.death_smoke_fx)

			smoke.pos = V.vclone(this.pos)
			smoke.pos.x = smoke.pos.x + math.random(-20, 20)
			smoke.pos.y = smoke.pos.y + this.flight_height + math.random(-20, 20)
			smoke.render.sprites[1].ts = store.tick_ts

			queue_insert(store, smoke)
			U.y_wait(store, fts(5))

			local particle = E:create_entity(this.death_particle_fx)

			particle.pos = V.vclone(this.pos)
			particle.pos.x = particle.pos.x + math.random(-20, 20)
			particle.pos.y = particle.pos.y + this.flight_height + math.random(-20, 20)
			particle.render.sprites[1].ts = store.tick_ts

			queue_insert(store, particle)
			U.y_wait(store, fts(5))
			LU.kill_all_enemies(store, true)
		end

		this.render.sprites[2].hidden = true

		LU.kill_all_enemies(store, true)
		U.y_animation_play(this, "diefly", nil, store.tick_ts, 1)
		LU.kill_all_enemies(store, true)
		signal.emit("boss-killed", this)

		this.bossfight_ended = true
	end

	local function start_burn()
		this.burn_aura.tween.disabled = false
		this.burn_aura.tween.reverse = false
		this.burn_aura.tween.ts = store.tick_ts
		this.burn_aura.aura.radius = this.burn_aura.aura._radius

		U.animation_start(this, "firewalkin", nil, store.tick_ts, false)
	end

	local function end_burn()
		this.burn_aura.tween.reverse = true
		this.burn_aura.tween.ts = store.tick_ts
		this.burn_aura.aura.radius = 0

		U.animation_start(this, "firewalkout", nil, store.tick_ts, false)
	end

	local function y_walk_step()
		if this.render.sprites[1].name == "run" then
			local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, this.burn_aura.aura._radius * 1.5, this.burn_aura.aura.vis_flags, this.burn_aura.aura.vis_bans, function(e, o)
				return e.pos.x > this.pos.x
			end)

			if soldiers and #soldiers > 0 then
				start_burn()
			end
		end

		if this.render.sprites[1].name == "firewalkin" and U.animation_finished(this) then
			U.animation_start(this, "firewalkloop", nil, store.tick_ts, true)
		end

		if this.render.sprites[1].name == "firewalkloop" then
			local soldiers = U.find_soldiers_in_range(store.entities, this.pos, 0, this.burn_aura.aura._radius * 1.5, this.burn_aura.aura.vis_flags, this.burn_aura.aura.vis_bans)

			if not soldiers or #soldiers == 0 then
				end_burn()
			end
		end

		if this.render.sprites[1].name == "firewalkout" and U.animation_finished(this) then
			U.animation_start(this, "run", false, store.tick_ts, true)
		end

		local next, new

		if this.motion.forced_waypoint then
			local w = this.motion.forced_waypoint

			next = w

			local dist_limit = 2 * this.motion.max_speed * store.tick_length

			if V.dist2(w.x, w.y, this.pos.x, this.pos.y) < dist_limit * dist_limit then
				this.pos.x, this.pos.y = w.x, w.y
				this.motion.forced_waypoint = nil

				return
			end
		else
			next, new = P:next_entity_node(this, store.tick_length)

			if not next then
				log.debug("enemy %s ran out of nodes to walk", this.id)
				coroutine.yield()

				return
			end
		end

		U.set_destination(this, next)
		U.walk(this, store.tick_length)
		coroutine.yield()

		this.motion.speed.x, this.motion.speed.y = 0, 0
	end

	local function find_targets()
		local soldiers = U.find_soldiers_in_range(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

		if not soldiers or #soldiers == 0 then
			return nil
		else
			table.sort(soldiers, function(e1, e2)
				return V.dist2(e1.pos.x, e1.pos.y, this.pos.x, this.pos.y) < V.dist2(e2.pos.x, e2.pos.y, this.pos.x, this.pos.y)
			end)
		end

		return soldiers
	end

	local function y_do_attack()
		local attacks = 0

		while attacks < this.attacks_count do
			local soldiers = find_targets()

			if not soldiers or #soldiers == 0 then
				this.walk_ts = store.tick_ts - this.stop_cooldown + 1

				if attacks == 0 then
					return
				else
					break
				end
			end

			if attacks == 0 then
				if this.render.sprites[1].name == "firewalkloop" or this.render.sprites[1].name == "firewalkin" then
					end_burn()
					U.y_animation_play(this, "firewalkout", nil, store.tick_ts, 1)
				end

				U.y_animation_play(this, "attackin", nil, store.tick_ts, 1)

				soldiers = find_targets()

				if not soldiers or #soldiers == 0 then
					break
				end
			end

			local soldier = soldiers[math.random(1, #soldiers)]
			local attack_ts = store.tick_ts

			SU.y_enemy_range_attacks(store, this, soldier)

			local elapsed_time = store.tick_ts - attack_ts

			U.y_wait(store, a.cooldown - elapsed_time)

			attacks = attacks + 1
		end

		this.walk_ts = store.tick_ts + fts(55)

		U.y_animation_play(this, "attackout", nil, store.tick_ts, 1)
		U.animation_start(this, "run", false, store.tick_ts, true, nil, true)
	end

	while true do
		if this.health.dead then
			y_on_death()

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			if store.tick_ts - this.walk_ts > this.stop_cooldown then
				y_do_attack()
			end

			y_walk_step()
		end
	end
end

scripts.decal_stage_24_bubble = {}

function scripts.decal_stage_24_bubble.update(this, store)
	local cd = math.random(3, 7)

	while true do
		U.y_wait(store, cd)

		this.render.sprites[1].hidden = false

		U.y_animation_play(this, "run", nil, store.tick_ts)

		this.render.sprites[1].hidden = true
		cd = math.random(3, 7)
	end
end

scripts.decal_stage_24_upgrade_station = {}

function scripts.decal_stage_24_upgrade_station.update(this, store)
	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local last_wave = 0
	local start_wave_ts = store.tick_ts
	local last_index_processed = 0

	local function get_wave_data_index(current_wave_data)
		for index, wave_data in ipairs(current_wave_data) do
			if index > last_index_processed and wave_data.time_start + wave_data.duration > store.tick_ts - start_wave_ts then
				return index
			end
		end

		return nil
	end

	local function check_close()
		if this.render.sprites[1].name == "idleopen" then
			S:queue(this.sound_close)
			U.y_animation_play(this, "close", nil, store.tick_ts, 1)
			U.animation_start(this, "idle", nil, store.tick_ts, true)
		end
	end

	while true do
		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
			last_index_processed = 0
		end

		if current_wave_data and #current_wave_data > 0 then
			local next_index_to_check = get_wave_data_index(current_wave_data)

			if next_index_to_check and next_index_to_check ~= last_index_processed then
				local wave_data = current_wave_data[next_index_to_check]

				if store.tick_ts - start_wave_ts >= wave_data.time_start then
					if this.render.sprites[1].name == "idle" then
						S:queue(this.sound_open)
						U.y_animation_play(this, "open", nil, store.tick_ts, 1)
					end

					U.animation_start(this, "idleopen", nil, store.tick_ts, true)

					while store.tick_ts - start_wave_ts < wave_data.time_start + wave_data.duration do
						local hammerer, enemies = U.find_nearest_enemy(store.entities, this.pos, 0, 200, 0, 0, function(e)
							return e.template_name == this.hammerer_t and e.nav_path.pi == 2 and e.nav_path.ni > 50 and e.nav_path.ni < 56
						end)

						if not hammerer or #enemies == 0 then
							U.y_wait(store, 0.3)
						else
							local original_path = hammerer.nav_path.pi

							hammerer.nav_path.pi = this.path_in
							hammerer.vis.bans = U.flag_set(hammerer.vis.bans, F_POLYMORPH)

							if not hammerer.enemy.counts.mod_teleport then
								hammerer.enemy.counts.mod_teleport = 0
							end

							local start_tel_count = hammerer.enemy.counts.mod_teleport

							while hammerer and P:nodes_to_goal(hammerer.nav_path) > 1 do
								if not hammerer or hammerer.health.dead then
									goto label_1479_0
								end

								if start_tel_count < hammerer.enemy.counts.mod_teleport then
									hammerer.nav_path.pi = original_path
									hammerer.vis.bans = U.flag_clear(hammerer.vis.bans, F_POLYMORPH)

									goto label_1479_0
								end

								coroutine.yield()
							end

							if not hammerer or hammerer.health.dead then
								-- block empty
							else
								queue_remove(store, hammerer)
								S:queue(this.sound_transform)
								U.y_animation_play(this, "convertstart", nil, store.tick_ts, 1)
								U.y_animation_play(this, "convertloop", nil, store.tick_ts, 3)
								U.animation_start(this, "convertend", nil, store.tick_ts, false)
								U.y_wait(store, fts(10))

								local fist = E:create_entity(this.fist_t)

								fist.pos = P:node_pos(this.path_out, 1, 1)
								fist.nav_path.pi = this.path_out
								fist.source_id = this.id

								queue_insert(store, fist)
								U.y_animation_wait(this)
								U.animation_start(this, "idleopen", nil, store.tick_ts, true)
							end
						end

						::label_1479_0::

						coroutine.yield()
					end

					last_index_processed = next_index_to_check
				else
					check_close()
				end
			end
		else
			check_close()
		end

		coroutine.yield()
	end
end

scripts.decal_stage_24_modes_decos = {}

function scripts.decal_stage_24_modes_decos.update(this, store)
	local cd = math.random(3, 7)

	while true do
		U.y_wait(store, cd)

		if math.random(1, 2) == 1 then
			U.y_animation_play(this, "chispas1", nil, store.tick_ts)
		else
			U.y_animation_play(this, "chispas2", nil, store.tick_ts)
		end

		U.animation_start(this, "idle", nil, store.tick_ts, true)

		cd = math.random(3, 7)
	end
end

scripts.decal_stage_25_solid_snake = {}

function scripts.decal_stage_25_solid_snake.update(this, store, script)
	local taps = 0
	local eyes_ts = store.tick_ts
	local eyes_cd = math.random(5, 10)
	local eyes_opened = false

	U.animation_start(this, "idle_1", nil, store.tick_ts, true)

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			eyes_opened = false
			taps = taps + 1

			if taps < 3 then
				S:queue(this.sound_1_2)
			else
				S:queue(this.sound_3)
			end

			U.y_animation_play(this, "touch_" .. taps, nil, store.tick_ts, 1)

			if taps >= 3 then
				this.render.sprites[1].hidden = true

				queue_remove(store, this)
				signal.emit("snake-stage25", this)

				return
			else
				this.ui.can_click = true

				U.animation_start(this, "idle_" .. taps * 2 + 1, nil, store.tick_ts, true)
			end

			if taps == 1 then
				this.ui.click_rect = this.click_rect_2
			elseif taps == 2 then
				this.ui.click_rect = this.click_rect_1
			end
		end

		if eyes_opened and U.animation_finished(this) then
			eyes_opened = false

			U.animation_start(this, "idle_" .. taps * 2 + 1, nil, store.tick_ts, true)
		end

		if not eyes_opened and eyes_cd < store.tick_ts - eyes_ts then
			eyes_opened = true

			U.animation_start(this, "idle_" .. taps * 2 + 2, nil, store.tick_ts, false)

			eyes_ts = store.tick_ts
			eyes_cd = math.random(5, 10)
		end

		coroutine.yield()
	end
end

scripts.controller_stage_25_torso = {}

function scripts.controller_stage_25_torso.update(this, store)
	local torso

	if store.level_mode == GAME_MODE_CAMPAIGN then
		for i, v in pairs(store.entities) do
			if v.template_name == this.torso_t then
				torso = v

				break
			end
		end
	else
		for i, v in pairs(store.entities) do
			if v.template_name == this.torso_modes_t then
				torso = v

				break
			end
		end
	end

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local last_wave = 0
	local start_wave_ts = store.tick_ts
	local last_index_processed = 0

	local function choose_fist_pos()
		local function is_in_valid_pos(soldier)
			local nearest_nodes = P:nearest_nodes(soldier.pos.x, soldier.pos.y)
			local pi, spi, ni = unpack(nearest_nodes[1])

			return P:is_node_valid(pi, ni)
		end

		local soldiers = table.filter(store.entities, function(k, v)
			return not v.pending_removal and v.soldier and v.vis and v.health and not v.health.dead and is_in_valid_pos(v)
		end)

		if not soldiers or #soldiers == 0 then
			return nil
		end

		for i = #soldiers, 2, -1 do
			local j = math.random(i)

			soldiers[i], soldiers[j] = soldiers[j], soldiers[i]
		end

		local soldier = soldiers[1]
		local near_soldiers = {}

		for k, v in ipairs(soldiers) do
			local near = U.find_soldiers_in_range(soldiers, v.pos, 0, this.fist_radius, 0, 0)

			if #near_soldiers < #near then
				soldier = v
				near_soldiers = near
			end
		end

		local x = 0
		local y = 0

		for k, v in ipairs(near_soldiers) do
			x = x + v.pos.x
			y = y + v.pos.y
		end

		x = x / #near_soldiers
		y = y / #near_soldiers

		local nearest_nodes = P:nearest_nodes(x, y)
		local pi, spi, ni = unpack(nearest_nodes[1])

		return P:node_pos(pi, 1, ni)
	end

	local function are_flying_heroes_behind(pos)
		local dragons = table.filter(store.entities, function(k, v)
			return not v.pending_removal and v.render and v.render.sprites[1].z == Z_FLYING_HEROES and math.abs(v.pos.x - pos.x) < 100 and v.pos.y > pos.y
		end)

		return dragons and #dragons > 0
	end

	local function choose_missile_target()
		local targets = {}
		local target

		for k, v in pairs(store.entities) do
			if v.tower and not v.tower.blocked and v.tower.type ~= "holder" and (not v.tower_holder or not v.tower_holder.blocked) and (not v.vis or band(v.vis.bans, F_STUN) == 0) then
				table.insert(targets, v)
			end
		end

		if #targets == 0 then
			for k, v in pairs(store.entities) do
				if v.tower_holder and not v.tower_holder.blocked and not v.tower.blocked and (not v.vis or band(v.vis.bans, F_STUN) == 0) then
					table.insert(targets, v)
				end
			end
		end

		local target = targets[math.random(1, #targets)]
		local m = E:create_entity(this.missile_mark_mod)

		m.modifier.target_id = target.id
		m.render.sprites[1].ts = store.tick_ts
		m.tween.ts = store.tick_ts
		m.pos = V.vclone(target.pos)

		queue_insert(store, m)

		return target
	end

	local function shoot_missile(target)
		S:queue(this.sound_missile)

		local bullet = E:create_entity(this.missile_t)

		bullet.pos = V.vclone(this.missile_spawn_pos)
		bullet.bullet.from = V.vclone(bullet.pos)
		bullet.bullet.to = V.vclone(target.pos)
		bullet.bullet.to.y = bullet.bullet.to.y + 20
		bullet.bullet.target_id = target.id
		bullet.bullet.source_id = this.id

		queue_insert(store, bullet)
	end

	local function get_wave_data_index(current_wave_data)
		for index, wave_data in ipairs(current_wave_data) do
			if index > last_index_processed and wave_data.time_start + this.action_duration > store.tick_ts - start_wave_ts then
				return index
			end
		end

		return nil
	end

	while true do
		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
			last_index_processed = 0
		end

		if current_wave_data and #current_wave_data > 0 then
			local next_index_to_check = get_wave_data_index(current_wave_data)

			if next_index_to_check and next_index_to_check ~= last_index_processed then
				local wave_data = current_wave_data[next_index_to_check]

				if store.tick_ts - start_wave_ts >= wave_data.time_start then
					if wave_data.action == "open" then
						if torso.render.sprites[1].name == "doors_close" then
							U.y_animation_wait(torso)
						elseif torso.render.sprites[1].name ~= "idle_doors" then
							U.y_animation_wait(torso)
							U.animation_start(torso, "idle_machinist", nil, store.tick_ts, true)

							goto label_1485_0
						end

						S:queue(this.sound_torso_open)
						U.y_animation_play(torso, "doors_open", nil, store.tick_ts, 1)
						U.animation_start(torso, "idle_machinist", nil, store.tick_ts, true)
					elseif wave_data.action == "fist" then
						S:queue(this.sound_torso_lever_1)
						U.animation_start(torso, "fist", nil, store.tick_ts, 1)
						U.y_wait(store, fts(15))

						local fist = E:create_entity(this.fist_t)

						fist.render.sprites[1].ts = store.tick_ts
						fist.pos = choose_fist_pos()

						if not fist.pos then
							local rand_pos = {
								V.v(256, 210),
								V.v(808, 212)
							}

							fist.pos = rand_pos[math.random(1, #rand_pos)]
						end

						fist.render.sprites[1].flip_x = fist.pos.x > 545

						if are_flying_heroes_behind(fist.pos) then
							fist.render.sprites[1].z = Z_FLYING_HEROES
						end

						queue_insert(store, fist)

						local fist_decal = E:create_entity(this.fist_decal_t)

						fist_decal.render.sprites[1].ts = store.tick_ts
						fist_decal.pos = fist.pos

						queue_insert(store, fist_decal)
						U.animation_start(fist, "in", nil, store.tick_ts, 1)
						U.y_animation_play(fist_decal, "in", nil, store.tick_ts, false)
						U.animation_start(fist, "attack", nil, store.tick_ts, false)
						U.animation_start(fist_decal, "attack", nil, store.tick_ts, false)
						U.y_wait(store, fts(41))
						S:queue(this.sound_fist)
						U.y_wait(store, fts(5))

						local shake = E:create_entity("aura_screen_shake")

						shake.aura.amplitude = 0.5
						shake.aura.duration = 0.75
						shake.aura.freq_factor = 4

						queue_insert(store, shake)

						local targets = table.filter(store.entities, function(k, v)
							return (v.enemy or v.soldier) and v.health and not v.health.dead and U.is_inside_ellipse(v.pos, fist.pos, this.fist_radius)
						end)
						local enemies_count = 0

						for k, v in ipairs(targets) do
							if v.enemy then
								v.enemy.gold = 0
								enemies_count = enemies_count + 1
							end

							local d = E:create_entity("damage")

							d.source_id = this.id
							d.target_id = v.id
							d.damage_type = this.fist_damage_type
							d.value = 1
							d.pop_chance = 0

							queue_damage(store, d)
						end

						signal.emit("fist-stage25", enemies_count)
						U.y_animation_wait(fist)
						queue_remove(store, fist)
						U.animation_start(torso, "idle_machinist", nil, store.tick_ts, true)
					elseif wave_data.action == "missile" then
						S:queue(this.sound_torso_lever_2)
						U.animation_start(torso, "missiles", nil, store.tick_ts, 1)

						local target = choose_missile_target()

						U.y_wait(store, this.missile_shoot_time - fts(3))
						S:queue(this.sound_torso_button)
						U.y_wait(store, fts(3))
						shoot_missile(target)
						U.y_animation_wait(torso)
						U.animation_start(torso, "idle_machinist", nil, store.tick_ts, true)
					elseif wave_data.action == "close" then
						if torso.render.sprites[1].name ~= "idle_machinist" then
							U.y_animation_wait(torso)
							U.animation_start(torso, "idle_machinist", nil, store.tick_ts, true)
						else
							S:queue(this.sound_torso_close)
							U.y_animation_play(torso, "doors_close", nil, store.tick_ts, 1)
							U.animation_start(torso, "idle_doors", nil, store.tick_ts, true)
						end
					end

					::label_1485_0::

					last_index_processed = next_index_to_check
				end
			end
		end

		coroutine.yield()
	end
end

scripts.bullet_stage_25_torso_missile = {}

function scripts.bullet_stage_25_torso_missile.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local ps

	if not source then
		queue_remove(store, this)

		return
	end

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 50 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	local function find_tower()
		local towers = table.filter(store.entities, function(k, v)
			return not v.pending_removal and v.tower and not v.tower.blocked and U.is_inside_ellipse(v.pos, b.to, 50)
		end)

		if not towers or #towers == 0 then
			return nil
		else
			return towers[1]
		end
	end

	local function check_target()
		if not target or not target.tower or target.pending_removal or not SU.has_modifiers(store, target, "mod_stage_25_torso_missile_mark") then
			if target then
				SU.remove_modifiers(store, target, "mod_stage_25_torso_missile_mark")
			end

			target = find_tower()
			b.target_id = target.id

			local m = E:create_entity(this.mark_mod)

			m.modifier.target_id = target.id
			m.render.sprites[1].ts = store.tick_ts
			m.tween.ts = store.tick_ts
			m.pos = V.vclone(target.pos)

			queue_insert(store, m)
		end
	end

	local function y_fly_to_pos(target_pos)
		local start_ts = store.tick_ts
		local last_pos = V.vclone(this.pos)
		local dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)

		while V.len(dx, dy) > 40 do
			last_pos.x, last_pos.y = this.pos.x, this.pos.y

			move_step(target_pos)

			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
			dist = V.len(dx, dy)

			coroutine.yield()
		end

		check_target()
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local source_pos = V.vclone(source.pos)

	if not this.relative_to_source then
		source_pos = v(0, 0)
	end

	fm.a.x, fm.a.y = 100, 0

	check_target()

	local target_pos

	if target.pos.x < 512 then
		table.remove(this.flight_positions, #this.flight_positions)
	end

	for k, v in ipairs(this.flight_positions) do
		target_pos = V.v(source_pos.x + v.x, source_pos.y + v.y)

		y_fly_to_pos(target_pos)
	end

	fm.a_step = 6.25
	fm.max_a = 3150
	fm.max_v = 1125
	ps.particle_system.emission_rate = 90

	check_target()

	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	while true do
		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
		end

		coroutine.yield()
	end

	check_target()

	if target then
		local hit_fx = E:create_entity(b.hit_fx)

		hit_fx.pos = V.vclone(b.to)
		hit_fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, hit_fx)
		SU.remove_modifiers(store, target, "mod_stage_25_torso_missile_mark")

		if (b.mod or b.mods) and target.tower then
			local mods = b.mods or {
				b.mod
			}

			for _, mod_name in pairs(mods) do
				local m = E:create_entity(mod_name)

				m.modifier.target_id = target.id
				m.modifier.ts = store.tick_ts

				queue_insert(store, m)
			end
		end
	end

	S:queue(this.sound_events.hit)

	this.render.sprites[1].hidden = true

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false
	end

	queue_remove(store, this)
end

scripts.mod_stage_25_torso_missile_mark = {}

function scripts.mod_stage_25_torso_missile_mark.queue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target or not target.vis then
		return
	end

	return scripts.mod_mark_flags.queue(this, store, insertion)
end

function scripts.mod_stage_25_torso_missile_mark.dequeue(this, store, insertion)
	local target = store.entities[this.modifier.target_id]

	if not target or not target.vis then
		return
	end

	return scripts.mod_mark_flags.dequeue(this, store, insertion)
end

scripts.mod_stage_25_torso_missile_stun = {}

function scripts.mod_stage_25_torso_missile_stun.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	local function block_tower()
		local t = target.tower

		t.block_count = t.block_count + 1

		if t.block_count > 0 then
			t.blocked = true

			if target.tower and not target.tower_holder then
				t.can_be_sold = false
			end
		end

		if target.tower and not target.tower._type then
			target.tower._type = target.tower.type
			target.tower.type = "tower_broken_stage_25"
			target.trigger_deselect = true
			target.repair = {}
			target.repair.cost = this.repair_cost
			target.repair.active = false

			if not target.user_selection then
				E:add_comps(target, "user_selection")
			end
		end
	end

	local function unblock_tower()
		local t = target.tower

		t.block_count = 0

		if t.block_count < 1 then
			t.blocked = nil
			t.block_count = 0

			if target.tower and not target.tower_holder then
				t.can_be_sold = true
			end
		end
	end

	m.ts = store.tick_ts

	block_tower()

	this.pos = target.pos
	this.tween.ts = store.tick_ts

	U.animation_start(this, "loop", nil, store.tick_ts, true)

	local start_ts = store.tick_ts
	local tap_ts = store.tick_ts
	local hand

	while store.tick_ts - start_ts < m.duration do
		if target.user_selection.in_progress and not target.repair.active then
			target.user_selection.in_progress = nil
			target.user_selection.allowed = false
			store.player_gold = store.player_gold - target.repair.cost
			target.repair.active = true

			local water = E:create_entity(this.water_decal_t)

			water.pos = this.pos
			water.render.sprites[1].ts = store.tick_ts

			queue_insert(store, water)
			S:queue("GUITowerSell")

			break
		end

		if store.tick_ts - tap_ts > 4 then
			tap_ts = store.tick_ts
			hand = E:create_entity(this.hand_decal_t)
			hand.pos = this.pos
			hand.render.sprites[1].ts = store.tick_ts
			hand.tween.ts = store.tick_ts

			queue_insert(store, hand)
		end

		if SU.has_modifiers(store, target, "mod_stage_25_torso_missile_mark") then
			SU.remove_modifiers(store, target, "mod_stage_25_torso_missile_mark")
		end

		if not table.contains(store.entities, target) then
			local towers = table.filter(store.entities, function(k, v)
				return not v.pending_removal and (v.tower and not v.tower.blocked or v.tower_holder and not v.tower_holder.blocked) and not v.tower.blocked and U.is_inside_ellipse(v.pos, this.pos, 20)
			end)

			if #towers > 0 then
				target = towers[1]
				target.test_deselect = true
				this.modifier.target_id = target.id

				block_tower()
			end
		end

		coroutine.yield()
	end

	if hand then
		queue_remove(store, hand)
	end

	this.tween.ts = store.tick_ts
	this.tween.reverse = true
	this.tween.remove = true
	this.tween.props[2].disabled = false

	unblock_tower()

	target.trigger_deselect = true
	target.user_selection.allowed = true

	queue_remove(store, this)
end

function scripts.mod_stage_25_torso_missile_stun.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		target.tower.type = target.tower._type
		target.tower._type = nil
	end

	return true
end

scripts.controller_stage_25_tunnel_glow = {}

function scripts.controller_stage_25_tunnel_glow.update(this, store)
	local glow

	for _, e in pairs(store.entities) do
		if e.template_name == this.glow_t then
			glow = e
		end
	end

	local on = false

	local function find_enemies(range)
		local enemies = table.filter(store.entities, function(k, v)
			return not v.pending_removal and v.enemy and v.nav_path and v.nav_path.pi == 1 and v.health and not v.health.dead and U.is_inside_ellipse(v.pos, this.pos, range)
		end)

		return enemies
	end

	while true do
		if on then
			local ts = store.tick_ts

			while store.tick_ts - ts < 4 do
				local targets = find_enemies(50)

				if targets and #targets > 0 then
					goto label_1508_0
				end

				coroutine.yield()
			end

			glow.tween.reverse = true
			glow.tween.ts = store.tick_ts
			on = false
		else
			local targets = find_enemies(50)

			if not targets or #targets == 0 then
				U.y_wait(store, fts(5))
			else
				U.y_wait(store, 1.5)

				glow.tween.disabled = false
				glow.tween.reverse = false
				glow.tween.ts = store.tick_ts
				on = true
			end
		end

		::label_1508_0::

		coroutine.yield()
	end
end

scripts.decal_stage_26_mewtwo = {}

function scripts.decal_stage_26_mewtwo.update(this, store, script)
	local taps = 0
	local eyes_ts = store.tick_ts
	local eyes_cd = math.random(5, 10)
	local eyes_opened = false

	U.animation_start(this, "idle_1", nil, store.tick_ts, true)

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false
			eyes_opened = false
			taps = taps + 1

			if taps < 3 then
				S:queue(this.sound_1_2)
			else
				S:queue(this.sound_3)
				S:queue(this.sound_end, {
					delay = 1
				})
			end

			U.y_animation_play(this, "touch_" .. taps, nil, store.tick_ts, 1)

			if taps >= 3 then
				local mewtwo = E:create_entity(this.mewtwo_t)

				mewtwo.pos = V.vclone(this.pos)
				mewtwo.render.sprites[1].ts = store.tick_ts

				queue_insert(store, mewtwo)
				U.animation_start(mewtwo, "spawn", nil, store.tick_ts, false)
				U.y_animation_play(this, "idle_4", nil, store.tick_ts, 1)
				U.y_animation_wait(mewtwo)
				signal.emit("mewtwo-stage26", this)
			else
				this.ui.can_click = true

				U.animation_start(this, "idle_" .. taps + 1, nil, store.tick_ts, true)
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_26_modes_decos = {}

function scripts.decal_stage_26_modes_decos.update(this, store)
	local cd = math.random(3, 7)

	while true do
		U.y_wait(store, cd)
		U.y_animation_play(this, "action_" .. math.random(1, 2), nil, store.tick_ts)
		U.animation_start(this, "idle", nil, store.tick_ts, true)

		cd = math.random(3, 7)
	end
end

scripts.controller_stage_26_taunts = {}

function scripts.controller_stage_26_taunts.update(this, store)
	local taunt_ts = store.tick_ts
	local taunt_cd = math.random(this.taunts.delay_min, this.taunts.delay_max)

	while store.wave_group_number == 0 do
		if taunt_cd < store.tick_ts - taunt_ts then
			y_show_taunt_set(store, this.taunts, "preparation", false)

			taunt_ts = store.tick_ts
			taunt_cd = math.random(this.taunts.delay_min, this.taunts.delay_max)
		end

		coroutine.yield()
	end

	while not store.waves_finished do
		if taunt_cd < store.tick_ts - taunt_ts then
			y_show_taunt_set(store, this.taunts, "fight", false)

			taunt_ts = store.tick_ts
			taunt_cd = math.random(this.taunts.delay_min, this.taunts.delay_max)
		end

		coroutine.yield()
	end
end

scripts.controller_stage_26_spawners = {}

function scripts.controller_stage_26_spawners.update(this, store)
	local fist_spawner_c, clone_spawner_c_left, clone_spawner_c_right, tube_left, tube_right, clone_spawner_left, clone_spawner_right, hulk_spawner_c

	for i, v in pairs(store.entities) do
		if v.template_name == this.fist_spawner_controller_t then
			fist_spawner_c = v
		end

		if v.template_name == this.clone_spawner_controller_t then
			if not clone_spawner_c_left then
				clone_spawner_c_left = v
			else
				clone_spawner_c_right = v
			end
		end

		if v.template_name == this.tube_left_t then
			tube_left = v
		end

		if v.template_name == this.tube_right_t then
			tube_right = v
		end

		if v.template_name == this.clone_spawner_t then
			if not clone_spawner_left then
				clone_spawner_left = v
			elseif clone_spawner_left.pos.x < v.pos.x then
				clone_spawner_right = v
			else
				clone_spawner_right = clone_spawner_left
				clone_spawner_left = v
			end
		end

		if v.template_name == this.hulk_spawner_controller_t then
			hulk_spawner_c = v
		end
	end

	clone_spawner_c_left.spawner_decal = clone_spawner_left
	clone_spawner_c_left.tube_decal = tube_left
	clone_spawner_c_right.spawner_decal = clone_spawner_right
	clone_spawner_c_right.tube_decal = tube_right

	while store.wave_group_number == 0 do
		coroutine.yield()
	end

	local last_wave = 0
	local start_wave_ts = store.tick_ts
	local last_index_processed = 0

	local function get_wave_data_index(current_wave_data)
		for index, wave_data in ipairs(current_wave_data) do
			if index > last_index_processed and wave_data.time_start + fts(30) > store.tick_ts - start_wave_ts then
				return index
			end
		end

		return nil
	end

	while true do
		local current_wave = store.wave_group_number
		local current_wave_data = this.wave_config[store.level_mode][current_wave]

		if current_wave ~= last_wave then
			last_wave = current_wave
			start_wave_ts = store.tick_ts
			last_index_processed = 0
		end

		if current_wave_data and #current_wave_data > 0 then
			if store.waves_finished then
				queue_remove(store, fist_spawner_c)
				queue_remove(store, clone_spawner_c_left)
				queue_remove(store, clone_spawner_c_right)

				return
			end

			local next_index_to_check = get_wave_data_index(current_wave_data)

			if next_index_to_check and next_index_to_check ~= last_index_processed then
				local wave_data = current_wave_data[next_index_to_check]

				if store.tick_ts - start_wave_ts >= wave_data.time_start then
					if wave_data.spawner == "fist" then
						if wave_data.action == "open" then
							fist_spawner_c.open = true
							fist_spawner_c.fists = wave_data.count
						else
							fist_spawner_c.close = true
						end
					elseif wave_data.spawner == "clone_left" then
						if wave_data.action == "open" then
							clone_spawner_c_left.open = true
						else
							clone_spawner_c_left.close = true
						end
					elseif wave_data.spawner == "clone_right" then
						if wave_data.action == "open" then
							clone_spawner_c_right.open = true
						else
							clone_spawner_c_right.close = true
						end
					elseif wave_data.spawner == "hulk" and wave_data.action == "activate" then
						hulk_spawner_c.activate = true
					end

					last_index_processed = next_index_to_check
				end
			end
		end

		coroutine.yield()
	end
end

scripts.controller_stage_26_fist_spawner = {}

function scripts.controller_stage_26_fist_spawner.update(this, store)
	local boss, hand_c

	for i, v in pairs(store.entities) do
		if v.template_name == this.boss_t then
			boss = v
		end

		if v.template_name == this.hand_controller_t then
			hand_c = v
		end
	end

	while true do
		if this.open then
			if boss then
				U.y_animation_play(boss, "grab", nil, store.tick_ts, 1)
			end

			hand_c.open = true
			hand_c.fists = this.fists

			if boss then
				U.y_animation_play(boss, "controlling_hand", nil, store.tick_ts, this.fists)
				U.y_animation_play(boss, "return_idle", nil, store.tick_ts, false)
				U.animation_start(boss, "idle", nil, store.tick_ts, true)
			end

			this.open = false
		end

		if this.close then
			hand_c.close = true
			this.close = false
		end

		coroutine.yield()
	end
end

scripts.controller_stage_26_fist_spawner_hand = {}

function scripts.controller_stage_26_fist_spawner_hand.update(this, store)
	local fist_spawner, fist_spawner_light

	for i, v in pairs(store.entities) do
		if v.template_name == this.fist_spawner_t then
			fist_spawner = v
		end

		if v.template_name == this.fist_spawner_light_t then
			fist_spawner_light = v
		end
	end

	while true do
		if this.open then
			S:queue(this.sound_hand)
			U.y_animation_play(fist_spawner, "hand_start", nil, store.tick_ts, 1)

			for i = 1, this.fists - 1 do
				S:queue(this.sound_hand)
				U.y_animation_play(fist_spawner, "hand_loop", nil, store.tick_ts, 1)
			end

			U.y_animation_play(fist_spawner, "hand_end", nil, store.tick_ts, 1)
			S:queue(this.sound_open)
			U.y_animation_play(fist_spawner, "door_open", nil, store.tick_ts, 1)
			U.animation_start(fist_spawner, "idle_2", nil, store.tick_ts, true)
			U.animation_start(fist_spawner_light, "run", nil, store.tick_ts, true)

			this.open = false
		end

		if this.close then
			U.animation_start(fist_spawner_light, "idle", nil, store.tick_ts, true)
			S:queue(this.sound_close)
			U.y_animation_play(fist_spawner, "door_close", nil, store.tick_ts, 1)
			U.animation_start(fist_spawner, "idle_1", nil, store.tick_ts, true)

			this.close = false
		end

		coroutine.yield()
	end
end

scripts.controller_stage_26_clone_spawner = {}

function scripts.controller_stage_26_clone_spawner.update(this, store)
	local boss, fist_spawner, fist_spawner_light

	for i, v in pairs(store.entities) do
		if v.template_name == this.boss_t then
			boss = v
		end
	end

	while true do
		if this.open then
			if boss then
				S:queue(this.sound_chain)
				U.y_animation_play(boss, "elevator_spawning", nil, store.tick_ts, 1)
			end

			U.y_animation_play(this.tube_decal, "run", nil, store.tick_ts, 1)
			U.animation_start(this.tube_decal, "idle", nil, store.tick_ts, true)
			S:queue(this.sound_in)
			U.y_animation_play(this.spawner_decal, "run", nil, store.tick_ts, 1)
			U.animation_start(this.spawner_decal, "idle_2", nil, store.tick_ts, true)

			this.open = false
		end

		if this.close then
			S:queue(this.sound_out)
			U.y_animation_play(this.spawner_decal, "reset", nil, store.tick_ts, 1)
			U.animation_start(this.spawner_decal, "idle_1", nil, store.tick_ts, true)

			this.close = false
		end

		coroutine.yield()
	end
end

scripts.controller_stage_26_hulk_spawner = {}

function scripts.controller_stage_26_hulk_spawner.update(this, store)
	local spawner_decal

	for i, v in pairs(store.entities) do
		if v.template_name == this.hulk_spawner_t then
			spawner_decal = v

			break
		end
	end

	while true do
		if this.activate then
			U.animation_start(spawner_decal, "run", nil, store.tick_ts, false)
			U.y_wait(store, 5.5)
			S:queue(this.sound_shot)
			U.y_wait(store, this.hulk_spawn_delay - 5.5)

			local hulk = E:create_entity(this.hulk_t)

			hulk.nav_path.pi = this.path_to_spawn
			hulk.nav_path.ni = 1
			hulk.nav_path.spi = 1
			hulk.pos = P:node_pos(this.path_to_spawn, 1, 1)
			hulk.source_id = this.id

			queue_insert(store, hulk)
			signal.emit("wave-notification", "icon", "enemy_darksteel_hulk")
			U.y_animation_wait(spawner_decal)
			U.y_wait(store, fts(60))
			U.y_animation_play(spawner_decal, "reset", nil, store.tick_ts, 1)
			U.animation_start(spawner_decal, "idle", nil, store.tick_ts, true)

			this.activate = false
		end

		coroutine.yield()
	end
end

function scripts.controller_stage_26_hulk_spawner.on_event(this, store)
	this.activate = true
end

scripts.boss_deformed_grymbeard = {}

function scripts.boss_deformed_grymbeard.update(this, store)
	local boss_decal

	for i, v in pairs(store.entities) do
		if v.template_name == this.boss_decal_t then
			boss_decal = v
		end
	end

	this.health.hp_max = this.clones_to_die
	this.health.hp = this.clones_to_die

	local spawn_ts = store.tick_ts

	signal.emit("boss_fight_start", this)
	W:start_manual_wave("BOSS1")

	while this.health.hp > 0 do
		if this.trigger_damage_anim then
			this.trigger_damage_anim = false

			S:queue(this.sound_damage)
			U.y_animation_play(boss_decal, "hit", nil, store.tick_ts, 1)
			U.animation_start(boss_decal, "loop", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

function scripts.boss_deformed_grymbeard.on_clone_death(this, store)
	this.trigger_damage_anim = true
	this.health.hp = km.clamp(0, this.health.hp_max, this.health.hp - 1)

	if this.health.hp <= 0 then
		LU.kill_all_enemies(store, true, false)
		S:stop_all()
		W:stop_manual_wave("BOSS1")

		this.health.dead = true

		signal.emit("boss-killed", this)
	end
end

scripts.enemy_deformed_grymbeard_clone = {}

function scripts.enemy_deformed_grymbeard_clone.insert(this, store, script)
	if scripts.enemy_basic.insert(this, store, script) then
		if this.shield then
			this.shield.render.sprites[1].hidden = this.health.hp / this.health.hp_max < this.shield_hp_threshold
		end

		return true
	end

	return false
end

function scripts.enemy_deformed_grymbeard_clone.update(this, store, script)
	local boss

	for i, v in pairs(store.entities) do
		if v.template_name == "boss_deformed_grymbeard" then
			boss = v
		end
	end

	if not this.shield then
		this.shield = E:create_entity(this.shield_t)
		this.shield.render.sprites[1].offset = this.render.sprites[1].offset

		queue_insert(store, this.shield)
	end

	this.shield.pos = this.pos

	local function break_fn()
		if this.shield.render.sprites[1].name == "idle" and this.health.hp / this.health.hp_max < this.shield_hp_threshold then
			U.animation_start(this.shield, "out", nil, store.tick_ts, false)

			this.health.magic_armor = 0
			this.motion.max_speed = this.motion.max_speed * this.no_shield_speed_factor
		end

		if this.shield.render.sprites[1].name == "out" and U.animation_finished(this.shield) then
			this.shield.render.sprites[1].hidden = true
		end
	end

	while true do
		if this.health.dead then
			queue_remove(store, this.shield)

			this.render.sprites[2].hidden = true

			if boss then
				boss:on_clone_death_f(store)
			end

			SU.y_enemy_death(store, this)

			if this.shield then
				queue_remove(store, this.shield)
			end

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			SU.y_enemy_walk_until_blocked(store, this, true, break_fn)
		end
	end
end

function scripts.enemy_deformed_grymbeard_clone.remove(this, store, script)
	if this.shield then
		this.shield.render.sprites[1].hidden = true
	end

	return true
end

scripts.controller_stage_27_platform = {}

function scripts.controller_stage_27_platform.update(this, store)
	local platform, platform_bars, cannon_left, cannon_right, door_mask, cannon_c_right, cannon_c_left

	for i, v in pairs(store.entities) do
		if v.template_name == this.platform_t then
			platform = v
		end

		if v.template_name == this.platform_bars_t then
			platform_bars = v
		end

		if v.template_name == this.cannon_left_t then
			cannon_left = v
		end

		if v.template_name == this.cannon_right_t then
			cannon_right = v
		end

		if v.template_name == this.door_mask_t then
			door_mask = v
		end

		if v.template_name == this.cannon_controller_t_l then
			cannon_c_left = v
		end

		if v.template_name == this.cannon_controller_t_r then
			cannon_c_right = v
		end
	end

	cannon_c_left.cannon = cannon_left
	cannon_c_right.cannon = cannon_right

	S:queue(this.sound_intro)

	platform.render.sprites[1].prefix = "dclenanos_stage05_platform_introDef"

	U.y_animation_play(platform, "intro", nil, store.tick_ts, 1)

	platform.render.sprites[1].prefix = "dclenanos_stage05_platformDef"

	U.animation_start(platform, "idle", nil, store.tick_ts, true)

	while true do
		if this.platform_up then
			S:queue(this.sound_platform_up)
			U.animation_start(platform, "raise", nil, store.tick_ts, false)
			U.y_wait(store, fts(23))

			platform.render.sprites[1].z = Z_DECALS

			U.y_wait(store, fts(12))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.5
			shake.aura.duration = 0.3
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
			queue_insert(store, shake)
			U.y_animation_wait(platform)
			U.animation_start(platform, "idleopen", nil, store.tick_ts, true)

			door_mask.render.sprites[1].hidden = false
			this.platform_up = false
		elseif this.platform_down then
			S:queue(this.sound_platform_down)

			door_mask.render.sprites[1].hidden = true

			U.animation_start(platform, "lower", nil, store.tick_ts, false)
			U.y_wait(store, fts(43))

			platform.render.sprites[1].z = Z_BACKGROUND_COVERS

			U.y_animation_wait(platform)
			U.animation_start(platform, "idle", nil, store.tick_ts, true)

			this.platform_down = false
		elseif this.platform_destroy then
			S:queue(this.sound_platform_destroy_chains)

			door_mask.render.sprites[1].hidden = true
			platform.render.sprites[1].z = Z_BACKGROUND_COVERS

			U.animation_start(platform_bars, "break", nil, store.tick_ts, false)
			U.animation_start(platform, "endfirstpart", nil, store.tick_ts, false)
			U.y_wait(store, fts(120))
			S:queue(this.sound_platform_destroy_impacts)
			U.y_wait(store, fts(13))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.5
			shake.aura.duration = 0.6
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
			U.y_wait(store, fts(33))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.75
			shake.aura.duration = 0.6
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
			U.y_wait(store, fts(33))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 1
			shake.aura.duration = 1
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
			U.y_animation_wait(platform)

			platform_bars.render.sprites[1].hidden = true
			this.platform_destroy = false

			local head_c

			for i, v in ipairs(store.entities) do
				if v.template_name == this.head_controller_t then
					head_c = v
				end
			end

			head_c.cannon_c_left = cannon_c_left
			head_c.cannon_c_right = cannon_c_right
			head_c.spawn_head = true

			U.y_wait(store, fts(1))
			queue_remove(store, platform)
			queue_remove(store, this)
		elseif this.cannons_in then
			S:queue(this.sound_cannon_alarm)
			U.animation_start(platform, "risecannons", nil, store.tick_ts, false)
			U.y_wait(store, fts(52))

			if this.cannons_config == "both" then
				local delay_between = fts(8)

				cannon_c_right.shoot_cannon = true
				cannon_c_right.clones_count = this.cannons_clones_count

				U.y_wait(store, delay_between)

				cannon_c_left.shoot_cannon = true
				cannon_c_left.clones_count = this.cannons_clones_count
			elseif this.cannons_config == "left" then
				cannon_c_left.shoot_cannon = true
				cannon_c_left.clones_count = this.cannons_clones_count
			else
				cannon_c_right.shoot_cannon = true
				cannon_c_right.clones_count = this.cannons_clones_count
			end

			U.y_animation_wait(platform)
			U.animation_start(platform, "idle", nil, store.tick_ts, true)

			this.cannons_in = false
		elseif this.show_taunt then
			local set = this.taunts.sets.fight
			local taunt_id = _(string.format(set.format, this.taunt_idx))

			signal.emit("show-balloon_tutorial", taunt_id, false)
			U.y_animation_play(platform, "taunt" .. math.random(1, 2), nil, store.tick_ts, 1)
			U.animation_start(platform, "idle", nil, store.tick_ts, true)

			this.show_taunt = false
		end

		coroutine.yield()
	end
end

function scripts.controller_stage_27_platform.on_platform_up_event(this, store, action)
	log.info("EVENT: RAISE PLATFORM")

	this.platform_up = true
end

function scripts.controller_stage_27_platform.on_platform_down_event(this, store, action)
	log.info("EVENT: LOWER PLATFORM")

	this.platform_down = true
end

function scripts.controller_stage_27_platform.on_platform_destroy_event(this, store, action)
	log.info("EVENT: DESTROY PLATFORM")

	this.platform_destroy = true
end

function scripts.controller_stage_27_platform.on_cannons_event(this, store, action, config, clones_count)
	log.info("EVENT: CANNONS - " .. config)

	this.cannons_in = true
	this.cannons_config = config
	this.cannons_clones_count = clones_count
end

function scripts.controller_stage_27_platform.on_taunt_event(this, store, action, taunt_idx)
	log.info("EVENT: TAUNT - " .. taunt_idx)

	this.show_taunt = true
	this.taunt_idx = taunt_idx
end

scripts.controller_stage_27_cannon = {}

function scripts.controller_stage_27_cannon.update(this, store)
	local function shoot_clone(pos, dies)
		local b

		if dies then
			b = E:create_entity(this.bullet_clone_dead_t)
		else
			b = E:create_entity(this.bullet_clone_alive_t)
		end

		b.pos = V.vclone(this.cannon.shot_pos)
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.vclone(pos)
		b.bullet.source_id = this.id
		b.bullet.flight_time = b.bullet.flight_time + fts(math.random(-7, 7))
		b.bullet.rotation_speed = b.bullet.rotation_speed * (0.5 + math.random() * 1.5)

		if math.random(1, 2) == 1 then
			b.bullet.rotation_speed = -b.bullet.rotation_speed
		end

		queue_insert(store, b)
	end

	local function shoot_cannon()
		local explotion = E:create_entity(this.cannon_shot_fx_t)

		explotion.pos = this.cannon.pos
		explotion.render.sprites[1].ts = store.tick_ts

		if this.cannon.pos.x < 512 then
			explotion.render.sprites[1].flip_x = true
		end

		queue_insert(store, explotion)

		local positions_aux = P:get_all_valid_pos(this.cannon.shot_target_pos.x, this.cannon.shot_target_pos.y, 0, 150, TERRAIN_LAND, nil, 0, {
			1,
			2,
			3
		})
		local positions = {}

		for i = 1, this.clones_count * 2 do
			local idx = math.random(1, #positions_aux)

			table.insert(positions, positions_aux[idx])
			table.remove(positions_aux, idx)
		end

		local dies = false

		for k, v in pairs(positions) do
			shoot_clone(v, dies)

			dies = not dies
		end
	end

	for i, v in pairs(store.entities) do
		if v.template_name == this._decal then
			this.cannon = v
		end
	end

	while true do
		if this.shoot_cannon then
			this.cannon.render.sprites[1].hidden = false

			U.y_animation_play(this.cannon, "start", nil, store.tick_ts, 1)
			U.y_wait(store, fts(21))
			S:queue(this.sound_shot)
			U.animation_start(this.cannon, "shoot", nil, store.tick_ts, false)
			U.y_wait(store, this.cannon_shoot_time)
			shoot_cannon()
			U.y_animation_wait(this.cannon)

			this.cannon.render.sprites[1].hidden = true
			this.shoot_cannon = false
		end

		coroutine.yield()
	end
end

function scripts.controller_stage_27_cannon.on_cannons_event(this, store, action, clones_count)
	this.shoot_cannon = true
	this.clones_count = clones_count
end

scripts.controller_spawn_enemy_common_clone = {}

function scripts.controller_spawn_enemy_common_clone.update(this, store)
	U.y_wait(store, this.spawn_delay)

	local nearest_nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1,
		2,
		3
	})
	local pi, spi, ni = unpack(nearest_nodes[1])
	local clone = E:create_entity(this.spawn_t)

	clone.nav_path.pi = pi
	clone.nav_path.ni = ni
	clone.nav_path.spi = spi
	clone.pos = V.vclone(this.pos)
	clone.source_id = this.id

	queue_insert(store, clone)
end

scripts.controller_stage_27_head = {}

function scripts.controller_stage_27_head.update(this, store)
	local head_pos = V.v(-188, 768)
	local head

	this.towers_stunned = 0

	if store.level_mode == GAME_MODE_CAMPAIGN then
		while not this.spawn_head do
			coroutine.yield()
		end

		head = E:create_entity(this.head_t)
		head.pos = V.vclone(head_pos)
		head.render.sprites[1].ts = store.tick_ts

		queue_insert(store, head)
	else
		for k, v in pairs(store.entities) do
			if v.template_name == this.head_t then
				head = v

				break
			end
		end

		this.ui.can_click = false
	end

	local taps_count = 0
	local tap_ts = 0
	local ray_shake, shooting_ray

	local function update_click_rect(dt, phase)
		this.ui.click_rect.pos.x = head.render.sprites[1].offset.x - 100
	end

	local function check_tap()
		if taps_count >= this.taps_to_cancel then
			return
		end

		if this.ui.clicked and (head.render.sprites[1].name == "ray" or head.render.sprites[1].name == "charge") then
			this.ui.clicked = nil
			tap_ts = store.tick_ts
			taps_count = taps_count + 1

			if taps_count >= this.taps_to_cancel then
				S:stop(this.sound_shoot)
				S:queue(this.sound_interrupt)
				U.animation_start(head, "raycancel", nil, store.tick_ts, false)

				shooting_ray = false

				if ray_shake then
					ray_shake.aura.duration = 0
				end

				local shake = E:create_entity("aura_screen_shake")

				shake.aura.amplitude = 1
				shake.aura.duration = 1
				shake.aura.freq_factor = 1

				queue_insert(store, shake)

				return true
			else
				S:queue(this.sound_cancel_tap)
				U.animation_start(head, "chargetap", nil, store.tick_ts, false)

				local offset_x = math.random(10, 15)
				local offset_y = math.random(10, 15)

				if math.random(0, 1) == 1 then
					offset_x = -offset_x
				end

				if math.random(0, 1) == 1 then
					offset_y = -offset_y
				end

				head.pos = V.v(head_pos.x + offset_x, head_pos.y + offset_y)
			end
		end

		if head.render.sprites[1].name == "chargetap" and store.tick_ts - tap_ts > fts(1) then
			if not shooting_ray then
				U.animation_start(head, "charge", nil, store.tick_ts, true)
			else
				U.animation_start(head, "ray", nil, store.tick_ts, true)
			end

			head.pos = V.vclone(head_pos)
		end

		return false
	end

	local function check_ray_end(end_offset, ray)
		if head.render.sprites[1].name == "raycancel" and U.animation_finished(head) then
			U.animation_start(head, "idle", nil, store.tick_ts, true)
		end

		if not ray then
			return
		end

		if head.render.sprites[1].name == "ray" and math.abs(head.render.sprites[1].offset.x) < math.abs(end_offset) then
			ray_shake.aura.duration = 0

			U.animation_start(head, "rayend", nil, store.tick_ts, false)
			U.animation_start(ray, "end", nil, store.tick_ts, false)
		end

		if ray.render.sprites[1].name == "end" and U.animation_finished(ray) then
			queue_remove(store, ray)
		end

		if head.render.sprites[1].name == "rayend" and U.animation_finished(head) then
			U.animation_start(head, "idle", nil, store.tick_ts, true)
		end
	end

	local function check_ray_dmg(ray)
		if not ray then
			return
		end

		if head.render.sprites[1].name ~= "ray" and head.render.sprites[1].name ~= "chargetap" then
			return
		end

		for k, v in pairs(store.entities) do
			if not v.pending_removal and v.pos and math.abs(v.pos.x - (ray.pos.x + ray.render.sprites[1].offset.x)) < 50 and v.pos.y < ray.pos.y then
				if v.tower and v.tower.type ~= "holder" and not U.has_modifiers(store, v, this.ray_stun_mod_t) then
					this.towers_stunned = this.towers_stunned + 1

					local m = E:create_entity(this.ray_stun_mod_t)

					m.modifier.target_id = v.id
					m.modifier.source_id = this.id

					queue_insert(store, m)
				elseif (v.enemy or v.soldier) and v.health and not v.health.dead then
					local d = E:create_entity("damage")

					d.source_id = this.id
					d.target_id = v.id
					d.damage_type = this.ray_damage_type
					d.value = 1
					d.pop_chance = 0

					queue_damage(store, d)
				end
			end
		end
	end

	while true do
		if this.do_attack then
			local start_offset, end_offset

			if this.attack_side == "left" then
				start_offset = -500
				end_offset = -250
			else
				start_offset = 380
				end_offset = 210
			end

			S:queue(this.sound_move)
			U.y_animation_play(head, "startmove", nil, store.tick_ts, 1)
			U.y_animation_play(head, "startmove" .. this.attack_side, nil, store.tick_ts, 1)
			U.animation_start(head, "move" .. this.attack_side, nil, store.tick_ts, true)
			U.y_ease_key(store, head.render.sprites[1].offset, "x", 0, start_offset, fts(60), "sine", update_click_rect)
			U.y_animation_play(head, "endmove" .. this.attack_side, nil, store.tick_ts, 1)

			if this.cannon_clones_count > 0 then
				if this.attack_side == "left" then
					this.cannon_c_right.shoot_cannon = true
					this.cannon_c_right.clones_count = this.cannon_clones_count
				else
					this.cannon_c_left.shoot_cannon = true
					this.cannon_c_left.clones_count = this.cannon_clones_count
				end
			end

			U.y_animation_play(head, "endmovetocharge", nil, store.tick_ts, 1)

			local charge_ts = store.tick_ts

			S:queue(this.sound_charge)
			U.animation_start(head, "charge", nil, store.tick_ts, true)

			taps_count = 0
			this.ui.clicked = nil

			local shown_hand = false

			while store.tick_ts - charge_ts < this.charge_time do
				if store.tick_ts - charge_ts > 2 and not shown_hand then
					shown_hand = true

					local hand = E:create_entity(this.hand_decal_t)

					hand.pos = V.v(615, 570)
					hand.render.sprites[1].offset = head.render.sprites[1].offset
					hand.render.sprites[1].ts = store.tick_ts
					hand.tween.ts = store.tick_ts

					queue_insert(store, hand)
				end

				if check_tap() then
					break
				end

				coroutine.yield()
			end

			local ray

			if taps_count < this.taps_to_cancel then
				shooting_ray = true

				S:queue(this.sound_shoot)

				ray_shake = E:create_entity("aura_screen_shake")
				ray_shake.aura.amplitude = 0.25
				ray_shake.aura.duration = 10
				ray_shake.aura.freq_factor = 4

				queue_insert(store, ray_shake)
				U.animation_start(head, "idle", nil, store.tick_ts, true)

				ray = E:create_entity(this.ray_t)
				ray.pos = V.v(591, 517)
				ray.render.sprites[1].offset = head.render.sprites[1].offset
				ray.render.sprites[1].ts = store.tick_ts

				queue_insert(store, ray)
				U.animation_start(ray, "start", nil, store.tick_ts, false)
				U.y_animation_play(head, "raystart", nil, store.tick_ts, 1)
				U.animation_start(ray, "loop", nil, store.tick_ts, true)
				U.animation_start(head, "ray", nil, store.tick_ts, true)
			end

			local ray_ts = store.tick_ts
			local stun_check_ts = store.tick_ts
			local phase
			local stop_sfx = false

			repeat
				local dt = store.tick_ts - ray_ts

				phase = km.clamp(0, 1, dt / this.attack_duration)
				head.render.sprites[1].offset.x = U.ease_value(start_offset, 0, phase, "quad")

				update_click_rect()

				if check_tap() then
					U.animation_start(ray, "end", nil, store.tick_ts, false)
				end

				if not stop_sfx and math.abs(head.render.sprites[1].offset.x) < math.abs(end_offset) then
					stop_sfx = true

					S:queue(this.sound_return)
				end

				check_ray_end(end_offset, ray)

				if store.tick_ts - stun_check_ts > 0.05 then
					check_ray_dmg(ray)

					stun_check_ts = store.tick_ts
				end

				coroutine.yield()
			until phase >= 1

			shooting_ray = false

			if taps_count >= this.taps_to_cancel and ray then
				U.y_animation_wait(ray)
			end

			this.do_attack = false
		elseif this.cannons_in then
			if this.cannons_config == "both" then
				local delay_between = fts(8)

				this.cannon_c_right.shoot_cannon = true
				this.cannon_c_right.clones_count = this.cannons_clones_count

				U.y_wait(store, delay_between)

				this.cannon_c_left.shoot_cannon = true
				this.cannon_c_left.clones_count = this.cannons_clones_count
			elseif this.cannons_config == "left" then
				this.cannon_c_left.shoot_cannon = true
				this.cannon_c_left.clones_count = this.cannons_clones_count
			else
				this.cannon_c_right.shoot_cannon = true
				this.cannon_c_right.clones_count = this.cannons_clones_count
			end

			this.cannons_in = false
		elseif this.activate_ears then
			if this.ears_config == "open" then
				S:queue(this.sound_ears_open)
				U.y_animation_play(head, "spawnstart", nil, store.tick_ts, 1)
				U.animation_start(head, "spawnidle", nil, store.tick_ts, true)
			else
				S:queue(this.sound_ears_close)
				U.y_animation_play(head, "spawnleave", nil, store.tick_ts, 1)
				U.animation_start(head, "idle", nil, store.tick_ts, true)
			end

			this.activate_ears = false
		elseif this.destroy_head then
			local function stun_towers()
				local towers = table.filter(store.entities, function(k, v)
					return not v.pending_removal and v.tower and not v.tower.blocked
				end)
				local selected_towers = {}

				if #towers > this.towers_to_stun then
					selected_towers = table.filter(towers, function(k, v)
						return v.tower.type ~= "holder"
					end)

					if #selected_towers < this.towers_to_stun then
						local holders = table.filter(towers, function(k, v)
							return v.tower.type == "holder"
						end)

						for i = #holders, 2, -1 do
							local j = math.random(i)

							holders[i], holders[j] = holders[j], holders[i]
						end

						for i = 1, this.towers_to_stun - #selected_towers do
							table.insert(selected_towers, holders[i])
						end
					elseif #selected_towers > this.towers_to_stun then
						for i = #selected_towers, 2, -1 do
							local j = math.random(i)

							selected_towers[i], selected_towers[j] = selected_towers[j], selected_towers[i]
						end

						for i = 1, #selected_towers - this.towers_to_stun do
							table.remove(selected_towers, 1)
						end
					end
				else
					selected_towers = towers
				end

				for k, v in pairs(selected_towers) do
					local bullet = E:create_entity(this.tower_stun_bullet_t)

					bullet.pos = V.v(591, 508)
					bullet.pos.x = bullet.pos.x - 70 + 140 * (v.pos.x / 1024)
					bullet.bullet.from = V.vclone(bullet.pos)
					bullet.bullet.to = V.vclone(v.pos)
					bullet.bullet.source_id = this.id
					bullet.bullet.target_id = v.id
					bullet.bullet.flight_time = bullet.bullet.flight_time + fts(math.random(-10, 10))

					queue_insert(store, bullet)
				end
			end

			S:queue("Stage27PreBossfightCinematic")
			U.y_wait(store, fts(12))
			U.y_animation_play(head, "headdeathstart", nil, store.tick_ts, 1)
			U.animation_start(head, "headdeathidle", nil, store.tick_ts, true)

			local goblins = E:create_entity(this.goblins_t)

			goblins.pos = V.vclone(head_pos)
			goblins.render.sprites[1].ts = store.tick_ts

			queue_insert(store, goblins)
			U.animation_start(goblins, "headdeath", nil, store.tick_ts, false)
			U.y_wait(store, fts(278))
			U.animation_start(head, "headdeathbombisplaced", nil, store.tick_ts, false)
			U.y_wait(store, fts(60))

			goblins.render.sprites[1].sort_y_offset = -390

			local explotion_ts = store.tick_ts
			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 2
			shake.aura.duration = 2
			shake.aura.freq_factor = 2

			queue_insert(store, shake)
			stun_towers()
			U.y_animation_wait(head)

			local smoke_back = E:create_entity(this.smoke_back_t)

			smoke_back.render.sprites[1].ts = store.tick_ts
			smoke_back.pos = V.vclone(head.pos)

			queue_insert(store, smoke_back)

			local smoke_front = E:create_entity(this.smoke_front_t)

			smoke_front.render.sprites[1].ts = store.tick_ts
			smoke_front.pos = V.vclone(head.pos)

			queue_insert(store, smoke_front)

			local sparks = E:create_entity(this.sparks_t)

			sparks.render.sprites[1].ts = store.tick_ts
			sparks.pos = V.vclone(head.pos)

			queue_insert(store, sparks)
			U.y_wait(store, fts(1))
			U.animation_start(head, "headdeathsmokeidle", nil, store.tick_ts, true)
			U.y_wait(store, fts(92) - (store.tick_ts - explotion_ts))

			local boss = E:create_entity("boss_grymbeard")

			boss.nav_path.pi = 3

			if math.random(1, 2) == 1 then
				boss.nav_path.pi = 7
			end

			boss.nav_path.spi = 1
			boss.pos = V.v(592, 394)

			local node = P:nearest_nodes(boss.pos.x, boss.pos.y, {
				boss.nav_path.pi
			}, {
				boss.nav_path.spi
			})[1]
			local pi, spi, ni = unpack(node)

			boss.nav_path.ni = ni + 5

			queue_insert(store, boss)
			U.y_wait(store, fts(1))
			U.animation_start(goblins, "decal", nil, store.tick_ts, true)

			goblins.render.sprites[1].z = Z_DECALS
			this.destroy_head = false
		elseif this.shoot_scrap then
			local function shuffle_table(nodes)
				for i = #nodes, 2, -1 do
					local j = math.random(i)

					nodes[i], nodes[j] = nodes[j], nodes[i]
				end

				return nodes
			end

			local function shoot_scrap(pos)
				local bullet = E:create_entity(this.scrap_bullet_t)

				bullet.pos = V.v(591, 508)
				bullet.pos.x = bullet.pos.x - 70 + 140 * (pos.x / 1024)
				bullet.bullet.from = V.vclone(bullet.pos)
				bullet.bullet.to = V.vclone(pos)
				bullet.bullet.source_id = this.id
				bullet.bullet.flight_time = bullet.bullet.flight_time + fts(math.random(-7, 7))

				queue_insert(store, bullet)

				local fx = E:create_entity(this.scrap_fx_t)

				fx.pos = V.vclone(bullet.pos)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end

			S:queue("Stage27BFRobotScrapCast")
			U.animation_start(head, "headdeathscrapshoot", nil, store.tick_ts, false)
			U.y_wait(store, fts(4))

			local shake = E:create_entity("aura_screen_shake")

			shake.aura.amplitude = 0.5
			shake.aura.duration = 1
			shake.aura.freq_factor = 1

			queue_insert(store, shake)

			local selected_positions = {}
			local target, targets = U.find_soldiers_in_range(store.entities, this.pos, 150, 1000, bor(F_ENEMY), bor(F_FLYING))
			local max_dist2 = 10000

			for i = 1, this.scrap_count do
				if not targets or #targets == 0 or #selected_positions > this.scrap_count / 2 then
					goto label_1538_0
				end

				local sel_target = targets[1]
				local node_offset = P:predict_enemy_node_advance(sel_target, fts(30))
				local e_ni = sel_target.nav_path.ni + node_offset
				local e_pos = P:node_pos(sel_target.nav_path.pi, sel_target.nav_path.spi, e_ni)

				table.insert(selected_positions, e_pos)
				table.remove(targets, 1)

				for i = #targets, 1, -1 do
					local e = targets[i]

					if max_dist2 > V.dist2(sel_target.pos.x, sel_target.pos.y, e.pos.x, e.pos.y) then
						table.remove(targets, i)
					end
				end
			end

			if #selected_positions == this.scrap_count then
				goto label_1538_1
			end

			::label_1538_0::

			do
				local nodes = P:get_all_valid_pos(this.pos.x, this.pos.y, 0, 1000, TERRAIN_LAND)

				shuffle_table(nodes)

				for i = #selected_positions + 1, this.scrap_count do
					local sel_node = nodes[1]

					table.insert(selected_positions, sel_node)
					table.remove(nodes, 1)

					for i = #nodes, 1, -1 do
						local n = nodes[i]

						if max_dist2 > V.dist2(sel_node.x, sel_node.y, n.x, n.y) then
							table.remove(nodes, i)
						end
					end
				end
			end

			::label_1538_1::

			shuffle_table(selected_positions)

			for _, p in pairs(selected_positions) do
				shoot_scrap(p)
			end

			U.y_animation_wait(head)

			this.shoot_scrap = false
		end

		coroutine.yield()
	end
end

function scripts.controller_stage_27_head.on_attack_left_event(this, store, action)
	log.info("EVENT: RAY ATTACK LEFT")

	this.do_attack = true
	this.attack_side = "left"
	this.cannon_clones_count = 0
end

function scripts.controller_stage_27_head.on_attack_right_event(this, store, action)
	log.info("EVENT: RAY ATTACK RIGHT")

	this.do_attack = true
	this.attack_side = "right"
	this.cannon_clones_count = 0
end

function scripts.controller_stage_27_head.on_attack_left_cannon_event(this, store, action, clones_count)
	log.info("EVENT: RAY ATTACK LEFT WITH CANNON")

	this.do_attack = true
	this.attack_side = "left"
	this.cannon_clones_count = tonumber(clones_count)
end

function scripts.controller_stage_27_head.on_attack_right_cannon_event(this, store, action, clones_count)
	log.info("EVENT: RAY ATTACK RIGHT WITH CANNON")

	this.do_attack = true
	this.attack_side = "right"
	this.cannon_clones_count = tonumber(clones_count)
end

function scripts.controller_stage_27_head.on_cannons_event(this, store, action, config, clones_count)
	log.info("EVENT: CANNONS - " .. config)

	this.cannons_in = true
	this.cannons_config = config
	this.cannons_clones_count = clones_count
end

function scripts.controller_stage_27_head.on_ears_event(this, store, action, config)
	log.info("EVENT: ACTIVATE EARS")

	this.activate_ears = true
	this.ears_config = config
end

function scripts.controller_stage_27_head.on_head_destroy_event(this, store, action)
	log.info("EVENT: DESTROY HEAD")

	this.destroy_head = true
end

function scripts.controller_stage_27_head.on_scrap_event(this, store, action, scrap_count)
	log.info("EVENT: SHOOT SCRAP")

	this.shoot_scrap = true
	this.scrap_count = scrap_count
end

scripts.mod_stage_27_ray_stun = {}

function scripts.mod_stage_27_ray_stun.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	m.ts = store.tick_ts

	SU.tower_block_inc(target)

	this.pos = target.pos
	this.tween.ts = store.tick_ts

	U.animation_start(this, "run", nil, store.tick_ts, true, 2)
	U.y_animation_play(this, "start", nil, store.tick_ts, 1, 1)
	U.animation_start(this, "loop", nil, store.tick_ts, true, 1)

	local start_ts = store.tick_ts

	while store.tick_ts - start_ts < m.duration do
		if this.remove then
			break
		end

		coroutine.yield()
	end

	SU.tower_block_dec(target)

	this.tween.ts = store.tick_ts
	this.tween.reverse = true
	this.tween.remove = true
end

scripts.bullet_stage_27_tower_stun = {}

function scripts.bullet_stage_27_tower_stun.update(this, store, script)
	local b = this.bullet
	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local warp_factor = b.warp_time and b.warp_time or 1

	while (store.tick_ts - b.ts + store.tick_length) * warp_factor < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola((store.tick_ts - b.ts) * warp_factor, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		else
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	local target = b.target_id and store.entities[b.target_id]

	if b.mod and target then
		local mod = E:create_entity(b.mod)

		mod.modifier.target_id = target.id
		mod.modifier.source_id = this.id

		queue_insert(store, mod)
	end

	S:queue(this.sound_events.hit)

	if b.hit_fx then
		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, sfx)
	end

	queue_remove(store, this)
end

scripts.mod_bullet_stage_27_tower_stun = {}

function scripts.mod_bullet_stage_27_tower_stun.update(this, store)
	local m = this.modifier
	local target = store.entities[m.target_id]
	local source = store.entities[m.source_id]

	if not target then
		queue_remove(store, this)

		return
	end

	local shown_hand = false

	local function block_tower()
		local t = target.tower

		t.block_count = t.block_count + 1

		if t.block_count > 0 then
			t.blocked = true

			if target.tower and not target.tower_holder then
				t.can_be_sold = false
			end
		end

		if target.tower and not target.tower._type then
			target.tower._type = target.tower.type
			target.tower.type = "tower_broken_stage_27"
			target.trigger_deselect = true
			target.repair = {}
			target.repair.cost = this.repair_cost[1]
			target.repair.active = false

			if not target.user_selection then
				E:add_comps(target, "user_selection")
			end
		end
	end

	local function unblock_tower()
		local t = target.tower

		t.block_count = 0

		if t.block_count < 1 then
			t.blocked = nil
			t.block_count = 0

			if target.tower and not target.tower_holder then
				t.can_be_sold = true
			end
		end
	end

	local function update_prices()
		local blocked = {}

		for k, v in pairs(store.entities) do
			if v.template_name == "mod_bullet_stage_27_tower_stun" and v.id ~= this.id then
				local tower = store.entities[v.modifier.target_id]

				if tower and not tower.repair.active then
					table.insert(blocked, tower)
				end
			end
		end

		local new_cost

		if 13 - #blocked + 1 > #this.repair_cost then
			new_cost = this.repair_cost[#this.repair_cost]
		else
			new_cost = this.repair_cost[13 - #blocked + 1]
		end

		for k, v in pairs(blocked) do
			v.repair.cost = new_cost
		end
	end

	m.ts = store.tick_ts

	block_tower()

	this.pos = target.pos

	U.y_animation_play(this, "in", nil, store.tick_ts, 1)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	local start_ts = store.tick_ts
	local tap_ts = store.tick_ts
	local tap_cd = math.random(4, 10)
	local hand

	while true do
		if target.user_selection.in_progress and not target.repair.active then
			target.user_selection.in_progress = nil
			target.user_selection.allowed = false
			store.player_gold = store.player_gold - target.repair.cost
			target.repair.active = true

			update_prices()
			S:queue("GUITowerSell", {
				delay = 0.5
			})
			U.y_animation_play(this, "out", nil, store.tick_ts, 1)

			break
		end

		if not shown_hand and tap_cd < store.tick_ts - tap_ts then
			hand = E:create_entity(this.hand_decal_t)
			hand.pos = this.pos
			hand.render.sprites[1].ts = store.tick_ts
			hand.tween.ts = store.tick_ts

			queue_insert(store, hand)

			shown_hand = true
		end

		if not table.contains(store.entities, target) then
			local towers = table.filter(store.entities, function(k, v)
				return not v.pending_removal and (v.tower and not v.tower.blocked or v.tower_holder and not v.tower_holder.blocked) and not v.tower.blocked and U.is_inside_ellipse(v.pos, this.pos, 20)
			end)

			if #towers > 0 then
				target = towers[1]
				target.test_deselect = true
				this.modifier.target_id = target.id

				block_tower()
			end
		end

		coroutine.yield()
	end

	if hand then
		queue_remove(store, hand)
	end

	unblock_tower()

	target.trigger_deselect = true
	target.user_selection.allowed = true

	queue_remove(store, this)
end

function scripts.mod_bullet_stage_27_tower_stun.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	if target then
		target.tower.type = target.tower._type
		target.tower._type = nil
	end

	return true
end

scripts.decal_stage_27_modes_decos = {}

function scripts.decal_stage_27_modes_decos.update(this, store, script)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil
			this.ui.can_click = false

			S:queue("Stage09SheepyCamera")
			U.y_animation_play(this, "action_" .. math.random(1, 3), nil, store.tick_ts, 1)
			U.animation_start(this, "idle", nil, store.tick_ts, true)

			this.ui.can_click = true
		end

		coroutine.yield()
	end
end

scripts.decal_stage_27_beam = {}

function scripts.decal_stage_27_beam.update(this, store, script)
	local taps = 0
	local idle_ts = store.tick_ts
	local idle_cd = math.random(5, 10)
	local doing_idle = false

	U.animation_start(this, "idle", nil, store.tick_ts, true)

	while true do
		if taps > 1 then
			-- block empty
		else
			if this.ui.clicked then
				this.ui.clicked = nil
				this.ui.can_click = false
				doing_idle = false
				taps = taps + 1

				S:queue(this.sound_prefix .. taps)

				if taps == 2 then
					S:queue(this.sound_prefix .. 3, {
						delay = 3
					})
				end

				U.y_animation_play(this, "action_" .. taps, nil, store.tick_ts, 1)

				if taps == 1 then
					this.ui.can_click = true

					U.animation_start(this, "idle_3", nil, store.tick_ts, true)
				else
					U.animation_start(this, "idle_5", nil, store.tick_ts, true)
					signal.emit("workers-stage27", this)

					goto label_1566_0
				end
			end

			if doing_idle and U.animation_finished(this) then
				doing_idle = false

				if taps == 0 then
					U.animation_start(this, "idle", nil, store.tick_ts, true)
				else
					U.animation_start(this, "idle_3", nil, store.tick_ts, true)
				end
			end

			if not doing_idle and idle_cd < store.tick_ts - idle_ts then
				doing_idle = true

				if taps == 0 then
					U.animation_start(this, "idle_2", nil, store.tick_ts, false)
				else
					U.animation_start(this, "idle_4", nil, store.tick_ts, false)
				end

				idle_ts = store.tick_ts
				idle_cd = math.random(5, 10)
			end
		end

		::label_1566_0::

		coroutine.yield()
	end
end

scripts.boss_grymbeard = {}

function scripts.boss_grymbeard.update(this, store, script)
	local spawn_ts = store.tick_ts
	local ra = this.ranged.attacks[1]

	local function shoot_clone(spawn_pos, target_pos)
		local b = E:create_entity(this.death_bullet_clone)

		b.pos = V.vclone(spawn_pos)
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.vclone(target_pos)
		b.bullet.source_id = this.id
		b.bullet.flight_time = b.bullet.flight_time + fts(math.random(-5, 5))
		b.bullet.rotation_speed = b.bullet.rotation_speed * (0.5 + math.random() * 1.5)

		if math.random(1, 2) == 1 then
			b.bullet.rotation_speed = -b.bullet.rotation_speed
		end

		queue_insert(store, b)
	end

	local function shoot_himself(spawn_pos, target_pos)
		local b = E:create_entity(this.death_bullet_boss)

		b.pos = V.vclone(spawn_pos)
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.vclone(target_pos)
		b.bullet.source_id = this.id

		queue_insert(store, b)
	end

	local function shoot_scrap(spawn_pos, target_pos, type)
		local b = E:create_entity(this.death_bullet_scrap .. type)

		b.pos = V.vclone(spawn_pos)
		b.bullet.from = V.vclone(b.pos)
		b.bullet.to = V.vclone(target_pos)
		b.bullet.source_id = this.id
		b.bullet.flight_time = b.bullet.flight_time + fts(math.random(-7, 7))
		b.bullet.rotation_speed = b.bullet.rotation_speed * (0.5 + math.random() * 1.5)

		if math.random(1, 2) == 1 then
			b.bullet.rotation_speed = -b.bullet.rotation_speed
		end

		queue_insert(store, b)
	end

	local function y_on_death()
		local function pick_clone_pos(offset_x, spi)
			if this.render.sprites[1].flip_x then
				offset_x = -offset_x
			end

			local nearest_nodes = P:nearest_nodes(this.pos.x + offset_x, this.pos.y)
			local pi, _, ni = unpack(nearest_nodes[1])
			local ni = ni + math.random(-5, 5)
			local pos = P:node_pos(pi, spi, ni)

			if V.dist2(pos.x, pos.y, this.pos.x, this.pos.y) < 2500 then
				ni = ni - 10

				return P:node_pos(pi, spi, ni)
			else
				return pos
			end
		end

		LU.kill_all_enemies(store, true)
		S:stop_all()
		W:stop_manual_wave("BOSS2")
		S:queue(this.sound_death)
		U.animation_start(this, "death", nil, store.tick_ts, false)

		local x_mult = this.render.sprites[1].flip_x and -1 or 1

		U.y_wait(store, fts(2))

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.5
		shake.aura.duration = 1
		shake.aura.freq_factor = 1

		queue_insert(store, shake)

		local t_pos = pick_clone_pos(-150, 2)

		shoot_clone(V.v(this.pos.x - 30 * x_mult, this.pos.y + 120), t_pos)
		U.y_wait(store, fts(64))

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.5
		shake.aura.duration = 1
		shake.aura.freq_factor = 1

		queue_insert(store, shake)

		t_pos = pick_clone_pos(150, 3)

		shoot_clone(V.v(this.pos.x + 30 * x_mult, this.pos.y + 120), t_pos)

		t_pos = pick_clone_pos(180, 2)

		shoot_clone(V.v(this.pos.x + 30 * x_mult, this.pos.y + 120), t_pos)
		U.y_wait(store, fts(48))

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.5
		shake.aura.duration = 0.5
		shake.aura.freq_factor = 1

		queue_insert(store, shake)

		t_pos = pick_clone_pos(-200, 3)

		shoot_clone(V.v(this.pos.x - 60 * x_mult, this.pos.y + 120), t_pos)
		U.y_wait(store, fts(26))

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 0.5
		shake.aura.duration = 0.5
		shake.aura.freq_factor = 1

		queue_insert(store, shake)

		t_pos = pick_clone_pos(200, 1)

		shoot_clone(V.v(this.pos.x + 10 * x_mult, this.pos.y + 120), t_pos)

		t_pos = pick_clone_pos(230, 2)

		shoot_clone(V.v(this.pos.x + 10 * x_mult, this.pos.y + 120), t_pos)
		U.y_wait(store, fts(52))

		local shake = E:create_entity("aura_screen_shake")

		shake.aura.amplitude = 1.5
		shake.aura.duration = 1
		shake.aura.freq_factor = 1.5

		queue_insert(store, shake)

		t_pos = pick_clone_pos(-130, 1)

		shoot_himself(V.v(this.pos.x - 20 * x_mult, this.pos.y + 120), t_pos)

		t_pos = pick_clone_pos(-100, 2)

		shoot_scrap(V.v(this.pos.x - 20 * x_mult, this.pos.y + 120), t_pos, 1)

		t_pos = pick_clone_pos(100, 3)

		shoot_scrap(V.v(this.pos.x - 20 * x_mult, this.pos.y + 120), t_pos, 1)

		t_pos = pick_clone_pos(150, 2)

		shoot_scrap(V.v(this.pos.x - 20 * x_mult, this.pos.y + 120), t_pos, 2)
		U.y_animation_wait(this)
		LU.kill_all_enemies(store, true)
		signal.emit("boss-killed", this)

		this.bossfight_ended = true
	end

	U.animation_start(this, "walk", nil, store.tick_ts, true)
	signal.emit("boss_fight_start", this)
	W:start_manual_wave("BOSS2")

	while true do
		if this.health.dead then
			y_on_death()

			return
		end

		if this.unit.is_stunned then
			SU.y_enemy_stun(store, this)
		else
			local function check_ranged()
				if not ra.disabled and (not ra.requires_magic or this.enemy.can_do_magic) and (ra.hold_advance or store.tick_ts - ra.ts > ra.cooldown) then
					local ranged = U.find_nearest_soldier(store.entities, this.pos, ra.min_range, ra.max_range, ra.vis_flags, ra.vis_bans)

					return ranged
				end

				return nil
			end

			local cont, blocker, ranged = SU.y_enemy_walk_until_blocked(store, this)

			if not cont then
				-- block empty
			else
				if blocker then
					if not SU.y_wait_for_blocker(store, this, blocker) then
						goto label_1567_0
					end

					while SU.can_melee_blocker(store, this, blocker) do
						ranged = check_ranged()

						if ranged then
							break
						end

						if not SU.y_enemy_melee_attacks(store, this, blocker) then
							goto label_1567_0
						end

						coroutine.yield()
					end
				end

				if ranged then
					while SU.can_range_soldier(store, this, ranged) do
						if not SU.y_enemy_range_attacks(store, this, ranged) then
							break
						end

						coroutine.yield()
					end
				end
			end
		end

		::label_1567_0::

		coroutine.yield()
	end
end

scripts.bullet_boss_grymbeard = {}

function scripts.bullet_boss_grymbeard.update(this, store)
	local b = this.bullet
	local fm = this.force_motion
	local target = store.entities[b.target_id]
	local source = store.entities[b.source_id]
	local ps

	if not source then
		queue_remove(store, this)

		return
	end

	local function move_step(dest)
		local dx, dy = V.sub(dest.x, dest.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)
		local nx, ny = V.mul(fm.max_v, V.normalize(dx, dy))
		local stx, sty = V.sub(nx, ny, fm.v.x, fm.v.y)

		if dist <= 8 * fm.max_v * store.tick_length then
			stx, sty = V.mul(fm.max_a, V.normalize(stx, sty))
		end

		fm.a.x, fm.a.y = V.add(fm.a.x, fm.a.y, V.trim(fm.max_a, V.mul(fm.a_step, stx, sty)))
		fm.v.x, fm.v.y = V.trim(fm.max_v, V.add(fm.v.x, fm.v.y, V.mul(store.tick_length, fm.a.x, fm.a.y)))
		this.pos.x, this.pos.y = V.add(this.pos.x, this.pos.y, V.mul(store.tick_length, fm.v.x, fm.v.y))
		fm.a.x, fm.a.y = 0, 0

		return dist <= fm.max_v * store.tick_length
	end

	local function fly_to_pos(target_pos)
		local start_ts = store.tick_ts
		local last_pos = V.vclone(this.pos)
		local dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
		local dist = V.len(dx, dy)

		while V.len(dx, dy) > 20 do
			last_pos.x, last_pos.y = this.pos.x, this.pos.y

			move_step(target_pos)

			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			ps.particle_system.emit_offset.x, ps.particle_system.emit_offset.y = V.rotate(this.render.sprites[1].r, ps.emit_offset_relative.x, ps.emit_offset_relative.y)
			dx, dy = V.sub(target_pos.x, target_pos.y, this.pos.x, this.pos.y)
			dist = V.len(dx, dy)

			coroutine.yield()
		end
	end

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.emit = true
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	local spawn_pos = V.vclone(this.pos)
	local source_pos = V.vclone(source.pos)
	local attack = table.deepclone(source.ranged.attacks[1])

	fm.a.x, fm.a.y = 0, 180

	local target_pos = v(spawn_pos.x, source_pos.y + 230)

	fly_to_pos(target_pos)

	local side_flip = 1

	if target and target.pos.x < spawn_pos.x then
		side_flip = -1
	end

	fm.a.x, fm.a.y = 100, 0

	local target_pos = v(spawn_pos.x + 70 * side_flip, source_pos.y + 230)

	fly_to_pos(target_pos)

	target_pos = v(spawn_pos.x + 35 * side_flip, source_pos.y + 200)

	fly_to_pos(target_pos)

	target_pos = v(spawn_pos.x, source_pos.y + 230)

	fly_to_pos(target_pos)

	target_pos = v(spawn_pos.x, source_pos.y + 280)

	fly_to_pos(target_pos)

	if target then
		target_pos = v(target.pos.x, source_pos.y + 280)

		fly_to_pos(target_pos)
	end

	fm.a_step = 5
	fm.max_a = 2700
	fm.max_v = 900
	ps.particle_system.emission_rate = 90

	if not target or target.health.dead then
		local new_target, targets = U.find_foremost_enemy(store.entities, source_pos, 0, attack.max_range, false, attack.vis_flags, attack.vis_bans, attack.filter_fn)

		if new_target then
			b.target_id = new_target.id
		end
	end

	local last_pos = V.vclone(this.pos)

	b.ts = store.tick_ts

	if target and band(target.vis.flags, F_FLYING) ~= 0 then
		b.ignore_hit_offset = false
	end

	while true do
		target = store.entities[b.target_id]

		if target and target.health and not target.health.dead and band(target.vis.bans, F_RANGED) == 0 then
			local hit_offset = V.v(0, 0)

			if not b.ignore_hit_offset then
				hit_offset.x = target.unit.hit_offset.x
				hit_offset.y = target.unit.hit_offset.y
			end

			b.to.x, b.to.y = target.pos.x + hit_offset.x, target.pos.y + hit_offset.y
		end

		last_pos.x, last_pos.y = this.pos.x, this.pos.y

		if move_step(b.to) then
			break
		end

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - last_pos.x, this.pos.y - last_pos.y)
			ps.particle_system.emit_offset.x, ps.particle_system.emit_offset.y = V.rotate(this.render.sprites[1].r, ps.emit_offset_relative.x, ps.emit_offset_relative.y)
		end

		coroutine.yield()
	end

	this.render.sprites[1].hidden = 0

	if b.damage_radius and b.damage_radius > 0 then
		local targets = U.find_soldiers_in_range(store.entities, this.pos, 0, b.damage_radius, b.vis_flags, b.vis_bans)

		if targets then
			for _, target in pairs(targets) do
				local d = SU.create_bullet_damage(b, target.id, this.id)

				queue_damage(store, d)
			end
		end
	end

	S:queue(this.sound_events.hit)

	if b.hit_decal then
		local decal = E:create_entity(b.hit_decal)

		decal.pos = V.vclone(b.to)
		decal.render.sprites[1].ts = store.tick_ts

		queue_insert(store, decal)
	end

	if b.hit_fx then
		local fx = E:create_entity(b.hit_fx)

		fx.pos = V.vclone(b.to)
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	if ps and ps.particle_system.emit then
		ps.particle_system.emit = false

		U.y_wait(store, ps.particle_system.particle_lifetime[2])
	end

	U.y_animation_wait(this)
	queue_remove(store, this)
end

scripts.ray5_simple = {}

function scripts.ray5_simple.update(this, store)
	local b = this.bullet
	local s = this.render.sprites[1]
	local target = store.entities[b.target_id]
	local dest = V.vclone(b.to)
	local tower = this.tower_ref

	local function update_sprite()
		if this.track_target and target and target.motion then
			local tpx, tpy = target.pos.x, target.pos.y

			if not b.ignore_hit_offset then
				tpx, tpy = tpx + target.unit.hit_offset.x, tpy + target.unit.hit_offset.y
			end

			local d = math.max(math.abs(tpx - b.to.x), math.abs(tpy - b.to.y))

			if d > b.max_track_distance then
				log.paranoid("(%s) ray_simple target (%s) out of max_track_distance", this.id, target.id)

				target = nil
			else
				dest.x, dest.y = target.pos.x, target.pos.y

				if target.unit and target.unit.hit_offset then
					dest.x, dest.y = dest.x + target.unit.hit_offset.x, dest.y + target.unit.hit_offset.y
				end
			end
		end

		local angle = V.angleTo(dest.x - this.pos.x, dest.y - this.pos.y)

		s.r = angle

		local dist_offset = 0

		if this.dist_offset then
			dist_offset = this.dist_offset
		end

		s.scale.x = (V.dist(dest.x, dest.y, this.pos.x, this.pos.y) + dist_offset) / this.image_width
	end

	if not b.ignore_hit_offset and this.track_target and target and target.motion then
		b.to.x, b.to.y = target.pos.x + target.unit.hit_offset.x, target.pos.y + target.unit.hit_offset.y
	end

	s.scale = s.scale or V.v(1, 1)
	s.ts = store.tick_ts

	update_sprite()

	s.hidden = true

	if b.hit_time > fts(1) then
		while store.tick_ts - s.ts < b.hit_time do
			coroutine.yield()

			if target and U.flag_has(target.vis.bans, F_RANGED) then
				target = nil
			end

			if this.track_target then
				update_sprite()
			end
		end
	end

	if target and b.damage_type ~= DAMAGE_NONE then
		local d = SU.create_bullet_damage(b, target.id, this.id)

		queue_damage(store, d)
	end

	local mods_added = {}

	if target and (b.mod or b.mods) then
		local mods = b.mods or {
			b.mod
		}

		for _, mod_name in pairs(mods) do
			local m = E:create_entity(mod_name)

			m.modifier.target_id = b.target_id

			if m.damage_from_bullet then
				local damage_factor = 1
				if tower and tower.tower and tower.tower.damage_factor then
					damage_factor = tower.tower.damage_factor
				end
				if m.dps then
					m.dps.damage_min = math.ceil(b.damage_min * damage_factor)
					m.dps.damage_max = math.ceil(b.damage_max * damage_factor)
				else
					m.modifier.damage_min = math.ceil(b.damage_min * damage_factor)
					m.modifier.damage_max = math.ceil(b.damage_max * damage_factor)
				end
			else
				local level

				if not tower then
					level = this.bullet.level
				else
					level = tower.level
					level = level or this.bullet.level
				end

				m.modifier.level = level
			end

			table.insert(mods_added, m)
			queue_insert(store, m)
		end
	end

	if b.hit_payload then
		local hp

		if type(b.hit_payload) == "string" then
			hp = E:create_entity(b.hit_payload)
		else
			hp = b.hit_payload
		end

		if hp.aura then
			hp.aura.level = this.bullet.level
			hp.aura.source_id = this.id

			if target then
				hp.pos.x, hp.pos.y = target.pos.x, target.pos.y
			else
				hp.pos.x, hp.pos.y = dest.x, dest.y
			end
		else
			hp.pos.x, hp.pos.y = dest.x, dest.y
		end

		queue_insert(store, hp)
	end

	local disable_hit = false

	if this.hit_fx_only_no_target then
		disable_hit = target ~= nil and not target.health.dead
	end

	local fx

	if b.hit_fx and not disable_hit then
		local is_air = target and band(target.vis.flags, F_FLYING) ~= 0

		fx = E:create_entity(b.hit_fx)

		if b.hit_fx_ignore_hit_offset and target and not is_air then
			fx.pos.x, fx.pos.y = target.pos.x, target.pos.y
		else
			fx.pos.x, fx.pos.y = dest.x, dest.y
		end

		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
	end

	if this.ray_duration then
		while store.tick_ts - s.ts < this.ray_duration do
			if this.track_target then
				update_sprite()
			end

			if tower and not store.entities[tower.id] then
				queue_remove(store, this)

				if fx then
					queue_remove(store, fx)
				end

				for key, value in pairs(mods_added) do
					queue_remove(store, value)
				end

				break
			end

			coroutine.yield()

			s.hidden = false
		end
	else
		while not U.animation_finished(this, 1) do
			if tower and not store.entities[tower.id] then
				queue_remove(store, this)

				break
			end

			coroutine.yield()
		end
	end

	queue_remove(store, this)
end

scripts.decal_stage_06_door = {}

function scripts.decal_stage_06_door.update(this, store, script)
	local spawners = LU.list_entities(store.entities, "mega_spawner")
	local megaspawner_door

	this.opened = false

	for key, value in pairs(spawners) do
		if value.load_file == "level06_door" then
			megaspawner_door = value
		end
	end

	local door = this.render.sprites[5]
	local pig = this.render.sprites[6]
	local pig_handle = this.render.sprites[7]
	local sp = this.spawner
	local pigOrigin = v(-120, 150)
	local pigDestination = v(-75, 20)
	local door_height = 50
	local wave_counter = 1
	local start_ts = store.tick_ts
	local phase
	local pig_clicks = 0
	local pig_dead = false
	local door_time = 10
	local offset_base_x = door.offset.x
	local offset_base_y = door.offset.y

	while true do
		if sp.spawn_data == nil then
			-- block empty
		elseif not sp.spawn_data.open then
			-- block empty
		else
			start_ts = store.tick_ts
			phase = 0
			pig_clicks = 0
			pig_dead = false
			this.ui.can_click = true

			U.animation_start(this, "walkingDown", false, store.tick_ts, true, 6)

			this.tween.disabled = false
			this.tween.reverse = true
			this.tween.ts = store.tick_ts

			repeat
				phase = (store.tick_ts - start_ts) / 5
				pig.offset.x = U.ease_value(pigOrigin.x, pigDestination.x, phase, "linear")
				pig.offset.y = U.ease_value(pigOrigin.y, pigDestination.y, phase, "linear")
				pig.hidden = false
				this.ui.click_rect = r(pig.offset.x - 25, pig.offset.y - 10, 50, 50)

				if this.ui.clicked then
					this.ui.clicked = nil

					S:queue(this.pig_click_sound)

					pig_clicks = pig_clicks + 1

					if pig_clicks >= this.clicks_to_kill then
						pig_dead = true

						break
					else
						this.tween.props[2].disabled = false
						this.tween.props[2].ts = store.tick_ts
						this.tween.props[2].sprite_id = 6
					end
				end

				coroutine.yield()
			until phase >= 1

			if pig_dead then
				sp.spawn_data = nil

				S:queue(this.pig_death_sound)
				U.animation_start(this, "death", nil, store.tick_ts, false, 6)
				U.y_animation_wait(this, 6)

				this.tween.disabled = false
				this.tween.ts = store.tick_ts
				this.tween.reverse = false
				this.ui.can_click = false
			else
				pig.hidden = true
				start_ts = store.tick_ts
				door.hidden = false

				U.animation_start(this, "ability1_1", false, store.tick_ts, true, 7)

				pig_handle.hidden = false

				U.animation_start_group(this, "ability1_1", nil, store.tick_ts, true, "layers")
				S:queue("Stage06WoodenDoorOpen")

				repeat
					phase = (store.tick_ts - start_ts) / door_time
					door.offset.y = U.ease_value(offset_base_y, door_height, phase, "linear")
					door.offset.x = offset_base_x + math.random(-1, 1)

					if this.ui.clicked then
						this.ui.clicked = nil

						S:queue(this.pig_click_sound)

						pig_clicks = pig_clicks + 1

						if pig_clicks >= this.clicks_to_kill then
							pig_dead = true

							break
						else
							this.tween.props[2].disabled = false
							this.tween.props[2].ts = store.tick_ts
							this.tween.props[2].sprite_id = 7
						end
					end

					coroutine.yield()
				until phase >= 1

				S:stop("Stage06WoodenDoorOpen")

				if pig_dead then
					sp.spawn_data = nil

					U.animation_start(this, "ability5_1", false, store.tick_ts, false, 4)
					S:queue("Stage06WoodenDoorClose")
					S:queue(this.pig_death_sound)
					U.animation_start(this, "death1_1", false, store.tick_ts, false, 7)
					U.y_animation_wait(this, 7)

					repeat
						phase = (store.tick_ts - start_ts) / 0.5
						door.offset.y = U.ease_value(door_height, offset_base_y, phase, "sine-out")

						coroutine.yield()
					until phase >= 1

					U.animation_start_group(this, "ability5_1", nil, store.tick_ts, false, "layers")

					door.hidden = true
				else
					this.opened = true

					U.animation_start_group(this, "idle1_1", nil, store.tick_ts, true, "layers")
					U.animation_start(this, "ability2_1", false, store.tick_ts, true, 7)

					megaspawner_door.manual_wave = "DOOR" .. wave_counter
					wave_counter = wave_counter + 1

					while sp.spawn_data == nil do
						coroutine.yield()
					end

					while sp.spawn_data.open do
						if this.ui.clicked then
							this.ui.clicked = nil

							S:queue(this.pig_click_sound)

							pig_clicks = pig_clicks + 1

							if not pig_dead and pig_clicks >= this.clicks_to_kill then
								pig_dead = true

								S:queue(this.pig_death_sound)
								U.animation_start(this, "death1_1", false, store.tick_ts, false, 7)
								U.y_animation_wait(this, 7)
							else
								this.tween.props[2].disabled = false
								this.tween.props[2].ts = store.tick_ts
								this.tween.props[2].sprite_id = 7
							end
						end

						coroutine.yield()
					end

					if not pig_dead then
						S:queue(this.pig_death_sound)
						U.animation_start(this, "death1_1", false, store.tick_ts, false, 7)
					end

					log.info("close the door")

					start_ts = store.tick_ts

					U.animation_start_group(this, "ability4_1", nil, store.tick_ts, true, "layers")
					S:queue("Stage06WoodenDoorClose")

					repeat
						phase = (store.tick_ts - start_ts) / 0.5
						door.offset.y = U.ease_value(door_height, offset_base_y, phase, "sine-out")

						coroutine.yield()
					until phase >= 1

					door.hidden = true

					U.animation_start_group(this, "ability5_1", nil, store.tick_ts, false, "layers")
				end
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.controller_terrain_3_spawner = {}

function scripts.controller_terrain_3_spawner.insert(this, store)
	local aura_glare = E:create_entity(this.aura_glare)

	aura_glare.pos = V.vclone(this.pos)
	aura_glare.aura.source_id = this.id
	aura_glare.aura.ts = store.tick_ts

	queue_insert(store, aura_glare)
	U.animation_start(this, "idle", nil, store.tick_ts, true)

	return true
end

function scripts.controller_terrain_3_spawner.update(this, store)
	local last_wave_processed = 0
	local is_active = false
	local spawn_last_ts
	local nearest_nodes = P:nearest_nodes(this.pos.x, this.pos.y, nil, {
		1,
		2,
		3
	})
	local nodes = {}

	for _, v in pairs(nearest_nodes) do
		local pi, spi, ni = unpack(v)
		local npos = P:node_pos(pi, spi, ni)

		if V.dist2(this.pos.x, this.pos.y, npos.x, npos.y) < 100 then
			table.insert(nodes, v)
		end
	end

	local node = nodes[math.random(1, #nodes)]

	U.y_wait(store, fts(math.random(0, 16)))
	U.animation_start(this, "idle", nil, store.tick_ts, true, 1, true)

	local function spawn_enemy()
		U.animation_start(this, "spawn", nil, store.tick_ts)
		U.y_wait(store, fts(4))

		local enemy = E:create_entity(this.enemies_to_spawn[1])

		enemy.pos = V.vclone(this.pos)
		enemy.pos.x, enemy.pos.y = enemy.pos.x + this.spawn_offset.x, enemy.pos.y + this.spawn_offset.y
		enemy.enemy.gold = 0
		enemy.nav_path.pi = node[1]
		enemy.nav_path.spi = math.random(1, 3)
		enemy.nav_path.ni = node[3]

		queue_insert(store, enemy)

		local fx = E:create_entity(this.entity_spawner_fx)

		fx.pos = V.vclone(enemy.pos)
		fx.pos.x, fx.pos.y = fx.pos.x + enemy.unit.hit_offset.x, fx.pos.y + enemy.unit.hit_offset.y
		fx.render.sprites[1].ts = store.tick_ts

		queue_insert(store, fx)
		U.y_animation_wait(this)
		U.animation_start(this, "activeloop", nil, store.tick_ts, true)
	end

	while true do
		if not is_active and this.glare_active then
			S:queue(this.sound_portal_open)
			U.y_animation_play(this, "activate", nil, store.tick_ts)
			U.animation_start(this, "activeloop", nil, store.tick_ts, true)

			is_active = true
			node = nodes[math.random(1, #nodes)]

			U.y_wait(store, fts(this.editor.delay))

			spawn_last_ts = store.tick_ts
		end

		if is_active then
			if not this.glare_active then
				U.y_wait(store, fts(math.random(0, 16)))
				S:queue(this.sound_portal_close)
				U.y_animation_play(this, "deactivate", nil, store.tick_ts)
				U.animation_start(this, "idle", nil, store.tick_ts, true)

				is_active = false
			elseif store.tick_ts - spawn_last_ts > fts(this.editor.interval) then
				spawn_last_ts = store.tick_ts

				spawn_enemy()
			end
		end

		coroutine.yield()
	end
end

function scripts.controller_terrain_3_spawner.on_start_glare(this, store)
	this.glare_active = true
end

function scripts.controller_terrain_3_spawner.on_end_glare(this, store)
	this.glare_active = false
end

scripts.tower_barrack_mercenaries_KR5 = {}

function scripts.tower_barrack_mercenaries_KR5.update(this, store, script)
	local b = this.barrack
	local door_sid = this.render.door_sid or 2
	local formation_offset = 0

	if not this.tower_upgrade_persistent_data.spawns_count then
		this.tower_upgrade_persistent_data.spawns_count = 0
	end

	while true do
		local old_count = #b.soldiers

		b.soldiers = table.filter(b.soldiers, function(_, s)
			return store.entities[s.id] ~= nil
		end)

		if #b.soldiers > 0 and #b.soldiers ~= old_count then
			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, this.barrack.max_soldiers, formation_offset)
			end
		end

		if b.unit_bought then
			this.tower_upgrade_persistent_data.spawns_count = this.tower_upgrade_persistent_data.spawns_count + 1

			if b.has_door and not b.door_open then
				U.animation_start(this, "open", nil, store.tick_ts, false, door_sid)
				U.y_animation_wait(this, door_sid)

				b.door_open = true
				b.door_open_ts = store.tick_ts
			end

			local s = E:create_entity(b.unit_bought)

			store.player_gold = store.player_gold - s.unit.price

			table.insert(b.soldiers, s)

			local i = #b.soldiers

			s.soldier.tower_id = this.id
			s.pos = V.v(V.add(this.pos.x, this.pos.y, b.respawn_offset.x, b.respawn_offset.y))
			s.nav_rally.new = true
			s.mercenary_spawn_number = this.tower_upgrade_persistent_data.spawns_count

			if this.spawn_waypoint_offset then
				s.motion.forced_waypoint = v(this.pos.x + this.spawn_waypoint_offset.x, this.pos.y + this.spawn_waypoint_offset.y)
			end

			queue_insert(store, s)

			for i, ss in ipairs(b.soldiers) do
				ss.nav_rally.pos, ss.nav_rally.center = U.rally_formation_position(i, b, this.barrack.max_soldiers, formation_offset)
			end

			signal.emit("tower-spawn", this, s)

			b.unit_bought = nil
		end

		if b.has_door and b.door_open and store.tick_ts - b.door_open_ts > b.door_hold_time then
			U.animation_start(this, "close", nil, store.tick_ts, false, door_sid)
			U.y_animation_wait(this, door_sid)

			b.door_open = false
		end

		if b.rally_new then
			b.rally_new = false

			signal.emit("rally-point-changed", this)

			local sounds = {}
			local all_dead = true

			for i, s in ipairs(b.soldiers) do
				s.nav_rally.pos, s.nav_rally.center = U.rally_formation_position(i, b, this.barrack.max_soldiers, formation_offset)
				s.nav_rally.new = true
				s.nav_rally.group_index = i - 1
				s.nav_rally.group_total = #b.soldiers

				if s.sound_events.change_rally_point then
					table.insert(sounds, s.sound_events.change_rally_point)
				end

				all_dead = all_dead and s.health.dead
			end

			if not all_dead then
				if #sounds > 0 then
					S:queue(sounds[math.random(1, #sounds)])
				else
					S:queue(this.sound_events.change_rally_point)
				end
			end
		end

		coroutine.yield()
	end
end

scripts.background_sounds_kr5 = {}

function scripts.background_sounds_kr5.update(this, store, script)
	while true do
		local delay = math.random(this.min_delay, this.max_delay)

		U.y_wait(store, delay)

		if store.wave_group_number > 0 and this.only_on_preparation then
			queue_remove(store, this)

			return true
		end

		S:queue(this.sounds[math.random(#this.sounds)])
	end
end

scripts.tower_holder_capture = {}

function scripts.tower_holder_capture.insert(this, store, script)
	this.tween.props[1].keys[2][1] = this.capture_duration

	local a = E:create_entity(this.aura_capture)

	a.aura.source_id = this.id
	a.capture_duration = this.capture_duration
	a.enable_waves = this.enable_waves
	a.spawn_delay = this.spawn_delay
	a.enabled_sprite = this.enabled_sprite
	a.disabled_sprite = this.disabled_sprite
	a.capture_default_increment = a.aura.cycle_time
	a.capture_default_decrement = a.capture_default_increment * a.capture_default_decrement_multiplier

	queue_insert(store, a)

	return true
end

scripts.aura_tower_holder_capture = {}

function scripts.aura_tower_holder_capture.update(this, store, script)
	this.aura.ts = store.tick_ts

	local holder = store.entities[this.aura.source_id]
	local conquered_amount = 0
	local last_tick_ts = store.tick_ts - this.aura.cycle_time

	if this.aura.track_source and this.aura.source_id then
		local te = store.entities[this.aura.source_id]

		if te and te.pos then
			this.pos = te.pos
		end
	end

	local function can_capture()
		local current_wave = store.wave_group_number

		if current_wave > 0 and (not this.enable_waves or table.contains(this.enable_waves, current_wave)) then
			return true
		end

		return false
	end

	while true do
		if conquered_amount == 0 then
			holder.render.sprites[2].hidden = true
			holder.render.sprites[3].hidden = true
		else
			holder.render.sprites[2].hidden = false
			holder.render.sprites[3].hidden = false
		end

		holder.render.sprites[3].ts = store.tick_ts - conquered_amount

		if can_capture() then
			holder.render.sprites[1].name = this.enabled_sprite
		else
			holder.render.sprites[1].name = this.disabled_sprite
			conquered_amount = km.clamp(0, this.capture_duration, conquered_amount - this.capture_default_decrement)

			goto label_1170_0
		end

		if store.tick_ts - last_tick_ts >= this.aura.cycle_time then
			local heroes = table.filter(store.entities, function(k, v)
				return v.unit and v.vis and v.hero and v.health and not v.health.dead and band(v.vis.flags, this.aura.vis_bans) == 0 and band(v.vis.bans, this.aura.vis_flags) == 0 and U.is_inside_ellipse(v.pos, this.pos, this.aura.radius) and (not this.aura.allowed_templates or table.contains(this.aura.allowed_templates, v.template_name)) and (not this.aura.excluded_templates or not table.contains(this.aura.excluded_templates, v.template_name)) and (not this.aura.excluded_entities or not table.contains(this.aura.excluded_entities, v.id))
			end)

			if heroes and #heroes > 0 then
				for _, heroe in pairs(heroes) do
					local capture_multiplier = this.capture_multiplier

					if heroe.capture_multiplier then
						capture_multiplier = heroe.capture_multiplier
					end

					conquered_amount = km.clamp(0, this.capture_duration, (conquered_amount + this.capture_default_increment) * capture_multiplier)
				end
			else
				conquered_amount = km.clamp(0, this.capture_duration, conquered_amount - this.capture_default_decrement)
			end

			last_tick_ts = store.tick_ts
		end

		if conquered_amount >= this.capture_duration then
			local h = E:create_entity(holder.tower_holder_on_capture)

			h.render.sprites[1].name = string.format(h.render.sprites[1].name, h.tower.terrain_style)
			h.pos = V.vclone(holder.pos)

			queue_insert(store, h)

			break
		end

		::label_1170_0::

		coroutine.yield()
	end

	queue_remove(store, holder)
	queue_remove(store, this)
end

scripts.tower_holder_animated = {}

function scripts.tower_holder_animated.remove(this, store, script)
	local fx = E:create_entity(this.tower_holder.unblock_fx)

	fx.pos = V.vclone(this.pos)
	fx.render.sprites[1].ts = store.tick_ts

	queue_insert(store, fx)

	return true
end

scripts.tower_holder_blocked_spiders = {}

function scripts.tower_holder_blocked_spiders.insert(this, store, script)
	this.tower_holder.unblock_price = this.prices[store.level_mode] and this.prices[store.level_mode] or this.prices[GAME_MODE_CAMPAIGN]

	return true
end

scripts.tunnel_KR5 = {}

function scripts.tunnel_KR5.insert(this, store, script)
	local tu = this.tunnel

	if not tu.pick_ni then
		tu.pick_ni = P:get_end_node(tu.pick_pi) - 1
	end

	if not tu.place_ni then
		tu.place_ni = 1
	end

	local pick_end = P:get_end_node(tu.pick_pi)
	local place_start = P:get_start_node(tu.place_pi)
	local pick_start = pick_end - this.untargetable_distance
	local place_end = place_start + this.untargetable_distance

	P:add_invalid_range(tu.pick_pi, pick_start, pick_end)
	P:add_invalid_range(tu.place_pi, place_start, place_end)

	return scripts.aura_apply_mod.insert(this, store, script)
end

function scripts.tunnel_KR5.update(this, store, script)
	local tu = this.tunnel

	if not tu.pick_ni then
		tu.pick_ni = P:get_end_node(tu.pick_pi) - 1
	end

	if not tu.place_ni then
		tu.place_ni = 1
	end

	local pf = P:node_pos(tu.pick_pi, 1, tu.pick_ni)
	local pt = P:node_pos(tu.place_pi, 1, tu.place_ni)
	local length = V.dist(pf.x, pf.y, pt.x, pt.y)
	local picked_enemies = tu.picked_enemies

	tu.length = length
	this.total_picked_enemies = 0

	while true do
		local enemies = table.filter(store.entities, function(_, e)
			return e and e.enemy and e.health and not e.health.dead and e.main_script and e.main_script.co ~= nil and e.nav_path and e.nav_path.pi == tu.pick_pi and e.nav_path.ni >= tu.pick_ni and (tu.pick_pi ~= tu.place_pi or e.nav_path.ni < tu.place_ni)
		end)

		for _, enemy in pairs(enemies) do
			if tu.pick_fx then
				local fx = E:create_entity(tu.pick_fx)

				fx.pos = V.v(enemy.pos.x, enemy.pos.y)
				fx.render.sprites[1].ts = store.tick_ts

				queue_insert(store, fx)
			end

			local release_ts = store.tick_ts + length / (tu.speed_factor * enemy.motion.max_speed)

			log.debug("tunnel %s picked %s", this.id, enemy.id)
			table.insert(picked_enemies, {
				release_ts = release_ts,
				entity = enemy
			})
			SU.remove_modifiers(store, enemy)
			SU.remove_auras(store, enemy)
			queue_remove(store, enemy)
			U.unblock_all(store, enemy)

			if enemy.ui then
				enemy.ui.can_click = false
			end

			enemy.main_script.co = nil
			enemy.main_script.runs = 0

			if enemy.count_group then
				enemy.count_group.in_limbo = true
			end

			this.total_picked_enemies = this.total_picked_enemies + 1
		end

		for i = #picked_enemies, 1, -1 do
			local p = picked_enemies[i]

			if p.release_ts > store.tick_ts then
				-- block empty
			else
				local enemy = p.entity

				enemy.nav_path.pi = tu.place_pi
				enemy.nav_path.ni = tu.place_ni
				enemy.pos = P:node_pos(enemy.nav_path)
				enemy.main_script.runs = 1
				enemy._placed_from_tunnel = true

				if enemy.ui then
					enemy.ui.can_click = true
				end

				queue_insert(store, enemy)
				table.remove(picked_enemies, i)

				if tu.place_fx then
					local fx = E:create_entity(tu.place_fx)

					fx.pos = V.v(enemy.pos.x, enemy.pos.y)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end

				log.debug("tunnel %s placed %s", this.id, enemy.id)
			end
		end

		coroutine.yield()
	end
end

scripts.tunnel_KR5_destructible = {}

function scripts.tunnel_KR5_destructible.update(this, store, script)
	local tu = this.tunnel

	if not tu.pick_ni then
		tu.pick_ni = P:get_end_node(tu.pick_pi) - 1
	end

	if not tu.place_ni then
		tu.place_ni = 1
	end

	local pf = P:node_pos(tu.pick_pi, 1, tu.pick_ni)
	local pt = P:node_pos(tu.place_pi, 1, tu.place_ni)
	local length = V.dist(pf.x, pf.y, pt.x, pt.y)
	local picked_enemies = tu.picked_enemies

	tu.length = length
	this.total_picked_enemies = 0

	while true do
		if not this.destroyed then
			local enemies = table.filter(store.entities, function(_, e)
				return e and e.enemy and e.health and not e.health.dead and e.main_script and e.main_script.co ~= nil and e.nav_path and e.nav_path.pi == tu.pick_pi and e.nav_path.ni >= tu.pick_ni and (tu.pick_pi ~= tu.place_pi or e.nav_path.ni < tu.place_ni)
			end)

			for _, enemy in pairs(enemies) do
				if tu.pick_fx then
					local fx = E:create_entity(tu.pick_fx)

					fx.pos = V.v(enemy.pos.x, enemy.pos.y)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end

				local picked_ts = store.tick_ts
				local release_ts = store.tick_ts + length / (tu.speed_factor * enemy.motion.max_speed)

				log.debug("tunnel %s picked %s", this.id, enemy.id)
				table.insert(picked_enemies, {
					picked_ts = picked_ts,
					release_ts = release_ts,
					entity = enemy
				})
				SU.remove_modifiers(store, enemy)
				SU.remove_auras(store, enemy)
				queue_remove(store, enemy)
				U.unblock_all(store, enemy)

				if enemy.ui then
					enemy.ui.can_click = false
				end

				enemy.main_script.co = nil
				enemy.main_script.runs = 0

				if enemy.count_group then
					enemy.count_group.in_limbo = true
				end

				this.total_picked_enemies = this.total_picked_enemies + 1
			end
		end

		for i = #picked_enemies, 1, -1 do
			local p = picked_enemies[i]

			if p.release_ts > store.tick_ts and not this.destroyed then
				-- block empty
			else
				local enemy = p.entity

				enemy.nav_path.pi = tu.place_pi

				if this.destroyed and tu.pick_pi == tu.place_pi then
					local duration = p.release_ts - p.picked_ts
					local elapsed = store.tick_ts - p.picked_ts
					local percentage_done = math.min(elapsed / duration, 1)
					local desired_ni = tu.pick_ni + math.floor((tu.place_ni - tu.pick_ni) * percentage_done)

					enemy.nav_path.ni = desired_ni
				else
					enemy.nav_path.ni = tu.place_ni
				end

				enemy.pos = P:node_pos(enemy.nav_path)
				enemy.main_script.runs = 1
				enemy._placed_from_tunnel = true

				if enemy.ui then
					enemy.ui.can_click = true
				end

				queue_insert(store, enemy)
				table.remove(picked_enemies, i)

				if tu.place_fx then
					local fx = E:create_entity(tu.place_fx)

					fx.pos = V.v(enemy.pos.x, enemy.pos.y)
					fx.render.sprites[1].ts = store.tick_ts

					queue_insert(store, fx)
				end

				log.debug("tunnel %s placed %s", this.id, enemy.id)
			end
		end

		if this.destroyed then
			break
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.bomb_KR5 = {}

function scripts.bomb_KR5.insert(this, store, script)
	local b = this.bullet

	b.speed = SU.initial_parabola_speed(b.from, b.to, b.flight_time, b.g)
	b.ts = store.tick_ts
	b.last_pos = V.vclone(b.from)

	if b.rotation_speed then
		this.render.sprites[1].r = (math.random() - 0.5) * math.pi / 2
		b.rotation_speed = b.rotation_speed * (b.to.x > b.from.x and -1 or 1)
	end

	if b.hide_radius then
		this.render.sprites[1].hidden = true
	end

	local s = this.render.sprites[1]
	if s.animated then
		s.ts = store.tick_ts
	end
	
	return true
end

function scripts.bomb_KR5.update(this, store, script)
	local b = this.bullet
	local dmin, dmax = b.damage_min, b.damage_max
	local dradius = b.damage_radius

	if b.level and b.level > 0 then
		if b.damage_radius_inc then
			dradius = dradius + b.level * b.damage_radius_inc
		end

		if b.damage_min_inc then
			dmin = dmin + b.level * b.damage_min_inc
		end

		if b.damage_max_inc then
			dmax = dmax + b.level * b.damage_max_inc
		end
	end

	if b.damages_min and b.damages_max and b.level then
		dmin = b.damages_min[b.level]
		dmax = b.damages_max[b.level]
	end

	local ps

	if b.particles_name then
		ps = E:create_entity(b.particles_name)
		ps.particle_system.track_id = this.id

		queue_insert(store, ps)
	end

	while store.tick_ts - b.ts + store.tick_length < b.flight_time do
		coroutine.yield()

		b.last_pos.x, b.last_pos.y = this.pos.x, this.pos.y
		this.pos.x, this.pos.y = SU.position_in_parabola(store.tick_ts - b.ts, b.from, b.speed, b.g)

		if b.align_with_trajectory then
			this.render.sprites[1].r = V.angleTo(this.pos.x - b.last_pos.x, this.pos.y - b.last_pos.y)
		elseif b.rotation_speed then
			this.render.sprites[1].r = this.render.sprites[1].r + b.rotation_speed * store.tick_length
		end

		if b.hide_radius then
			this.render.sprites[1].hidden = V.dist(this.pos.x, this.pos.y, b.from.x, b.from.y) < b.hide_radius or V.dist(this.pos.x, this.pos.y, b.to.x, b.to.y) < b.hide_radius
		end
	end

	local enemies = table.filter(store.entities, function(k, v)
		return v.enemy and v.vis and v.health and not v.health.dead and band(v.vis.flags, b.damage_bans) == 0 and band(v.vis.bans, b.damage_flags) == 0 and U.is_inside_ellipse(v.pos, b.to, dradius)
	end)

	for _, enemy in pairs(enemies) do
		local d = E:create_entity("damage")

		d.damage_type = b.damage_type
		d.reduce_armor = b.reduce_armor
		d.reduce_magic_armor = b.reduce_magic_armor

		if b.damage_decay_random then
			d.value = U.frandom(dmin, dmax)
		else
			local upg = UP:get_upgrade("towers_improved_formulas")
			local source = store.entities[b.source_id]

			if upg and (source and source.tower or this.from_tower) then
				d.value = dmax
			else
				local dist_factor = U.dist_factor_inside_ellipse(enemy.pos, b.to, dradius)

				d.value = math.floor(dmax - (dmax - dmin) * dist_factor)
			end
		end

		d.value = math.ceil(b.damage_factor * d.value)
		d.source_id = this.id
		d.target_id = enemy.id

		if b.xp_gain_factor and b.xp_dest_id then
			d.xp_gain_factor = b.xp_gain_factor
			d.xp_dest_id = b.source_id
		end

		queue_damage(store, d)
		log.paranoid("bomb id:%s, radius:%s, enemy id:%s, dist:%s, damage:%s damage_type:%x", this.id, dradius, enemy.id, V.dist(enemy.pos.x, enemy.pos.y, b.to.x, b.to.y), d.value, d.damage_type)

		if this.up_shock_and_awe_chance and band(enemy.vis.bans, F_STUN) == 0 and band(enemy.vis.flags, bor(F_BOSS, F_CLIFF, F_FLYING)) == 0 and math.random() < this.up_shock_and_awe_chance then
			local mod = E:create_entity("mod_shock_and_awe")

			mod.modifier.target_id = enemy.id

			queue_insert(store, mod)
		end

		if b.mod or b.mods then
			local mods = b.mods or {
				b.mod
			}
			for i, mod_name in ipairs(mods) do
				local mod = E:create_entity(mod_name)
				mod.modifier.target_id = enemy.id
				mod.modifier.source_id = this.id
				mod.modifier.level = b.level
				queue_insert(store, mod)
			end
		end
	end

	local p = SU.create_bullet_pop(store, this)
	if p then
		queue_insert(store, p)
	end

	local cell_type = GR:cell_type(b.to.x, b.to.y)

	if b.hit_fx_water and band(cell_type, TERRAIN_WATER) ~= 0 then
		S:queue(this.sound_events.hit_water)

		local water_fx = E:create_entity(b.hit_fx_water)

		water_fx.pos.x, water_fx.pos.y = b.to.x, b.to.y
		water_fx.render.sprites[1].ts = store.tick_ts
		water_fx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, water_fx)
	elseif b.hit_fx then
		S:queue(this.sound_events.hit)

		local sfx = E:create_entity(b.hit_fx)

		sfx.pos = V.vclone(b.to)
		sfx.render.sprites[1].ts = store.tick_ts
		sfx.render.sprites[1].sort_y_offset = b.hit_fx_sort_y_offset

		queue_insert(store, sfx)
	end

	if b.hit_decal and band(cell_type, TERRAIN_WATER) == 0 then
		SU.create_bullet_hit_decal(this, store)
	end

	SU.create_bullet_hit_payload(this, store)

	queue_remove(store, this)
end

scripts.controller_path_direction = {}

function scripts.controller_path_direction.update(this, store)
	local markers_pool = {}

	local function add_markers_to_pool()
		for i = 1, this.pool_batch_size do
			local path_marker = E:create_entity(this.path_marker_entity)

			path_marker.render.sprites[1].hidden = true

			table.insert(markers_pool, path_marker)
			queue_insert(store, path_marker)
		end
	end

	local function clear_markers()
		for _, m in ipairs(markers_pool) do
			m.render.sprites[1].hidden = true
		end
	end

	while true do
		if this.selected_entity then
			clear_markers()

			local dist = V.dist(this.start_pos.x, this.start_pos.y, this.end_pos.x, this.end_pos.y)

			if dist < this.distance_between then
				-- block empty
			else
				this.start_pos = this.selected_entity.pos

				local start_pos = V.vclone(this.start_pos)

				if this.selected_entity.reinforcement and this.selected_entity.reinforcement.squad_id then
					local middle = V.v(0, 0)
					local c = 0

					for _, e in pairs(store.entities) do
						if e.nav_rally and e.reinforcement and e.reinforcement.squad_id == this.selected_entity.reinforcement.squad_id then
							middle.x = middle.x + e.pos.x
							middle.y = middle.y + e.pos.y
							c = c + 1
						end
					end

					start_pos.x, start_pos.y = middle.x / c, middle.y / c
				elseif this.selected_entity.soldier and this.selected_entity.soldier.tower_id then
					local middle = V.v(0, 0)
					local c = 0

					for _, e in pairs(store.entities) do
						if e.soldier and e.soldier.tower_id == this.selected_entity.soldier.tower_id and e.health and not e.health.dead then
							middle.x = middle.x + e.pos.x
							middle.y = middle.y + e.pos.y
							c = c + 1
						end
					end

					start_pos.x, start_pos.y = middle.x / c, middle.y / c
				end

				if this.selected_entity.drag_line_origin_offset then
					local o = this.selected_entity.drag_line_origin_offset

					start_pos.x, start_pos.y = start_pos.x + o.x, start_pos.y + o.y
				end

				dist = V.dist(start_pos.x, start_pos.y, this.end_pos.x, this.end_pos.y)

				local markers_amount = math.floor(dist / this.distance_between)

				while markers_amount > #markers_pool do
					add_markers_to_pool()
				end

				for i = 1, markers_amount do
					local pos = V.v(this.end_pos.x - start_pos.x, this.end_pos.y - start_pos.y)

					pos.x, pos.y = V.normalize(pos.x, pos.y)

					local marker_pos = V.v(start_pos.x + pos.x * (i * this.distance_between), start_pos.y + pos.y * (i * this.distance_between))

					markers_pool[i].pos = V.vclone(marker_pos)
					markers_pool[i].render.sprites[1].hidden = false
					markers_pool[i].render.sprites[1].r = V.angleTo(marker_pos.x - start_pos.x, marker_pos.y - start_pos.y)
				end
			end
		else
			clear_markers()
		end

		coroutine.yield()
	end
end

scripts.controller_tower_swap = {}

function scripts.controller_tower_swap.update(this, store)
	local function create_tower(from, to)
		local ne = E:create_entity(from.template_name)

		ne.pos = V.vclone(to.pos)
		ne.tower.holder_id = to.tower.holder_id
		ne.tower.flip_x = to.tower.flip_x
		ne.tower.spent = from.tower.spent

		if to.tower.default_rally_pos then
			ne.tower.default_rally_pos = V.vclone(to.tower.default_rally_pos)
		end

		if to.tower.terrain_style then
			ne.tower.terrain_style = to.tower.terrain_style
		elseif from.tower.terrain_style then
			ne.tower.terrain_style = from.tower.terrain_style
		end

		if ne.tower.terrain_style then
			if from.tower.type ~= "holder" then
				if string.find(ne.render.sprites[1].name, "%%04i") then
					ne.render.sprites[1].name = string.format(ne.render.sprites[1].name, ne.tower.terrain_style)
				end
			else
				ne.render.sprites[1].name = string.format("terrains_holders_%04i", ne.tower.terrain_style)
				ne.render.sprites[2].name = string.format("terrains_holders_%04i_flag", ne.tower.terrain_style)
			end
		end

		if ne.ui and to.ui then
			ne.ui.nav_mesh_id = to.ui.nav_mesh_id
		end

		if from.powers then
			for i, v in pairs(from.powers) do
				if v.level > 0 then
					ne.powers[i].level = v.level
					ne.powers[i].changed = true
				end
			end
		end

		ne.tower_upgrade_persistent_data = from.tower_upgrade_persistent_data and table.clone(from.tower_upgrade_persistent_data) or E:clone_c("tower_upgrade_persistent_data")
		ne.tower_upgrade_persistent_data.swaped = true

		if ne.sound_events then
			ne.sound_events.insert = nil
		end

		return ne
	end

	local function create_spawner_out(to)
		local ne = E:create_entity(this.fx_out)

		ne.render.sprites[1].ts = store.tick_ts
		ne.pos = V.vclone(to.pos)

		queue_insert(store, ne)
	end

	local function create_spawner_in(to)
		local ne = E:create_entity(this.fx_in)

		ne.render.sprites[1].ts = store.tick_ts
		ne.pos = V.vclone(to.pos)

		queue_insert(store, ne)
	end

	local function create_temp_holder(to)
		local th = E:create_entity("tower_holder")

		th.pos = V.vclone(to.pos)
		th.ui.can_click = false
		local terrain_style = to.tower.terrain_style
		if terrain_style then
			th.render.sprites[1].name = string.format("terrains_holders_%04i", terrain_style)
			th.render.sprites[2].name = string.format("terrains_holders_%04i_flag", terrain_style)
		else
			th.render.sprites[1].name = nil
			th.render.sprites[2].name = nil
		end

		queue_insert(store, th)

		return th
	end

	local t1 = this.tower_1
	local t2 = this.tower_2

	if t1 and t2 and t1.tower and t2.tower then
		S:queue(this.swap_sound)

		if t2.tower.type == "holder" then
			local nt1 = create_tower(t1, t2)
			local nt2 = create_tower(t2, t1)

			t1.ui.can_click = false
			t2.ui.can_click = false

			if this.fx_out then
				create_spawner_out(t1)
				U.y_wait(store, fts(4))
			end

			queue_remove(store, t1)
			queue_insert(store, nt2)
			U.y_wait(store, this.delay_empty)
			create_spawner_in(nt1)
			U.y_wait(store, this.fx_in_delay)
			queue_remove(store, t2)
			queue_insert(store, nt1)
		else
			local nt1 = create_tower(t1, t2)
			local nt2 = create_tower(t2, t1)

			t1.ui.can_click = false
			t2.ui.can_click = false

			if this.fx_out then
				create_spawner_out(t1)
				U.y_wait(store, fts(4))
			end

			queue_remove(store, t1)

			local th1 = create_temp_holder(t1)

			U.y_wait(store, fts(10))
			create_spawner_out(t2)
			U.y_wait(store, fts(4))
			queue_remove(store, t2)

			local th2 = create_temp_holder(t2)

			U.y_wait(store, this.delay)
			S:queue(this.swap_sound)
			create_spawner_in(nt2)
			U.y_wait(store, this.fx_spawn_delay)
			queue_insert(store, nt2)
			queue_remove(store, th1)
			U.y_wait(store, this.fx_delay_between)
			create_spawner_in(nt1)
			U.y_wait(store, this.fx_spawn_delay)
			queue_insert(store, nt1)
			queue_remove(store, th2)
		end
	end

	queue_remove(store, this)
end

scripts.tower_ghost_hover_controller = {}

function scripts.tower_ghost_hover_controller.insert(this, store, script)
	this.hovers = {}

	for _, v in pairs(store.entities) do
		if v.tower and v.ui.can_click and v.tower.can_be_sold then
			local h = E:create_entity(this.template_hover)

			h.pos = V.vclone(v.pos)

			queue_insert(store, h)
			table.insert(this.hovers, h)
		end
	end

	return true
end

function scripts.tower_ghost_hover_controller.remove(this, store)
	if this.hovers then
		for _, v in pairs(this.hovers) do
			queue_remove(store, v)
		end

		this.hovers = nil
	end

	return true
end

scripts.power_reinforcements_control_KR5 = {}

function scripts.power_reinforcements_control_KR5.insert(this, store, script)
	local x, y = this.pos.x, this.pos.y
	local spawned_special = false
	local special_spawn_radius = 30
	local special_angle_offset = 15
	local upg = UP:get_upgrade("reinforcements_power_trio")

	if upg then
		local e = E:create_entity("soldier_reinforcement_special_linirea")
		local spawn_pos = U.point_on_ellipse(V.v(x, y), special_spawn_radius, -math.pi / 2 + special_angle_offset)

		e.pos = V.vclone(spawn_pos)
		e.nav_rally.center = V.v(x, y)
		e.nav_rally.pos = V.vclone(e.pos)
		e.reinforcement.squad_id = this.id

		queue_insert(store, e)

		spawned_special = true
	end

	upg = UP:get_upgrade("reinforcements_power_trio_dark")

	if upg then
		local e = E:create_entity("soldier_reinforcement_special_dark_army")
		local spawn_pos = U.point_on_ellipse(V.v(x, y), special_spawn_radius, -math.pi / 2 + special_angle_offset)

		e.pos = V.vclone(spawn_pos)
		e.nav_rally.center = V.v(x, y)
		e.nav_rally.pos = V.vclone(e.pos)
		e.reinforcement.squad_id = this.id

		queue_insert(store, e)

		spawned_special = true
	end

	local variants = 3

	if UP:get_upgrade("reinforcements_shadow_archer") then
		variants = 1
	elseif UP:get_upgrade("reinforcements_rebel_militia") then
		variants = 2
	end

	local i = math.random(1, variants)
	local e = E:create_entity("re_current_" .. i)

	if spawned_special then
		local a = 2 * math.pi / 3
		local spawn_pos = U.point_on_ellipse(V.v(x, y), special_spawn_radius, a - math.pi / 2 + special_angle_offset)

		e.pos = V.vclone(spawn_pos)
	else
		e.pos.x = x + 10
		e.pos.y = y - 10
	end

	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.id

	queue_insert(store, e)

	i = math.random(1, variants)
	e = E:create_entity("re_current_" .. i)

	if spawned_special then
		local a = 2 * math.pi / 3
		local spawn_pos = U.point_on_ellipse(V.v(x, y), special_spawn_radius, 2 * a - math.pi / 2 + special_angle_offset)

		e.pos = V.vclone(spawn_pos)
	else
		e.pos.x = x - 10
		e.pos.y = y + 10
	end

	e.nav_rally.center = V.v(x, y)
	e.nav_rally.pos = V.vclone(e.pos)
	e.reinforcement.squad_id = this.id

	queue_insert(store, e)

	return false
end

scripts.power_stage_15_denas_control = {}

function scripts.power_stage_15_denas_control.insert(this, store, script)
	local denas = E:create_entity(this.denas_t)

	denas.pos = V.vclone(this.pos)
	denas.nav_rally.center = V.vclone(this.pos)
	denas.nav_rally.pos = V.vclone(denas.pos)
	denas.reinforcement.squad_id = this.id

	queue_insert(store, denas)

	return true
end

function scripts.hero_basic.get_info_ranged_with_damage_factor(this)
	local a = this.ranged.attacks[1]
	local b = E:get_template(a.bullet)
	local min, max = b.bullet.damage_min, b.bullet.damage_max

	min, max = min * this.unit.damage_factor, max * this.unit.damage_factor
	min, max = math.ceil(min), math.ceil(max)

	return {
		type = STATS_TYPE_SOLDIER,
		hp = this.health.hp,
		hp_max = this.health.hp_max,
		damage_min = min,
		damage_max = max,
		damage_type = b.bullet.damage_type,
		damage_icon = this.info.damage_icon,
		armor = this.health.armor,
		respawn = this.health.dead_lifetime
	}
end

scripts.mod_upgrade_visual_learning = {}

function scripts.mod_upgrade_visual_learning.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	target.health.armor = target.health.armor + this.armor_bonus

	return true
end

function scripts.mod_upgrade_visual_learning.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	target.health.armor = target.health.armor - this.armor_bonus

	return true
end

scripts.mod_upgrade_lone_wolves = {}

function scripts.mod_upgrade_lone_wolves.insert(this, store)
	local target = store.entities[this.modifier.target_id]

	for _, skill in pairs(target.hero.skills) do
		if skill.level > 0 then
			if skill.xp_gain then
				skill.xp_gain[skill.level] = skill.xp_gain[skill.level] * this.xp_gain_factor
			else
				skill.xp_gain_factor = skill.xp_gain_factor * this.xp_gain_factor
			end
		end
	end

	return true
end

function scripts.mod_upgrade_lone_wolves.remove(this, store)
	local target = store.entities[this.modifier.target_id]

	for _, skill in pairs(target.hero.skills) do
		if skill.level > 0 then
			if skill.xp_gain then
				skill.xp_gain[skill.level] = skill.xp_gain[skill.level] / this.xp_gain_factor
			else
				skill.xp_gain_factor = skill.xp_gain_factor / this.xp_gain_factor
			end
		end
	end

	return true
end

scripts.decal_stage_09_bridge = {}

function scripts.decal_stage_09_bridge.insert(this, store)
	local mask = E:create_entity(this.mask_entity)

	mask.pos.x, mask.pos.y = this.pos.x, this.pos.y

	queue_insert(store, mask)

	this.mask = mask

	return true
end

function scripts.decal_stage_09_bridge.update(this, store)
	if this.start_in_loop then
		U.animation_start(this.mask, this.mask_loop_animation, nil, store.tick_ts, true)
	else
		this.render.sprites[1].hidden = true
		this.mask.render.sprites[1].hidden = true

		if this.in_delay then
			U.y_wait(store, this.in_delay)
		end

		this.render.sprites[1].hidden = false
		this.render.sprites[1].ts = store.tick_ts

		if this.mask_before then
			this.mask.render.sprites[1].hidden = false
			this.mask.render.sprites[1].ts = store.tick_ts

			U.animation_start(this.mask, this.mask_in_animation, nil, store.tick_ts)
		end

		U.y_animation_play(this, this.animation_in, nil, store.tick_ts)

		if not this.mask_before then
			this.mask.render.sprites[1].hidden = false
			this.mask.render.sprites[1].ts = store.tick_ts
		else
			U.animation_start(this.mask, this.mask_loop_animation, nil, store.tick_ts, true)
		end
	end

	while true do
		U.y_animation_play(this, this.animation_loop, nil, store.tick_ts)
		coroutine.yield()
	end

	queue_remove(store, this)
end

scripts.aura_stage_09_spawn_nightmare_convert_spawn_fx = {}

function scripts.aura_stage_09_spawn_nightmare_convert_spawn_fx.update(this, store)
	local enemies_spawned = {}

	while true do
		local targets = U.find_enemies_in_range(store.entities, this.pos, 0, this.aura.radius, this.aura.vis_flags, this.aura.vis_bans, function(e)
			return this.include_templates and table.contains(this.include_templates, e.template_name)
		end)

		if targets and #targets > 0 then
			for _, e in ipairs(targets) do
				if not table.contains(enemies_spawned, e.id) then
					e.can_be_converted = true

					table.insert(enemies_spawned, e.id)

					this.portal.enemy_spawned = true
				end
			end
		end

		coroutine.yield()
	end
end

scripts.decal_stage_09_candle = {}

function scripts.decal_stage_09_candle.update(this, store)
	local is_on = false

	while true do
		if this.turn_on then
			this.turn_on = nil

			U.y_animation_play(this, "on", nil, store.tick_ts)

			is_on = true
		elseif this.turn_off then
			this.turn_off = nil

			U.y_animation_play(this, "off", nil, store.tick_ts)

			is_on = false
		end

		if is_on then
			U.animation_start(this, "idle_on", nil, store.tick_ts, true)
		else
			U.animation_start(this, "idle_off", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_09_path_portal = {}

function scripts.decal_stage_09_path_portal.update(this, store)
	local is_on = false

	while true do
		if this.turn_on then
			this.turn_on = nil

			U.y_animation_play(this, "light_on", nil, store.tick_ts)

			is_on = true
		elseif this.turn_off then
			this.turn_off = nil

			U.y_animation_play(this, "light_off", nil, store.tick_ts)

			is_on = false
		end

		if is_on then
			U.animation_start(this, "idle_on", nil, store.tick_ts, true)
		else
			U.animation_start(this, "idle", nil, store.tick_ts, true)
		end

		coroutine.yield()
	end
end

scripts.decal_stage_09_sheepy_easteregg = {}

function scripts.decal_stage_09_sheepy_easteregg.update(this, store)
	local bridge_down = false

	local function check_bridge_down()
		if not bridge_down and store.wave_group_number == 10 then
			bridge_down = true

			return true
		end

		return false
	end

	while true do
		if this.ui.clicked then
			this.ui.clicked = nil

			S:queue("Stage09SheepyCamera")
			U.animation_start(this, "action_" .. math.random(1, 3), nil, store.tick_ts)
			signal.emit("sheepy_tap_achievement", 1)

			while not U.animation_finished(this) do
				if check_bridge_down() then
					U.y_wait(store, fts(13))
					S:queue("Stage09SheepyBridge")
					U.y_animation_play(this, "bridge", true, store.tick_ts)

					goto label_1203_0
				end

				coroutine.yield()
			end
		end

		if check_bridge_down() then
			U.y_wait(store, fts(13))
			S:queue("Stage09SheepyBridge")
			U.y_animation_play(this, "bridge", true, store.tick_ts)

			break
		end

		coroutine.yield()
	end

	::label_1203_0::

	queue_remove(store, this)
end

-- customization
scripts.mod_fury = {}
function scripts.mod_fury.insert(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if not target or target.health.dead or not target.unit or not target.unit.damage_factor then
		return false
	end

	if this.received_damage_factor then
		target.health.damage_factor = target.health.damage_factor * this.received_damage_factor
	end

	if this.inflicted_damage_factor then
		target.unit.damage_factor = target.unit.damage_factor * this.inflicted_damage_factor
	end

	if this.speed_factor and target.motion then
		target.motion.max_speed = target.motion.max_speed * this.speed_factor
	end

	if IS_KR5 and (band(this.modifier.vis_flags, target.vis.bans) ~= 0 or band(this.modifier.vis_bans, target.vis.flags) ~= 0) then
		log.paranoid("mod %s cannot be applied to entity %s:%s because of vis flags/bans", this.template_name, target.id, target.template_name)

		return false
	end

	if this.render then
		for _, s in pairs(this.render.sprites) do
			s.ts = store.tick_ts

			if s.size_names then
				s.name = s.size_names[target.unit.size]
			end

			if s.size_scales then
				s.scale = s.size_scales[target.unit.size]
			end
		end
	end

	signal.emit("mod-applied", this, target)

	return true
end

function scripts.mod_fury.remove(this, store, script)
	local target = store.entities[this.modifier.target_id]

	if target and target.health and target.unit then
		if this.received_damage_factor then
			target.health.damage_factor = target.health.damage_factor / this.received_damage_factor
		end

		if this.inflicted_damage_factor then
			target.unit.damage_factor = target.unit.damage_factor / this.inflicted_damage_factor
		end

		if this.speed_factor and target.motion then
			target.motion.max_speed = target.motion.max_speed / this.speed_factor
		end
	end

	return true
end

return scripts